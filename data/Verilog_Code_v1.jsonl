{"task_id": 53, "completion": "parameter M = `T_100ms;\nlocalparam N = $clog2(M);\nreg [N-1:0] divcounter = 0;\nalways @(posedge clk)\n    divcounter <= (divcounter == M - 1) ? 0 : divcounter + 1;\nassign clk_out = (divcounter == 0) ? 1 : 0;\nendmodule"}
{"task_id": 30, "completion": "genvar j;\n    generate for (j=0; j <= SWR-1; j=j+1) begin\n        case (j)\n            SWR-1-j:begin\n                assign Data_o[j]=Data_i[SWR-1-j];\n            end\n            default:begin\n                Multiplexer_AC #(.W(1)) rotate_mux(\n                    .ctrl(select_i),\n                    .D0 (Data_i[j]),\n                    .D1 (Data_i[SWR-1-j]),\n                    .S (Data_o[j])\n                );\n            end\n        endcase\n    end\n    endgenerate\nendmodule"}
{"task_id": 22, "completion": "reg [6:0] timer;\n    wire timer_top = (timer == 7'd127);\n    reg internal_enable;\n    wire out = internal_enable && timer_top;\n\n    always @(posedge clk) begin\n        if(ena) begin\n            internal_enable <= 1;\n            timer <= 0;\n        end else if(cnt && !timer_top) timer <= timer + 7'd1;\n    end\nendmodule"}
{"task_id": 62, "completion": "seg_7 hex_group0 (    .num (num[3:0]),    .en  (en),    .seg (hex0)  );  seg_7 hex_group1 (    .num (num[7:4]),    .en  (en),    .seg (hex1)  );  seg_7 hex_group2 (    .num (num[11:8]),    .en  (en),    .seg (hex2)  );  seg_7 hex_group3 (    .num (num[15:12]),    .en  (en),    .seg (hex3)  );endmodule"}
{"task_id": 93, "completion": "reg [WIDTH-1:0] sync_reg[N-1:0];\n\n    assign out = sync_reg[N-1];\n\n    integer k;\n\n    always @(posedge clk) begin\n        sync_reg[0] <= in;\n        for (k = 1; k < N; k = k + 1) begin\n            sync_reg[k] <= sync_reg[k-1];\n        end\n    end\n\nendmodule"}
{"task_id": 24, "completion": "parameter M = `T_100ms;\n    localparam N = $clog2(M);\n    reg [N-1:0] divcounter = 0;\n\n    always @(posedge clk)\n        divcounter <= (divcounter == M - 1) ? 0 : divcounter + 1;\n\n    assign clk_out = (divcounter == 0) ? 1 : 0;\n\nendmodule"}
{"task_id": 44, "completion": "`include \"parameters_global.v\" \n    input clk;\n    input reset_n;\n    input in;\n    input edge_detect;\n    output reg out;\n    reg latch;\n    always @(posedge clk or negedge reset_n) begin\n    if (~reset_n) \n        begin\n            out     <= #`DEL 1'b0;\n            latch   <= #`DEL 1'b0;\n        end\n    else\n        begin\n            latch   <= #`DEL in;  \n            if (edge_detect == edge_rising)\n                begin\n                    if (latch == 0 && in == 1)\n                        out     <= #`DEL 1'b1;\n                    else\n                        out     <= #`DEL 1'b0;\n                end\n            else\n                begin\n                    if (latch == 1 && in == 0)\n                        out     <= #`DEL 1'b1;\n                    else\n                        out     <= #`DEL 1'b0;\n                end\n        end\n    end\nendmodule"}
{"task_id": 140, "completion": "// Voltage supply signals\n    supply1 VPWR;\n    supply0 VGND;\n\nendmodule"}
{"task_id": 55, "completion": "supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    wire not0_out_Y;\n\n    not not0 (not0_out_Y, A              );\n    buf buf0 (Y         , not0_out_Y     );\n\nendmodule"}
{"task_id": 149, "completion": "supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\nendmodule"}
{"task_id": 194, "completion": "supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    bufif0 bufif00 (Z, A, TE_B);\nendmodule"}
{"task_id": 11, "completion": "wire [31:0] control_bus;    wire [31:0] q_buff;    wire rdempty;    reg rdreq;    always @(posedge clk) begin        if (rdreq) begin            ep_dataout <= q_buff;        end        rdreq <= ~rdempty;    end    fifo32_shallow fifo32_shallow_inst (        .data (control_bus),        .rdclk (clk),        .rdreq (rdreq),        .wrclk (okClk),        .wrreq (1'b1),        .q (q_buff),        .rdempty (rdempty),        .wrfull ()    );    okWireIn control_wires(        .okHE(okHE),        .ep_addr(ep_addr),        .ep_dataout(control_bus)    );endmodule"}
{"task_id": 5, "completion": "assign pwr_oe3 = 1'b0;\n    assign pwr_oe1 = ssp_dout;\n    assign pwr_oe2 = ssp_dout;\n    assign pwr_oe4 = ssp_dout;\n    assign ssp_clk = cross_lo;\n    assign pwr_lo = 1'b0;\n    assign pwr_hi = 1'b0;\n    assign dbg = ssp_frame;\n\n    reg [7:0] pck_divider;\n    reg clk_state;\n\n    always @(posedge pck0)\n    begin\n\tif(pck_divider == divisor[7:0])\n\t\tbegin\n\t\t\tpck_divider <= 8'd0;\n\t\t\tclk_state = !clk_state;\n\t\tend\n\telse\n\tbegin\n\t\tpck_divider <= pck_divider + 1;\n\tend\n    end\n\n    assign adc_clk = ~clk_state;\n\n    reg is_high;\n    reg is_low;\n    reg output_state;\n\n    always @(posedge pck0)\n    begin\n\tif((pck_divider == 8'd7) && !clk_state) begin\n\t\tis_high = (adc_d >= 8'd200);\n\t\tis_low = (adc_d <= 8'd64);\n\tend\n    end\n\n    always @(posedge is_high or posedge is_low)\n    begin\n\tif(is_high)\n\t\toutput_state <= 1'd1;\n\telse if(is_low)\n\t\toutput_state <= 1'd0;\n    end\n\n    assign ssp_frame = output_state;\n\nendmodule"}
{"task_id": 2, "completion": "localparam SM_IDLE                = 2'b00; localparam SM_CMD_EN              = 2'b01; localparam SM_CMD_ACCEPTED        = 2'b10; localparam SM_DONE                = 2'b11; reg [1:0]       state; reg [1:0]       state_r1; reg [1:0]       next_state; reg [7:0]       s_arlen_r; always @(posedge clk) begin if (reset) begin state <= SM_IDLE; state_r1 <= SM_IDLE; s_arlen_r  <= 0; end else begin state <= next_state; state_r1 <= state; s_arlen_r  <= s_arlen; end end always @( * ) begin next_state = state; case (state) SM_IDLE: if (s_arvalid & data_ready) begin next_state = SM_CMD_EN; end else begin next_state = state; end SM_CMD_EN: if (~data_ready & m_arready & next_pending) begin next_state = SM_CMD_ACCEPTED; end else if (m_arready & ~next_pending)begin next_state = SM_DONE; end else if (m_arready & next_pending) begin next_state = SM_CMD_EN; end else begin next_state = state; end SM_CMD_ACCEPTED: if (data_ready) begin next_state = SM_CMD_EN; end else begin next_state = state; end SM_DONE: next_state = SM_IDLE; default: next_state = SM_IDLE; endcase end assign m_arvalid  = (state == SM_CMD_EN); assign next    = m_arready && (state == SM_CMD_EN); assign         r_push  = next; assign a_push  = (state == SM_IDLE); assign s_arready = ((state == SM_CMD_EN) || (state == SM_DONE))  && (next_state == SM_IDLE);endmodule"}
{"task_id": 109, "completion": "reg [4:0]cnt0, cnt1;\n    reg Iv0=0,Iv1=0;\n    reg out0, out1;\n    \nalways@(posedge(clk))begin\n        if (I0==Iv0)begin\n            if (cnt0==19)O0<=I0;\n            else cnt0<=cnt0+1;\n          end\n        else begin\n            cnt0<=\"00000\";\n            Iv0<=I0;\n        end\n        if (I1==Iv1)begin\n                if (cnt1==19)O1<=I1;\n                else cnt1<=cnt1+1;\n              end\n            else begin\n                cnt1<=\"00000\";\n                Iv1<=I1;\n            end\n        end\n        \n    endmodule"}
{"task_id": 126, "completion": "reg cout;\n\t\n\talways @ (sum)\n\t\tbegin\n\t\t\tif (sum[4] == 1)\n\t\t\t\tcout <= 4'b0001;\n\t\t\telse\n\t\t\t\tcout <= 4'b0000;\n\t\tend\n\t\n\treg out;\n\t\n\talways @(dsp_sel,sum,cout,opB,opA)\n\t\tbegin\n\t\t\tif (dsp_sel == 2'b00)\n\t\t\t\tout <= sum[3:0];\n\t\t\telse if (dsp_sel == 2'b01)\n\t\t\t\tout <= cout;\n\t\t\telse if (dsp_sel == 2'b10)\n\t\t\t\tout <= opB;\n\t\t\telse if (dsp_sel == 2'b11)\n\t\t\t\tout <= opA;\n\t\tend\n\nendmodule"}
{"task_id": 29, "completion": "generate\n    genvar i;\n    if (NUMBER_OF_STAGES == 0) begin\n      always @ *\n        pipe_out = pipe_in;\n    end\n    else if (NUMBER_OF_STAGES == 1) begin\n      always @ (posedge clk or negedge reset_n)\n        pipe_out <= (!reset_n) ? 0 : pipe_in;\n    end\n    else begin\n      reg [BIT_WIDTH*(NUMBER_OF_STAGES-1)-1:0] pipe_gen;\n      always @ (posedge clk or negedge reset_n) begin\n        if (!reset_n) begin\n          pipe_gen[BIT_WIDTH-1:0] <= 0;\n          pipe_out <= 0;\n        end\n        else begin\n          pipe_gen[BIT_WIDTH-1:0] <= pipe_in;\n          pipe_out <= pipe_gen[BIT_WIDTH*(NUMBER_OF_STAGES-1)-1:BIT_WIDTH*(NUMBER_OF_STAGES-2)];\n        end\n      end\n      for (i = 1; i < NUMBER_OF_STAGES-1; i = i + 1) begin : pipeline\n        always @ (posedge clk or negedge reset_n)\n          pipe_gen[BIT_WIDTH*(i+1)-1:BIT_WIDTH*i] <= (!reset_n) ? 0 : pipe_gen[BIT_WIDTH*i-1:BIT_WIDTH*(i-1)];\n      end\n    end\n  endgenerate\n\nendmodule"}
{"task_id": 180, "completion": "wire not0_out ;    wire or0_out_X;    not not0 (not0_out , D_N              );    or  or0  (or0_out_X, not0_out, C, B, A);    buf buf0 (X        , or0_out_X        );    endmodule"}
{"task_id": 165, "completion": "supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\nendmodule"}
{"task_id": 3, "completion": "seg_7 hex_group0 (        .num (num[3:0]),        .en  (en),        .seg (hex0)    );    seg_7 hex_group1 (        .num (num[7:4]),        .en  (en),        .seg (hex1)    );    seg_7 hex_group2 (        .num (num[11:8]),        .en  (en),        .seg (hex2)    );    seg_7 hex_group3 (        .num (num[15:12]),        .en  (en),        .seg (hex3)    );endmodule"}
{"task_id": 17, "completion": "reg cout;    always @ (sum)    begin        if (sum[4] == 1)            cout <= 4'b0001;        else            cout <= 4'b0000;    end    reg out;    always @(dsp_sel,sum,cout,opB,opA)    begin        if (dsp_sel == 2'b00)            out <= sum[3:0];        else if (dsp_sel == 2'b01)            out <= cout;        else if (dsp_sel == 2'b10)            out <= opB;        else if (dsp_sel == 2'b11)            out <= opA;    end endmodule"}
{"task_id": 98, "completion": "wire nand0_out        ;\n    wire or0_out          ;\n    wire nand1_out_Y      ;\n    wire pwrgood_pp0_out_Y;\n\n    nand                               nand0       (nand0_out        , A2_N, A1_N             );\n    or                                 or0         (or0_out          , B2, B1                 );\n    nand                               nand1       (nand1_out_Y      , nand0_out, or0_out     );\n    sky130_fd_sc_lp__udp_pwrgood_pp$PG pwrgood_pp0 (pwrgood_pp0_out_Y, nand1_out_Y, VPWR, VGND);\n    buf                                buf0        (Y                , pwrgood_pp0_out_Y      );\n\nendmodule"}
{"task_id": 76, "completion": "seg_7 hex_group0 (    .num (num[3:0]),    .en  (en),    .seg (hex0)  );  seg_7 hex_group1 (    .num (num[7:4]),    .en  (en),    .seg (hex1)  );  seg_7 hex_group2 (    .num (num[11:8]),    .en  (en),    .seg (hex2)  );  seg_7 hex_group3 (    .num (num[15:12]),    .en  (en),    .seg (hex3)  );endmodule"}
{"task_id": 39, "completion": "supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\nendmodule"}
{"task_id": 56, "completion": "wire             clk_en;  \n  reg     [ 23: 0] data_out;  \n  wire    [ 23: 0] out_port;  \n  wire    [ 23: 0] read_mux_out;  \n  wire    [ 31: 0] readdata;  \n  assign clk_en = 1;  \n  assign read_mux_out = {24 {(address == 0)}} & data_out;  \n  always @(posedge clk or negedge reset_n)  \n    begin  \n      if (reset_n == 0)  \n          data_out <= 0;  \n      else if (chipselect && ~write_n && (address == 0))  \n          data_out <= writedata[23 : 0];  \n    end  \n  assign readdata = {32'b0 | read_mux_out};  \n  assign out_port = data_out;  \n\nendmodule"}
{"task_id": 175, "completion": "wire carry_out1, carry_out2, carry_out3;       \n    AdderSlice Bit0 (        .A(A[0]),        .B(B[0]),        .S(S[0]),        .Cout(carry_out1),        .Cin(Operation)     );     \n    AdderSlice Bit1 (          .A(A[1]),          .B(B[1] ),          .S(S[1]),          .Cout(carry_out2),          .Cin(carry_out1)      );       \n    AdderSlice Bit2 (         .A(A[2]),         .B(B[2] ),         .S(S[2]),         .Cout(carry_out3),         .Cin(carry_out2)     );     \n    AdderSlice Bit3 (         .A(A[3]),         .B(B[3] ),         .S(S[3]),         .Cout(Cout),         .Cin(carry_out3)     );    \nendmodule"}
{"task_id": 84, "completion": "wire [21:0] sub_wire0; wire [22:0] sub_wire1; wire [21:0] q = sub_wire0[21:0]; wire [22:0] remainder = sub_wire1[22:0]; altsqrt ALTSQRT_component ( .clk (clk), .ena (ena), .radical (radical), .q (sub_wire0), .remainder (sub_wire1) ); defparam ALTSQRT_component.pipeline = 5, ALTSQRT_component.q_port_width = 22, ALTSQRT_component.r_port_width = 23, ALTSQRT_component.width = 43; endmodule"}
{"task_id": 116, "completion": "reg [WIDTH-1:0] sync_reg[N-1:0];\n\n    assign out = sync_reg[N-1];\n\n    integer k;\n\n    always @(posedge clk) begin\n        sync_reg[0] <= in;\n        for (k = 1; k < N; k = k + 1) begin\n            sync_reg[k] <= sync_reg[k-1];\n        end\n    end\n\nendmodule"}
{"task_id": 59, "completion": "parameter LUT_SIZE   = ZUMA_LUT_SIZE;\n    parameter NUM_STAGES = NUM_CONFIG_STAGES;\n    reg  [31:0] next_address;\n    reg  [31:0] address;\n    wire [CONFIG_WIDTH-1:0] cfg;\n    wire [CONFIG_WIDTH-1:0] cfg_in;\n    reg write;\n    reg reset_done;\n    reg virtual_reset;\n    always @ (posedge clk) begin : COUNTER\n        address <= next_address;\n        if (reset) begin\n            next_address  <= 32'b0;\n            write         <=  1'b1;\n            reset_done    <=  1'b0;\n            virtual_reset <=  1'b0;\n        end else if (write) begin\n            next_address <=  next_address + 1;\n            if (next_address > (2**LUT_SIZE)*NUM_STAGES) begin\n               write <= 1'b0;\n            end\n        end else if (~reset_done) begin\n            virtual_reset <= 1'b1;\n            reset_done    <= 1'b1;\n        end else if (virtual_reset) begin\n            virtual_reset <= 1'b0;\n        end else begin\n            next_address <= next_address;\n        end     \n    end \n    generate\n        genvar i;\n        for (i = 0; i < CONFIG_WIDTH; i = i + 1) begin: reverse\n           assign cfg_in[CONFIG_WIDTH-1-i] = cfg[i];\n        end\n    endgenerate\n    fixed_config #(.LUT_SIZE(LUT_SIZE), .NUM_STAGES(NUM_STAGES)) config_data (\n        .address_in(next_address),\n        .clock(clk),\n        .q(cfg) \n    );\n    ZUMA_custom_generated XUM (\n        .clk(clk),\n        .fpga_inputs(inputs),\n        .fpga_outputs(outputs),\n        .config_data(cfg_in),\n        .config_en(write),\n        .progress(),\n        .config_addr(address),\n        .clk2(clk),\n        .ffrst(virtual_reset)\n    );\nendmodule"}
{"task_id": 186, "completion": "// Voltage supply signals\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    sky130_fd_sc_lp__nand3 base (\n        .Y(Y),\n        .A(A),\n        .B(B),\n        .C(C)\n    );\n\nendmodule"}
{"task_id": 101, "completion": "reg cout;\n        \n        always @ (sum)\n            begin\n                if (sum[4] == 1)\n                    cout <= 4'b0001;\n                else\n                    cout <= 4'b0000;\n            end\n        \n        reg out;\n        \n        always @(dsp_sel,sum,cout,opB,opA)\n            begin\n                if (dsp_sel == 2'b00)\n                    out <= sum[3:0];\n                else if (dsp_sel == 2'b01)\n                    out <= cout;\n                else if (dsp_sel == 2'b10)\n                    out <= opB;\n                else if (dsp_sel == 2'b11)\n                    out <= opA;\n            end\n\nendmodule"}
{"task_id": 144, "completion": "regfile reggie(        .Aselect(Aselect),        .Bselect(Bselect),        .Dselect(Dselect),        .dbus(dbus),        .bbus(bbus),        .abus(abus),        .clk(clk)    );        alupipe alup(        .S(S),        .Cin(Cin),        .clk(clk),        .abus(abus),        .bbus(bbus),        .dbus(dbus)    );endmodule"}
{"task_id": 155, "completion": "wire q; wire [31:0] data; wire [5:0] select; assign q = (select == 5'h00) ? data[0] : (select == 5'h01) ? data[1] : (select == 5'h02) ? data[2] : (select == 5'h03) ? data[3] : (select == 5'h04) ? data[4] : (select == 5'h05) ? data[5] : (select == 5'h06) ? data[6] : (select == 5'h07) ? data[7] : (select == 5'h08) ? data[8] : (select == 5'h09) ? data[9] : (select == 5'h0A) ? data[10] : (select == 5'h0B) ? data[11] : (select == 5'h0C) ? data[12] : (select == 5'h0D) ? data[13] : (select == 5'h0E) ? data[14] : (select == 5'h0F) ? data[15] : (select == 5'h10) ? data[16] : (select == 5'h11) ? data[17] : (select == 5'h12) ? data[18] : (select == 5'h13) ? data[19] : (select == 5'h14) ? data[20] : (select == 5'h15) ? data[21] : (select == 5'h16) ? data[22] : (select == 5'h17) ? data[23] : (select == 5'h18) ? data[24] : (select == 5'h19) ? data[25] : (select == 5'h1A) ? data[26] : (select == 5'h1B) ? data[27] : (select == 5'h1C) ? data[28] : (select == 5'h1D) ? data[29] : (select == 5'h1E) ? data[30] : (select == 5'h1F) ? data[31] : 1'bx; endmodule"}
{"task_id": 131, "completion": "reg [6:0] timer;\n    wire timer_top = (timer == 7'd127);\n    reg internal_enable;\n    wire out = internal_enable && timer_top;\n\n    always @(posedge clk) begin\n        if(ena) begin\n            internal_enable <= 1;\n            timer <= 0;\n        end else if(cnt && !timer_top) timer <= timer + 7'd1;\n    end\nendmodule"}
{"task_id": 64, "completion": "if (condition(w)) begin       \n        case (f(w))            \n            DecInst i:          \n                inst <= g(i, oc);      \n                decoder_result <= 1;  \n            DecError m:         \n                decoder_result <= 3;  \n            DecUndefined:         \n                decoder_result <= 0;  \n            DecUnpredictable:     \n                decoder_result <= 2;  \n        endcase       \n    end else begin       \n        decoder_result <= 0;      \n    end\nendmodule"}
{"task_id": 74, "completion": "always @(posedge clk_sys) begin\n        if(rst) begin\n            ao486_rst <= 1;\n        end else begin\n            if(write && writedata[0] == 1'b0 && address == 4'b0000)\n              ao486_rst <= 0;\n            else if(write && writedata[0] == 1'b1 && address == 4'b0000)\n              ao486_rst <= 1;\n        end\n    end\nendmodule"}
{"task_id": 197, "completion": "reg [31:0]   ram [2047:0] /*verilator public*/;\nreg [31:0]   ram_read_q;\n\nalways @ (posedge clk_i)\nbegin\n    if (wr_i)\n        ram[addr_i] <= data_i;\n    ram_read_q <= ram[addr_i];\nend\n\nassign data_o = ram_read_q;\n\nendmodule"}
{"task_id": 170, "completion": "output Q   ;\n    input  D   ;\n    input  GATE;\n    input  VPWR;\n    input  VGND;\n\n    wire buf_Q GATE_delayed;\n    wire buf_Q D_delayed;\n    reg notifier;\n    wire buf_Q;\n    wire awake;\n\n    sky130_fd_sc_hs__u_dl_p_no_pg u_dl_p_no_pg0 (buf_Q, D_delayed, GATE_delayed, notifier, VPWR, VGND);\n    buf buf0 (Q, buf_Q);\n    assign awake = (VPWR === 1'b1);\nendmodule"}
{"task_id": 110, "completion": "wire [7:0] min_value = 8'd120; wire [7:0] max_weight = 8'd60; wire [7:0] max_volume = 8'd60; wire [7:0] total_value = A * 8'd4 + B * 8'd8 + C * 8'd0 + D * 8'd20 + E * 8'd10 + F * 8'd12 + G * 8'd18 + H * 8'd14 + I * 8'd6 + J * 8'd15 + K * 8'd30 + L * 8'd8 + M * 8'd16 + N * 8'd18; wire [7:0] total_weight = A * 8'd28 + B * 8'd8 + C * 8'd27 + D * 8'd18 + E * 8'd27 + F * 8'd28 + G * 8'd6 + H * 8'd1 + I * 8'd20 + J * 8'd0 + K * 8'd5 + L * 8'd13 + M * 8'd8 + N * 8'd14; wire [7:0] total_volume = A * 8'd27 + B * 8'd27 + C * 8'd4 + D * 8'd4 + E * 8'd0 + F * 8'd24 + G * 8'd4 + H * 8'd20 + I * 8'd12 + J * 8'd15 + K * 8'd5 + L * 8'd2 + M * 8'd9 + N * 8'd28; assign valid = ((total_value >= min_value) && (total_weight <= max_weight) && (total_volume <= max_volume)); endmodule"}
{"task_id": 171, "completion": "output Y   ;\n    input  A_N ;\n    input  B_N ;\n    input  C   ;\n    input  D   ;\n    input  VPWR;\n    input  VGND;\n    input  VPB ;\n    input  VNB ;\n    sky130_fd_sc_hdll__nand4bb base (\n        .Y(Y),\n        .A_N(A_N),\n        .B_N(B_N),\n        .C(C),\n        .D(D),\n        .VPWR(VPWR),\n        .VGND(VGND),\n        .VPB(VPB),\n        .VNB(VNB)\n    );\n\nendmodule"}
{"task_id": 113, "completion": "genvar j;\ngenerate for (j=0; j <= SWR-1; j=j+1) begin\n\tcase (j)\n\t\tSWR-1-j:begin\n\t\t\tassign Data_o[j]=Data_i[SWR-1-j];\n\t\tend\n\t\tdefault:begin\n\t\t\tMultiplexer_AC #(.W(1)) rotate_mux(\n\t\t\t.ctrl(select_i),\n\t\t\t.D0 (Data_i[j]),\n\t\t\t.D1 (Data_i[SWR-1-j]),\n\t\t\t.S (Data_o[j])\n\t\t\t);\n\t\tend\n\tendcase\nend\nendgenerate\nendmodule"}
{"task_id": 195, "completion": "sky130_fd_sc_hdll__o2bb2a base (\n        .X(X),\n        .A1_N(A1_N),\n        .A2_N(A2_N),\n        .B1(B1),\n        .B2(B2),\n        .VPWR(VPWR),\n        .VGND(VGND),\n        .VPB(VPB),\n        .VNB(VNB)\n    );\n\nendmodule"}
{"task_id": 94, "completion": "(*preserve*) reg [DEPTH-1:0] altera_reset_synchronizer_int_chain;\n    reg altera_reset_synchronizer_int_chain_out;\n\n    generate if (ASYNC_RESET) begin\n\n        always @(posedge clk or posedge reset_in) begin\n            if (reset_in) begin\n                altera_reset_synchronizer_int_chain <= {DEPTH{1'b1}};\n                altera_reset_synchronizer_int_chain_out <= 1'b1;\n            end\n            else begin\n                altera_reset_synchronizer_int_chain[DEPTH-2:0] <= altera_reset_synchronizer_int_chain[DEPTH-1:1];\n                altera_reset_synchronizer_int_chain[DEPTH-1] <= 0;\n                altera_reset_synchronizer_int_chain_out <= altera_reset_synchronizer_int_chain[0];\n            end\n        end\n\n        assign reset_out = altera_reset_synchronizer_int_chain_out;\n     \n    end else begin\n\n        always @(posedge clk) begin\n            altera_reset_synchronizer_int_chain[DEPTH-2:0] <= altera_reset_synchronizer_int_chain[DEPTH-1:1];\n            altera_reset_synchronizer_int_chain[DEPTH-1] <= reset_in;\n            altera_reset_synchronizer_int_chain_out <= altera_reset_synchronizer_int_chain[0];\n        end\n\n        assign reset_out = altera_reset_synchronizer_int_chain_out;\n \n    end\n    endgenerate\n\nendmodule"}
{"task_id": 21, "completion": "wire a,b,c,d,e,f,g,h,i,j,k,l; assign an[3] = a; assign an[2] = b; assign an[1] = c; assign an[0] = d; assign dsp_sel[1] = e; assign dsp_sel[0] = i; FDRSE #(.INIT(1'b0)) DFF3(.Q(a), .C(clk), .CE(en), .D(d), .R(1'b0), .S(1'b0)); FDRSE #(.INIT(1'b1)) DFF2(.Q(b), .C(clk), .CE(en), .D(a), .R(1'b0), .S(1'b0)); FDRSE #(.INIT(1'b1)) DFF1(.Q(c), .C(clk), .CE(en), .D(b), .R(1'b0), .S(1'b0)); FDRSE #(.INIT(1'b1)) DFF0(.Q(d), .C(clk), .CE(en), .D(c), .R(1'b0), .S(1'b0)); FDRSE #(.INIT(1'b1)) DFF7(.Q(e), .C(clk), .CE(en), .D(h), .R(1'b0), .S(1'b0)); FDRSE #(.INIT(1'b1)) DFF6(.Q(f), .C(clk), .CE(en), .D(e), .R(1'b0), .S(1'b0)); FDRSE #(.INIT(1'b0)) DFF5(.Q(g), .C(clk), .CE(en), .D(f), .R(1'b0), .S(1'b0)); FDRSE #(.INIT(1'b0)) DFF4(.Q(h), .C(clk), .CE(en), .D(g), .R(1'b0), .S(1'b0)); FDRSE #(.INIT(1'b1)) DFF11(.Q(i), .C(clk), .CE(en), .D(l), .R(1'b0), .S(1'b0)); FDRSE #(.INIT(1'b0)) DFF10(.Q(j), .C(clk), .CE(en), .D(i), .R(1'b0), .S(1'b0)); FDRSE #(.INIT(1'b1)) DFF9(.Q(k), .C(clk), .CE(en), .D(j), .R(1'b0), .S(1'b0)); FDRSE #(.INIT(1'b0)) DFF8(.Q(l), .C(clk), .CE(en), .D(k), .R(1'b0), .S(1'b0)); endmodule"}
{"task_id": 23, "completion": "reg                     full0;\n   reg                     full1;\n   reg [DATA_WIDTH-1:0]    data0;\n   reg [DATA_WIDTH-1:0]    data1;\n\n   assign out_valid = full1;\n   assign out_data  = data1;    \n   generate if (PIPELINE_READY == 1) \n     begin : REGISTERED_READY_PLINE\n        assign in_ready  = !full0;\n        always @(posedge clk, posedge reset) begin\n           if (reset) begin\n              data0 <= {DATA_WIDTH{1'b0}};\n              data1 <= {DATA_WIDTH{1'b0}};\n           end else begin\n              if (~full0)\n                data0 <= in_data;\n              if (~full1 || (out_ready && out_valid)) begin\n                 if (full0)\n                   data1 <= data0;\n                 else\n                   data1 <= in_data;\n              end\n           end\n        end\n        always @(posedge clk or posedge reset) begin\n           if (reset) begin\n              full0    <= 1'b0;\n              full1    <= 1'b0;\n           end else begin\n              if (~full0 & ~full1) begin\n                 if (in_valid) begin\n                    full1 <= 1'b1;\n                 end\n              end \n              if (full1 & ~full0) begin\n                 if (in_valid & ~out_ready) begin\n                    full0 <= 1'b1;\n                 end\n                 if (~in_valid & out_ready) begin\n                    full1 <= 1'b0;\n                 end\n              end \n              if (full1 & full0) begin\n                 if (out_ready) begin\n                    full0 <= 1'b0;\n                 end\n              end \n           end\n        end\n     end \n   else \n     begin : UNREGISTERED_READY_PLINE\n\n\tassign in_ready = (~full1) | out_ready;\n\talways @(posedge clk or posedge reset) begin\n\t   if (reset) begin\n\t      data1 <= 'b0;\n\t      full1 <= 1'b0;\n\t   end\n\t   else begin\n\t      if (in_ready) begin\n\t\t data1 <= in_data;\n\t\t full1 <= in_valid;\n\t      end\n\t   end\n\tend\t\n     end\n   endgenerate\nendmodule"}
{"task_id": 193, "completion": "reg [AW-1:0] next_write_addr;\n\n    reg [AW-1:0] read_addr;\n    reg [AW-1:0] write_addr;\n\n    wire mem_read_clock_enable;\n    wire mem_write_clock_enable;\n\n    assign empty = read_addr == write_addr;\n    assign overflow = next_write_addr == read_addr;\n\n    always @(negedge reset or negedge clock) begin\n        if (~reset) begin\n            write_addr <= 0;\n            next_write_addr <= 1;\n        end\n        else\n            if (write_clock_enable)\n                if (~overflow) begin\n                    write_addr <= write_addr + 1;\n                    next_write_addr <= next_write_addr + 1;\n                end\n    end\n\n    always @(negedge reset or negedge clock) begin\n        if (~reset) begin\n            read_addr <= 0;\n        end\n        else begin\n            if (read_clock_enable)\n                if (~empty)\n                    read_addr <= read_addr + 1;\n        end\n    end\n\n    assign mem_read_clock_enable = ~empty & read_clock_enable;\n    assign mem_write_clock_enable = ~overflow & write_clock_enable;\n\n    buffer #(.AW(AW), .DW(DW))\n        MEM (\n            .clock(clock),\n            .write_clock_enable(mem_write_clock_enable),\n            .write_data(write_data),\n            .write_addr(write_addr),\n            .read_clock_enable(mem_read_clock_enable),\n            .read_data(read_data),\n            .read_addr(read_addr));\nendmodule"}
{"task_id": 6, "completion": "wire CLKIN_IBUFG_OUT;\n\twire CLK0_OUT;\n\twire CLKFB_IN;\n\twire CLKIN_IBUFG;\n\twire CLK0_BUF;\n\twire CLKFX1_BUF;\n\twire CLKFX2_BUF;\n\twire CLKDV_BUF;\n\twire GND_BIT;\n\twire dcm_progclk_buf;\n\n\tassign GND_BIT = 0;\n\tassign CLKIN_IBUFG_OUT = CLKIN_IBUFG;\n\tassign CLK0_OUT = CLKFB_IN;\n\n\tIBUFG  CLKIN_IBUFG_INST (.I(CLKIN_IN), \n\t\t.O(CLKIN_IBUFG));\n\tBUFG  CLK0_BUFG_INST (.I(CLK0_BUF), \n\t\t.O(CLKFB_IN));\n\tBUFG  CLKFX1_BUFG_INST (.I(CLKFX1_BUF), \n\t\t.O(CLKFX1_OUT));\n\tBUFG  CLKFX2_BUFG_INST (.I(CLKFX2_BUF), \n\t\t.O(CLKFX2_OUT));\n\tBUFG  CLKDV_BUFG_INST (.I(CLKDV_BUF), \n\t\t.O(CLKDV_OUT));\n\tBUFG  DCMPROGCLK_BUFG_INST (.I(dcm_progclk), \n\t\t.O(dcm_progclk_buf));\n\n\tDCM_SP #( .CLK_FEEDBACK(\"1X\"), .CLKDV_DIVIDE(8.0), .CLKFX_DIVIDE(8),\n\t\t.CLKFX_MULTIPLY(4), .CLKIN_DIVIDE_BY_2(\"FALSE\"), \n\t\t.CLKIN_PERIOD(10.000), .CLKOUT_PHASE_SHIFT(\"NONE\"), \n\t\t.DESKEW_ADJUST(\"SYSTEM_SYNCHRONOUS\"), .DFS_FREQUENCY_MODE(\"LOW\"), \n\t\t.DLL_FREQUENCY_MODE(\"LOW\"), .DUTY_CYCLE_CORRECTION(\"TRUE\"), \n\t\t.FACTORY_JF(16'hC080), .PHASE_SHIFT(0), .STARTUP_WAIT(\"FALSE\") ) \n\t\tDCM_SP_INST (.CLKFB(CLKFB_IN), \n\t\t.CLKIN(CLKIN_IBUFG), \n\t\t.DSSEN(GND_BIT), \n\t\t.PSCLK(GND_BIT), \n\t\t.PSEN(GND_BIT), \n\t\t.PSINCDEC(GND_BIT), \n\t\t.RST(GND_BIT), \n\t\t.CLKDV(CLKDV_BUF), \n\t\t.CLKFX(CLKFX1_BUF), \n\t\t.CLKFX180(), \n\t\t.CLK0(CLK0_BUF), \n\t\t.CLK2X(), \n\t\t.CLK2X180(), \n\t\t.CLK90(), \n\t\t.CLK180(), \n\t\t.CLK270(), \n\t\t.LOCKED(DCM_SP_LOCKED_OUT), \n\t\t.PSDONE(), \n\t\t.STATUS());\n\n\tDCM_CLKGEN #(\n\t\t.CLKFX_DIVIDE(100),\n\t\t.CLKFX_MULTIPLY(SPEED_MHZ),\n\t\t.CLKFXDV_DIVIDE(2),\n\t\t.CLKIN_PERIOD(10.0),\n\t\t.CLKFX_MD_MAX(0.000),\n\t\t.SPREAD_SPECTRUM(\"NONE\"),\n\t\t.STARTUP_WAIT(\"FALSE\")\n\t\t) \n\t\tDCM_CLKGEN_INST (\n\t\t.CLKIN(CLKIN_IBUFG),\n\t\t.CLKFX(CLKFX2_BUF),\n\t\t.FREEZEDCM(1'b0),\n\t\t.PROGCLK(dcm_progclk_buf),\n\t\t.PROGDATA(dcm_progdata),\n\t\t.PROGEN(dcm_progen),\n\t\t.PROGDONE(dcm_progdone),\n\t\t.LOCKED(dcm_locked),\n\t\t.STATUS(dcm_status),\n\t\t.RST(dcm_reset)\n\t\t);\n\nendmodule"}
{"task_id": 145, "completion": "wire nand0_out        ;\n    wire or0_out          ;\n    wire nand1_out_Y      ;\n    wire pwrgood_pp0_out_Y;\n\n    nand                               nand0       (nand0_out        , A2_N, A1_N             );\n    or                                 or0         (or0_out          , B2, B1                 );\n    nand                               nand1       (nand1_out_Y      , nand0_out, or0_out     );\n    sky130_fd_sc_ls__udp_pwrgood_pp$PG pwrgood_pp0 (pwrgood_pp0_out_Y, nand1_out_Y, VPWR, VGND);\n    buf                                buf0        (Y                , pwrgood_pp0_out_Y      );\n\nendmodule"}
{"task_id": 159, "completion": "output GCLK;    input  GATE;    input  CLK ;    input  SCE ;    input  VPWR;    input  VGND;    wire m0              ;    wire m0n             ;    wire clkn            ;    wire CLK_delayed     ;    wire SCE_delayed     ;    wire GATE_delayed    ;    wire SCE_gate_delayed;    reg  notifier        ;    wire awake           ;    wire SCE_awake       ;    wire GATE_awake      ;    not                           not0          (m0n             , m0                                          );    not                           not1          (clkn            , CLK_delayed                                 );    nor                           nor0          (SCE_gate_delayed, GATE_delayed, SCE_delayed                   );    sky130_fd_sc_hs__u_dl_p_no_pg u_dl_p_no_pg0 (m0              , SCE_gate_delayed, clkn, notifier, VPWR, VGND);    and                           and0          (GCLK            , m0n, CLK_delayed                            );    assign awake = ( VPWR === 1'b1 );    assign SCE_awake = ( awake & ( GATE_delayed === 1'b0 ) );    assign GATE_awake = ( awake & ( SCE_delayed === 1'b0 ) );endmodule"}
{"task_id": 92, "completion": "wire a,b,c,d,e,f,g,h,i,j,k,l; assign an[3] = a; assign an[2] = b; assign an[1] = c; assign an[0] = d; assign dsp_sel[1] = e; assign dsp_sel[0] = i; FDRSE #( .INIT(1'b0) ) DFF3( .Q(a), .C(clk), .CE(en), .D(d), .R(1'b0), .S(1'b0) ); FDRSE #( .INIT(1'b1) ) DFF2( .Q(b), .C(clk), .CE(en), .D(a), .R(1'b0), .S(1'b0) ); FDRSE #( .INIT(1'b1) ) DFF1( .Q(c), .C(clk), .CE(en), .D(b), .R(1'b0), .S(1'b0) ); FDRSE #( .INIT(1'b1) ) DFF0( .Q(d), .C(clk), .CE(en), .D(c), .R(1'b0), .S(1'b0) ); FDRSE #( .INIT(1'b1) ) DFF7( .Q(e), .C(clk), .CE(en), .D(h), .R(1'b0), .S(1'b0) ); FDRSE #( .INIT(1'b1) ) DFF6( .Q(f), .C(clk), .CE(en), .D(e), .R(1'b0), .S(1'b0) ); FDRSE #( .INIT(1'b0) ) DFF5( .Q(g), .C(clk), .CE(en), .D(f), .R(1'b0), .S(1'b0) ); FDRSE #( .INIT(1'b0) ) DFF4( .Q(h), .C(clk), .CE(en), .D(g), .R(1'b0), .S(1'b0) ); FDRSE #( .INIT(1'b1) ) DFF11( .Q(i), .C(clk), .CE(en), .D(l), .R(1'b0), .S(1'b0) ); FDRSE #( .INIT(1'b0) ) DFF10( .Q(j), .C(clk), .CE(en), .D(i), .R(1'b0), .S(1'b0) ); FDRSE #( .INIT(1'b1) ) DFF9( .Q(k), .C(clk), .CE(en), .D(j), .R(1'b0), .S(1'b0) ); FDRSE #( .INIT(1'b0) ) DFF8( .Q(l), .C(clk), .CE(en), .D(k), .R(1'b0), .S(1'b0) ); endmodule"}
{"task_id": 119, "completion": "genvar j;\n    generate for (j=0; j<=SWR-1 ; j=j+1) begin\n\n\t\tlocalparam sh=(2**LEVEL)+j;\n\n\t\tcase (sh>SWR-1)\n\n\t\t\t1'b1:begin\n\t\t\t\tMultiplexer_AC #(.W(1)) rotate_mux(\n\t\t\t\t    .ctrl(select_i),\n\t\t\t\t    .D0 (Data_i[j]),\n\t\t\t\t    .D1 (bit_shift_i),\n\t\t\t\t    .S (Data_o[j])\n\t\t\t\t);\n\t\t\tend\n\t\t\t1'b0:begin\n\t\t\t\tMultiplexer_AC #(.W(1)) rotate_mux(\n\t\t\t\t    .ctrl(select_i),\n\t\t\t\t    .D0 (Data_i[j]),\n\t\t\t\t    .D1 (Data_i[sh]),\n\t\t\t\t    .S (Data_o[j])\n\t\t\t\t);\n\t\t\tend\n\t\tendcase\n\tend\n    endgenerate\nendmodule"}
{"task_id": 105, "completion": "(*preserve*) reg [DEPTH-1:0] altera_reset_synchronizer_int_chain;\n    reg altera_reset_synchronizer_int_chain_out;\n\n    generate if (ASYNC_RESET) begin\n\n        always @(posedge clk or posedge reset_in) begin\n            if (reset_in) begin\n                altera_reset_synchronizer_int_chain <= {DEPTH{1'b1}};\n                altera_reset_synchronizer_int_chain_out <= 1'b1;\n            end\n            else begin\n                altera_reset_synchronizer_int_chain[DEPTH-2:0] <= altera_reset_synchronizer_int_chain[DEPTH-1:1];\n                altera_reset_synchronizer_int_chain[DEPTH-1] <= 0;\n                altera_reset_synchronizer_int_chain_out <= altera_reset_synchronizer_int_chain[0];\n            end\n        end\n\n        assign reset_out = altera_reset_synchronizer_int_chain_out;\n     \n    end else begin\n\n        always @(posedge clk) begin\n            altera_reset_synchronizer_int_chain[DEPTH-2:0] <= altera_reset_synchronizer_int_chain[DEPTH-1:1];\n            altera_reset_synchronizer_int_chain[DEPTH-1] <= reset_in;\n            altera_reset_synchronizer_int_chain_out <= altera_reset_synchronizer_int_chain[0];\n        end\n\n        assign reset_out = altera_reset_synchronizer_int_chain_out;\n \n    end\n    endgenerate\n\nendmodule"}
{"task_id": 166, "completion": "parameter DBIT = 8;\n\tparameter SB_TICK = 16;\n\tlocalparam IDLE = 0;\n\tlocalparam START = 1;\n\tlocalparam DATA = 2;\n\tlocalparam STOP = 3;\n\n\treg [1:0] state_reg, state_next;\n\treg [3:0] s_reg, s_next;\n\treg [2:0] n_reg, n_next;\n\treg [7:0] b_reg, b_next;\n\treg tx_reg, tx_next;\n\n\talways @(posedge clk, posedge reset) begin\n\t\tif (reset) begin\n\t\t\tstate_reg <= IDLE;\n\t\t\ts_reg <= 0;\n\t\t\tn_reg <= 0;\n\t\t\tb_reg <= 0;\n\t\t\ttx_reg <= 1;\n\t\tend\n\t\telse begin\n\t\t\tstate_reg <= state_next;\n\t\t\ts_reg <= s_next;\n\t\t\tn_reg <= n_next;\n\t\t\tb_reg <= b_next;\n\t\t\ttx_reg <= tx_next;\n\t\tend\n\tend\n\n\talways @(state_reg, s_reg, n_reg, b_reg, s_tick, tx_reg, tx_start, din) begin\n\t\tstate_next <= state_reg;\n\t\ts_next <= s_reg;\n\t\tn_next <= n_reg;\n\t\tb_next <= b_reg;\n\t\ttx_next <= tx_reg;\n\t\ttx_done_tick <= 0;\n\t\t\n\t\tcase (state_reg)\n\t\t\tIDLE: begin\n\t\t\t\ttx_next <= 1;\n\t\t\t\tif (tx_start) begin\n\t\t\t\t\tstate_next <= START;\n\t\t\t\t\ts_next <= 0;\n\t\t\t\t\tb_next <= din;\n\t\t\t\tend\n\t\t\tend\n\t\t\t\n\t\t\tSTART: begin\n\t\t\t\ttx_next <= 0;\n\t\t\t\tif (s_tick) begin\n\t\t\t\t\tif (s_reg == 15) begin\n\t\t\t\t\t\tstate_next <= DATA;\n\t\t\t\t\t\ts_next <= 0;\n\t\t\t\t\t\tn_next <= 0;\n\t\t\t\t\tend\n\t\t\t\t\telse\n\t\t\t\t\t\ts_next <= s_reg + 1;\n\t\t\t\tend\n\t\t\tend\n\t\t\t\n\t\t\tDATA: begin\n\t\t\t\ttx_next <= b_reg[0];\n\t\t\t\tif (s_tick) begin\n\t\t\t\t\tif (s_reg == 15) begin\n\t\t\t\t\t\ts_next <= 0;\n\t\t\t\t\t\tb_next <= {1'b0, b_reg[7:1]};\n\t\t\t\t\t\tif (n_reg == DBIT-1)\n\t\t\t\t\t\t\tstate_next <= STOP;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tn_next <= n_reg + 1;\n\t\t\t\t\tend\n\t\t\t\t\telse\n\t\t\t\t\t\ts_next <= s_reg + 1;\n\t\t\t\tend\n\t\t\tend\n\t\t\t\n\t\t\tSTOP: begin\n\t\t\t\ttx_next <= 1;\n\t\t\t\tif (s_tick) begin\n\t\t\t\t\tif (s_reg == SB_TICK-1) begin\n\t\t\t\t\t\tstate_next <= IDLE;\n\t\t\t\t\t\ttx_done_tick <= 1;\n\t\t\t\t\tend\n\t\t\t\t\telse\n\t\t\t\t\t\ts_next <= s_reg + 1;\n\t\t\t\tend\n\t\t\tend\n\t\tendcase\n\tend\n\n\tassign tx = tx_reg;\n\nendmodule"}
{"task_id": 111, "completion": "localparam RANDOM_INIT = 9'b1_1111_1111;\n\n    localparam WAITING = 0,\n               PADDING = 1,\n               ENCODING = 2;\n\n    reg [1:0] state, next_state;\n    reg [6:0] count, next_count;\n\n    reg [8:0] random_regs, next_random_regs;\n    reg [7:0] working_random, next_working_random;\n    wire [8:0] next_random = {random_regs[5] ^ random_regs[0], random_regs[8:1]};\n\n    always @(*) begin\n        case (state)\n            WAITING: begin\n                if (indicator)\n                    next_state = PADDING;\n                else\n                    next_state = WAITING;\n                next_count = 0;\n                next_random_regs = RANDOM_INIT;\n                next_working_random = RANDOM_INIT;\n            end\n\n            PADDING: begin\n                if (count < 79) begin\n                    next_state = PADDING;\n                    next_count = count + 1;\n                    next_random_regs = RANDOM_INIT;\n                end else begin\n                    next_state = ENCODING;\n                    next_count = 0;\n                    next_random_regs = next_random;\n                end\n                next_working_random = RANDOM_INIT;\n            end\n\n            ENCODING: begin\n                if (indicator) begin\n                    next_state = WAITING;\n                    next_count = 0;\n                end else begin\n                    next_state = ENCODING;\n                    next_count = count + 1;\n                end\n                next_random_regs = next_random;\n                next_working_random = (count[2:0] == 7 ?\n                                       random_regs :\n                                       working_random);\n            end\n\n            default: begin\n                next_state = WAITING;\n                next_count = 0;\n                next_random_regs = RANDOM_INIT;\n                next_working_random = RANDOM_INIT;\n            end\n        endcase\n    end\n\n    always @(posedge clk or negedge reset_n) begin\n        if (~reset_n) begin\n            state <= WAITING;\n            count <= 0;\n            random_regs <= RANDOM_INIT;\n            working_random <= RANDOM_INIT;\n        end else begin\n            state <= next_state;\n            count <= next_count;\n            random_regs <= next_random_regs;\n            working_random <= next_working_random;\n        end\n    end\n\n    assign next_indicator = indicator;\n\n    assign dout = (state == ENCODING ? din ^ working_random : din);\n\nendmodule"}
{"task_id": 142, "completion": "wire                  aclk;\nwire                  aclken;\nwire                  a_tvalid;\nwire [63:0]           a_tdata;\nwire                  r_tvalid;\nwire [63:0]           r_tdata;\nreg  [din1_WIDTH-1:0] din1_buf1;\n\nANN_ap_dexp_16_full_dsp_64 ANN_ap_dexp_16_full_dsp_64_u (\n    .aclk                 ( aclk ),\n    .aclken               ( aclken ),\n    .s_axis_a_tvalid      ( a_tvalid ),\n    .s_axis_a_tdata       ( a_tdata ),\n    .m_axis_result_tvalid ( r_tvalid ),\n    .m_axis_result_tdata  ( r_tdata )\n);\n\nassign aclk     = clk;\nassign aclken   = ce;\nassign a_tvalid = 1'b1;\nassign a_tdata  = din1_buf1==='bx ? 'b0 : din1_buf1;\nassign dout     = r_tdata;\n\nalways @(posedge clk) begin\n    if (ce) begin\n        din1_buf1 <= din1;\n    end\nend\n\nendmodule"}
{"task_id": 28, "completion": "wire tick, rx_done_tick;\n\twire [DBIT-1:0] rx_data_out, tx_fifo_out;\n\t\n\tbaud_rate_gen #(.M(DVSR)) baud_gen_unit\n\t\t(   .clk(clk), .reset(reset), .tick(tick));\n\t\n\trx #(.DBIT(DBIT), .SB_TICK(SB_TICK)) uart_rx_unit\n\t\t(   .clk(clk), .reset(reset), .rx(rx), .s_tick(tick),\n\t\t\t.rx_done_tick(rx_done_tick), .dout(rx_data_out));\n\t\n\tfifo #(.B(DBIT), .W(FIFO_W)) fifo_rx_unit\n\t\t(   .clk(clk), .reset(reset), .rd(rd_uart), \n\t\t\t.wr(rx_done_tick), .w_data(rx_data_out),\n\t\t\t.empty(rx_empty), .full(), .r_data(r_data));\n\t\n\ttx #(.DBIT(DBIT), .SB_TICK(SB_TICK)) uart_tx_unit\n\t\t(   .clk(clk), .reset(reset), .tx_start(wr_uart),\n\t\t\t.s_tick(tick), .data_in(w_data), \n\t\t\t.tx_done_tick(tx_done_tick), .tx(tx));\n\nendmodule"}
{"task_id": 191, "completion": "sky130_fd_sc_hdll__sdfxtp base (\n        .Q(Q),\n        .CLK(CLK),\n        .D(D),\n        .SCD(SCD),\n        .SCE(SCE),\n        .VPWR(VPWR),\n        .VGND(VGND),\n        .VPB(VPB),\n        .VNB(VNB)\n    );\n\nendmodule"}
{"task_id": 163, "completion": "wire Feedback;\nreg [9:0] x;\nwire [9:0] Random;\nreg  [9:0] RandomLatched;\n\nalways @ (posedge MTxClk or posedge Reset)\nbegin\n  if(Reset)\n    x[9:0] <= #Tp 0;\n  else\n    x[9:0] <= #Tp {x[8:0], Feedback};\nend\n\nassign Feedback = ~(x[2] ^ x[9]);\n\nassign Random [0] = x[0];\nassign Random [1] = (RetryCnt > 1) ? x[1] : 1'b0;\nassign Random [2] = (RetryCnt > 2) ? x[2] : 1'b0;\nassign Random [3] = (RetryCnt > 3) ? x[3] : 1'b0;\nassign Random [4] = (RetryCnt > 4) ? x[4] : 1'b0;\nassign Random [5] = (RetryCnt > 5) ? x[5] : 1'b0;\nassign Random [6] = (RetryCnt > 6) ? x[6] : 1'b0;\nassign Random [7] = (RetryCnt > 7) ? x[7] : 1'b0;\nassign Random [8] = (RetryCnt > 8) ? x[8] : 1'b0;\nassign Random [9] = (RetryCnt > 9) ? x[9] : 1'b0;\n\nalways @ (posedge MTxClk or posedge Reset)\nbegin\n  if(Reset)\n    RandomLatched <= #Tp 10'h000;\n  else\n    begin\n      if(StateJam & StateJam_q)\n        RandomLatched <= #Tp Random;\n    end\nend\n\nassign RandomEq0 = RandomLatched == 10'h0;\n\nassign RandomEqByteCnt = ByteCnt[9:0] == RandomLatched & (&NibCnt[6:0]);\n\nendmodule"}
{"task_id": 176, "completion": "parameter       DATA_WIDTH = 64;\n  localparam      DW = DATA_WIDTH - 1;\n  input           dac_clk;\n  input           dac_rd;\n  output          dac_valid;\n  output  [DW:0]  dac_data;\n  input           dma_clk;\n  output          dma_fs;\n  input           dma_valid;\n  input   [63:0]  dma_data;\n  output          dma_ready;\n  input           up_rstn;\n  input           up_clk;\n  input           up_sel;\n  input           up_wr;\n  input   [13:0]  up_addr;\n  input   [31:0]  up_wdata;\n  output  [31:0]  up_rdata;\n  output          up_ack;\n  wire            dac_rst;\n  wire            dma_rst;\n  wire            dma_ovf_s;\n  wire            dma_unf_s;\n  wire    [31:0]  dma_frmcnt_s;\n  ad_axis_dma_tx #(.DATA_WIDTH(DATA_WIDTH)) i_axis_dma_tx (\n    .dma_clk (dma_clk),\n    .dma_rst (dma_rst),\n    .dma_fs (dma_fs),\n    .dma_valid (dma_valid),\n    .dma_data (dma_data),\n    .dma_ready (dma_ready),\n    .dma_ovf (dma_ovf_s),\n    .dma_unf (dma_unf_s),\n    .dac_clk (dac_clk),\n    .dac_rst (dac_rst),\n    .dac_rd (dac_rd),\n    .dac_valid (dac_valid),\n    .dac_data (dac_data),\n    .dma_frmcnt (dma_frmcnt_s));\n  up_axis_dma_tx i_up_axis_dma_tx (\n    .dac_clk (dac_clk),\n    .dac_rst (dac_rst),\n    .dma_clk (dma_clk),\n    .dma_rst (dma_rst),\n    .dma_frmcnt (dma_frmcnt_s),\n    .dma_ovf (dma_ovf_s),\n    .dma_unf (dma_unf_s),\n    .up_rstn (up_rstn),\n    .up_clk (up_clk),\n    .up_sel (up_sel),\n    .up_wr (up_wr),\n    .up_addr (up_addr),\n    .up_wdata (up_wdata),\n    .up_rdata (up_rdata),\n    .up_ack (up_ack));\nendmodule"}
{"task_id": 115, "completion": "input  aclr;\n    input  clock;\n    input [15:0]  data;\n    input  rdreq;\n    input  wrreq;\n    output  almost_empty;\n    output  empty;\n    output  full;\n    output [15:0]  q;\n    output [9:0]  usedw;\n\n    wire [9:0] sub_wire0;\n    wire  sub_wire1;\n    wire  sub_wire2;\n    wire [15:0] sub_wire3;\n    wire  sub_wire4;\n    wire [9:0] usedw = sub_wire0[9:0];\n    wire  empty = sub_wire1;\n    wire  almost_empty = sub_wire2;\n    wire [15:0] q = sub_wire3[15:0];\n    wire  full = sub_wire4;\n\n    scfifo scfifo_component ( .rdreq (rdreq), .aclr (aclr), .clock (clock), .wrreq (wrreq), .data (data), .usedw (sub_wire0), .empty (sub_wire1), .almost_empty (sub_wire2), .q (sub_wire3), .full (sub_wire4) );\n    defparam\n        scfifo_component.add_ram_output_register = \"OFF\",\n        scfifo_component.almost_empty_value = 504,\n        scfifo_component.intended_device_family = \"Cyclone\",\n        scfifo_component.lpm_hint = \"RAM_BLOCK_TYPE=M4K\",\n        scfifo_component.lpm_numwords = 1024,\n        scfifo_component.lpm_showahead = \"OFF\",\n        scfifo_component.lpm_type = \"scfifo\",\n        scfifo_component.lpm_width = 16,\n        scfifo_component.lpm_widthu = 10,\n        scfifo_component.overflow_checking = \"ON\",\n        scfifo_component.underflow_checking = \"ON\",\n        scfifo_component.use_eab = \"ON\";\n\nendmodule"}
{"task_id": 36, "completion": "parameter\n    INPUT_BITS   = 16;\n  localparam\n    OUTPUT_BITS  = INPUT_BITS / 2 + INPUT_BITS % 2;\n  reg [OUTPUT_BITS-1:0]         start_gen;\n  reg [OUTPUT_BITS*INPUT_BITS-1:0] root_gen;\n  reg [OUTPUT_BITS*INPUT_BITS-1:0] radicand_gen;\n  wire [OUTPUT_BITS*INPUT_BITS-1:0] mask_gen;\n\n  always @ (posedge clk or negedge reset_n) begin\n    if (!reset_n) begin\n      start_gen[0]                 <= 0;\n      radicand_gen[INPUT_BITS-1:0] <= 0;\n      root_gen[INPUT_BITS-1:0]     <= 0;\n    end\n    else begin\n      start_gen[0] <= start;\n      if ( mask_gen[INPUT_BITS-1:0] <= radicand ) begin\n        radicand_gen[INPUT_BITS-1:0] <= radicand - mask_gen[INPUT_BITS-1:0];\n        root_gen[INPUT_BITS-1:0] <= mask_gen[INPUT_BITS-1:0];\n      end\n      else begin\n        radicand_gen[INPUT_BITS-1:0] <= radicand;\n        root_gen[INPUT_BITS-1:0] <= 0;\n      end\n    end\n  end\n\n  generate\n    genvar i;\n    for (i = 0; i < OUTPUT_BITS; i = i + 1) begin: mask_4\n      if (i % 2)\n        assign mask_gen[INPUT_BITS*(OUTPUT_BITS-i)-1:INPUT_BITS*(OUTPUT_BITS-i-1)]  = 4 << 4 * (i/2);\n      else\n        assign mask_gen[INPUT_BITS*(OUTPUT_BITS-i)-1:INPUT_BITS*(OUTPUT_BITS-i-1)]  = 1 << 4 * (i/2);\n    end\n    for (i = 0; i < OUTPUT_BITS - 1; i = i + 1) begin: pipeline\n      always @ (posedge clk or negedge reset_n) begin : pipeline_stage\n        if (!reset_n) begin\n          start_gen[i+1]                                    <= 0;\n          radicand_gen[INPUT_BITS*(i+2)-1:INPUT_BITS*(i+1)] <= 0;\n          root_gen[INPUT_BITS*(i+2)-1:INPUT_BITS*(i+1)]     <= 0;\n        end\n        else begin\n          start_gen[i+1] <= start_gen[i];\n          if ((root_gen[INPUT_BITS*(i+1)-1:INPUT_BITS*i] + \n               mask_gen[INPUT_BITS*(i+2)-1:INPUT_BITS*(i+1)]) <= radicand_gen[INPUT_BITS*(i+1)-1:INPUT_BITS*i]) begin\n            radicand_gen[INPUT_BITS*(i+2)-1:INPUT_BITS*(i+1)] <= radicand_gen[INPUT_BITS*(i+1)-1:INPUT_BITS*i] - \n                                                                 mask_gen[INPUT_BITS*(i+2)-1:INPUT_BITS*(i+1)] - \n                                                                 root_gen[INPUT_BITS*(i+1)-1:INPUT_BITS*i];\n            root_gen[INPUT_BITS*(i+2)-1:INPUT_BITS*(i+1)] <= (root_gen[INPUT_BITS*(i+1)-1:INPUT_BITS*i] >> 1) + \n                                                             mask_gen[INPUT_BITS*(i+2)-1:INPUT_BITS*(i+1)];\n          end\n          else begin\n            radicand_gen[INPUT_BITS*(i+2)-1:INPUT_BITS*(i+1)] <= radicand_gen[INPUT_BITS*(i+1)-1:INPUT_BITS*i];\n            root_gen[INPUT_BITS*(i+2)-1:INPUT_BITS*(i+1)]     <= root_gen[INPUT_BITS*(i+1)-1:INPUT_BITS*i] >> 1;\n          end\n        end\n      end\n    end\n  endgenerate\n\n  always @ (posedge clk or negedge reset_n) begin\n    if (!reset_n) begin\n      data_valid <= 0;\n      root       <= 0;\n    end\n    else begin\n      data_valid <= start_gen[OUTPUT_BITS-1];\n      if (root_gen[OUTPUT_BITS*INPUT_BITS-1:OUTPUT_BITS*INPUT_BITS-INPUT_BITS] > root_gen[OUTPUT_BITS*INPUT_BITS-1:OUTPUT_BITS*INPUT_BITS-INPUT_BITS])\n        root <= root_gen[OUTPUT_BITS*INPUT_BITS-1:OUTPUT_BITS*INPUT_BITS-INPUT_BITS] + 1;\n      else\n        root  <= root_gen[OUTPUT_BITS*INPUT_BITS-1:OUTPUT_BITS*INPUT_BITS-INPUT_BITS];\n    end\n  end\n\nendmodule"}
{"task_id": 139, "completion": "wire clk_fb;\n\n    wire [3:0] oclk;\n    wire [3:0] gclk;\n\n    MMCME2_ADV #(\n    .BANDWIDTH          (\"HIGH\"),\n    .COMPENSATION       (\"INTERNAL\"),\n\n    .CLKIN1_PERIOD      (10.0),\n    .CLKIN2_PERIOD      (10.0),\n\n    .CLKFBOUT_MULT_F    (10.5),\n    .CLKFBOUT_PHASE     (0),\n\n    .CLKOUT0_DIVIDE_F   (12.5),\n    .CLKOUT0_DUTY_CYCLE (0.50),\n    .CLKOUT0_PHASE      (45.0),\n\n    .CLKOUT1_DIVIDE     (32),\n    .CLKOUT1_DUTY_CYCLE (0.53125),\n    .CLKOUT1_PHASE      (90.0),\n\n    .CLKOUT2_DIVIDE     (48),\n    .CLKOUT2_DUTY_CYCLE (0.50),\n    .CLKOUT2_PHASE      (135.0),\n\n    .CLKOUT3_DIVIDE     (64),\n    .CLKOUT3_DUTY_CYCLE (0.50),\n    .CLKOUT3_PHASE      (45.0),\n\n    .STARTUP_WAIT       (\"FALSE\")\n    ) mmcm\n    (\n    .CLKIN1     (clk),\n    .CLKIN2     (clk),\n    .CLKINSEL   (1'b0),\n\n    .RST        (sw[0]),\n    .PWRDWN     (1'b0),\n\n    .CLKFBIN    (clk_fb),\n    .CLKFBOUT   (clk_fb),\n\n    .CLKOUT0    (oclk[0]),\n    .CLKOUT1    (oclk[1]),\n    .CLKOUT2    (oclk[2]),\n    .CLKOUT3    (oclk[3])\n    );\n\n    genvar i;\n    generate for (i=0; i<4; i=i+1) begin\n\n      BUFG bufg (.I(oclk[i]), .O(gclk[i]));\n\n      reg r;\n      always @(posedge gclk[i])\n        r <= ~r;\n\n      assign led[i] = r;\n\n    end endgenerate\n\n    assign led[4] = 1'b0;\n    assign led[5] = 1'b0;\n    assign led[6] = 1'b0;\n    assign led[7] = |sw;\n\n    assign jc2 = jc1;\n    assign jc4 = jc3;\n\nendmodule"}
{"task_id": 188, "completion": "wire    [1:0] logic_S;\n    wire    SYNTHESIZED_WIRE_0;\n    wire    SYNTHESIZED_WIRE_1;\n    wire    SYNTHESIZED_WIRE_2;\n    wire    SYNTHESIZED_WIRE_3;\n    wire    SYNTHESIZED_WIRE_4;\n    wire    SYNTHESIZED_WIRE_5;\n    wire    SYNTHESIZED_WIRE_6;\n    wire    SYNTHESIZED_WIRE_7;\n    wire    SYNTHESIZED_WIRE_8;\n    wire    SYNTHESIZED_WIRE_9;\n    wire    SYNTHESIZED_WIRE_10;\n\n    assign    SYNTHESIZED_WIRE_6 = 0;\n    assign    SYNTHESIZED_WIRE_7 = 1;\n\n\n    Mux_4_to_1    b2v_inst(\n        .I1(FS[0]),\n        .I2(FS[1]),\n        .I3(FS[2]),\n        .I4(FS[3]),\n        .S(logic_S),\n        .OUT(SYNTHESIZED_WIRE_2));\n\n\n    Mux_2_to_1    b2v_inst11(\n        .S(FS[3]),\n        .I1(SYNTHESIZED_WIRE_0),\n        .I2(SYNTHESIZED_WIRE_1),\n        .OUT(SYNTHESIZED_WIRE_3));\n\n\n    Mux_2_to_1    b2v_inst13(\n        .S(FS[4]),\n        .I1(SYNTHESIZED_WIRE_2),\n        .I2(SYNTHESIZED_WIRE_3),\n        .OUT(F));\n\n\n    Mux_2_to_1    b2v_inst14(\n        .S(FS[3]),\n        .I1(SYNTHESIZED_WIRE_4),\n        .I2(logic_S[1]),\n        .OUT(C_out));\n\n\n    Mux_2_to_1    b2v_inst2(\n        .S(FS[0]),\n        .I1(logic_S[1]),\n        .I2(SYNTHESIZED_WIRE_5),\n        .OUT(SYNTHESIZED_WIRE_9));\n\n    assign    SYNTHESIZED_WIRE_5 =  ~logic_S[1];\n\n\n    Mux_4_to_1    b2v_inst4(\n        .I1(SYNTHESIZED_WIRE_6),\n        .I2(SYNTHESIZED_WIRE_7),\n        .I3(logic_S[0]),\n        .I4(SYNTHESIZED_WIRE_8),\n        .S(FS[2:1]),\n        .OUT(SYNTHESIZED_WIRE_10));\n\n    assign    SYNTHESIZED_WIRE_8 =  ~logic_S[0];\n\n\n    Mux_2_to_1    b2v_inst8(\n        .S(FS[0]),\n        .I1(C_in),\n        .I2(A_from_next_bit),\n        .OUT(SYNTHESIZED_WIRE_1));\n\n\n    Full_adder    b2v_inst9(\n        .B(SYNTHESIZED_WIRE_9),\n        .A(SYNTHESIZED_WIRE_10),\n        .C_in(C_in),\n        .S(SYNTHESIZED_WIRE_0),\n        .C_out(SYNTHESIZED_WIRE_4));\n\n    assign    logic_S[0] = B;\n    assign    logic_S[1] = A;\n\nendmodule"}
{"task_id": 217, "completion": "wire port_b_1;\n\n\tent_ba inst_ba (\n\n\t);\n\tent_bb inst_bb (\n\n\t);\n\nendmodule"}
{"task_id": 181, "completion": "localparam BUFR_DIVIDE = 2;    BUFR #( .BUFR_DIVIDE(BUFR_DIVIDE), .SIM_DEVICE(\"7SERIES\") ) BUFR_clkdiv ( .O(clk_bufr), .CE(1'b1), .CLR(1'b0), .I(clk_pcie) );    assign fifo_rd_en = control_reg[4] ? counter_fifo_rd_en : fifo16to32_rd_en;    assign fifo_empty = control_reg[4] ? counter_fifo_empty : fifo16to32_empty;    assign fifo_full = control_reg[4] ? counter_fifo_full : fifo16to32_full;    wire [63:0] freq_det_q_d,freq_det_q_c;    reg [63:0] total_size_reg1;    reg [63:0] total_size_reg2;    wire [31:0] fifo16to32_dout;    wire [31:0] counter_data;    wire [31:0] counter_fifo_dout;    assign dout32 = control_reg[4] ? counter_fifo_dout : (control_reg[5] ? fifo16to32_dout : {fifo16to32_dout[7:0],fifo16to32_dout[15:8],fifo16to32_dout[23:16],fifo16to32_dout[31:24]});    wire rec_en = control_reg[1] ? 1'b0 : control_reg[0];    assign fifo16to32_rd_en = !fifo16to32_empty & !ddr3_fifo_full;    fifo8to32 fifo16to32_ch ( .rst(data_path_rst), .wr_clk(adc_clk), .rd_clk(clk_pcie), .din(din16), .wr_en(rec_en), .rd_en(fifo16to32_rd_en), .dout(fifo16to32_dout), .full(fifo16to32_full), .empty(fifo16to32_empty) );    wire counter_ce = control_reg[7] & control_reg[4] & rec_en;    assign counter_fifo_rd_en = !counter_fifo_empty & !ddr3_fifo_full;    COUNTER_LOAD_MACRO #( .COUNT_BY(48'h000000000001), .DEVICE(\"7SERIES\"), .WIDTH_DATA(32) ) counter32_ch ( .Q(counter_data), .CLK(clk_bufr), .CE(counter_ce & (~data_path_rst)), .DIRECTION(1'b1), .LOAD(control_reg[18]), .LOAD_DATA(counter_load_data), .RST(data_path_rst) );    counter_fifo counter_fifo_ch ( .rst(data_path_rst), .wr_clk(clk_bufr), .rd_clk(clk_pcie), .din(counter_data), .wr_en(counter_ce & (~data_path_rst)), .rd_en(counter_fifo_rd_en), .dout(counter_fifo_dout), .full(counter_fifo_full), .empty(counter_fifo_empty) );    assign total_size_mannul_reset = control_reg[17];    assign total_size = control_reg[4] ? total_size_reg2 : total_size_reg1;    always @(posedge c_div or posedge data_path_rst)begin if(data_path_rst)begin total_size_reg1 <= 64'b0; end else if(!rec_en | total_size_mannul_reset)begin total_size_reg1 <= 64'b0; end else begin total_size_reg1 <= total_size_reg1 + 64'd8; end end    always @(posedge clk_bufr or posedge data_path_rst)begin if(data_path_rst)begin total_size_reg2 <= 64'b0; end else if(!counter_ce | total_size_mannul_reset)begin total_size_reg2 <= 64'b0; end else begin total_size_reg2 <= total_size_reg2 + 64'd32; end end    assign freq_reg = control_reg[4] ? (freq_det_q_c<<3) : (freq_det_q_d<<3);    Freq_Count_Top freq_det_d ( .sys_clk_50m(clk_50m), .ch_c(c_div), .freq_reg(freq_det_q_d), .sys_rst_n(~data_path_rst) );    Freq_Count_Top freq_det_c ( .sys_clk_50m(clk_50m), .ch_c(clk_bufr), .freq_reg(freq_det_q_c), .sys_rst_n(~data_path_rst) );    endmodule"}
{"task_id": 164, "completion": "wire [14:0]DDR_addr;\n    wire [2:0]DDR_ba;\n    wire DDR_cas_n;\n    wire DDR_ck_n;\n    wire DDR_ck_p;\n    wire DDR_cke;\n    wire DDR_cs_n;\n    wire [3:0]DDR_dm;\n    wire [31:0]DDR_dq;\n    wire [3:0]DDR_dqs_n;\n    wire [3:0]DDR_dqs_p;\n    wire DDR_odt;\n    wire DDR_ras_n;\n    wire DDR_reset_n;\n    wire DDR_we_n;\n    wire FIXED_IO_ddr_vrn;\n    wire FIXED_IO_ddr_vrp;\n    wire [53:0]FIXED_IO_mio;\n    wire FIXED_IO_ps_clk;\n    wire FIXED_IO_ps_porb;\n    wire FIXED_IO_ps_srstb;\n    wire ac_mclk;\n    wire ac_mute_n;\n    wire clk125;\n    wire i2s_sclk;\n    wire i2s_sd;\n    wire i2s_ws;\n    wire iic_0_scl_i;\n    wire iic_0_scl_io;\n    wire iic_0_scl_o;\n    wire iic_0_scl_t;\n    wire iic_0_sda_i;\n    wire iic_0_sda_io;\n    wire iic_0_sda_o;\n    wire iic_0_sda_t;\n    wire [3:0]led;\n\n    IOBUF iic_0_scl_iobuf\n         (.I(iic_0_scl_o),\n          .IO(iic_0_scl_io),\n          .O(iic_0_scl_i),\n          .T(iic_0_scl_t));\n    IOBUF iic_0_sda_iobuf\n         (.I(iic_0_sda_o),\n          .IO(iic_0_sda_io),\n          .O(iic_0_sda_i),\n          .T(iic_0_sda_t));\n    opl3_cpu opl3_cpu_i\n         (.DDR_addr(DDR_addr),\n          .DDR_ba(DDR_ba),\n          .DDR_cas_n(DDR_cas_n),\n          .DDR_ck_n(DDR_ck_n),\n          .DDR_ck_p(DDR_ck_p),\n          .DDR_cke(DDR_cke),\n          .DDR_cs_n(DDR_cs_n),\n          .DDR_dm(DDR_dm),\n          .DDR_dq(DDR_dq),\n          .DDR_dqs_n(DDR_dqs_n),\n          .DDR_dqs_p(DDR_dqs_p),\n          .DDR_odt(DDR_odt),\n          .DDR_ras_n(DDR_ras_n),\n          .DDR_reset_n(DDR_reset_n),\n          .DDR_we_n(DDR_we_n),\n          .FIXED_IO_ddr_vrn(FIXED_IO_ddr_vrn),\n          .FIXED_IO_ddr_vrp(FIXED_IO_ddr_vrp),\n          .FIXED_IO_mio(FIXED_IO_mio),\n          .FIXED_IO_ps_clk(FIXED_IO_ps_clk),\n          .FIXED_IO_ps_porb(FIXED_IO_ps_porb),\n          .FIXED_IO_ps_srstb(FIXED_IO_ps_srstb),\n          .IIC_0_scl_i(iic_0_scl_i),\n          .IIC_0_scl_o(iic_0_scl_o),\n          .IIC_0_scl_t(iic_0_scl_t),\n          .IIC_0_sda_i(iic_0_sda_i),\n          .IIC_0_sda_o(iic_0_sda_o),\n          .IIC_0_sda_t(iic_0_sda_t),\n          .ac_mclk(ac_mclk),\n          .ac_mute_n(ac_mute_n),\n          .clk125(clk125),\n          .i2s_sclk(i2s_sclk),\n          .i2s_sd(i2s_sd),\n          .i2s_ws(i2s_ws),\n          .led(led));\nendmodule"}
{"task_id": 161, "completion": "parameter integer S = 7;\nparameter integer D = 6;\nparameter integer DS = (D*S)-1;\nwire rst;\nwire [DS:0] rxd;\nreg [DS:0] txd;\nreg [DS:0] rxr;\nreg state;\nreg bslip;\nreg [3:0] count;\nwire [6:0] clk_iserdes_data;\nparameter [S-1:0] TX_CLK_GEN = 7'b1100001;\nassign rst = reset;\nassign dummy_out = rxr;\nserdes_1_to_n_clk_pll_s8_diff #(  \n.S(S),  \n.CLKIN_PERIOD(6.700),\n.PLLD(1),\n.PLLX(S),\n.BS(\"TRUE\"))\ninst_clkin (\n.clkin_p (clkin_p),\n.clkin_n (clkin_n),\n.rxioclk (rx_bufpll_clk_xn),\n.pattern1(7'b1100001),\n.pattern2(7'b1100011),\n.rx_serdesstrobe(rx_serdesstrobe),\n.rx_bufg_pll_x1(rx_bufg_x1),\n.bitslip(bitslip),\n.reset(rst),\n.datain(clk_iserdes_data),\n.rx_pll_lckd(),\n.rx_pllout_xs(),\n.rx_bufpll_lckd(rx_bufpll_lckd));\nassign not_bufpll_lckd = ~rx_bufpll_lckd;\nserdes_1_to_n_data_s8_diff #(  \n.S(S),\n.D(D))\ninst_datain (\n.use_phase_detector(1'b1),\n.datain_p(datain_p),\n.datain_n(datain_n),\n.rxioclk(rx_bufpll_clk_xn),\n.rxserdesstrobe(rx_serdesstrobe),\n.gclk(rx_bufg_x1),\n.bitslip(bitslip),\n.reset(not_bufpll_lckd),\n.data_out(rxd),\n.debug_in(2'b00),\n.debug());\nalways @ (posedge rx_bufg_x1)\nbegin\n\ttxd <= rxd;\nend\nserdes_n_to_1_s8_diff #(  \n.S(S),\n.D(1))\ninst_clkout (\n.dataout_p(clkout_p),\n.dataout_n(clkout_n),\n.txioclk(rx_bufpll_clk_xn),\n.txserdesstrobe(rx_serdesstrobe),\n.gclk(rx_bufg_x1),\n.reset(rst),\n.datain(TX_CLK_GEN));\nserdes_n_to_1_s8_diff #(  \n.S(S),\n.D(D))\ninst_dataout (\n.dataout_p(dataout_p),\n.dataout_n(dataout_n),\n.txioclk(rx_bufpll_clk_xn),\n.txserdesstrobe(rx_serdesstrobe),\n.gclk(rx_bufg_x1),\n.reset(rst),\n.datain(txd));\nendmodule"}
{"task_id": 37, "completion": "reg [23:0] cnt_reg = 24'd0;\n\n    reg [N-1:0] debounce_reg[WIDTH-1:0];\n\n    reg [WIDTH-1:0] state;\n\n    assign out = state;\n\n    integer k;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            cnt_reg <= 0;\n            state <= 0;\n            \n            for (k = 0; k < WIDTH; k = k + 1) begin\n                debounce_reg[k] <= 0;\n            end\n        end else begin\n            if (cnt_reg < RATE) begin\n                cnt_reg <= cnt_reg + 24'd1;\n            end else begin\n                cnt_reg <= 24'd0;\n            end\n            \n            if (cnt_reg == 24'd0) begin\n                for (k = 0; k < WIDTH; k = k + 1) begin\n                    debounce_reg[k] <= {debounce_reg[k][N-2:0], in[k]};\n                end\n            end\n            \n            for (k = 0; k < WIDTH; k = k + 1) begin\n                if (|debounce_reg[k] == 0) begin\n                    state[k] <= 0;\n                end else if (&debounce_reg[k] == 1) begin\n                    state[k] <= 1;\n                end else begin\n                    state[k] <= state[k];\n                end\n            end\n        end\n    end\n\nendmodule"}
{"task_id": 58, "completion": "clocker clk( .clk1(clk24in),\n                 .clk2(clk20in),\n                 .clksel(clksel1),\n                 .divsel(clksel0),\n                 .clkout(clkout)\n               );\n\n    assign mema14  = 1'bZ;\n    assign mema15  = 1'bZ;\n    assign mema19  = 1'bZ;\n    assign romcs_n = 1'bZ;\n    assign memoe_n = 1'bZ;\n    assign memwe_n = 1'bZ;\n    assign cs      = 1'b0;\n    assign out_ramcs0_n = 1'b1;\n    assign out_ramcs1_n = 1'b1;\n    assign rd = 8'bZZZZ_ZZZZ;\n    assign warmres_n = 1'bZ;\n    assign d = 8'bZZZZ_ZZZZ;\n    assign {ra6,ra7,ra10,ra11,ra12,ra13} = 6'd0;\n    assign config_n = coldres_n;\nendmodule"}
{"task_id": 83, "completion": "wire or0_out             ;\n    wire and0_out            ;\n    wire and1_out            ;\n    wire and2_out            ;\n    wire nor0_out            ;\n    wire nor1_out            ;\n    wire or1_out_COUT        ;\n    wire pwrgood_pp0_out_COUT;\n    wire or2_out_SUM         ;\n    wire pwrgood_pp1_out_SUM ;\n\n    or                                 or0         (or0_out             , CIN, B                  );\n    and                                and0        (and0_out            , or0_out, A              );\n    and                                and1        (and1_out            , B, CIN                  );\n    or                                 or1         (or1_out_COUT        , and1_out, and0_out      );\n    sky130_fd_sc_ms__udp_pwrgood_pp$PG pwrgood_pp0 (pwrgood_pp0_out_COUT, or1_out_COUT, VPWR, VGND);\n    buf                                buf0        (COUT                , pwrgood_pp0_out_COUT    );\n    and                                and2        (and2_out            , CIN, A, B               );\n    nor                                nor0        (nor0_out            , A, or0_out              );\n    nor                                nor1        (nor1_out            , nor0_out, COUT          );\n    or                                 or2         (or2_out_SUM         , nor1_out, and2_out      );\n    sky130_fd_sc_ms__udp_pwrgood_pp$PG pwrgood_pp1 (pwrgood_pp1_out_SUM , or2_out_SUM, VPWR, VGND );\n    buf                                buf1        (SUM                 , pwrgood_pp1_out_SUM     );\n\nendmodule"}
{"task_id": 50, "completion": "wire a,b,c,d,e,f,g,h,i,j,k,l;\n    \n    assign an[3] = a;\n    assign an[2] = b;\n    assign an[1] = c;\n    assign an[0] = d;\n    \n    assign dsp_sel[1] = e;\n    \n    assign dsp_sel[0] = i;\n    \n                FDRSE #(\n                .INIT(1'b0) // Initial value of register (1'b0 or 1'b1)\n                ) DFF3(\n                .Q(a), // Data output\n                .C(clk), // Clock input\n                .CE(en), // Clock enable input\n                .D(d), // Data input\n                .R(1'b0), // Synchronous reset input\n                .S(1'b0) // Synchronous set input\n                );\n                FDRSE #(\n                .INIT(1'b1) // Initial value of register (1'b0 or 1'b1)\n                ) DFF2(\n                .Q(b), // Data output\n                .C(clk), // Clock input\n                .CE(en), // Clock enable input\n                .D(a), // Data input\n                .R(1'b0), // Synchronous reset input\n                .S(1'b0) // Synchronous set input\n                );\n                FDRSE #(\n                .INIT(1'b1) // Initial value of register (1'b0 or 1'b1)\n                ) DFF1(\n                .Q(c), // Data output\n                .C(clk), // Clock input\n                .CE(en), // Clock enable input\n                .D(b), // Data input\n                .R(1'b0), // Synchronous reset input\n                .S(1'b0) // Synchronous set input\n                );\n                FDRSE #(\n                .INIT(1'b1) // Initial value of register (1'b0 or 1'b1)\n                ) DFF0(\n                .Q(d), // Data output\n                .C(clk), // Clock input\n                .CE(en), // Clock enable input\n                .D(c), // Data input\n                .R(1'b0), // Synchronous reset input\n                .S(1'b0) // Synchronous set input\n                );\n                \n                FDRSE #(\n                .INIT(1'b1) // Initial value of register (1'b0 or 1'b1)\n                ) DFF7(\n                .Q(e), // Data output\n                .C(clk), // Clock input\n                .CE(en), // Clock enable input\n                .D(h), // Data input\n                .R(1'b0), // Synchronous reset input\n                .S(1'b0) // Synchronous set input\n                );\n                FDRSE #(\n                .INIT(1'b1) // Initial value of register (1'b0 or 1'b1)\n                ) DFF6(\n                .Q(f), // Data output\n                .C(clk), // Clock input\n                .CE(en), // Clock enable input\n                .D(e), // Data input\n                .R(1'b0), // Synchronous reset input\n                .S(1'b0) // Synchronous set input\n                );              \n                FDRSE #(\n                .INIT(1'b0) // Initial value of register (1'b0 or 1'b1)\n                ) DFF5(\n                .Q(g), // Data output\n                .C(clk), // Clock input\n                .CE(en), // Clock enable input\n                .D(f), // Data input\n                .R(1'b0), // Synchronous reset input\n                .S(1'b0) // Synchronous set input\n                );\n                FDRSE #(\n                .INIT(1'b0) // Initial value of register (1'b0 or 1'b1)\n                ) DFF4(\n                .Q(h), // Data output\n                .C(clk), // Clock input\n                .CE(en), // Clock enable input\n                .D(g), // Data input\n                .R(1'b0), // Synchronous reset input\n                .S(1'b0) // Synchronous set input\n                );\n                \n                FDRSE #(\n                .INIT(1'b1) // Initial value of register (1'b0 or 1'b1)\n                ) DFF11(\n                .Q(i), // Data output\n                .C(clk), // Clock input\n                .CE(en), // Clock enable input\n                .D(l), // Data input\n                .R(1'b0), // Synchronous reset input\n                .S(1'b0) // Synchronous set input\n                );\n                FDRSE #(\n                .INIT(1'b0) // Initial value of register (1'b0 or 1'b1)\n                ) DFF10(\n                .Q(j), // Data output\n                .C(clk), // Clock input\n                .CE(en), // Clock enable input\n                .D(i), // Data input\n                .R(1'b0), // Synchronous reset input\n                .S(1'b0) // Synchronous set input\n                );              \n                FDRSE #(\n                .INIT(1'b1) // Initial value of register (1'b0 or 1'b1)\n                ) DFF9(\n                .Q(k), // Data output\n                .C(clk), // Clock input\n                .CE(en), // Clock enable input\n                .D(j), // Data input\n                .R(1'b0), // Synchronous reset input\n                .S(1'b0) // Synchronous set input\n                );\n                FDRSE #(\n                .INIT(1'b0) // Initial value of register (1'b0 or 1'b1)\n                ) DFF8(\n                .Q(l), // Data output\n                .C(clk), // Clock input\n                .CE(en), // Clock enable input\n                .D(k), // Data input\n                .R(1'b0), // Synchronous reset input\n                .S(1'b0) // Synchronous set input\n                );\nendmodule"}
{"task_id": 232, "completion": "assign tx = rx;  wire [3:0] addr; wire ram_out; wire ram_in; RAM_SHIFTER #( .IO_WIDTH(16), .ADDR_WIDTH(4) ) shifter ( .clk(clk), .in(sw), .out(led), .addr(addr), .ram_out(ram_out), .ram_in(ram_in) ); RAM32X1D #( .INIT(32'h96A5_96A5) ) ram0 ( .WCLK(clk), .A4(sw[0]), .A3(addr[3]), .A2(addr[2]), .A1(addr[1]), .A0(addr[0]), .DPRA4(~sw[0]), .DPRA3(addr[3]), .DPRA2(addr[2]), .DPRA1(addr[1]), .DPRA0(addr[0]), .DPO(ram_out), .D(ram_in), .WE(1'b1) );endmodule"}
{"task_id": 82, "completion": "always @(Data_Dec_i)\n    begin\n        if(~Data_Dec_i[25]) begin Data_Bin_o = 5'b00000;//0\n        end else if(~Data_Dec_i[24]) begin Data_Bin_o = 5'b00001;//1\n        end else if(~Data_Dec_i[23]) begin Data_Bin_o = 5'b00010;//2\n        end else if(~Data_Dec_i[22]) begin Data_Bin_o = 5'b00011;//3\n        end else if(~Data_Dec_i[21]) begin Data_Bin_o = 5'b00100;//4\n        end else if(~Data_Dec_i[20]) begin Data_Bin_o = 5'b00101;//5\n        end else if(~Data_Dec_i[19]) begin Data_Bin_o = 5'b00110;//6\n        end else if(~Data_Dec_i[18]) begin Data_Bin_o = 5'b00111;//7\n        end else if(~Data_Dec_i[17]) begin Data_Bin_o = 5'b01000;//8\n        end else if(~Data_Dec_i[16]) begin Data_Bin_o = 5'b01001;//9\n        end else if(~Data_Dec_i[15]) begin Data_Bin_o = 5'b01010;//10\n        end else if(~Data_Dec_i[14]) begin Data_Bin_o = 5'b01011;//11\n        end else if(~Data_Dec_i[13]) begin Data_Bin_o = 5'b01100;//12\n        end else if(~Data_Dec_i[12]) begin Data_Bin_o = 5'b01101;//13\n        end else if(~Data_Dec_i[11]) begin Data_Bin_o = 5'b01110;//14\n        end else if(~Data_Dec_i[10]) begin Data_Bin_o = 5'b01111;//15\n        end else if(~Data_Dec_i[9])  begin Data_Bin_o = 5'b10000;//16\n        end else if(~Data_Dec_i[8])  begin Data_Bin_o = 5'b10001;//17\n        end else if(~Data_Dec_i[7])  begin Data_Bin_o = 5'b10010;//18\n        end else if(~Data_Dec_i[6])  begin Data_Bin_o = 5'b10011;//19\n        end else if(~Data_Dec_i[5])  begin Data_Bin_o = 5'b10100;//20\n        end else if(~Data_Dec_i[4])  begin Data_Bin_o = 5'b10101;//21\n        end else if(~Data_Dec_i[3])  begin Data_Bin_o = 5'b10110;//22\n        end else if(~Data_Dec_i[2])  begin Data_Bin_o = 5'b10111;//23\n        end else if(~Data_Dec_i[1])  begin Data_Bin_o = 5'b11000;//24\n        end else if(~Data_Dec_i[0])  begin Data_Bin_o = 5'b10101;//25\n        end\n        else Data_Bin_o = 5'b00000;//zero value\n    end\nendmodule"}
{"task_id": 226, "completion": "supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB;\n    supply0 VNB;\n\n    wire and0_out_COUT;\n    wire xor0_out_SUM;\n\n    and and0 (and0_out_COUT, A, B);\n    buf buf0 (COUT, and0_out_COUT);\n    xor xor0 (xor0_out_SUM, B, A);\n    buf buf1 (SUM, xor0_out_SUM);\n\nendmodule"}
{"task_id": 216, "completion": "assign clk_o = clk_i;\n\n  bsg_dff #(.width_p(width_p)) data_ff \n  (.clk_i(clk_i),.data_i(data_i),.data_o(data_o));\n\nendmodule"}
{"task_id": 130, "completion": "wire a,b,c,d,e,f,g,h,i,j,k,l; assign an[3] = a; assign an[2] = b; assign an[1] = c; assign an[0] = d; assign dsp_sel[1] = e; assign dsp_sel[0] = i; FDRSE #( .INIT(1'b0) ) DFF3( .Q(a), .C(clk), .CE(en), .D(d), .R(1'b0), .S(1'b0) ); FDRSE #( .INIT(1'b1) ) DFF2( .Q(b), .C(clk), .CE(en), .D(a), .R(1'b0), .S(1'b0) ); FDRSE #( .INIT(1'b1) ) DFF1( .Q(c), .C(clk), .CE(en), .D(b), .R(1'b0), .S(1'b0) ); FDRSE #( .INIT(1'b1) ) DFF0( .Q(d), .C(clk), .CE(en), .D(c), .R(1'b0), .S(1'b0) ); FDRSE #( .INIT(1'b1) ) DFF7( .Q(e), .C(clk), .CE(en), .D(h), .R(1'b0), .S(1'b0) ); FDRSE #( .INIT(1'b1) ) DFF6( .Q(f), .C(clk), .CE(en), .D(e), .R(1'b0), .S(1'b0) ); FDRSE #( .INIT(1'b0) ) DFF5( .Q(g), .C(clk), .CE(en), .D(f), .R(1'b0), .S(1'b0) ); FDRSE #( .INIT(1'b0) ) DFF4( .Q(h), .C(clk), .CE(en), .D(g), .R(1'b0), .S(1'b0) ); FDRSE #( .INIT(1'b1) ) DFF11( .Q(i), .C(clk), .CE(en), .D(l), .R(1'b0), .S(1'b0) ); FDRSE #( .INIT(1'b0) ) DFF10( .Q(j), .C(clk), .CE(en), .D(i), .R(1'b0), .S(1'b0) ); FDRSE #( .INIT(1'b1) ) DFF9( .Q(k), .C(clk), .CE(en), .D(j), .R(1'b0), .S(1'b0) ); FDRSE #( .INIT(1'b0) ) DFF8( .Q(l), .C(clk), .CE(en), .D(k), .R(1'b0), .S(1'b0) ); endmodule"}
{"task_id": 129, "completion": "wire [9:0] sub_wire0;    wire sub_wire1;    wire sub_wire2;    wire [15:0] sub_wire3;    wire sub_wire4;    wire [9:0] usedw = sub_wire0[9:0];    wire empty = sub_wire1;    wire almost_empty = sub_wire2;    wire [15:0] q = sub_wire3[15:0];    wire full = sub_wire4;    scfifo scfifo_component (                .rdreq (rdreq),                .aclr (aclr),                .clock (clock),                .wrreq (wrreq),                .data (data),                .usedw (sub_wire0),                .empty (sub_wire1),                .almost_empty (sub_wire2),                .q (sub_wire3),                .full (sub_wire4)                );    defparam        scfifo_component.add_ram_output_register = \"OFF\",        scfifo_component.almost_empty_value = 504,        scfifo_component.intended_device_family = \"Cyclone\",        scfifo_component.lpm_hint = \"RAM_BLOCK_TYPE=M4K\",        scfifo_component.lpm_numwords = 1024,        scfifo_component.lpm_showahead = \"OFF\",        scfifo_component.lpm_type = \"scfifo\",        scfifo_component.lpm_width = 16,        scfifo_component.lpm_widthu = 10,        scfifo_component.overflow_checking = \"ON\",        scfifo_component.underflow_checking = \"ON\",        scfifo_component.use_eab = \"ON\";endmodule"}
{"task_id": 125, "completion": "generate\n    genvar i;\n    if (NUMBER_OF_STAGES == 0) begin\n      always @ *\n        pipe_out = pipe_in;\n    end\n    else if (NUMBER_OF_STAGES == 1) begin\n      always @ (posedge clk or negedge reset_n)\n        pipe_out <= (!reset_n) ? 0 : pipe_in;\n    end\n    else begin\n      reg [BIT_WIDTH*(NUMBER_OF_STAGES-1)-1:0] pipe_gen;\n      always @ (posedge clk or negedge reset_n) begin\n        if (!reset_n) begin\n          pipe_gen[BIT_WIDTH-1:0] <= 0;\n          pipe_out <= 0;\n        end\n        else begin\n          pipe_gen[BIT_WIDTH-1:0] <= pipe_in;\n          pipe_out <= pipe_gen[BIT_WIDTH*(NUMBER_OF_STAGES-1)-1:BIT_WIDTH*(NUMBER_OF_STAGES-2)];\n        end\n      end\n      for (i = 1; i < NUMBER_OF_STAGES-1; i = i + 1) begin : pipeline\n        always @ (posedge clk or negedge reset_n)\n          pipe_gen[BIT_WIDTH*(i+1)-1:BIT_WIDTH*i] <= (!reset_n) ? 0 : pipe_gen[BIT_WIDTH*i-1:BIT_WIDTH*(i-1)];\n      end\n    end\n  endgenerate\nendmodule"}
{"task_id": 96, "completion": "wire [ADDR_WIDTH - 1:0] shiftReg_addr;\n    wire [DATA_WIDTH - 1:0] shiftReg_data, shiftReg_q;\n    reg [ADDR_WIDTH:0] mOutPtr = {(ADDR_WIDTH+1){1'b1}};\n    reg internal_empty_n = 0, internal_full_n = 1;\n\n    assign if_empty_n = internal_empty_n;\n    assign if_full_n = internal_full_n;\n    assign shiftReg_data = if_din;\n    assign if_dout = shiftReg_q;\n\n    always @ (posedge clk) begin\n        if (reset == 1'b1) begin\n            mOutPtr <= ~{ADDR_WIDTH+1{1'b0}};\n            internal_empty_n <= 1'b0;\n            internal_full_n <= 1'b1;\n        end else begin\n            if (((if_read & if_read_ce) == 1 & internal_empty_n == 1) && \n                ((if_write & if_write_ce) == 0 | internal_full_n == 0)) begin\n                mOutPtr <= mOutPtr -1;\n                if (mOutPtr == 0)\n                    internal_empty_n <= 1'b0;\n                internal_full_n <= 1'b1;\n            end else if (((if_read & if_read_ce) == 0 | internal_empty_n == 0) && \n                      ((if_write & if_write_ce) == 1 & internal_full_n == 1)) begin\n                mOutPtr <= mOutPtr +1;\n                internal_empty_n <= 1'b1;\n                if (mOutPtr == DEPTH-2)\n                    internal_full_n <= 1'b0;\n            end \n        end\n    end\n\n    assign shiftReg_addr = mOutPtr[ADDR_WIDTH] == 1'b0 ? mOutPtr[ADDR_WIDTH-1:0]:{ADDR_WIDTH{1'b0}};\n    assign shiftReg_ce = (if_write & if_write_ce) & internal_full_n;\n\n    FIFO_pixelq_op_img_data_stream_1_V_shiftReg \n    #(\n        .DATA_WIDTH(DATA_WIDTH),\n        .ADDR_WIDTH(ADDR_WIDTH),\n        .DEPTH(DEPTH))\n    U_FIFO_pixelq_op_img_data_stream_1_V_ram (\n        .clk(clk),\n        .data(shiftReg_data),\n        .ce(shiftReg_ce),\n        .a(shiftReg_addr),\n        .q(shiftReg_q));\nendmodule"}
{"task_id": 26, "completion": "reg [3:0] int_mm_no;\n    reg [5:0] lod_fract;\n\n    wire over_flow;\n    wire [9:0] log_in;\n\n    assign log_in = val[17:8];\n    assign over_flow = |val[31:18];\n\n    always @(posedge clk) begin\n        casex ({over_flow, log_in})\n            11'b0_10xxxxxxx_x, 11'b0_011xxxxxx_x: begin\n                if(trilinear_en && log_in[9]) begin\n                    int_mm_no <= 4'h9;\n                    lod_fract <= val[16:11];\n                end \n                else begin\n                    int_mm_no <= 4'h8;\n                    lod_fract <= val[15:10];\n                end\n            end\n            11'b0_010xxxxxx_x, 11'b0_0011xxxxx_x: begin\n                if(trilinear_en && log_in[8]) begin\n                    int_mm_no <= 4'h8;\n                    lod_fract <= val[15:10];\n                end \n                else begin\n                    int_mm_no <= 4'h7;\n                    lod_fract <= val[14:9];\n                end\n            end\n            11'b0_0010xxxxx_x, 11'b0_00011xxxx_x: begin\n                if(trilinear_en && log_in[7]) begin\n                    int_mm_no <= 4'h7;\n                    lod_fract <= val[14:9];\n                end \n                else begin\n                    int_mm_no <= 4'h6;\n                    lod_fract <= val[13:8];\n                end\n            end\n            11'b0_00010xxxx_x, 11'b0_000011xxx_x: begin\n                if(trilinear_en && log_in[6]) begin\n                    int_mm_no <= 4'h6;\n                    lod_fract <= val[13:8];\n                end \n                else begin\n                    int_mm_no <= 4'h5;\n                    lod_fract <= val[12:7];\n                end\n            end\n            11'b0_000010xxx_x, 11'b0_0000011xx_x: begin\n                if(trilinear_en && log_in[5]) begin\n                    int_mm_no <= 4'h5;\n                    lod_fract <= val[12:7];\n                end \n                else begin\n                    int_mm_no <= 4'h4;\n                    lod_fract <= val[11:6];\n                end\n            end\n            11'b0_0000010xx_x, 11'b0_00000011x_x: begin\n                if(trilinear_en && log_in[4]) begin\n                    int_mm_no <= 4'h4;\n                    lod_fract <= val[11:6];\n                end \n                else begin\n                    int_mm_no <= 4'h3;\n                    lod_fract <= val[10:5];\n                end\n            end\n            11'b0_00000010x_x, 11'b0_000000011_x: begin\n                if(trilinear_en && log_in[3]) begin\n                    int_mm_no <= 4'h3;\n                    lod_fract <= val[10:5];\n                end \n                else begin\n                    int_mm_no <= 4'h2;\n                    lod_fract <= val[9:4];\n                end\n            end\n            11'b0_000000010_x, 11'b0_000000001_1: begin\n                if(trilinear_en && log_in[2]) begin\n                    int_mm_no <= 4'h2;\n                    lod_fract <= val[9:4];\n                end \n                else begin\n                    int_mm_no <= 4'h1;\n                    lod_fract <= val[8:3];\n                end\n            end\n            11'b0_000000001_0, 11'b0_000000000_x: begin\n                if(trilinear_en && log_in[1]) begin\n                    int_mm_no <= 4'h1;\n                    lod_fract <= val[8:3];\n                end \n                else begin\n                    int_mm_no <= 4'h0;\n                    lod_fract <= val[7:2];\n                end\n            end\n            default: begin\n                    int_mm_no <= 4'h9;\n                    lod_fract <= val[16:11];\n            end\n        endcase\n    end\n\n    assign log2 = {int_mm_no, lod_fract};\n\nendmodule"}
{"task_id": 114, "completion": "function integer f_clogb2 (input integer size);\n  integer s;\n  begin\n    s = size;\n    s = s - 1;\n    for (f_clogb2=1; s>1; f_clogb2=f_clogb2+1)\n          s = s >> 1;\n  end\nendfunction\n\nlocalparam integer LP_LOG_FIFO_DEPTH = f_clogb2(C_FIFO_DEPTH);\n\nreg  [LP_LOG_FIFO_DEPTH-1:0]        fifo_index;\nwire [4-1:0]                        fifo_addr;\nwire                                push;\nwire                                pop ;\nreg                                 areset_r1;\n\nalways @(posedge aclk) begin \n  areset_r1 <= ~aresetn;\nend\n\nalways @(posedge aclk) begin \n  if (~aresetn) begin\n    fifo_index <= {LP_LOG_FIFO_DEPTH{1'b1}};\n  end\n  else begin\n    fifo_index <= push & ~pop ? fifo_index + 1'b1 :\n                  ~push & pop ? fifo_index - 1'b1 : \n                  fifo_index;\n  end\nend\n\nassign push = s_valid & s_ready;\n\nalways @(posedge aclk) begin \n  if (~aresetn) begin \n    s_ready <= 1'b0;\n  end\n  else begin \n    s_ready <= areset_r1 ? 1'b1 : \n               push & ~pop && (fifo_index == (C_FIFO_DEPTH - 2'd2)) ? 1'b0 :\n               ~push & pop ? 1'b1 : \n               s_ready;\n  end\nend\n\nassign pop = m_valid & m_ready;\n               \nalways @(posedge aclk) begin \n  if (~aresetn) begin \n    m_valid <= 1'b0;\n  end\n  else begin \n    m_valid <= ~push & pop && (fifo_index == {LP_LOG_FIFO_DEPTH{1'b0}}) ? 1'b0 :\n               push & ~pop ? 1'b1 : \n               m_valid;\n  end\nend\n\ngenerate \n  if (LP_LOG_FIFO_DEPTH < 4) begin : gen_pad_fifo_addr\n    assign fifo_addr[0+:LP_LOG_FIFO_DEPTH] = fifo_index[LP_LOG_FIFO_DEPTH-1:0];\n    assign fifo_addr[LP_LOG_FIFO_DEPTH+:(4-LP_LOG_FIFO_DEPTH)] = {4-LP_LOG_FIFO_DEPTH{1'b0}};\n  end\n  else begin : gen_fifo_addr\n    assign fifo_addr[LP_LOG_FIFO_DEPTH-1:0] = fifo_index[LP_LOG_FIFO_DEPTH-1:0];\n  end\nendgenerate\n\ngenerate\n  genvar i;\n  for (i = 0; i < C_PAYLOAD_WIDTH; i = i + 1) begin : gen_data_bit\n    SRL16E \n    u_srl_fifo(\n      .Q   ( m_payload[i] ) ,\n      .A0  ( fifo_addr[0]     ) ,\n      .A1  ( fifo_addr[1]     ) ,\n      .A2  ( fifo_addr[2]     ) ,\n      .A3  ( fifo_addr[3]     ) ,\n      .CE  ( push              ) ,\n      .CLK ( aclk              ) ,\n      .D   ( s_payload[i] ) \n    );\n  end\nendgenerate\n\nendmodule"}
{"task_id": 31, "completion": "function integer f_clogb2 (input integer size);\n  integer s;\n  begin\n    s = size;\n    s = s - 1;\n    for (f_clogb2=1; s>1; f_clogb2=f_clogb2+1)\n          s = s >> 1;\n  end\nendfunction // clogb2\n\nlocalparam integer LP_LOG_FIFO_DEPTH = f_clogb2(C_FIFO_DEPTH);\n\nreg  [LP_LOG_FIFO_DEPTH-1:0]        fifo_index;\nwire [4-1:0]                        fifo_addr;\nwire                                push;\nwire                                pop ;\nreg                                 areset_r1;\n\nalways @(posedge aclk) begin \n  areset_r1 <= ~aresetn;\nend\n\nalways @(posedge aclk) begin \n  if (~aresetn) begin\n    fifo_index <= {LP_LOG_FIFO_DEPTH{1'b1}};\n  end\n  else begin\n    fifo_index <= push & ~pop ? fifo_index + 1'b1 :\n                  ~push & pop ? fifo_index - 1'b1 : \n                  fifo_index;\n  end\nend\n\nassign push = s_valid & s_ready;\n\nalways @(posedge aclk) begin \n  if (~aresetn) begin \n    s_ready <= 1'b0;\n  end\n  else begin \n    s_ready <= areset_r1 ? 1'b1 : \n               push & ~pop && (fifo_index == (C_FIFO_DEPTH - 2'd2)) ? 1'b0 :\n               ~push & pop ? 1'b1 : \n               s_ready;\n  end\nend\n\nassign pop = m_valid & m_ready;\n               \nalways @(posedge aclk) begin \n  if (~aresetn) begin \n    m_valid <= 1'b0;\n  end\n  else begin \n    m_valid <= ~push & pop && (fifo_index == {LP_LOG_FIFO_DEPTH{1'b0}}) ? 1'b0 :\n               push & ~pop ? 1'b1 : \n               m_valid;\n  end\nend\n\ngenerate \n  if (LP_LOG_FIFO_DEPTH < 4) begin : gen_pad_fifo_addr\n    assign fifo_addr[0+:LP_LOG_FIFO_DEPTH] = fifo_index[LP_LOG_FIFO_DEPTH-1:0];\n    assign fifo_addr[LP_LOG_FIFO_DEPTH+:(4-LP_LOG_FIFO_DEPTH)] = {4-LP_LOG_FIFO_DEPTH{1'b0}};\n  end\n  else begin : gen_fifo_addr\n    assign fifo_addr[LP_LOG_FIFO_DEPTH-1:0] = fifo_index[LP_LOG_FIFO_DEPTH-1:0];\n  end\nendgenerate\n\ngenerate\n  genvar i;\n  for (i = 0; i < C_PAYLOAD_WIDTH; i = i + 1) begin : gen_data_bit\n    SRL16E \n    u_srl_fifo(\n      .Q   ( m_payload[i] ) ,\n      .A0  ( fifo_addr[0]     ) ,\n      .A1  ( fifo_addr[1]     ) ,\n      .A2  ( fifo_addr[2]     ) ,\n      .A3  ( fifo_addr[3]     ) ,\n      .CE  ( push              ) ,\n      .CLK ( aclk              ) ,\n      .D   ( s_payload[i] ) \n    );\n  end\nendgenerate\n\nendmodule"}
{"task_id": 268, "completion": "supply1 VPWR;    supply0 VGND;endmodule"}
{"task_id": 104, "completion": "wire a,b,c,d,e,f,g,h,i,j,k,l;        assign an[3] = a;        assign an[2] = b;        assign an[1] = c;        assign an[0] = d;        assign dsp_sel[1] = e;        assign dsp_sel[0] = i;                FDRSE #(                .INIT(1'b0) // Initial value of register (1'b0 or 1'b1)                ) DFF3(                .Q(a), // Data output                .C(clk), // Clock input                .CE(en), // Clock enable input                .D(d), // Data input                .R(1'b0), // Synchronous reset input                .S(1'b0) // Synchronous set input                );                FDRSE #(                .INIT(1'b1) // Initial value of register (1'b0 or 1'b1)                ) DFF2(                .Q(b), // Data output                .C(clk), // Clock input                .CE(en), // Clock enable input                .D(a), // Data input                .R(1'b0), // Synchronous reset input                .S(1'b0) // Synchronous set input                );                FDRSE #(                .INIT(1'b1) // Initial value of register (1'b0 or 1'b1)                ) DFF1(                .Q(c), // Data output                .C(clk), // Clock input                .CE(en), // Clock enable input                .D(b), // Data input                .R(1'b0), // Synchronous reset input                .S(1'b0) // Synchronous set input                );                FDRSE #(                .INIT(1'b1) // Initial value of register (1'b0 or 1'b1)                ) DFF0(                .Q(d), // Data output                .C(clk), // Clock input                .CE(en), // Clock enable input                .D(c), // Data input                .R(1'b0), // Synchronous reset input                .S(1'b0) // Synchronous set input                );                FDRSE #(                .INIT(1'b1) // Initial value of register (1'b0 or 1'b1)                ) DFF7(                .Q(e), // Data output                .C(clk), // Clock input                .CE(en), // Clock enable input                .D(h), // Data input                .R(1'b0), // Synchronous reset input                .S(1'b0) // Synchronous set input                );                FDRSE #(                .INIT(1'b1) // Initial value of register (1'b0 or 1'b1)                ) DFF6(                .Q(f), // Data output                .C(clk), // Clock input                .CE(en), // Clock enable input                .D(e), // Data input                .R(1'b0), // Synchronous reset input                .S(1'b0) // Synchronous set input                );                            FDRSE #(                .INIT(1'b0) // Initial value of register (1'b0 or 1'b1)                ) DFF5(                .Q(g), // Data output                .C(clk), // Clock input                .CE(en), // Clock enable input                .D(f), // Data input                .R(1'b0), // Synchronous reset input                .S(1'b0) // Synchronous set input                );                FDRSE #(                .INIT(1'b0) // Initial value of register (1'b0 or 1'b1)                ) DFF4(                .Q(h), // Data output                .C(clk), // Clock input                .CE(en), // Clock enable input                .D(g), // Data input                .R(1'b0), // Synchronous reset input                .S(1'b0) // Synchronous set input                );                FDRSE #(                .INIT(1'b1) // Initial value of register (1'b0 or 1'b1)                ) DFF11(                .Q(i), // Data output                .C(clk), // Clock input                .CE(en), // Clock enable input                .D(l), // Data input                .R(1'b0), // Synchronous reset input                .S(1'b0) // Synchronous set input                );                FDRSE #(                .INIT(1'b0) // Initial value of register (1'b0 or 1'b1)                ) DFF10(                .Q(j), // Data output                .C(clk), // Clock input                .CE(en), // Clock enable input                .D(i), // Data input                .R(1'b0), // Synchronous reset input                .S(1'b0) // Synchronous set input                );                FDRSE #(                .INIT(1'b1) // Initial value of register (1'b0 or 1'b1)                ) DFF9(                .Q(k), // Data output                .C(clk), // Clock input                .CE(en), // Clock enable input                .D(j), // Data input                .R(1'b0), // Synchronous reset input                .S(1'b0) // Synchronous set input                );                FDRSE #(                .INIT(1'b0) // Initial value of register (1'b0 or 1'b1)                ) DFF8(                .Q(l), // Data output                .C(clk), // Clock input                .CE(en), // Clock enable input                .D(k), // Data input                .R(1'b0), // Synchronous reset input                .S(1'b0) // Synchronous set input                );            endmodule"}
{"task_id": 248, "completion": "assign X = ~(A ^ B ^ C);\nendmodule"}
{"task_id": 219, "completion": "wire buf0_out_X;\n    wire pwrgood_pp0_out_X;\n\n    buf buf0 (buf0_out_X, A);\n    sky130_fd_sc_ls__udp_pwrgood_pp$PG pwrgood_pp0 (pwrgood_pp0_out_X, buf0_out_X, VPWR, VGND);\n    buf buf1 (X, pwrgood_pp0_out_X);\n\nendmodule"}
{"task_id": 66, "completion": "wire CLKFB_IN; wire CLKIN_IBUFG; wire CLK0_BUF; wire CLKFX1_BUF; wire CLKFX2_BUF; wire CLKDV_BUF; wire GND_BIT; wire dcm_progclk_buf; assign GND_BIT = 0; assign CLKIN_IBUFG_OUT = CLKIN_IBUFG; assign CLK0_OUT = CLKFB_IN; IBUFG  CLKIN_IBUFG_INST (.I(CLKIN_IN), .O(CLKIN_IBUFG)); BUFG  CLK0_BUFG_INST (.I(CLK0_BUF), .O(CLKFB_IN)); BUFG  CLKFX1_BUFG_INST (.I(CLKFX1_BUF), .O(CLKFX1_OUT)); BUFG  CLKFX2_BUFG_INST (.I(CLKFX2_BUF), .O(CLKFX2_OUT)); BUFG  CLKDV_BUFG_INST (.I(CLKDV_BUF), .O(CLKDV_OUT)); BUFG  DCMPROGCLK_BUFG_INST (.I(dcm_progclk), .O(dcm_progclk_buf)); DCM_SP #( .CLK_FEEDBACK(\"1X\"), .CLKDV_DIVIDE(8.0), .CLKFX_DIVIDE(8), .CLKFX_MULTIPLY(4), .CLKIN_DIVIDE_BY_2(\"FALSE\"),  .CLKIN_PERIOD(10.000), .CLKOUT_PHASE_SHIFT(\"NONE\"), .DESKEW_ADJUST(\"SYSTEM_SYNCHRONOUS\"), .DFS_FREQUENCY_MODE(\"LOW\"), .DLL_FREQUENCY_MODE(\"LOW\"), .DUTY_CYCLE_CORRECTION(\"TRUE\"), .FACTORY_JF(16'hC080), .PHASE_SHIFT(0), .STARTUP_WAIT(\"FALSE\") ) DCM_SP_INST (.CLKFB(CLKFB_IN), .CLKIN(CLKIN_IBUFG), .DSSEN(GND_BIT), .PSCLK(GND_BIT), .PSEN(GND_BIT), .PSINCDEC(GND_BIT), .RST(GND_BIT), .CLKDV(CLKDV_BUF), .CLKFX(CLKFX1_BUF), .CLKFX180(), .CLK0(CLK0_BUF), .CLK2X(), .CLK2X180(), .CLK90(), .CLK180(), .CLK270(), .LOCKED(DCM_SP_LOCKED_OUT), .PSDONE(), .STATUS()); DCM_CLKGEN #( .CLKFX_DIVIDE(100), .CLKFX_MULTIPLY(SPEED_MHZ), .CLKFXDV_DIVIDE(2), .CLKIN_PERIOD(10.0), .CLKFX_MD_MAX(0.000), .SPREAD_SPECTRUM(\"NONE\"), .STARTUP_WAIT(\"FALSE\") ) DCM_CLKGEN_INST ( .CLKIN(CLKIN_IBUFG), .CLKFX(CLKFX2_BUF), .FREEZEDCM(1'b0), .PROGCLK(dcm_progclk_buf), .PROGDATA(dcm_progdata), .PROGEN(dcm_progen), .PROGDONE(dcm_progdone), .LOCKED(dcm_locked), .STATUS(dcm_status), .RST(dcm_reset) ); endmodule"}
{"task_id": 47, "completion": "reg                           sel_first;\n    reg  [11:0]                   axaddr_incr;\n    reg  [8:0]                    axlen_cnt;\n    reg                           next_pending_r;\n    wire [3:0]                    axsize_shift;\n    wire [11:0]                   axsize_mask;\n\n    localparam    L_AXI_ADDR_LOW_BIT = (C_AXI_ADDR_WIDTH >= 12) ? 12 : 11;\n\n    generate\n      if (C_AXI_ADDR_WIDTH > 12) begin : ADDR_GT_4K\n        assign cmd_byte_addr = (sel_first) ? axaddr : {axaddr[C_AXI_ADDR_WIDTH-1:L_AXI_ADDR_LOW_BIT],axaddr_incr[11:0]};\n      end else begin : ADDR_4K\n        assign cmd_byte_addr = (sel_first) ? axaddr : axaddr_incr[11:0];\n      end\n    endgenerate\n\n    assign axsize_shift = (1 << axsize[1:0]);\n    assign axsize_mask  = ~(axsize_shift - 1'b1);\n\n    always @(posedge clk) begin\n      if (sel_first) begin\n        if(~next) begin\n          axaddr_incr <= axaddr[11:0] & axsize_mask;\n        end else begin\n          axaddr_incr <= (axaddr[11:0] & axsize_mask) + axsize_shift;\n        end\n      end else if (next) begin\n        axaddr_incr <= axaddr_incr + axsize_shift;\n      end\n    end\n\n    always @(posedge clk) begin\n      if (axhandshake)begin\n         axlen_cnt <= axlen;\n         next_pending_r <= (axlen >= 1);\n      end else if (next) begin\n        if (axlen_cnt > 1) begin\n          axlen_cnt <= axlen_cnt - 1;\n          next_pending_r <= ((axlen_cnt - 1) >= 1);\n        end else begin\n          axlen_cnt <= 9'd0;\n          next_pending_r <= 1'b0;\n        end\n      end\n    end\n\n    always @( * ) begin\n      if (axhandshake)begin\n         next_pending = (axlen >= 1);\n      end else if (next) begin\n        if (axlen_cnt > 1) begin\n          next_pending = ((axlen_cnt - 1) >= 1);\n        end else begin\n          next_pending = 1'b0;\n        end\n      end else begin\n        next_pending = next_pending_r;\n      end\n    end\n\n    always @(posedge clk) begin\n      if (reset | axhandshake) begin\n        sel_first <= 1'b1;\n      end else if (next) begin\n        sel_first <= 1'b0;\n      end\n    end\nendmodule"}
{"task_id": 271, "completion": "assign X = ((!A1_N & !A2_N) | (B1 & B2));\nendmodule"}
{"task_id": 244, "completion": "wire [WIDTH - 1:0]  chain [DELAY:0];\n    assign chain[0] = in;\n    assign out      = chain[DELAY];\n    genvar i;\n    generate\n        for(i = 0; i < DELAY; i = i + 1)\n        begin : chain_connector\n            wlatch #(\n                .WIDTH(WIDTH)\n            )\n            lat (\n                .ce(ce),\n                .rst(rst),\n                .clk(clk),\n                .in(chain[i]),\n                .out(chain[i + 1])\n            );\n        end\n    endgenerate\nendmodule"}
{"task_id": 246, "completion": "output X;\n    input  A;\n    input  B;\n    input  C;\n    input  VPWR;\n    input  VGND;\n    input  VPB;\n    input  VNB;\n    sky130_fd_sc_hvl__or3 base (\n        .X(X),\n        .A(A),\n        .B(B),\n        .C(C),\n        .VPWR(VPWR),\n        .VGND(VGND),\n        .VPB(VPB),\n        .VNB(VNB)\n    );\n\nendmodule"}
{"task_id": 286, "completion": "output Q    ;\n    input  CLK  ;\n    input  D    ;\n    input  SET_B;\n    input  VPWR ;\n    input  VGND ;\n    input  VPB  ;\n    input  VNB  ;\n\n    wire buf_Q        ;\n    wire SET          ;\n    reg  notifier     ;\n    wire D_delayed    ;\n    wire SET_B_delayed;\n    wire CLK_delayed  ;\n    wire awake        ;\n    wire cond0        ;\n    wire cond1        ;\n\n    not                                 not0 (SET   , SET_B_delayed                                    );\n    sky130_fd_sc_lp__udp_dff$PS_pp$PG$N dff0 (buf_Q , D_delayed, CLK_delayed, SET, notifier, VPWR, VGND);\n    assign awake = ( VPWR === 1'b1 );\n    assign cond0 = ( SET_B_delayed === 1'b1 );\n    assign cond1 = ( SET_B === 1'b1 );\n    buf                                 buf0 (Q     , buf_Q                                            );\n\nendmodule"}
{"task_id": 241, "completion": "/* synthesis syn_black_box black_box_pad_pin=\"slowest_sync_clk,ext_reset_in,aux_reset_in,mb_debug_sys_rst,dcm_locked,mb_reset,bus_struct_reset[0:0],peripheral_reset[0:0],interconnect_aresetn[0:0],peripheral_aresetn[0:0]\" */\n    input slowest_sync_clk;\n    input ext_reset_in;\n    input aux_reset_in;\n    input mb_debug_sys_rst;\n    input dcm_locked;\n    output mb_reset;\n    output [0:0]bus_struct_reset;\n    output [0:0]peripheral_reset;\n    output [0:0]interconnect_aresetn;\n    output [0:0]peripheral_aresetn;\nendmodule"}
{"task_id": 249, "completion": "output Y   ;\n    input  A1  ;\n    input  A2  ;\n    input  B1  ;\n    input  VPWR;\n    input  VGND;\n    input  VPB ;\n    input  VNB ;\n\n    wire or0_out          ;\n    wire nand0_out_Y      ;\n    wire pwrgood_pp0_out_Y;\n\n    or                                 or0         (or0_out          , A2, A1                 );\n    nand                               nand0       (nand0_out_Y      , B1, or0_out            );\n    sky130_fd_sc_ls__udp_pwrgood_pp$PG pwrgood_pp0 (pwrgood_pp0_out_Y, nand0_out_Y, VPWR, VGND);\n    buf                                buf0        (Y                , pwrgood_pp0_out_Y      );\n\nendmodule"}
{"task_id": 78, "completion": "localparam [3:0] \n\t\tstart = 4'd0,\n\t\tload_oper = 4'd1,\n\t\tzero_info_state = 4'd2,\n\t\tload_diff_exp = 4'd3,\n\t\textra1_64= 4'd4,\n\t\tnorm_sgf_first= 4'd5,\n\t\tadd_subt = 4'd6,\n\t\tadd_subt_r = 4'd7,\n\t\toverflow_add = 4'd8,\n\t\tround_sgf = 4'd9,\n\t\toverflow_add_r = 4'd10,\n\t\textra2_64= 4'd11,\n\t\tnorm_sgf_r = 4'd12,\n\t\tload_final_result  = 4'd13,\n\t\tready_flag = 4'd14;\nreg [3:0] state_reg, state_next ; \nassign load_1_o= (state_reg==load_oper);\nassign load_2_o= (state_reg==zero_info_state);\nalways @(posedge clk, posedge rst)\n\tif (rst) begin\n\t\tstate_reg <= start;\n\tend\n\telse begin\n\t\tstate_reg <= state_next;\n\tend\nalways @*\n\tbegin\n\tstate_next = state_reg;\nrst_int = 0;\nload_3_o=0;\nload_8_o=0;\nA_S_op_o=1;\nload_4_o=0;\nleft_right_o=0;\nbit_shift_o=0;\nload_5_o=0;\nload_6_o=0;\nload_7_o=0;\nctrl_a_o=0;\nctrl_b_o=2'b00;\nctrl_b_load_o=0;\nctrl_c_o=0;\nctrl_d_o=0;\nready = 0;\nrst_int = 0;\ncase(state_reg)\n\tstart: begin\n\t\trst_int=1;\n\t\tif(beg_FSM) begin\n\t\t\tstate_next = load_oper;\n\t\tend\n\tend\n\tload_oper: begin\n\t\tstate_next = zero_info_state;\n\tend\n\tzero_info_state: begin\n\t\tif (zero_flag_i)begin\n\t\t\tstate_next = ready_flag;\n\t\tend\n\t\telse begin\n\t\t\tstate_next = load_diff_exp;\n\t\tend\n\tend\n\tload_diff_exp: begin\n\t\tload_3_o = 1;\n\t\tstate_next = extra1_64;\n\tend\n\textra1_64: begin\n\t\tload_3_o = 1;\n\t\tif (norm_iteration_i)begin\n\t\t\tload_8_o=1;\n\t\t\tif(add_overflow_i)begin\n\t\t\t\tA_S_op_o=0;\n\t\t\t\tleft_right_o=0;\n\t\t\t\tbit_shift_o=1;\n\t\t\tend\n\t\t\telse begin\n\t\t\t\tA_S_op_o=1;\n\t\t\t\tleft_right_o=1;\n\t\t\t\tbit_shift_o=0;\n\t\t\tend\n\t\tend\n\t\tstate_next = norm_sgf_first;\n\tend\n\tnorm_sgf_first: begin\n\t\tload_4_o = 1;\n\t\tif (norm_iteration_i)begin\n\t\t\tif(add_overflow_i)begin\n\t\t\t\tleft_right_o=0;\n\t\t\t\tbit_shift_o=1;\n\t\t\t\tstate_next = round_sgf;\n\t\t\tend\n\t\t\telse begin\n\t\t\t\tleft_right_o=1;\n\t\t\t\tbit_shift_o=0;\n\t\t\t\tstate_next = round_sgf;\n\t\t\tend\n\t\tend\n\t\telse \n\t\t\tstate_next = add_subt;\n\tend\n\tadd_subt: begin\n\t\tload_5_o = 1;\n\t\tctrl_c_o = 1;\n\t\tstate_next = overflow_add;\n\tend\n\toverflow_add: begin\n\t\tload_6_o=1;\n\t\tctrl_b_load_o=1;\n\t\tif ( add_overflow_i)begin\n\t\t\tctrl_b_o=2'b10;\n\t\tend\n\t\telse begin\n\t\t\tA_S_op_o=1;\n\t\t\tctrl_b_o=2'b01;\n\t\tend\n\t\tstate_next = extra1_64;\n\tend\n\tround_sgf: begin\n\t\tload_4_o = 0;\n\t\tif(round_i) begin\n\t\t\tctrl_d_o =1;\n\t\t\tctrl_a_o = 1;\n\t\t\tstate_next = add_subt_r;\n\t\tend\n\t\telse begin\n\t\t\tstate_next = load_final_result;\n\t\tend\n\tend\n\tadd_subt_r: begin\n\t\tload_5_o = 1;\n\t\tstate_next = overflow_add_r;\n\tend\n\toverflow_add_r: begin\n\t\tctrl_b_load_o=1;\n\t\tif ( add_overflow_i)begin\n\t\t\tctrl_b_o=2'b10;\n\t\tend\n\t\telse begin\n\t\t\tctrl_b_o=2'b11;\n\t\tend\n\t\tstate_next = extra2_64;\n\tend\n\textra2_64: begin\n\t\tload_3_o = 1;\n\t\tload_8_o = 1;\n\t\tif ( add_overflow_i)begin\n\t\t\tA_S_op_o=0;\n\t\t\tbit_shift_o=1;\n\t\tend\n\t\tstate_next = norm_sgf_r;\n\tend\n\tnorm_sgf_r: begin\n\t\tload_4_o = 1;\n\t\tif ( add_overflow_i)begin\n\t\t\tleft_right_o=0;\n\t\t\tbit_shift_o=1;\n\t\tend\n\t\tstate_next = load_final_result;\n\tend\n\tload_final_result: begin\n\t\tload_7_o = 1;\n\t\tstate_next = ready_flag;\n\tend\n\tready_flag: begin\n\t\tready = 1;\n\t\tif(rst_FSM) begin\n\t\t\tstate_next = start;\n\t\tend\n\tend\n\tdefault: begin\n\t\tstate_next = start;\n\tend\nendcase\nend\nendmodule"}
{"task_id": 280, "completion": "parameter INIT_FILE = \"NIOS_onchip_memory2_0.hex\";\n\n  wire             clocken0;\n  wire    [ 31: 0] readdata;\n  wire             wren;\n  assign wren = chipselect & write;\n  assign clocken0 = clken & ~reset_req;\n  altsyncram the_altsyncram\n    (\n      .address_a (address),\n      .byteena_a (byteenable),\n      .clock0 (clk),\n      .clocken0 (clocken0),\n      .data_a (writedata),\n      .q_a (readdata),\n      .wren_a (wren)\n    );\n\n  defparam the_altsyncram.byte_size = 8,\n           the_altsyncram.init_file = INIT_FILE,\n           the_altsyncram.lpm_type = \"altsyncram\",\n           the_altsyncram.maximum_depth = 8192,\n           the_altsyncram.numwords_a = 8192,\n           the_altsyncram.operation_mode = \"SINGLE_PORT\",\n           the_altsyncram.outdata_reg_a = \"UNREGISTERED\",\n           the_altsyncram.ram_block_type = \"AUTO\",\n           the_altsyncram.read_during_write_mode_mixed_ports = \"DONT_CARE\",\n           the_altsyncram.width_a = 32,\n           the_altsyncram.width_byteena_a = 4,\n           the_altsyncram.widthad_a = 13;\n\nendmodule"}
{"task_id": 235, "completion": "output Y   ;\n    input  A1  ;\n    input  A2  ;\n    input  A3  ;\n    input  A4  ;\n    input  B1  ;\n    input  VPWR;\n    input  VGND;\n    input  VPB ;\n    input  VNB ;\n    sky130_fd_sc_ms__a41oi base (\n        .Y(Y),\n        .A1(A1),\n        .A2(A2),\n        .A3(A3),\n        .A4(A4),\n        .B1(B1),\n        .VPWR(VPWR),\n        .VGND(VGND),\n        .VPB(VPB),\n        .VNB(VNB)\n    );\n\nendmodule"}
{"task_id": 27, "completion": "localparam  RX_IDLE           = 0;\n    localparam  RX_CHECK_START    = 1;\n    localparam  RX_READING        = 2;\n    localparam  RX_CHECK_STOP     = 3;\n    localparam  RX_DELAY_RESTART  = 4;\n    localparam  RX_ERROR          = 5;\n    localparam  RX_RECEIVED       = 6;\n\n    localparam  TX_IDLE           = 0;\n    localparam  TX_SENDING        = 1;\n    localparam  TX_FINISHED       = 2;\n\n    reg         [2:0]             rx_state;\n    reg         [3:0]             rx_bit_count;\n    reg         [7:0]             rx_data;\n    reg         [31:0]            rx_clock_div;\n    reg         [31:0]            rx_clock_div_count;\n    reg         [31:0]            rx_prescaler_count;\n\n    reg         [2:0]             tx_state;\n    reg         [3:0]             tx_bit_count;\n    reg         [7:0]             tx_data;\n    reg         [31:0]            tx_clock_div;\n    reg         [31:0]            tx_prescaler_count;\n    reg         [31:0]            tx_clock_div_count;\n\n    assign      prescaler         = `CLOCK_RATE / (`PRESCALER_COUNT);\n    assign      default_clock_div = `CLOCK_RATE / (`PRESCALER_COUNT * DEFAULT_BAUDRATE);\n    assign      is_receiving      = (rx_state != RX_IDLE);\n    assign      is_transmitting   = (tx_state != TX_IDLE);\n\n    always @ (posedge clk) begin\n      if (rst || set_clock_div) begin\n        rx_state                  <=  RX_IDLE;\n\n        rx_bit_count              <=  0;\n\n        rx_clock_div_count        <=  0;\n        rx_clock_div              <=  `FULL_PERIOD;\n\n        rx_data                   <=  0;\n        rx_byte                   <=  0;\n        rx_error                  <=  0;\n        if (set_clock_div) begin\n          rx_clock_div            <=  user_clock_div;\n        end\n        else begin\n          rx_clock_div            <=  default_clock_div;\n        end\n      end\n      else begin\n        received                  <=  0;\n        rx_error                  <=  0;\n\n        rx_clock_div_count        <=  rx_clock_div_count + 1;\n        if (rx_clock_div_count >= rx_clock_div) begin\n           rx_prescaler_count     <=  rx_prescaler_count + 1;\n          rx_clock_div_count      <=  0;\n        end\n\n        case (rx_state)\n          RX_IDLE: begin\n            rx_prescaler_count    <=  0;\n            rx_data               <=  0;\n            rx_bit_count          <=  0;\n            if (!rx) begin\n              rx_state            <=  RX_CHECK_START;\n            end\n            else begin\n              rx_clock_div_count  <=  0;\n            end\n          end\n          RX_CHECK_START: begin\n            if (rx_prescaler_count >= (`HALF_PERIOD)) begin\n              rx_prescaler_count  <=  0;\n              if (!rx) begin\n                rx_state          <=  RX_READING;\n              end\n              else begin\n                rx_state          <=  RX_IDLE;\n              end\n            end\n          end\n          RX_READING: begin\n            if (rx_prescaler_count >= (`FULL_PERIOD)) begin\n              rx_data             <=  {rx, rx_data[7:1]};\n              rx_prescaler_count  <=  0;\n              if (rx_bit_count    >=  7) begin\n                rx_state          <=  RX_CHECK_STOP;\n              end\n              else begin\n                rx_bit_count      <=  rx_bit_count + 1;\n              end\n            end\n          end\n          RX_CHECK_STOP: begin\n            if (rx_prescaler_count >= (`FULL_PERIOD)) begin\n              if (rx) begin\n                rx_byte           <=  rx_data;\n                received          <=  1;\n                rx_state          <=  RX_IDLE;\n              end\n              else begin\n                rx_error          <=  1;\n                rx_state          <=  RX_IDLE;\n              end\n            end\n          end\n          default: begin\n            rx_state              <=  RX_IDLE;\n          end\n        endcase\n      end\n    end\n\n    always @ (posedge clk) begin\n      if (rst || set_clock_div) begin\n        tx                        <=  1;\n        tx_state                  <=  TX_IDLE;\n        tx_data                   <=  0;\n        tx_bit_count              <=  0;\n        tx_clock_div_count        <=  0;\n        tx_prescaler_count        <=  0;\n\n        if (set_clock_div) begin\n          tx_clock_div            <=  user_clock_div;\n        end\n        else begin\n          tx_clock_div            <=  default_clock_div;\n        end\n      end\n      else begin\n        tx_clock_div_count        <=  tx_clock_div_count + 1;\n        if (tx_clock_div_count >= tx_clock_div) begin\n          tx_prescaler_count      <=  tx_prescaler_count + 1;\n          tx_clock_div_count      <=  0;\n        end\n\n        case (tx_state)\n          TX_IDLE: begin\n            tx                    <=  1;\n            tx_clock_div_count    <=  1;\n            tx_prescaler_count    <=  0;\n            if (transmit) begin\n              tx                  <=  0;\n              tx_data             <=  tx_byte;\n              tx_bit_count        <=  0;\n              tx_state            <=  TX_SENDING;\n            end\n          end\n          TX_SENDING: begin\n            if (tx_prescaler_count >= (`FULL_PERIOD)) begin\n              tx_prescaler_count  <=  0;\n              if (tx_bit_count < 8) begin\n                tx                <=  tx_data[0];\n                tx_data           <=  {1'b0, tx_data[7:1]};\n                tx_bit_count      <=  tx_bit_count + 1;\n              end\n              else begin\n                tx                <=  1;\n                tx_state          <=  TX_FINISHED;\n              end\n            end\n          end\n          TX_FINISHED: begin\n            if (tx_prescaler_count >= (STOP_BITS * `FULL_PERIOD)) begin\n              tx_state            <=  TX_IDLE;\n            end\n          end\n          default: begin\n            tx_state              <=  TX_IDLE;\n          end\n        endcase\n      end\n    end\n\nendmodule"}
{"task_id": 213, "completion": "parameter n = 8, M = 256, m = 4, B = 4'b1100, mu = 253, r = 4, U = 46288;\n\nreg [7:0] count_bits0, count_bits1;\nreg [5:0] count_match;\nreg [2:0] count_blocks;\nreg [21:0] chi_sqr; \nreg [m-1:0] cap; \n\nalways @(posedge clk)\n\tif (rst) begin\n\t\tcount_bits0 <= 8'HFF;\n\t\tcount_bits1 <= 0;\n\t\tcount_blocks <= 8'HFF;\n\t\tcount_match <= 0;\n\t\tcap <= 0;\n\t\tchi_sqr <= 0;\n\t\tpass <= 0;\n\tend\n\telse begin\n\t\tcount_bits0 <= count_bits0 + 1; \n\t\tif (count_bits0 == (M-1)) begin\n\t\t\tcount_bits0 <= 0;\n\t\t\tcount_blocks <= count_blocks + 1;\n\t\t\tif (count_blocks == (n-1)) begin\n\t\t\t\tcount_blocks <= 0; \n\t\t\tend\n\t\tend\n\t\tcount_bits1 <= count_bits0;\n\t\tcap <= {cap[m-2:0],rand};\n\t\tif (~(|(cap^B))) count_match <= count_match + 1;\t\t\n\t\tif (count_bits1 == (M-1)) begin\n\t\t\tcap <= 0;\n\t\t\tcount_match <= 0;\n\t\t\tchi_sqr <= chi_sqr + ((count_match << r) - mu)*((count_match << r) - mu);\n\t\tend\n\t\tif (count_blocks == 0)\n\t\t\tif (count_bits1 == 0) \n\t\t\tbegin\n\t\t\t\tchi_sqr <= 0;\n\t\t\t\tif (chi_sqr <= U) pass <= 1;\n\t\t\t\telse pass <= 0;\n\t\t\tend\n\tend\n\nendmodule"}
{"task_id": 222, "completion": "reg [8:0] combin;\n    assign {RegWrite,RegDst,ALUSrc,ALUControl,Branch,MemWrite,MemtoReg} = combin;\n    always @(opcode)\n        case(opcode)\n            4'b0000: combin=9'b0_0000_0000;   //NOP\n            4'b0001: combin=9'b1_1000_1000;   //ADD\n            4'b0010: combin=9'b1_1001_0000;   //SUB\n            4'b0011: combin=9'b1_1001_1000;   //AND\n            4'b0100: combin=9'b1_1001_0000;   //OR\n            4'b0101: combin=9'b1_0110_1000;   //LFT SHift\n            4'b0110: combin=9'b1_0111_0000;   //RT Shift\n            4'b0111: combin=9'b1_0100_1000;   //ADDI\n            4'b1000: combin=9'b1_0101_0000;   //SUBI\n            4'b1001: combin=9'b1_0100_1001;   //LD REG\n            4'b1010: combin=9'b0_0100_1010;   //Store Reg\n            4'b1011: combin=9'b1_0100_1001;   //LD I\n            4'b1100: combin=9'b0_0100_1010;   //Store I\n            4'b1101: combin=9'b0_0001_0100;   //Jump\n            default: combin=9'b0_0000_0000;   //NOP\n        endcase\nendmodule"}
{"task_id": 117, "completion": "wire            ps2_clk_posedge;        \n  wire            ps2_clk_negedge;        \n\n  reg    [7:0]    idle_counter;            \n  reg             ps2_clk_reg;            \n  reg             ps2_data_reg;            \n  reg             last_ps2_clk;            \n\n  reg    [2:0]    ns_ps2_transceiver;        \n  reg    [2:0]    s_ps2_transceiver;        \n\n  localparam  PS2_STATE_0_IDLE            = 3'h0,        \n              PS2_STATE_1_DATA_IN         = 3'h1,        \n              PS2_STATE_2_COMMAND_OUT     = 3'h2,        \n              PS2_STATE_3_END_TRANSFER    = 3'h3,        \n              PS2_STATE_4_END_DELAYED     = 3'h4;        \n\n  always @(posedge clk) begin\n    if(reset == 1'b1) s_ps2_transceiver <= PS2_STATE_0_IDLE;\n    else              s_ps2_transceiver <= ns_ps2_transceiver;\n  end\n\n  always @(*) begin\n    ns_ps2_transceiver = PS2_STATE_0_IDLE;        \n    case (s_ps2_transceiver)\n    PS2_STATE_0_IDLE:\n        begin\n            if((idle_counter == 8'hFF) && (send_command == 1'b1))\n                ns_ps2_transceiver = PS2_STATE_2_COMMAND_OUT;\n            else if ((ps2_data_reg == 1'b0) && (ps2_clk_posedge == 1'b1))\n                ns_ps2_transceiver = PS2_STATE_1_DATA_IN;\n            else ns_ps2_transceiver = PS2_STATE_0_IDLE;\n        end\n    PS2_STATE_1_DATA_IN:\n        begin\n            if((received_data_en == 1'b1))   ns_ps2_transceiver = PS2_STATE_0_IDLE;\n            else                             ns_ps2_transceiver = PS2_STATE_1_DATA_IN;\n        end\n    PS2_STATE_2_COMMAND_OUT:\n        begin\n            if((command_was_sent == 1'b1) || (error_communication_timed_out == 1'b1))\n                ns_ps2_transceiver = PS2_STATE_3_END_TRANSFER;\n            else ns_ps2_transceiver = PS2_STATE_2_COMMAND_OUT;\n        end\n    PS2_STATE_3_END_TRANSFER:\n        begin\n            if(send_command == 1'b0) ns_ps2_transceiver = PS2_STATE_0_IDLE;\n            else if((ps2_data_reg == 1'b0) && (ps2_clk_posedge == 1'b1))\n                ns_ps2_transceiver = PS2_STATE_4_END_DELAYED;\n            else ns_ps2_transceiver = PS2_STATE_3_END_TRANSFER;\n        end\n    PS2_STATE_4_END_DELAYED:\n        begin\n            if(received_data_en == 1'b1) begin\n                if(send_command == 1'b0) ns_ps2_transceiver = PS2_STATE_0_IDLE;\n                else                     ns_ps2_transceiver = PS2_STATE_3_END_TRANSFER;\n            end\n            else ns_ps2_transceiver = PS2_STATE_4_END_DELAYED;\n        end\n    default:\n            ns_ps2_transceiver = PS2_STATE_0_IDLE;\n    endcase\n  end\n\n  always @(posedge clk) begin\n    if(reset == 1'b1)     begin\n        last_ps2_clk    <= 1'b1;\n        ps2_clk_reg     <= 1'b1;\n        ps2_data_reg    <= 1'b1;\n    end\n    else begin\n        last_ps2_clk    <= ps2_clk_reg;\n        ps2_clk_reg     <= ps2_clk;\n        ps2_data_reg    <= ps2_dat;\n    end\n  end\n\n  always @(posedge clk) begin\n    if(reset == 1'b1) idle_counter <= 6'h00;\n    else if((s_ps2_transceiver == PS2_STATE_0_IDLE) && (idle_counter != 8'hFF))\n        idle_counter <= idle_counter + 6'h01;\n    else if (s_ps2_transceiver != PS2_STATE_0_IDLE)\n        idle_counter <= 6'h00;\n  end\n\n  assign ps2_clk_posedge = ((ps2_clk_reg == 1'b1) && (last_ps2_clk == 1'b0)) ? 1'b1 : 1'b0;\n  assign ps2_clk_negedge = ((ps2_clk_reg == 1'b0) && (last_ps2_clk == 1'b1)) ? 1'b1 : 1'b0;\n\n  assign start_receiving_data      = (s_ps2_transceiver == PS2_STATE_1_DATA_IN);\n  assign wait_for_incoming_data    = (s_ps2_transceiver == PS2_STATE_3_END_TRANSFER);\n\n  ps2_mouse_cmdout mouse_cmdout (\n    .clk                           (clk),            \n    .reset                         (reset),\n    .the_command                   (the_command),\n    .send_command                  (send_command),\n    .ps2_clk_posedge               (ps2_clk_posedge),\n    .ps2_clk_negedge               (ps2_clk_negedge),\n    .ps2_clk                       (ps2_clk),        \n    .ps2_dat                       (ps2_dat),\n    .command_was_sent              (command_was_sent),    \n    .error_communication_timed_out (error_communication_timed_out)\n  );\n\n  ps2_mouse_datain mouse_datain (\n    .clk                    (clk),        \n    .reset                  (reset),\n    .wait_for_incoming_data (wait_for_incoming_data),\n    .start_receiving_data   (start_receiving_data),\n    .ps2_clk_posedge        (ps2_clk_posedge),\n    .ps2_clk_negedge        (ps2_clk_negedge),\n    .ps2_data               (ps2_data_reg),\n    .received_data          (received_data),   \n    .received_data_en       (received_data_en)\n  );\n\nendmodule"}
{"task_id": 233, "completion": "wire [3:0] sub_wire0;\n    wire [3:0] sub_wire1;\n    wire [3:0] dataout_h = sub_wire0[3:0];\n    wire [3:0] dataout_l = sub_wire1[3:0];\n\n    altddio_in\taltddio_in_component (\n                .datain (datain),\n                .inclock (inclock),\n                .aclr (aclr),\n                .dataout_h (sub_wire0),\n                .dataout_l (sub_wire1),\n                .aset (1'b0),\n                .inclocken (1'b1));\n    defparam\n        altddio_in_component.intended_device_family = \"Stratix II\",\n        altddio_in_component.invert_input_clocks = \"OFF\",\n        altddio_in_component.lpm_type = \"altddio_in\",\n        altddio_in_component.width = 4;\n\nendmodule"}
{"task_id": 34, "completion": "localparam [3:0]\n        start = 4'd0,\n        load_oper = 4'd1,\n        zero_info_state = 4'd2,\n        load_diff_exp = 4'd3,\n        extra1_64= 4'd4,\n        norm_sgf_first= 4'd5,\n        add_subt = 4'd6,\n        add_subt_r = 4'd7,\n        overflow_add = 4'd8,\n        round_sgf = 4'd9,\n        overflow_add_r = 4'd10,\n        extra2_64= 4'd11,\n        norm_sgf_r = 4'd12,\n        load_final_result  = 4'd13,\n        ready_flag = 4'd14;\n    reg [3:0] state_reg, state_next ;\n    assign load_1_o= (state_reg==load_oper);\n    assign load_2_o= (state_reg==zero_info_state);\n    always @(posedge clk, posedge rst)\n        if (rst) begin\n            state_reg <= start;\n        end else begin\n            state_reg <= state_next;\n        end\n    always @*\n    begin\n        state_next = state_reg;\n        rst_int = 0;\n        load_3_o=0;\n        load_8_o=0;\n        A_S_op_o=1;\n        load_4_o=0;\n        left_right_o=0;\n        bit_shift_o=0;\n        load_5_o=0;\n        load_6_o=0;\n        load_7_o=0;\n        ctrl_a_o=0;\n        ctrl_b_o=2'b00;\n        ctrl_b_load_o=0;\n        ctrl_c_o=0;\n        ctrl_d_o=0;\n        ready = 0;\n        rst_int = 0;\n        case(state_reg)\n            start: begin\n                rst_int=1;\n                if(beg_FSM) begin\n                    state_next = load_oper;\n                end\n            end\n            load_oper: begin\n                state_next = zero_info_state;\n            end\n            zero_info_state: begin\n                if (zero_flag_i)begin\n                    state_next = ready_flag;\n                end else begin\n                    state_next = load_diff_exp;\n                end\n            end\n            load_diff_exp: begin\n                load_3_o = 1;\n                state_next = extra1_64;\n            end\n            extra1_64: begin\n                load_3_o = 1;\n                if (norm_iteration_i)begin\n                    load_8_o=1;\n                    if(add_overflow_i)begin\n                        A_S_op_o=0;\n                        left_right_o=0;\n                        bit_shift_o=1;\n                    end\n                    else begin\n                        A_S_op_o=1;\n                        left_right_o=1;\n                        bit_shift_o=0;\n                    end\n                end\n                state_next = norm_sgf_first;\n            end\n            norm_sgf_first: begin\n                load_4_o = 1;\n                if (norm_iteration_i)begin\n                    if(add_overflow_i)begin\n                        left_right_o=0;\n                        bit_shift_o=1;\n                        state_next = round_sgf;\n                    end\n                    else begin\n                        left_right_o=1;\n                        bit_shift_o=0;\n                        state_next = round_sgf;\n                    end\n                end\n                else state_next = add_subt;\n            end\n            add_subt: begin\n                load_5_o = 1;\n                ctrl_c_o = 1;\n                state_next = overflow_add;\n            end\n            overflow_add: begin\n                load_6_o=1;\n                ctrl_b_load_o=1;\n                if (add_overflow_i)begin\n                    ctrl_b_o=2'b10;\n                end else begin\n                    A_S_op_o=1;\n                    ctrl_b_o=2'b01;\n                end\n                state_next = extra1_64;\n            end\n            round_sgf: begin\n                load_4_o = 0;\n                if(round_i) begin\n                    ctrl_d_o =1;\n                    ctrl_a_o = 1;\n                    state_next = add_subt_r;\n                end else begin\n                    state_next = load_final_result;\n                end\n            end\n            add_subt_r: begin\n                load_5_o = 1;\n                state_next = overflow_add_r;\n            end\n            overflow_add_r: begin\n                ctrl_b_load_o=1;\n                if (add_overflow_i)begin\n                    ctrl_b_o=2'b10;\n                end else begin\n                    ctrl_b_o=2'b11;\n                end\n                state_next = extra2_64;\n            end\n            extra2_64: begin\n                load_3_o = 1;\n                load_8_o = 1;\n                if (add_overflow_i)begin\n                    A_S_op_o=0;\n                    bit_shift_o=1;\n                end\n                state_next = norm_sgf_r;\n            end\n            norm_sgf_r: begin\n                load_4_o = 1;\n                if (add_overflow_i)begin\n                    left_right_o=0;\n                    bit_shift_o=1;\n                end\n                state_next = load_final_result;\n            end\n            load_final_result: begin\n                load_7_o = 1;\n                state_next = ready_flag;\n            end\n            ready_flag: begin\n                ready = 1;\n                if(rst_FSM) begin\n                    state_next = start;\n                end\n            end\n            default: begin\n                state_next =start;\n            end\n        endcase\n    end\nendmodule"}
{"task_id": 289, "completion": "supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\nendmodule"}
{"task_id": 67, "completion": "wire [W-1:0] intDX; wire [W-1:0] intDY; wire intAS; wire gtXY; wire eqXY; wire [W-2:0] intM; wire [W-2:0] intm; RegisterAdd #(.W(W)) XRegister (.clk(clk), .rst(rst), .load(load_a_i), .D(Data_X_i), .Q(intDX)); RegisterAdd #(.W(W)) YRegister (.clk(clk), .rst(rst), .load(load_a_i), .D(Data_Y_i), .Q(intDY)); RegisterAdd #(.W(1)) ASRegister (.clk(clk), .rst(rst), .load(load_a_i), .D(add_subt_i), .Q(intAS)); Comparator #(.W(W-1)) Magnitude_Comparator (.Data_X_i(intDX[W-2:0]), .Data_Y_i(intDY[W-2:0]), .gtXY_o(gtXY), .eqXY_o(eqXY)); xor_tri #(.W(W)) Op_verification (.A_i(intDX[W-1]), .B_i(intDY[W-1]), .C_i(intAS), .Z_o(real_op_o)); sgn_result result_sign_bit (.Add_Subt_i(intAS), .sgn_X_i(intDX[W-1]), .sgn_Y_i(intDY[W-1]), .gtXY_i(gtXY), .eqXY_i(eqXY), .sgn_result_o(sign_result)); MultiplexTxT #(.W(W-1)) MuxXY (.select(gtXY), .D0_i(intDX[W-2:0]), .D1_i(intDY[W-2:0]), .S0_o(intM), .S1_o(intm)); RegisterAdd #(.W(W-1)) MRegister (.clk(clk), .rst(rst), .load(load_b_i), .D(intM), .Q(DMP_o)); RegisterAdd #(.W(W-1)) mRegister (.clk(clk), .rst(rst), .load(load_b_i), .D(intm), .Q(DmP_o)); RegisterAdd #(.W(1)) SignRegister (.clk(clk), .rst(rst), .load(load_b_i), .D(sign_result), .Q(sign_final_result_o)); assign zero_flag_o = real_op_o & eqXY; endmodule"}
{"task_id": 127, "completion": "wire    [ 31: 0] M_mul_cell_p1;\n  wire    [ 31: 0] M_mul_cell_p2;\n  wire    [ 31: 0] M_mul_cell_p3;\n  wire             mul_clr;\n  wire    [ 31: 0] mul_src1;\n  wire    [ 31: 0] mul_src2;\n  assign mul_clr = ~reset_n;\n  assign mul_src1 = E_src1;\n  assign mul_src2 = E_src2;\n  altera_mult_add the_altmult_add_p1\n    (\n      .aclr0 (mul_clr),\n      .clock0 (clk),\n      .dataa (mul_src1[15 : 0]),\n      .datab (mul_src2[15 : 0]),\n      .ena0 (M_en),\n      .result (M_mul_cell_p1)\n    );\n\n  defparam the_altmult_add_p1.addnsub_multiplier_pipeline_aclr1 = \"ACLR0\",\n           the_altmult_add_p1.addnsub_multiplier_pipeline_register1 = \"CLOCK0\",\n           the_altmult_add_p1.addnsub_multiplier_register1 = \"UNREGISTERED\",\n           the_altmult_add_p1.dedicated_multiplier_circuitry = \"YES\",\n           the_altmult_add_p1.input_register_a0 = \"UNREGISTERED\",\n           the_altmult_add_p1.input_register_b0 = \"UNREGISTERED\",\n           the_altmult_add_p1.input_source_a0 = \"DATAA\",\n           the_altmult_add_p1.input_source_b0 = \"DATAB\",\n           the_altmult_add_p1.lpm_type = \"altera_mult_add\",\n           the_altmult_add_p1.multiplier1_direction = \"ADD\",\n           the_altmult_add_p1.multiplier_aclr0 = \"ACLR0\",\n           the_altmult_add_p1.multiplier_register0 = \"CLOCK0\",\n           the_altmult_add_p1.number_of_multipliers = 1,\n           the_altmult_add_p1.output_register = \"UNREGISTERED\",\n           the_altmult_add_p1.port_addnsub1 = \"PORT_UNUSED\",\n           the_altmult_add_p1.port_addnsub3 = \"PORT_UNUSED\",\n           the_altmult_add_p1.representation_a = \"UNSIGNED\",\n           the_altmult_add_p1.representation_b = \"UNSIGNED\",\n           the_altmult_add_p1.selected_device_family = \"CYCLONEV\",\n           the_altmult_add_p1.signed_pipeline_aclr_a = \"ACLR0\",\n           the_altmult_add_p1.signed_pipeline_aclr_b = \"ACLR0\",\n           the_altmult_add_p1.signed_pipeline_register_a = \"CLOCK0\",\n           the_altmult_add_p1.signed_pipeline_register_b = \"CLOCK0\",\n           the_altmult_add_p1.signed_register_a = \"UNREGISTERED\",\n           the_altmult_add_p1.signed_register_b = \"UNREGISTERED\",\n           the_altmult_add_p1.width_a = 16,\n           the_altmult_add_p1.width_b = 16,\n           the_altmult_add_p1.width_result = 32;\n\n  altera_mult_add the_altmult_add_p2\n    (\n      .aclr0 (mul_clr),\n      .clock0 (clk),\n      .dataa (mul_src1[15 : 0]),\n      .datab (mul_src2[31 : 16]),\n      .ena0 (M_en),\n      .result (M_mul_cell_p2)\n    );\n\n  defparam the_altmult_add_p2.addnsub_multiplier_pipeline_aclr1 = \"ACLR0\",\n           the_altmult_add_p2.addnsub_multiplier_pipeline_register1 = \"CLOCK0\",\n           the_altmult_add_p2.addnsub_multiplier_register1 = \"UNREGISTERED\",\n           the_altmult_add_p2.dedicated_multiplier_circuitry = \"YES\",\n           the_altmult_add_p2.input_register_a0 = \"UNREGISTERED\",\n           the_altmult_add_p2.input_register_b0 = \"UNREGISTERED\",\n           the_altmult_add_p2.input_source_a0 = \"DATAA\",\n           the_altmult_add_p2.input_source_b0 = \"DATAB\",\n           the_altmult_add_p2.lpm_type = \"altera_mult_add\",\n           the_altmult_add_p2.multiplier1_direction = \"ADD\",\n           the_altmult_add_p2.multiplier_aclr0 = \"ACLR0\",\n           the_altmult_add_p2.multiplier_register0 = \"CLOCK0\",\n           the_altmult_add_p2.number_of_multipliers = 1,\n           the_altmult_add_p2.output_register = \"UNREGISTERED\",\n           the_altmult_add_p2.port_addnsub1 = \"PORT_UNUSED\",\n           the_altmult_add_p2.port_addnsub3 = \"PORT_UNUSED\",\n           the_altmult_add_p2.representation_a = \"UNSIGNED\",\n           the_altmult_add_p2.representation_b = \"UNSIGNED\",\n           the_altmult_add_p2.selected_device_family = \"CYCLONEV\",\n           the_altmult_add_p2.signed_pipeline_aclr_a = \"ACLR0\",\n           the_altmult_add_p2.signed_pipeline_aclr_b = \"ACLR0\",\n           the_altmult_add_p2.signed_pipeline_register_a = \"CLOCK0\",\n           the_altmult_add_p2.signed_pipeline_register_b = \"CLOCK0\",\n           the_altmult_add_p2.signed_register_a = \"UNREGISTERED\",\n           the_altmult_add_p2.signed_register_b = \"UNREGISTERED\",\n           the_altmult_add_p2.width_a = 16,\n           the_altmult_add_p2.width_b = 16,\n           the_altmult_add_p2.width_result = 32;\n\n  altera_mult_add the_altmult_add_p3\n    (\n      .aclr0 (mul_clr),\n      .clock0 (clk),\n      .dataa (mul_src1[31 : 16]),\n      .datab (mul_src2[15 : 0]),\n      .ena0 (M_en),\n      .result (M_mul_cell_p3)\n    );\n\n  defparam the_altmult_add_p3.addnsub_multiplier_pipeline_aclr1 = \"ACLR0\",\n           the_altmult_add_p3.addnsub_multiplier_pipeline_register1 = \"CLOCK0\",\n           the_altmult_add_p3.addnsub_multiplier_register1 = \"UNREGISTERED\",\n           the_altmult_add_p3.dedicated_multiplier_circuitry = \"YES\",\n           the_altmult_add_p3.input_register_a0 = \"UNREGISTERED\",\n           the_altmult_add_p3.input_register_b0 = \"UNREGISTERED\",\n           the_altmult_add_p3.input_source_a0 = \"DATAA\",\n           the_altmult_add_p3.input_source_b0 = \"DATAB\",\n           the_altmult_add_p3.lpm_type = \"altera_mult_add\",\n           the_altmult_add_p3.multiplier1_direction = \"ADD\",\n           the_altmult_add_p3.multiplier_aclr0 = \"ACLR0\",\n           the_altmult_add_p3.multiplier_register0 = \"CLOCK0\",\n           the_altmult_add_p3.number_of_multipliers = 1,\n           the_altmult_add_p3.output_register = \"UNREGISTERED\",\n           the_altmult_add_p3.port_addnsub1 = \"PORT_UNUSED\",\n           the_altmult_add_p3.port_addnsub3 = \"PORT_UNUSED\",\n           the_altmult_add_p3.representation_a = \"UNSIGNED\",\n           the_altmult_add_p3.representation_b = \"UNSIGNED\",\n           the_altmult_add_p3.selected_device_family = \"CYCLONEV\",\n           the_altmult_add_p3.signed_pipeline_aclr_a = \"ACLR0\",\n           the_altmult_add_p3.signed_pipeline_aclr_b = \"ACLR0\",\n           the_altmult_add_p3.signed_pipeline_register_a = \"CLOCK0\",\n           the_altmult_add_p3.signed_pipeline_register_b = \"CLOCK0\",\n           the_altmult_add_p3.signed_register_a = \"UNREGISTERED\",\n           the_altmult_add_p3.signed_register_b = \"UNREGISTERED\",\n           the_altmult_add_p3.width_a = 16,\n           the_altmult_add_p3.width_b = 16,\n           the_altmult_add_p3.width_result = 32;\n\nendmodule"}
{"task_id": 292, "completion": "output X   ;\n    input  A1  ;\n    input  A2  ;\n    input  B1  ;\n    input  B2  ;\n    input  VPWR;\n    input  VGND;\n    input  VPB ;\n    input  VNB ;\n    sky130_fd_sc_ls__o22a base (\n        .X(X),\n        .A1(A1),\n        .A2(A2),\n        .B1(B1),\n        .B2(B2),\n        .VPWR(VPWR),\n        .VGND(VGND),\n        .VPB(VPB),\n        .VNB(VNB)\n    );\n\nendmodule"}
{"task_id": 220, "completion": "parameter CW                    = 0;\nparameter DW                    = 7;\nparameter EW                    = 0;\nparameter WIW                   = 9;\nparameter HIW                   = 7;\nparameter WIDTH_IN             = 640;\nparameter WIDTH_DROP_MASK       = 4'b0000;\nparameter HEIGHT_DROP_MASK      = 4'b0000;\nparameter MH_WW                = 9;\nparameter MH_WIDTH_IN          = 640;\nparameter MH_CW                = 0;\nparameter MW_CW                = 0;\n\n// Internal Wires\nwire            [CW: 0]    internal_channel;\nwire            [DW: 0]    internal_data;\nwire                        internal_startofpacket;\nwire                        internal_endofpacket;\nwire                        internal_valid;\n\nwire                        internal_ready;\n\n// Output Assignments\nassign stream_out_empty        = 'h0;\n\naltera_up_video_scaler_multiply_height Multiply_Height (\n\t.clk                          (clk),\n\t.reset                       (reset),\n\t.stream_in_data              (stream_in_data),\n\t.stream_in_startofpacket      (stream_in_startofpacket),\n\t.stream_in_endofpacket        (stream_in_endofpacket),\n\t.stream_in_valid             (stream_in_valid),\n\t.stream_out_ready            (stream_out_ready),\n\t.stream_in_ready             (stream_in_ready),\n\t.stream_out_channel          (stream_out_channel),\n\t.stream_out_data             (stream_out_data),\n\t.stream_out_startofpacket    (stream_out_startofpacket),\n\t.stream_out_endofpacket      (stream_out_endofpacket),\n\t.stream_out_valid            (stream_out_valid)\n);\ndefparam\n\tMultiply_Height.DW          = DW,\n\tMultiply_Height.WW          = MH_WW,\n\tMultiply_Height.WIDTH       = MH_WIDTH_IN,\n\tMultiply_Height.MCW         = MH_CW;\n\nendmodule"}
{"task_id": 290, "completion": "ClockDivider_clk_wiz inst\n  (\n  .clk(clk),\n  .clk_vga(clk_vga),\n  .clk_cpu(clk_cpu),\n  .clk_2cpu(clk_2cpu)              \n  );\n\nendmodule"}
{"task_id": 231, "completion": "reg VS = 0;\n    reg HS = 0;\n    wire clk_25MHz;\n    reg [9:0] CurHPos = 0;\n    reg [9:0] CurVPos = 0;\n    reg HBlank_reg, VBlank_reg, Blank = 0;\n    reg [9:0] CurrentX = 0;\n    reg [8:0] CurrentY = 0;\n    clock_divider clk_div(.clk_in(clk_50MHz), .clk_out(clk_25MHz));\n    clock_shift clk_shift(.clk_in(clk_25MHz), .clk_out(CLK_DATA));\n    always @(posedge clk_25MHz) begin\n        if(CurHPos < HLimit-1) begin\n            CurHPos <= CurHPos + 1;\n        end\n        else begin\n            CurHPos <= 0;\n            if(CurVPos < VLimit-1)\n                CurVPos <= CurVPos + 1;\n            else\n                CurVPos <= 0;\n        end\n        if(RESET) begin\n            CurHPos <= 0;\n            CurVPos <= 0;\n        end\n    end\n    always @(posedge clk_25MHz)\n        if((CurHPos < HSyncWidth) && ~RESET)\n            HS <= 1;\n        else\n            HS <= 0;\n    always @(posedge clk_25MHz)\n        if((CurVPos < VSyncWidth) && ~RESET)\n            VS <= 1;\n        else\n            VS <= 0;\n    always @(posedge clk_25MHz) \n        if((CurHPos >= HSyncWidth + HFrontPorch) && (CurHPos < HSyncWidth + HFrontPorch + HDisplayArea) || RESET)\n            HBlank_reg <= 0;\n        else\n            HBlank_reg <= 1;\n    always @(posedge clk_25MHz)\n        if((CurVPos >= VSyncWidth + VFrontPorch) && (CurVPos < VSyncWidth + VFrontPorch + VDisplayArea) || RESET)\n            VBlank_reg <= 0;\n        else\n            VBlank_reg <= 1;\n    always @(posedge clk_25MHz)\n        if((HBlank_reg || VBlank_reg) && ~RESET)\n            Blank <= 1;\n        else\n            Blank <= 0;\n    always @(posedge clk_25MHz)\n        if(HBlank_reg && ~RESET)\n            CurrentX <= 0;\n        else\n            CurrentX <= CurHPos - HSyncWidth - HFrontPorch;\n    always @(posedge clk_25MHz) \n        if(VBlank_reg && ~RESET)\n            CurrentY <= 0;\n        else\n            CurrentY <= CurVPos - VSyncWidth - VFrontPorch;\n    assign CURX = CurrentX;\n    assign CURY = CurrentY;\n    assign hs_vga = HS;\n    assign vs_vga = VS;\n    assign RED = (Blank) ? 3'b000 : COLOR[7:5];\n    assign GREEN = (Blank) ? 3'b000 : COLOR[4:2];\n    assign BLUE = (Blank) ? 2'b00 : COLOR[1:0];\nendmodule"}
{"task_id": 135, "completion": "localparam MAX_DEPTH = 9;    wire[META_WIDTH+MEMORY_WIDTH-1:0] prarr_data [0:MAX_DEPTH-1];    wire[MAX_DEPTH-1:0] prarr_valid ;    wire[MAX_DEPTH-1:0] prarr_scan ;    wire[MAX_DEPTH-1:0] prarr_ready ;    wire[MAX_DEPTH-1:0] prarr_in_ready ;    wire [MEMORY_WIDTH-1:0] varr_data [0:MAX_DEPTH];    wire [MAX_DEPTH:0] varr_valid;    wire [MAX_DEPTH:0] varr_last;    wire [MAX_DEPTH:0] varr_drop;    wire [MAX_DEPTH:0] varr_ready;    assign varr_data[0] = value_data;    assign varr_valid[0] = value_valid;    assign varr_last[0] = value_last;    assign varr_drop[0] = value_drop;    assign value_ready = varr_ready[0];    assign output_data = varr_data[MAX_DEPTH];    assign output_valid = varr_valid[MAX_DEPTH];    assign output_last = varr_last[MAX_DEPTH];    assign output_drop = varr_drop[MAX_DEPTH];    assign varr_ready[MAX_DEPTH] = output_ready;    assign pred_ready = &prarr_in_ready;    generate        genvar i;        for (i=0; i<MAX_DEPTH; i=i+1) begin            if (i<PIPE_DEPTH-1) begin                nukv_fifogen #(                        .DATA_SIZE(48+96+1),                        .ADDR_BITS(7)                    ) fifo_predconfig (                    .clk(clk),                    .rst(rst),                    .s_axis_tdata({pred_data[META_WIDTH+i*48 +: 48],pred_data[META_WIDTH-1:0], pred_scan}),                    .s_axis_tvalid(pred_valid & pred_ready),                    .s_axis_tready(prarr_in_ready[i]),                    .m_axis_tdata({prarr_data[i],prarr_scan[i]}),                    .m_axis_tvalid(prarr_valid[i]),                    .m_axis_tready(prarr_ready[i])                );                nukv_Predicate_Eval #(.SUPPORT_SCANS(SUPPORT_SCANS))                  pred_eval                    (                    .clk(clk),                    .rst(rst),                    .pred_data(prarr_data[i]),                    .pred_valid(prarr_valid[i]),                    .pred_ready(prarr_ready[i]),                    .pred_scan((SUPPORT_SCANS==1) ? prarr_scan[i] : 0),                    .value_data(varr_data[i]),                    .value_last(varr_last[i]),                     .value_drop(varr_drop[i]),                    .value_valid(varr_valid[i]),                    .value_ready(varr_ready[i]),                    .output_valid(varr_valid[i+1]),                    .output_ready(varr_ready[i+1]),                    .output_data(varr_data[i+1]),                    .output_last(varr_last[i+1]),                    .output_drop(varr_drop[i+1]),                    .scan_on_outside(scan_on_outside)                );            end else if (i==PIPE_DEPTH-1) begin                nukv_fifogen #(                        .DATA_SIZE(48+96+1),                        .ADDR_BITS(7)                    ) fifo_predconfig (                    .clk(clk),                    .rst(rst),                    .s_axis_tdata({pred_data[META_WIDTH+i*48 +: 48],pred_data[META_WIDTH-1:0], pred_scan}),                    .s_axis_tvalid(pred_valid & pred_ready),                    .s_axis_tready(prarr_in_ready[i]),                    .m_axis_tdata({prarr_data[i],prarr_scan[i]}),                    .m_axis_tvalid(prarr_valid[i]),                    .m_axis_tready(prarr_ready[i])                );                nukv_Predicate_Eval #(.SUPPORT_SCANS(SUPPORT_SCANS))                  pred_eval                    (                    .clk(clk),                    .rst(rst),                    .pred_data(prarr_data[i]),                    .pred_valid(prarr_valid[i]),                    .pred_ready(prarr_ready[i]),                    .pred_scan((SUPPORT_SCANS==1) ? prarr_scan[i] : 0),                    .value_data(varr_data[i]),                    .value_last(varr_last[i]),                     .value_drop(varr_drop[i]),                    .value_valid(varr_valid[i]),                    .value_ready(varr_ready[i]),                    .output_valid(varr_valid[i+1]),                    .output_ready(varr_ready[i+1]),                    .output_data(varr_data[i+1]),                    .output_last(varr_last[i+1]),                    .output_drop(varr_drop[i+1]),                    .scan_on_outside(scan_on_outside),                    .error_input    (error_input),                    .cmd_valid      (cmd_valid),                    .cmd_length     (cmd_length),                    .cmd_meta       (cmd_meta),                    .cmd_ready      (cmd_ready)                );            end else begin                assign prarr_in_ready[i] = 1;                assign varr_data[i+1] = varr_data[i];                assign varr_valid[i+1] = varr_valid[i];                assign varr_last[i+1] = varr_last[i];                assign varr_drop[i+1] = varr_drop[i];                assign varr_ready[i] = varr_ready[i+1];            end        end    endgenerate    endmodule"}
{"task_id": 35, "completion": "assign s_awpayload[G_AXI_AWADDR_INDEX+:G_AXI_AWADDR_WIDTH] = s_axi_awaddr;\nassign s_awpayload[G_AXI_AWPROT_INDEX+:G_AXI_AWPROT_WIDTH] = s_axi_awprot;\n\nassign s_wpayload[G_AXI_WDATA_INDEX+:G_AXI_WDATA_WIDTH] = s_axi_wdata;\nassign s_wpayload[G_AXI_WSTRB_INDEX+:G_AXI_WSTRB_WIDTH] = s_axi_wstrb;\n\nassign s_axi_bresp = s_bpayload[G_AXI_BRESP_INDEX+:G_AXI_BRESP_WIDTH];\n\nassign s_arpayload[G_AXI_ARADDR_INDEX+:G_AXI_ARADDR_WIDTH] = s_axi_araddr;\nassign s_arpayload[G_AXI_ARPROT_INDEX+:G_AXI_ARPROT_WIDTH] = s_axi_arprot;\n\nassign s_axi_rdata = s_rpayload[G_AXI_RDATA_INDEX+:G_AXI_RDATA_WIDTH];\nassign s_axi_rresp = s_rpayload[G_AXI_RRESP_INDEX+:G_AXI_RRESP_WIDTH];\n\ngenerate\n  if (C_AXI_PROTOCOL == 0 || C_AXI_PROTOCOL == 1) begin : gen_axi4_or_axi3_packing\n    assign s_awpayload[G_AXI_AWSIZE_INDEX+:G_AXI_AWSIZE_WIDTH]   = s_axi_awsize;\n    assign s_awpayload[G_AXI_AWBURST_INDEX+:G_AXI_AWBURST_WIDTH] = s_axi_awburst;\n    assign s_awpayload[G_AXI_AWCACHE_INDEX+:G_AXI_AWCACHE_WIDTH] = s_axi_awcache;\n    assign s_awpayload[G_AXI_AWLEN_INDEX+:G_AXI_AWLEN_WIDTH]     = s_axi_awlen;\n    assign s_awpayload[G_AXI_AWLOCK_INDEX+:G_AXI_AWLOCK_WIDTH]   = s_axi_awlock;\n    assign s_awpayload[G_AXI_AWID_INDEX+:G_AXI_AWID_WIDTH]       = s_axi_awid;\n    assign s_awpayload[G_AXI_AWQOS_INDEX+:G_AXI_AWQOS_WIDTH]     = s_axi_awqos;\n\n    assign s_wpayload[G_AXI_WLAST_INDEX+:G_AXI_WLAST_WIDTH]      = s_axi_wlast;\n    if (C_AXI_PROTOCOL == 1) begin : gen_axi3_wid_packing\n      assign s_wpayload[G_AXI_WID_INDEX+:G_AXI_WID_WIDTH]        = s_axi_wid;\n    end\n    else begin : gen_no_axi3_wid_packing\n    end\n\n    assign s_axi_bid = s_bpayload[G_AXI_BID_INDEX+:G_AXI_BID_WIDTH];\n\n    assign s_arpayload[G_AXI_ARSIZE_INDEX+:G_AXI_ARSIZE_WIDTH]   = s_axi_arsize;\n    assign s_arpayload[G_AXI_ARBURST_INDEX+:G_AXI_ARBURST_WIDTH] = s_axi_arburst;\n    assign s_arpayload[G_AXI_ARCACHE_INDEX+:G_AXI_ARCACHE_WIDTH] = s_axi_arcache;\n    assign s_arpayload[G_AXI_ARLEN_INDEX+:G_AXI_ARLEN_WIDTH]     = s_axi_arlen;\n    assign s_arpayload[G_AXI_ARLOCK_INDEX+:G_AXI_ARLOCK_WIDTH]   = s_axi_arlock;\n    assign s_arpayload[G_AXI_ARID_INDEX+:G_AXI_ARID_WIDTH]       = s_axi_arid;\n    assign s_arpayload[G_AXI_ARQOS_INDEX+:G_AXI_ARQOS_WIDTH]     = s_axi_arqos;\n\n    assign s_axi_rlast = s_rpayload[G_AXI_RLAST_INDEX+:G_AXI_RLAST_WIDTH];\n    assign s_axi_rid   = s_rpayload[G_AXI_RID_INDEX+:G_AXI_RID_WIDTH];\n\n    if (C_AXI_SUPPORTS_REGION_SIGNALS == 1 && G_AXI_AWREGION_WIDTH > 0) begin : gen_region_signals\n      assign s_awpayload[G_AXI_AWREGION_INDEX+:G_AXI_AWREGION_WIDTH] = s_axi_awregion;\n      assign s_arpayload[G_AXI_ARREGION_INDEX+:G_AXI_ARREGION_WIDTH] = s_axi_arregion;\n    end \n    else begin : gen_no_region_signals\n    end\n    if (C_AXI_SUPPORTS_USER_SIGNALS == 1 && C_AXI_PROTOCOL != 2) begin : gen_user_signals\n      assign s_awpayload[G_AXI_AWUSER_INDEX+:G_AXI_AWUSER_WIDTH] = s_axi_awuser;\n      assign s_wpayload[G_AXI_WUSER_INDEX+:G_AXI_WUSER_WIDTH]    = s_axi_wuser;\n      assign s_axi_buser                                       = s_bpayload[G_AXI_BUSER_INDEX+:G_AXI_BUSER_WIDTH];\n      assign s_arpayload[G_AXI_ARUSER_INDEX+:G_AXI_ARUSER_WIDTH] = s_axi_aruser;\n      assign s_axi_ruser                                       = s_rpayload[G_AXI_RUSER_INDEX+:G_AXI_RUSER_WIDTH];\n    end \n    else begin : gen_no_user_signals\n      assign s_axi_buser = 'b0;\n      assign s_axi_ruser = 'b0;\n    end\n  end\n  else begin : gen_axi4lite_packing\n    assign s_axi_bid = 'b0;\n    assign s_axi_buser = 'b0;\n\n    assign s_axi_rlast = 1'b1;\n    assign s_axi_rid   = 'b0;\n    assign s_axi_ruser = 'b0;\n  end\nendgenerate\nendmodule"}
{"task_id": 255, "completion": "parameter           CLK_KHZ              = 8192;\nparameter           BOOT_VECTOR          = 32'h10000000;\nparameter           ISR_VECTOR           = 32'h10000000;\n\nwire [31:0]         soc_addr;\nwire [31:0]         soc_data_w;\nwire [31:0]         soc_data_r;\nwire                soc_we;\nwire                soc_stb;\nwire                soc_ack;\nwire                soc_irq;\n\nwire[31:0]          dmem_address;\nwire[31:0]          dmem_data_w;\nwire[31:0]          dmem_data_r;\nwire[3:0]           dmem_sel;\nwire[2:0]           dmem_cti;\nwire                dmem_we;\nwire                dmem_stb;\nwire                dmem_cyc;\nwire                dmem_stall;\nwire                dmem_ack;\n\nwire[31:0]          imem_addr;\nwire[31:0]          imem_data;\nwire[3:0]           imem_sel;\nwire                imem_stb;\nwire                imem_cyc;\nwire[2:0]           imem_cti;\nwire                imem_stall;\nwire                imem_ack;\n\nram\nu_ram\n(\n    .clka_i(clk_i), \n    .rsta_i(rst_i), \n    .stba_i(imem_stb), \n    .wea_i(1'b0), \n    .sela_i(imem_sel), \n    .addra_i(imem_addr[31:2]), \n    .dataa_i(32'b0),\n    .dataa_o(imem_data),\n    .acka_o(imem_ack),\n\n    .clkb_i(clk_i), \n    .rstb_i(rst_i), \n    .stbb_i(dmem_stb), \n    .web_i(dmem_we), \n    .selb_i(dmem_sel), \n    .addrb_i(dmem_address[31:2]), \n    .datab_i(dmem_data_w),\n    .datab_o(dmem_data_r),\n    .ackb_o(dmem_ack)\n);\n\ncpu_if\n#(\n    .CLK_KHZ(CLK_KHZ),\n    .BOOT_VECTOR(32'h10000000),\n    .ISR_VECTOR(32'h10000000),\n    .ENABLE_ICACHE(`ICACHE_ENABLED),\n    .ENABLE_DCACHE(`DCACHE_ENABLED),\n    .REGISTER_FILE_TYPE(\"SIMULATION\")\n)\nu_cpu\n(\n    .clk_i(clk_i),\n    .rst_i(rst_i),\n    .fault_o(fault_o),\n    .break_o(break_o),\n    .nmi_i(1'b0),\n    .intr_i(soc_irq),\n    .imem0_addr_o(imem_addr),\n    .imem0_data_i(imem_data),\n    .imem0_sel_o(imem_sel),\n    .imem0_cti_o(imem_cti),\n    .imem0_cyc_o(imem_cyc),\n    .imem0_stb_o(imem_stb),\n    .imem0_stall_i(1'b0),\n    .imem0_ack_i(imem_ack),\n    .dmem0_addr_o(dmem_address),\n    .dmem0_data_o(dmem_data_w),\n    .dmem0_data_i(dmem_data_r),\n    .dmem0_sel_o(dmem_sel),\n    .dmem0_cti_o(dmem_cti),\n    .dmem0_cyc_o(dmem_cyc),\n    .dmem0_we_o(dmem_we),\n    .dmem0_stb_o(dmem_stb),\n    .dmem0_stall_i(1'b0),\n    .dmem0_ack_i(dmem_ack),\n    .dmem1_addr_o(/*open*/),\n    .dmem1_data_o(/*open*/),\n    .dmem1_data_i(32'b0),\n    .dmem1_sel_o(/*open*/),\n    .dmem1_we_o(/*open*/),\n    .dmem1_stb_o(/*open*/),\n    .dmem1_cyc_o(/*open*/),\n    .dmem1_cti_o(/*open*/),\n    .dmem1_stall_i(1'b0),\n    .dmem1_ack_i(1'b1),\n    .dmem2_addr_o(soc_addr),\n    .dmem2_data_o(soc_data_w),\n    .dmem2_data_i(soc_data_r),\n    .dmem2_sel_o(/*open*/),\n    .dmem2_we_o(soc_we),\n    .dmem2_stb_o(soc_stb),\n    .dmem2_cyc_o(/*open*/),\n    .dmem2_cti_o(/*open*/),\n    .dmem2_stall_i(1'b0),\n    .dmem2_ack_i(soc_ack)\n);\n\nsoc\n#(\n    .CLK_KHZ(CLK_KHZ),\n    .ENABLE_SYSTICK_TIMER(\"ENABLED\"),\n    .ENABLE_HIGHRES_TIMER(\"ENABLED\"),\n    .EXTERNAL_INTERRUPTS(1)\n)\nu_soc\n(\n    .clk_i(clk_i),\n    .rst_i(rst_i),\n    .ext_intr_i(1'b0),\n    .intr_o(soc_irq),\n    .io_addr_i(soc_addr),    \n    .io_data_i(soc_data_w),\n    .io_data_o(soc_data_r),    \n    .io_we_i(soc_we),\n    .io_stb_i(soc_stb),\n    .io_ack_o(soc_ack)\n);\n    \nendmodule"}
{"task_id": 234, "completion": "output X;\n    input  A;\n    input  B;\n    input  C;\n\n    // Voltage supply signals\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    sky130_fd_sc_ms__maj3 base (\n        .X(X),\n        .A(A),\n        .B(B),\n        .C(C)\n    );\n\nendmodule"}
{"task_id": 307, "completion": "// Voltage supply signals\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    sky130_fd_sc_ms__and3b base (\n        .X(X),\n        .A_N(A_N),\n        .B(B),\n        .C(C)\n    );\n\nendmodule"}
{"task_id": 303, "completion": "assign X = (A | B) | (~C_N | ~D_N);\nendmodule"}
{"task_id": 91, "completion": "input aclr;\ninput clock;\ninput [15:0] data;\ninput rdreq;\ninput wrreq;\noutput almost_empty;\noutput empty;\noutput full;\noutput [15:0] q;\noutput [9:0] usedw;\n\nwire [9:0] sub_wire0;\nwire sub_wire1;\nwire sub_wire2;\nwire [15:0] sub_wire3;\nwire sub_wire4;\n\nwire [9:0] usedw = sub_wire0[9:0];\nwire empty = sub_wire1;\nwire almost_empty = sub_wire2;\nwire [15:0] q = sub_wire3[15:0];\nwire full = sub_wire4;\n\nscfifo scfifo_component (\n\t\t\trdreq (rdreq),\n\t\t\taclr (aclr),\n\t\t\tclock (clock),\n\t\t\twrreq (wrreq),\n\t\t\tdata (data),\n\t\t\tusedw (sub_wire0),\n\t\t\tempty (sub_wire1),\n\t\t\talmost_empty (sub_wire2),\n\t\t\tq (sub_wire3),\n\t\t\tfull (sub_wire4)\n\t\t);\n\ndefparam\n\t\tscfifo_component.add_ram_output_register = \"OFF\",\n\t\tscfifo_component.almost_empty_value = 504,\n\t\tscfifo_component.intended_device_family = \"Cyclone\",\n\t\tscfifo_component.lpm_hint = \"RAM_BLOCK_TYPE=M4K\",\n\t\tscfifo_component.lpm_numwords = 1024,\n\t\tscfifo_component.lpm_showahead = \"OFF\",\n\t\tscfifo_component.lpm_type = \"scfifo\",\n\t\tscfifo_component.lpm_width = 16,\n\t\tscfifo_component.lpm_widthu = 10,\n\t\tscfifo_component.overflow_checking = \"ON\",\n\t\tscfifo_component.underflow_checking = \"ON\",\n\t\tscfifo_component.use_eab = \"ON\";\n\nendmodule"}
{"task_id": 300, "completion": "output Y   ;\n    input  A   ;\n    input  B   ;\n    input  C_N ;\n    input  D_N ;\n    input  VPWR;\n    input  VGND;\n    input  VPB ;\n    input  VNB ;\n    sky130_fd_sc_hdll__nor4bb base (\n        .Y(Y),\n        .A(A),\n        .B(B),\n        .C_N(C_N),\n        .D_N(D_N),\n        .VPWR(VPWR),\n        .VGND(VGND),\n        .VPB(VPB),\n        .VNB(VNB)\n    );\n\nendmodule"}
{"task_id": 228, "completion": "wire [`PC_INDEX_WIDTH - 2:0] target_outdir_0_plus1, target_outdir_1_plus2, target_outdir_2_plus3, target_outdir_3;    assign target_outdir_0_plus1 = (indir == 4) ? 2'd0 : ((indir + 2'd1) % 4);    assign target_outdir_1_plus2 = (indir == 4) ? 2'd1 : ((indir + 2'd2) % 4);    assign target_outdir_2_plus3 = (indir == 4) ? 2'd2 : ((indir + 2'd3) % 4);    assign target_outdir_3 = (indir == 4) ? 2'd3 : indir;    wire [`NUM_PORT-1:0] w_ppv_0, w_ppv_1, w_ppv_2, w_ppv_3;    rc rc0(    .dst                    (dst),     .dstList                (dstList),    .outdir                 (target_outdir_0_plus1),    .mc                     (mc),    .preferPortVector       (w_ppv_0)    );    rc rc1(    .dst                    (dst),     .dstList                (dstList),    .outdir                 (target_outdir_1_plus2),    .mc                     (mc),    .preferPortVector       (w_ppv_1)    );    rc rc2(    .dst                    (dst),     .dstList                (dstList),    .outdir                 (target_outdir_2_plus3),    .mc                     (mc),    .preferPortVector       (w_ppv_2)    );    rc rc3(    .dst                    (dst),     .dstList                (dstList),    .outdir                 (target_outdir_3),    .mc                     (mc),    .preferPortVector       (w_ppv_3)    );    assign nextPPV = (indir == 4) ? {w_ppv_0, w_ppv_1, w_ppv_2, w_ppv_3} :                     (indir == 3) ? {w_ppv_0, w_ppv_1, w_ppv_2, `NUM_PORT'h0} :                     (indir == 2) ? {w_ppv_0, w_ppv_1, `NUM_PORT'h0, w_ppv_3} :                     (indir == 1) ? {w_ppv_0, `NUM_PORT'h0, w_ppv_2, w_ppv_3} :                     {`NUM_PORT'h0, w_ppv_1, w_ppv_2, w_ppv_3};    endmodule"}
{"task_id": 160, "completion": "input\t aclr;\n\tinput\t[127:0]  data;\n\tinput\t rdclk;\n\tinput\t rdreq;\n\tinput\t wrclk;\n\tinput\t wrreq;\n\toutput\t[127:0]  q;\n\toutput\t rdempty;\n\toutput\t[6:0]  rdusedw;\n\toutput\t wrempty;\n\toutput\t[6:0]  wrusedw;\n\n\ttri0\t aclr;\n\n\twire  sub_wire0;\n\twire [127:0] sub_wire1;\n\twire  sub_wire2;\n\twire [6:0] sub_wire3;\n\twire [6:0] sub_wire4;\n\twire  wrempty = sub_wire0;\n\twire [127:0] q = sub_wire1[127:0];\n\twire  rdempty = sub_wire2;\n\twire [6:0] wrusedw = sub_wire3[6:0];\n\twire [6:0] rdusedw = sub_wire4[6:0];\n\n\tdcfifo\tdcfifo_component (\n\t\t\t.rdclk (rdclk),\n\t\t\t.wrclk (wrclk),\n\t\t\t.wrreq (wrreq),\n\t\t\t.aclr (aclr),\n\t\t\t.data (data),\n\t\t\t.rdreq (rdreq),\n\t\t\t.wrempty (sub_wire0),\n\t\t\t.q (sub_wire1),\n\t\t\t.rdempty (sub_wire2),\n\t\t\t.wrusedw (sub_wire3),\n\t\t\t.rdusedw (sub_wire4),\n\t\t\t.rdfull (),\n\t\t\t.wrfull ());\n\tdefparam\n\t\tdcfifo_component.intended_device_family = \"Arria II GX\",\n\t\tdcfifo_component.lpm_numwords = 128,\n\t\tdcfifo_component.lpm_showahead = \"ON\",\n\t\tdcfifo_component.lpm_type = \"dcfifo\",\n\t\tdcfifo_component.lpm_width = 128,\n\t\tdcfifo_component.lpm_widthu = 7,\n\t\tdcfifo_component.overflow_checking = \"ON\",\n\t\tdcfifo_component.rdsync_delaypipe = 4,\n\t\tdcfifo_component.underflow_checking = \"ON\",\n\t\tdcfifo_component.use_eab = \"ON\",\n\t\tdcfifo_component.write_aclr_synch = \"ON\",\n\t\tdcfifo_component.wrsync_delaypipe = 4;\n\nendmodule"}
{"task_id": 185, "completion": "reg                    wEnbR ;\n  reg  [`log2(CDEP)+9:0] wAddrR;\n  reg  [PWID*9-1:0]      mPattR;\n  reg  [PWID*9-1:0]      wPattR;\n  wire                   wEnbI ;\n  wire [`log2(CDEP)+9:0] wAddrI;\n  wire [PWID*9-1:0]      mPattI;\n  wire [PWID*9-1:0]      wPattI;\n  always @(posedge clk, posedge rst)\n    if (rst) {wEnbR,wAddrR,mPattR,wPattR} <= {(`log2(CDEP)+18*PWID+11){1'b0}};\n    else     {wEnbR,wAddrR,mPattR,wPattR} <= \n             {wEnb ,wAddr ,mPatt ,wPatt } ;\n\n  assign     {wEnbI,wAddrI,mPattI,wPattI} = REGI  ?\n             {wEnbR,wAddrR,mPattR,wPattR} : \n             {wEnb ,wAddr ,mPatt ,wPatt } ;\n\n  reg                    matchR;\n  reg  [`log2(CDEP)+9:0] mAddrR;\n  wire                   matchI;\n  wire [`log2(CDEP)+9:0] mAddrI;\n  always @(posedge clk, posedge rst)\n    if (rst) {matchR,mAddrR} <= {(`log2(CDEP)+11){1'b0}};\n    else     {matchR,mAddrR} <= \n             {matchI,mAddrI} ;\n\n    assign   {match ,mAddr } = REGO ?\n             {matchR,mAddrR} :\n             {matchI,mAddrI} ;\n\n  wire [CDEP*1024-1:0] mIndc_i [PWID-1:0];\n  genvar gi;\n  generate\n    for (gi=0 ; gi<PWID ; gi=gi+1) begin: STG\n      ii2dcam9b #( .CDEP (CDEP             ),   \n                   .PIPE (PIPE             ))   \n      ii2dcam9bi ( .clk  (clk              ),   \n                   .rst  (rst              ),   \n                   .wEnb (wEnbI            ),   \n                   .wAddr(wAddrI           ),   \n                   .mPatt(mPattI[gi*9 +: 9]),   \n                   .wPatt(wPattI[gi*9 +: 9]),   \n                   .mIndc(mIndc_i[gi]      ));  \n    end\n  endgenerate\n\n  integer i;\n  reg [CDEP*1024-1:0] mIndc; \n  always @(*) begin\n    mIndc = {(CDEP*1024){1'b1}};\n    for (i=0; i<PWID; i=i+1)\n      mIndc = mIndc & mIndc_i[i];\n  end\n\n`ifdef SIM\n  pe_bhv #( .OHW(CDEP*1024) )\n`else\n  pe_cam \n`endif\n  pe_cam_inst (\n    .clk(clk   ), \n    .rst(rst   ), \n    .oht(mIndc ), \n    .bin(mAddrI), \n    .vld(matchI)  \n  );\n\nendmodule"}
{"task_id": 310, "completion": "output Y   ;\n    input  A_N ;\n    input  B   ;\n    input  C   ;\n    input  VPWR;\n    input  VGND;\n    input  VPB ;\n    input  VNB ;\n\n    wire not0_out         ;\n    wire nand0_out_Y      ;\n    wire pwrgood_pp0_out_Y;\n\n    not                                not0        (not0_out         , A_N                    );\n    nand                               nand0       (nand0_out_Y      , B, not0_out, C         );\n    sky130_fd_sc_ls__udp_pwrgood_pp$PG pwrgood_pp0 (pwrgood_pp0_out_Y, nand0_out_Y, VPWR, VGND);\n    buf                                buf0        (Y                , pwrgood_pp0_out_Y      );\n\nendmodule"}
{"task_id": 295, "completion": "// Flip-flop implementation details would go here\n    // including behavior upon clock edges and reset conditions\nendmodule"}
{"task_id": 323, "completion": "`define ADD 2'b00\n\t`define SUB 2'b01\n\t`define ANDVAL 2'b10\n\t`define NOTB 2'b11\n\n\tparameter width= 1;\n\treg addSubVals, andVals, notBVal, sub;\n       \nalways @(*) begin\n\t\tcase(ALUop) //Set the operation needed to be true and the rest to be false\n\t\t\t`ADD: {addSubVals, andVals, notBVal, sub}= {4'b1000};\t\n\t\t\t`SUB: {addSubVals, andVals, notBVal, sub}= {4'b1001};\t\t\n\t\t\t`ANDVAL: {addSubVals, andVals, notBVal, sub}= {4'b0100};\t\t\n\t\t\t`NOTB: {addSubVals, andVals, notBVal, sub}= {4'b0010};\t\t\t\n\t\t\tdefault: {addSubVals, andVals, notBVal, sub}= {4'bxxxx};\t//default all x\n\t\tendcase\n\tend\n\t\n\t//Instantiate operation module to compute the specified operation\n\toperation #(16) instantiateOperation(\n\t\t.Ain(Ain), \n\t\t.Bin(Bin),  \n\t\t.overflow(overflow), \n\t\t.addSubVals(addSubVals), \n\t\t.andVals(andVals), \n\t\t.notBVal(notBVal), \n\t\t.sub(sub), \n\t\t.computedValue(ALUComputedValue)\n\t\t);\n\nendmodule"}
{"task_id": 284, "completion": "output Q;\n    input  CLK;\n    input  D;\n    input  SCD;\n    input  SCE;\n    sky130_fd_sc_ls__sdfxtp base (\n        .Q(Q),\n        .CLK(CLK),\n        .D(D),\n        .SCD(SCD),\n        .SCE(SCE),\n        .VPWR(VPWR),\n        .VGND(VGND),\n        .VPB(VPB),\n        .VNB(VNB)\n    );\nendmodule"}
{"task_id": 267, "completion": "output Y   ;\n    input  A1  ;\n    input  A2  ;\n    input  A3  ;\n    input  B1  ;\n    input  VPWR;\n    input  VGND;\n    input  VPB ;\n    input  VNB ;\n\n    // Local signals\n    wire or0_out          ;\n    wire nand0_out_Y      ;\n    wire pwrgood_pp0_out_Y;\n\n    //                                 Name         Output             Other arguments\n    or                                 or0         (or0_out          , A2, A1, A3             );\n    nand                               nand0       (nand0_out_Y      , B1, or0_out            );\n    sky130_fd_sc_ls__udp_pwrgood_pp$PG pwrgood_pp0 (pwrgood_pp0_out_Y, nand0_out_Y, VPWR, VGND);\n    buf                                buf0        (Y                , pwrgood_pp0_out_Y      );\n\nendmodule"}
{"task_id": 334, "completion": "supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n     // No contents.\nendmodule"}
{"task_id": 46, "completion": "reg [17:1] csr_adr_i;  reg csr_stb_i;  wire [15:0] conf_wb_dat_o;  wire conf_wb_ack_o;  wire [15:0] mem_wb_dat_o;  wire mem_wb_ack_o;  wire [17:1] csr_adr_o;  wire [15:0] csr_dat_i;  wire csr_stb_o;  wire v_retrace;  wire vh_retrace;  wire w_vert_sync;  wire shift_reg1;  wire graphics_alpha;  wire memory_mapping1;  wire [1:0] write_mode;  wire [1:0] raster_op;  wire read_mode;  wire [7:0] bitmask;  wire [3:0] set_reset;  wire [3:0] enable_set_reset;  wire [3:0] map_mask;  wire x_dotclockdiv2;  wire chain_four;  wire [1:0] read_map_select;  wire [3:0] color_compare;  wire [3:0] color_dont_care;  wire [17:1] wbm_adr_o;  wire [1:0] wbm_sel_o;  wire wbm_we_o;  wire [15:0] wbm_dat_o;  wire [15:0] wbm_dat_i;  wire wbm_stb_o;  wire wbm_ack_i;  wire stb;  wire [5:0] cur_start;  wire [5:0] cur_end;  wire [15:0] start_addr;  wire [4:0] vcursor;  wire [6:0] hcursor;  wire [6:0] horiz_total;  wire [6:0] end_horiz;  wire [6:0] st_hor_retr;  wire [4:0] end_hor_retr;  wire [9:0] vert_total;  wire [9:0] end_vert;  wire [9:0] st_ver_retr;  wire [3:0] end_ver_retr;  wire [3:0] pal_addr;  wire pal_we;  wire [7:0] pal_read;  wire [7:0] pal_write;  wire dac_we;  wire [1:0] dac_read_data_cycle;  wire [7:0] dac_read_data_register;  wire [3:0] dac_read_data;  wire [1:0] dac_write_data_cycle;  wire [7:0] dac_write_data_register;  wire [3:0] dac_write_data;  vga_config_iface config_iface (    .wb_clk_i (wb_clk_i),    .wb_rst_i (wb_rst_i),    .wb_dat_i (wb_dat_i),    .wb_dat_o (conf_wb_dat_o),    .wb_adr_i (wb_adr_i[4:1]),    .wb_we_i  (wb_we_i),    .wb_sel_i (wb_sel_i),    .wb_stb_i (stb & wb_tga_i),    .wb_ack_o (conf_wb_ack_o),    .shift_reg1       (shift_reg1),    .graphics_alpha   (graphics_alpha),    .memory_mapping1  (memory_mapping1),    .write_mode       (write_mode),    .raster_op        (raster_op),    .read_mode        (read_mode),    .bitmask          (bitmask),    .set_reset        (set_reset),    .enable_set_reset (enable_set_reset),    .map_mask         (map_mask),    .x_dotclockdiv2   (x_dotclockdiv2),    .chain_four       (chain_four),    .read_map_select  (read_map_select),    .color_compare    (color_compare),    .color_dont_care  (color_dont_care),    .pal_addr  (pal_addr),    .pal_we    (pal_we),    .pal_read  (pal_read),    .pal_write (pal_write),    .dac_we                  (dac_we),    .dac_read_data_cycle     (dac_read_data_cycle),    .dac_read_data_register  (dac_read_data_register),    .dac_read_data           (dac_read_data),    .dac_write_data_cycle    (dac_write_data_cycle),    .dac_write_data_register (dac_write_data_register),    .dac_write_data          (dac_write_data),    .cur_start  (cur_start),    .cur_end    (cur_end),    .start_addr (start_addr),    .vcursor    (vcursor),    .hcursor    (hcursor),    .horiz_total  (horiz_total),    .end_horiz    (end_horiz),    .st_hor_retr  (st_hor_retr),    .end_hor_retr (end_hor_retr),    .vert_total   (vert_total),    .end_vert     (end_vert),    .st_ver_retr  (st_ver_retr),    .end_ver_retr (end_ver_retr),    .v_retrace  (v_retrace),    .vh_retrace (vh_retrace)  );  vga_lcd lcd (    .clk (wb_clk_i),    .rst (wb_rst_i),    .shift_reg1     (shift_reg1),    .graphics_alpha (graphics_alpha),    .pal_addr  (pal_addr),    .pal_we    (pal_we),    .pal_read  (pal_read),    .pal_write (pal_write),    .dac_we                  (dac_we),    .dac_read_data_cycle     (dac_read_data_cycle),    .dac_read_data_register  (dac_read_data_register),    .dac_read_data           (dac_read_data),    .dac_write_data_cycle    (dac_write_data_cycle),    .dac_write_data_register (dac_write_data_register),    .dac_write_data          (dac_write_data),    .csr_adr_o (csr_adr_o),    .csr_dat_i (csr_dat_i),    .csr_stb_o (csr_stb_o),    .vga_red_o   (vga_red_o),    .vga_green_o (vga_green_o),    .vga_blue_o  (vga_blue_o),    .horiz_sync  (horiz_sync),    .vert_sync   (w_vert_sync),    .cur_start  (cur_start),    .cur_end    (cur_end),    .vcursor    (vcursor),    .hcursor    (hcursor),    .horiz_total  (horiz_total),    .end_horiz    (end_horiz),    .st_hor_retr  (st_hor_retr),    .end_hor_retr (end_hor_retr),    .vert_total   (vert_total),    .end_vert     (end_vert),    .st_ver_retr  (st_ver_retr),    .end_ver_retr (end_ver_retr),    .x_dotclockdiv2 (x_dotclockdiv2),    .v_retrace  (v_retrace),    .vh_retrace (vh_retrace)  );  vga_cpu_mem_iface cpu_mem_iface (    .wb_clk_i (wb_clk_i),    .wb_rst_i (wb_rst_i),    .wbs_adr_i (wb_adr_i),    .wbs_sel_i (wb_sel_i),    .wbs_we_i  (wb_we_i),    .wbs_dat_i (wb_dat_i),    .wbs_dat_o (mem_wb_dat_o),    .wbs_stb_i (stb & !wb_tga_i),    .wbs_ack_o (mem_wb_ack_o),    .wbm_adr_o (wbm_adr_o),    .wbm_sel_o (wbm_sel_o),    .wbm_we_o  (wbm_we_o),    .wbm_dat_o (wbm_dat_o),    .wbm_dat_i (wbm_dat_i),    .wbm_stb_o (wbm_stb_o),    .wbm_ack_i (wbm_ack_i),    .chain_four       (chain_four),    .memory_mapping1  (memory_mapping1),    .write_mode       (write_mode),    .raster_op        (raster_op),    .read_mode        (read_mode),    .bitmask          (bitmask),    .set_reset        (set_reset),    .enable_set_reset (enable_set_reset),    .map_mask         (map_mask),    .read_map_select  (read_map_select),    .color_compare    (color_compare),    .color_dont_care  (color_dont_care)  );  vga_mem_arbitrer mem_arbitrer (    .clk_i (wb_clk_i),    .rst_i (wb_rst_i),    .wb_adr_i (wbm_adr_o),    .wb_sel_i (wbm_sel_o),    .wb_we_i  (wbm_we_o),    .wb_dat_i (wbm_dat_o),    .wb_dat_o (wbm_dat_i),    .wb_stb_i (wbm_stb_o),    .wb_ack_o (wbm_ack_i),    .csr_adr_i (csr_adr_i),    .csr_dat_o (csr_dat_i),    .csr_stb_i (csr_stb_i),    .csrm_adr_o (csrm_adr_o),    .csrm_sel_o (csrm_sel_o),    .csrm_we_o  (csrm_we_o),    .csrm_dat_o (csrm_dat_o),    .csrm_dat_i (csrm_dat_i)  );  assign wb_dat_o  = wb_tga_i ? conf_wb_dat_o : mem_wb_dat_o;  assign wb_ack_o  = wb_tga_i ? conf_wb_ack_o : mem_wb_ack_o;  assign stb       = wb_stb_i & wb_cyc_i;  assign vert_sync = ~graphics_alpha ^ w_vert_sync;  always @(posedge wb_clk_i)    csr_adr_i <= wb_rst_i ? 17'h0 : csr_adr_o + start_addr[15:1];  always @(posedge wb_clk_i)    csr_stb_i <= wb_rst_i ? 1'b0 : csr_stb_o;  endmodule"}
{"task_id": 72, "completion": "input\t\t\t\tclk;\ninput\t\t\t\trst;\ninput\t\t\t\tic_en;\ninput\t\t\t\ticqmem_cycstb_i;\ninput\t\t\t\ticqmem_ci_i;\ninput\t\t\t\ttagcomp_miss;\ninput\t\t\t\tbiudata_valid;\ninput\t\t\t\tbiudata_error;\ninput\t[31:0]\t\t\tstart_addr;\noutput\t[31:0]\t\t\tsaved_addr;\noutput\t[3:0]\t\t\ticram_we;\noutput\t\t\t\tbiu_read;\noutput\t\t\t\tfirst_hit_ack;\noutput\t\t\t\tfirst_miss_ack;\noutput\t\t\t\tfirst_miss_err;\noutput\t\t\t\tburst;\noutput\t\t\t\ttag_we;\n\nreg\t[31:0]\t\t\tsaved_addr_r;\nreg\t[1:0]\t\t\tstate;\nreg\t[2:0]\t\t\tcnt;\nreg\t\t\t\thitmiss_eval;\nreg\t\t\t\tload;\nreg\t\t\t\tcache_inhibit;\n\nassign icram_we = {4{biu_read & biudata_valid & !cache_inhibit}};\nassign tag_we = biu_read & biudata_valid & !cache_inhibit;\nassign biu_read = (hitmiss_eval & tagcomp_miss) | (!hitmiss_eval & load);\nassign saved_addr = saved_addr_r;\nassign first_hit_ack = (state == `OR1200_ICFSM_CFETCH) & hitmiss_eval & !tagcomp_miss & !cache_inhibit & !icqmem_ci_i;\nassign first_miss_ack = (state == `OR1200_ICFSM_CFETCH) & biudata_valid;\nassign first_miss_err = (state == `OR1200_ICFSM_CFETCH) & biudata_error;\nassign burst = (state == `OR1200_ICFSM_CFETCH) & tagcomp_miss & !cache_inhibit | (state == `OR1200_ICFSM_LREFILL3);\n\nalways @(posedge clk or posedge rst) begin\n\tif (rst) begin\n\t\tstate <= #1 `OR1200_ICFSM_IDLE;\n\t\tsaved_addr_r <= #1 32'b0;\n\t\thitmiss_eval <= #1 1'b0;\n\t\tload <= #1 1'b0;\n\t\tcnt <= #1 3'b000;\n\t\tcache_inhibit <= #1 1'b0;\n\tend\n\telse\n\tcase (state)  // synopsys parallel_case\n\t\t`OR1200_ICFSM_IDLE :\n\t\t\tif (ic_en & icqmem_cycstb_i) begin\t\t\t// fetch\n\t\t\t\tstate <= #1 `OR1200_ICFSM_CFETCH;\n\t\t\t\tsaved_addr_r <= #1 start_addr;\n\t\t\t\thitmiss_eval <= #1 1'b1;\n\t\t\t\tload <= #1 1'b1;\n\t\t\t\tcache_inhibit <= #1 1'b0;\n\t\t\tend\n\t\t\telse begin\t\t\t\t// idle\n\t\t\t\thitmiss_eval <= #1 1'b0;\n\t\t\t\tload <= #1 1'b0;\n\t\t\t\tcache_inhibit <= #1 1'b0;\n\t\t\tend\n\t\t`OR1200_ICFSM_CFETCH: begin\t\t\t// fetch\n\t\t\t\tif (icqmem_cycstb_i & icqmem_ci_i)\n\t\t\t\t\tcache_inhibit <= #1 1'b1;\n\t\t\t\tif (hitmiss_eval)\n\t\t\t\t\tsaved_addr_r[31:13] <= #1 start_addr[31:13];\n\t\t\t\tif ((!ic_en) ||\n\t\t\t\t\t(hitmiss_eval & !icqmem_cycstb_i) ||\t// fetch aborted (usually caused by IMMU)\n\t\t\t\t\t(biudata_error) ||\t\t\t\t// fetch terminated with an error\n\t\t\t\t\t(cache_inhibit & biudata_valid)) begin\t// fetch from cache-inhibited page\n\t\t\t\t\tstate <= #1 `OR1200_ICFSM_IDLE;\n\t\t\t\t\thitmiss_eval <= #1 1'b0;\n\t\t\t\t\tload <= #1 1'b0;\n\t\t\t\t\tcache_inhibit <= #1 1'b0;\n\t\t\t\tend\n\t\t\t\telse if (tagcomp_miss & biudata_valid) begin\t// fetch missed, finish current external fetch and refill\n\t\t\t\t\tstate <= #1 `OR1200_ICFSM_LREFILL3;\n\t\t\t\t\tsaved_addr_r[3:2] <= #1 saved_addr_r[3:2] + 1'd1;\n\t\t\t\t\thitmiss_eval <= #1 1'b0;\n\t\t\t\t\tcnt <= #1 `OR1200_ICLS-2;\n\t\t\t\t\tcache_inhibit <= #1 1'b0;\n\t\t\t\tend\n\t\t\t\telse if (!tagcomp_miss & !icqmem_ci_i) begin\t// fetch hit, finish immediately\n\t\t\t\t\tsaved_addr_r <= #1 start_addr;\n\t\t\t\t\tcache_inhibit <= #1 1'b0;\n\t\t\t\tend\n\t\t\t\telse if (!icqmem_cycstb_i) begin\t// fetch aborted (usually caused by exception)\n\t\t\t\t\tstate <= #1 `OR1200_ICFSM_IDLE;\n\t\t\t\t\thitmiss_eval <= #1 1'b0;\n\t\t\t\t\tload <= #1 1'b0;\n\t\t\t\t\tcache_inhibit <= #1 1'b0;\n\t\t\t\tend\n\t\t\t\telse\t\t\t\t// fetch in-progress\n\t\t\t\t\thitmiss_eval <= #1 1'b0;\n\t\t\tend\n\t\t`OR1200_ICFSM_LREFILL3 : begin\n\t\t\t\tif (biudata_valid && (|cnt)) begin\t\t\t// refill ack, more fetchs to come\n\t\t\t\t\tcnt <= #1 cnt - 3'd1;\n\t\t\t\t\tsaved_addr_r[3:2] <= #1 saved_addr_r[3:2] + 1'd1;\n\t\t\t\tend\n\t\t\t\telse if (biudata_valid) begin\t\t\t// last fetch of line refill\n\t\t\t\t\tstate <= #1 `OR1200_ICFSM_IDLE;\n\t\t\t\t\tsaved_addr_r <= #1 start_addr;\n\t\t\t\t\thitmiss_eval <= #1 1'b0;\n\t\t\t\t\tload <= #1 1'b0;\n\t\t\t\tend\n\t\t\tend\n\t\tdefault:\n\t\t\tstate <= #1 `OR1200_ICFSM_IDLE;\n\tendcase\nend\n\nendmodule"}
{"task_id": 269, "completion": "reg [DATA_WIDTH-1:0] registers [REGISTER_COUNT-1:0];    integer index;        always @* begin        register_output1 <= registers[choose_register_i1];        register_output2 <= registers[choose_register_i2];    end        always @(posedge clk_i or posedge rst_i) begin        if(rst_i == 1'b1) begin            for (index = 0; index < REGISTER_COUNT; index = index + 1) begin                registers[index] <= 0;            end        end        else begin            if (alu_active_i) begin                registers[choose_register_i1] <= alu_result_i;            end            else if (mem_read_rdy_i) begin                registers[choose_register_i1] <= load_value_i;            end            else if (register_active_i) begin                registers[choose_register_i1] <= register_input[DATA_WIDTH-1:0];            end        end    endendmodule"}
{"task_id": 203, "completion": "parameter AW   = 2;\n   reg [AW:0]      wr_gray_pointer;\n   reg [AW:0]      wr_binary_pointer;\n   reg             wr_fifo_full;\n   wire            wr_fifo_full_next;\n   wire [AW:0]     wr_gray_next;\n   wire [AW:0]     wr_binary_next;\n   wire            wr_fifo_progfull_next;\n   reg             wr_fifo_progfull;\n   always @(posedge wr_clk or posedge reset)\n     if(reset)\n       begin\n\t  wr_binary_pointer[AW:0]     <= {(AW+1){1'b0}};\n\t  wr_gray_pointer[AW:0]       <= {(AW+1){1'b0}};\n       end\n     else if(wr_write)\n       begin\n\t  wr_binary_pointer[AW:0]     <= wr_binary_next[AW:0];\n\t  wr_gray_pointer[AW:0]       <= wr_gray_next[AW:0];\n       end\n   assign wr_addr[AW-1:0]       = wr_binary_pointer[AW-1:0];\n   assign wr_binary_next[AW:0]  = wr_binary_pointer[AW:0] + \n\t\t\t\t\t  {{(AW){1'b0}},wr_write};\n   assign wr_gray_next[AW:0]    = {1'b0,wr_binary_next[AW:1]} ^ \n\t\t\t\t\t  wr_binary_next[AW:0];\n   assign wr_fifo_full_next =\n\t\t\t (wr_gray_next[AW-2:0] == wr_rd_gray_pointer[AW-2:0]) &\n\t\t\t (wr_gray_next[AW]     ^  wr_rd_gray_pointer[AW])     &\n\t\t\t (wr_gray_next[AW-1]   ^  wr_rd_gray_pointer[AW-1]);\n   assign wr_fifo_progfull_next =\n\t\t\t (wr_gray_next[AW-3:0] == wr_rd_gray_pointer[AW-3:0]) &\n\t\t\t (wr_gray_next[AW]     ^  wr_rd_gray_pointer[AW])     &\n\t\t\t (wr_gray_next[AW-1]   ^  wr_rd_gray_pointer[AW-1])   &\n\t\t\t (wr_gray_next[AW-2]   ^  wr_rd_gray_pointer[AW-2]);\n   always @ (posedge wr_clk or posedge reset)\n     if(reset)\n       wr_fifo_full <= 1'b0;\n     else\n       wr_fifo_full <=wr_fifo_full_next;\n   always @ (posedge wr_clk or posedge reset)\n     if(reset)\n       wr_fifo_progfull <= 1'b0;\n     else\n       wr_fifo_progfull <=wr_fifo_progfull_next;\nendmodule"}
{"task_id": 291, "completion": "supply1 VPWR;\n    supply0 VGND;\nendmodule"}
{"task_id": 304, "completion": "sky130_fd_sc_lp__einvp base (        .Z(Z),        .A(A),        .TE(TE),        .VPWR(VPWR),        .VGND(VGND),        .VPB(VPB),        .VNB(VNB)    );    endmodule"}
{"task_id": 51, "completion": "wire            ps2_clk_posedge;        // Internal Wires\n  wire            ps2_clk_negedge;\n\n  reg    [7:0]    idle_counter;            // Internal Registers\n  reg             ps2_clk_reg;\n  reg             ps2_data_reg;\n  reg             last_ps2_clk;\n\n  reg    [2:0]    ns_ps2_transceiver;        // State Machine Registers\n  reg    [2:0]    s_ps2_transceiver;\n\n  localparam  PS2_STATE_0_IDLE            = 3'h0,        // states\n              PS2_STATE_1_DATA_IN         = 3'h1,\n              PS2_STATE_2_COMMAND_OUT     = 3'h2,\n              PS2_STATE_3_END_TRANSFER    = 3'h3,\n              PS2_STATE_4_END_DELAYED     = 3'h4;\n\n  always @(posedge clk) begin\n    if(reset == 1'b1) s_ps2_transceiver <= PS2_STATE_0_IDLE;\n    else              s_ps2_transceiver <= ns_ps2_transceiver;\n  end\n\n  always @(*) begin\n    ns_ps2_transceiver = PS2_STATE_0_IDLE;        // Defaults\n\n    case (s_ps2_transceiver)\n    PS2_STATE_0_IDLE:\n        begin\n            if((idle_counter == 8'hFF) && (send_command == 1'b1))\n                ns_ps2_transceiver = PS2_STATE_2_COMMAND_OUT;\n            else if ((ps2_data_reg == 1'b0) && (ps2_clk_posedge == 1'b1))\n                ns_ps2_transceiver = PS2_STATE_1_DATA_IN;\n            else ns_ps2_transceiver = PS2_STATE_0_IDLE;\n        end\n    PS2_STATE_1_DATA_IN:\n        begin\n            if((received_data_en == 1'b1))   ns_ps2_transceiver = PS2_STATE_0_IDLE;\n            else                             ns_ps2_transceiver = PS2_STATE_1_DATA_IN;\n        end\n    PS2_STATE_2_COMMAND_OUT:\n        begin\n            if((command_was_sent == 1'b1) || (error_communication_timed_out == 1'b1))\n                ns_ps2_transceiver = PS2_STATE_3_END_TRANSFER;\n            else ns_ps2_transceiver = PS2_STATE_2_COMMAND_OUT;\n        end\n    PS2_STATE_3_END_TRANSFER:\n        begin\n            if(send_command == 1'b0) ns_ps2_transceiver = PS2_STATE_0_IDLE;\n            else if((ps2_data_reg == 1'b0) && (ps2_clk_posedge == 1'b1))\n                ns_ps2_transceiver = PS2_STATE_4_END_DELAYED;\n            else ns_ps2_transceiver = PS2_STATE_3_END_TRANSFER;\n        end\n    PS2_STATE_4_END_DELAYED:\n        begin\n            if(received_data_en == 1'b1) begin\n                if(send_command == 1'b0) ns_ps2_transceiver = PS2_STATE_0_IDLE;\n                else                     ns_ps2_transceiver = PS2_STATE_3_END_TRANSFER;\n            end\n            else ns_ps2_transceiver = PS2_STATE_4_END_DELAYED;\n        end\n\n    default:\n            ns_ps2_transceiver = PS2_STATE_0_IDLE;\n    endcase\n  end\n\n  always @(posedge clk) begin\n    if(reset == 1'b1)     begin\n        last_ps2_clk    <= 1'b1;\n        ps2_clk_reg     <= 1'b1;\n        ps2_data_reg    <= 1'b1;\n    end\n    else begin\n        last_ps2_clk    <= ps2_clk_reg;\n        ps2_clk_reg     <= ps2_clk;\n        ps2_data_reg    <= ps2_dat;\n    end\n  end\n\n  always @(posedge clk) begin\n    if(reset == 1'b1) idle_counter <= 6'h00;\n    else if((s_ps2_transceiver == PS2_STATE_0_IDLE) && (idle_counter != 8'hFF))\n        idle_counter <= idle_counter + 6'h01;\n    else if (s_ps2_transceiver != PS2_STATE_0_IDLE)\n        idle_counter <= 6'h00;\n  end\n\n  assign ps2_clk_posedge = ((ps2_clk_reg == 1'b1) && (last_ps2_clk == 1'b0)) ? 1'b1 : 1'b0;\n  assign ps2_clk_negedge = ((ps2_clk_reg == 1'b0) && (last_ps2_clk == 1'b1)) ? 1'b1 : 1'b0;\n\n  assign start_receiving_data      = (s_ps2_transceiver == PS2_STATE_1_DATA_IN);\n  assign wait_for_incoming_data    = (s_ps2_transceiver == PS2_STATE_3_END_TRANSFER);\n\n  ps2_mouse_cmdout mouse_cmdout (\n    .clk                           (clk),            // Inputs\n    .reset                         (reset),\n    .the_command                   (the_command),\n    .send_command                  (send_command),\n    .ps2_clk_posedge               (ps2_clk_posedge),\n    .ps2_clk_negedge               (ps2_clk_negedge),\n    .ps2_clk                       (ps2_clk),        // Bidirectionals\n    .ps2_dat                       (ps2_dat),\n    .command_was_sent              (command_was_sent),    // Outputs\n    .error_communication_timed_out (error_communication_timed_out)\n  );\n\n  ps2_mouse_datain mouse_datain (\n    .clk                    (clk),        // Inputs\n    .reset                  (reset),\n    .wait_for_incoming_data (wait_for_incoming_data),\n    .start_receiving_data   (start_receiving_data),\n    .ps2_clk_posedge        (ps2_clk_posedge),\n    .ps2_clk_negedge        (ps2_clk_negedge),\n    .ps2_data               (ps2_data_reg),\n    .received_data          (received_data),   // Outputs\n    .received_data_en       (received_data_en)\n  );\n\nendmodule"}
{"task_id": 336, "completion": "output Y   ;\n    input  A1  ;\n    input  A2  ;\n    input  A3  ;\n    input  B1  ;\n    input  VPWR;\n    input  VGND;\n    input  VPB ;\n    input  VNB ;\n    sky130_fd_sc_hd__a31oi base (\n        .Y(Y),\n        .A1(A1),\n        .A2(A2),\n        .A3(A3),\n        .B1(B1),\n        .VPWR(VPWR),\n        .VGND(VGND),\n        .VPB(VPB),\n        .VNB(VNB)\n    );\n\nendmodule"}
{"task_id": 335, "completion": "// Module behavior and internal logic would be defined here.\nendmodule"}
{"task_id": 333, "completion": "logic [width_lp-1:0] bits_r, bits_n;\n  always_comb\n    begin\n      bits_n   = bits_r;\n      if (clear_i)\n        bits_n = (width_lp) ' (1);\n      if (up_i)\n        bits_n = { bits_n[width_lp-2:0], bits_n[width_lp-1] };      \n      if (reset_i)\n        bits_n = (width_lp) ' (init_val_p);\n    end\n    always_ff @(posedge clk_i)\n    if (reset_i | up_i | clear_i)\n        bits_r <= bits_n;\n  assign count_r_o = bits_r;\nendmodule"}
{"task_id": 95, "completion": "localparam P_AXBURST_FIXED = 2'b00;\n    localparam P_AXBURST_INCR  = 2'b01;\n    localparam P_AXBURST_WRAP  = 2'b10;\n    wire [C_AXI_ADDR_WIDTH-1:0] incr_cmd_byte_addr;\n    wire incr_next_pending;\n    wire [C_AXI_ADDR_WIDTH-1:0] wrap_cmd_byte_addr;\n    wire wrap_next_pending;\n    reg sel_first;\n    reg s_axburst_eq1;\n    reg s_axburst_eq0;\n    reg sel_first_i;\n\n    assign m_axaddr = (s_axburst == P_AXBURST_FIXED) ? s_axaddr : \n                      (s_axburst == P_AXBURST_INCR) ? incr_cmd_byte_addr : \n                                                        wrap_cmd_byte_addr;\n    assign incr_burst = (s_axburst[1]) ? 1'b0 : 1'b1;\n\n    always @(posedge clk) begin\n        if (reset | s_axhandshake) begin\n            sel_first <= 1'b1;\n        end else if (next) begin\n            sel_first <= 1'b0;\n        end\n    end\n\n    always @( * ) begin\n        if (reset | s_axhandshake) begin\n            sel_first_i = 1'b1;\n        end else if (next) begin\n            sel_first_i = 1'b0;\n        end else begin\n            sel_first_i = sel_first;\n        end\n    end\n\n    assign next_pending = s_axburst[1] ? s_axburst_eq1 : s_axburst_eq0;\n\n    always @(posedge clk) begin\n        if (sel_first_i || s_axburst[1]) begin\n            s_axburst_eq1 <= wrap_next_pending;\n        end else begin\n            s_axburst_eq1 <= incr_next_pending;\n        end\n        if (sel_first_i || !s_axburst[1]) begin\n            s_axburst_eq0 <= incr_next_pending;\n        end else begin\n            s_axburst_eq0 <= wrap_next_pending;\n        end\n    end\n\n    axi_protocol_converter_v2_1_b2s_incr_cmd #(\n      .C_AXI_ADDR_WIDTH (C_AXI_ADDR_WIDTH)\n    )\n    incr_cmd_0\n    (\n      .clk (clk),\n      .reset (reset),\n      .axaddr (s_axaddr),\n      .axlen (s_axlen),\n      .axsize (s_axsize),\n      .axhandshake (s_axhandshake),\n      .cmd_byte_addr (incr_cmd_byte_addr),\n      .next (next),\n      .next_pending (incr_next_pending)\n    );\n\n    axi_protocol_converter_v2_1_b2s_wrap_cmd #(\n      .C_AXI_ADDR_WIDTH (C_AXI_ADDR_WIDTH)\n    )\n    wrap_cmd_0\n    (\n      .clk (clk),\n      .reset (reset),\n      .axaddr (s_axaddr),\n      .axlen (s_axlen),\n      .axsize (s_axsize),\n      .axhandshake (s_axhandshake),\n      .cmd_byte_addr (wrap_cmd_byte_addr),\n      .next (next),\n      .next_pending (wrap_next_pending)\n    );\n\nendmodule"}
{"task_id": 14, "completion": "axi_dwidth_converter_v2_1_7_top #(\n    .C_FAMILY(\"zynq\"),\n    .C_AXI_PROTOCOL(0),\n    .C_S_AXI_ID_WIDTH(1),\n    .C_SUPPORTS_ID(0),\n    .C_AXI_ADDR_WIDTH(32),\n    .C_S_AXI_DATA_WIDTH(32),\n    .C_M_AXI_DATA_WIDTH(64),\n    .C_AXI_SUPPORTS_WRITE(1),\n    .C_AXI_SUPPORTS_READ(1),\n    .C_FIFO_MODE(1),\n    .C_S_AXI_ACLK_RATIO(1),\n    .C_M_AXI_ACLK_RATIO(2),\n    .C_AXI_IS_ACLK_ASYNC(0),\n    .C_MAX_SPLIT_BEATS(16),\n    .C_PACKING_LEVEL(1),\n    .C_SYNCHRONIZER_STAGE(3)\n  ) inst (\n    .s_axi_aclk(s_axi_aclk),\n    .s_axi_aresetn(s_axi_aresetn),\n    .s_axi_awid(1'H0),\n    .s_axi_awaddr(s_axi_awaddr),\n    .s_axi_awlen(s_axi_awlen),\n    .s_axi_awsize(s_axi_awsize),\n    .s_axi_awburst(s_axi_awburst),\n    .s_axi_awlock(s_axi_awlock),\n    .s_axi_awcache(s_axi_awcache),\n    .s_axi_awprot(s_axi_awprot),\n    .s_axi_awregion(s_axi_awregion),\n    .s_axi_awqos(s_axi_awqos),\n    .s_axi_awvalid(s_axi_awvalid),\n    .s_axi_awready(s_axi_awready),\n    .s_axi_wdata(s_axi_wdata),\n    .s_axi_wstrb(s_axi_wstrb),\n    .s_axi_wlast(s_axi_wlast),\n    .s_axi_wvalid(s_axi_wvalid),\n    .s_axi_wready(s_axi_wready),\n    .s_axi_bid(),\n    .s_axi_bresp(s_axi_bresp),\n    .s_axi_bvalid(s_axi_bvalid),\n    .s_axi_bready(s_axi_bready),\n    .s_axi_arid(1'H0),\n    .s_axi_araddr(s_axi_araddr),\n    .s_axi_arlen(s_axi_arlen),\n    .s_axi_arsize(s_axi_arsize),\n    .s_axi_arburst(s_axi_arburst),\n    .s_axi_arlock(s_axi_arlock),\n    .s_axi_arcache(s_axi_arcache),\n    .s_axi_arprot(s_axi_arprot),\n    .s_axi_arregion(s_axi_arregion),\n    .s_axi_arqos(s_axi_arqos),\n    .s_axi_arvalid(s_axi_arvalid),\n    .s_axi_arready(s_axi_arready),\n    .s_axi_rid(),\n    .s_axi_rdata(s_axi_rdata),\n    .s_axi_rresp(s_axi_rresp),\n    .s_axi_rlast(s_axi_rlast),\n    .s_axi_rvalid(s_axi_rvalid),\n    .s_axi_rready(s_axi_rready),\n    .m_axi_aclk(1'H0),\n    .m_axi_aresetn(1'H0),\n    .m_axi_awaddr(m_axi_awaddr),\n    .m_axi_awlen(m_axi_awlen),\n    .m_axi_awsize(m_axi_awsize),\n    .m_axi_awburst(m_axi_awburst),\n    .m_axi_awlock(m_axi_awlock),\n    .m_axi_awcache(m_axi_awcache),\n    .m_axi_awprot(m_axi_awprot),\n    .m_axi_awregion(m_axi_awregion),\n    .m_axi_awqos(m_axi_awqos),\n    .m_axi_awvalid(m_axi_awvalid),\n    .m_axi_awready(m_axi_awready),\n    .m_axi_wdata(m_axi_wdata),\n    .m_axi_wstrb(m_axi_wstrb),\n    .m_axi_wlast(m_axi_wlast),\n    .m_axi_wvalid(m_axi_wvalid),\n    .m_axi_wready(m_axi_wready),\n    .m_axi_bresp(m_axi_bresp),\n    .m_axi_bvalid(m_axi_bvalid),\n    .m_axi_bready(m_axi_bready),\n    .m_axi_araddr(m_axi_araddr),\n    .m_axi_arlen(m_axi_arlen),\n    .m_axi_arsize(m_axi_arsize),\n    .m_axi_arburst(m_axi_arburst),\n    .m_axi_arlock(m_axi_arlock),\n    .m_axi_arcache(m_axi_arcache),\n    .m_axi_arprot(m_axi_arprot),\n    .m_axi_arregion(m_axi_arregion),\n    .m_axi_arqos(m_axi_arqos),\n    .m_axi_arvalid(m_axi_arvalid),\n    .m_axi_arready(m_axi_arready),\n    .m_axi_rdata(m_axi_rdata),\n    .m_axi_rresp(m_axi_rresp),\n    .m_axi_rlast(m_axi_rlast),\n    .m_axi_rvalid(m_axi_rvalid),\n    .m_axi_rready(m_axi_rready)\n  );\nendmodule"}
{"task_id": 124, "completion": "localparam s0 = 4'b0001;\n    localparam s1 = 4'b0010;\n    localparam s2 = 4'b0100;\n    localparam s3 = 4'b1000;\n\n    localparam TMPVAR_WIDTH = NUMERATOR_WIDTH + DENOMINATOR_WIDTH;\n    localparam REM_ITER_MSB = DENOMINATOR_WIDTH;\n    localparam QUOT_MSB = NUMERATOR_WIDTH - 1;\n\n    reg [3 : 0] state;\n    reg [NUMERATOR_WIDTH - 1 : 0] numer;\n    reg [DENOMINATOR_WIDTH - 1 : 0] denom;\n    reg [DENOMINATOR_WIDTH : 0] denom_neg;\n    reg [NUMERATOR_WIDTH - 1 : 0] quot;\n    reg [DENOMINATOR_WIDTH - 1 : 0] rem;\n    reg [DENOMINATOR_WIDTH : 0] rem_iter;\n    reg [7 : 0] count;\n\n    wire [DENOMINATOR_WIDTH : 0] rem_iter_shift;\n    wire [NUMERATOR_WIDTH - 1 : 0] quot_shift;\n    wire [DENOMINATOR_WIDTH : 0] rem_iter_sum;\n\n    assign {rem_iter_shift, quot_shift} = {rem_iter, quot} << 1;\n    assign rem_iter_sum = rem_iter_shift + (rem_iter[REM_ITER_MSB]) ? denom : denom_neg;\n\n    always @ (posedge clk or posedge clr)\n    begin\n        if (clr) begin\n            state <= s0;\n            rdy_out <= 1'b0;\n            numer <= 0;\n            denom <= 0;\n            denom_neg <= 0;\n            quot <= 0;\n            rem_iter <= 0;\n            rem <= 0;\n            count <= 0;\n        end\n        else begin\n            case (state)\n                s0 : begin\n                    numer <= numer_in;\n                    denom <= denom_in;\n                    denom_neg <= {1'b1,~denom_in} + 1;\n                    quot <= numer_in;\n                    rem_iter <= 0;\n                    count <= 0;\n                    state <= s1;\n                end\n                s1 : begin\n                    count <= count + 1;\n                    quot[QUOT_MSB : 1] <= quot_shift[QUOT_MSB : 1];\n                    rem_iter <= rem_iter_sum;\n                    if (rem_iter_sum[REM_ITER_MSB]) begin\n                        quot[0] <= 0;\n                    end\n                    else begin\n                        quot[0] <= 1;\n                    end\n                    if (count == NUMERATOR_WIDTH - 1) begin\n                        state <= s2;\n                    end\n                end\n                s2 : begin\n                    if (rem_iter[REM_ITER_MSB]) begin\n                        rem <= rem_iter + denom;\n                    end\n                    else begin\n                        rem <= rem_iter;\n                    end\n                    state <= s3;\n                end\n                s3 : begin\n                    quot_out <= quot;\n                    rem_out <= rem;\n                    rdy_out <= 1'b1;\n                end\n                default : begin\n                    state <= s0;\n                end\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": 277, "completion": "assign D[3] = (H[6]^H[5]^H[4]^H[2])&(H[6]^H[5]^H[3]^H[1])&(H[6]^H[4]^H[3]^H[0])  ? ~H[6] : H[6];\n    assign D[2] = (H[6]^H[5]^H[4]^H[2])&(H[6]^H[5]^H[3]^H[1])&!(H[6]^H[4]^H[3]^H[0]) ? ~H[5] : H[5];\n    assign D[1] = (H[6]^H[5]^H[4]^H[2])&!(H[6]^H[5]^H[3]^H[1])&(H[6]^H[4]^H[3]^H[0]) ? ~H[4] : H[4];\n    assign D[0] = !(H[6]^H[5]^H[4]^H[2])&(H[6]^H[5]^H[3]^H[1])&(H[6]^H[4]^H[3]^H[0]) ? ~H[3] : H[3];\n\nendmodule"}
{"task_id": 319, "completion": "wire [2:0] ACK;\n    wire [3:0] B32_Q;\n    \n    assign nWR_ACK = ~WR_ACK;\n\n    assign ACK[0] = ~&{nWR_ACK, ACK_BITS[0]};\n    assign ACK[1] = ~&{nWR_ACK, ACK_BITS[1]};\n    assign ACK[2] = ~&{nWR_ACK, ACK_BITS[2]};\n    \n    FD3 B56(RESET_IRQ, 1'b0, ACK[0], B56_Q, B56_nQ);\n    FD3 B52(TIMER_IRQ, 1'b0, ACK[1], B52_Q, B52_nQ);\n    FD3 C52(VBL_IRQ, 1'b0, ACK[2], C52_Q, );\n    \n    // B49\n    assign B49_OUT = B52_Q | B56_nQ;\n    \n    // B50A\n    assign B50A_OUT = ~|{C52_Q, B56_nQ, B52_nQ};\n    \n    FDSCell B32(CLK, {1'b0, B50A_OUT, B49_OUT, B56_Q}, B32_Q);\n    \n    assign IPL0 = ~|{~B32_Q[0], B32_Q[2]};\n    assign IPL1 = ~|{~B32_Q[1], ~B32_Q[0]};\n    \n    // Interrupt priority encoder (is priority right ?)\n    // IRQ  IPL\n    // xx1: 000 Reset IRQ\n    // x10: 001 Timer IRQ\n    // 100: 010 VBL IRQ\n    // 000: 011 No interrupt\nendmodule"}
{"task_id": 351, "completion": "assign readdata = address ? 1403034160 : 2899645186;endmodule"}
{"task_id": 340, "completion": "wire [7:0] shifted_data;  \n  assign shifted_data = (i_rotate) ? (i_right ? {i_data[0], i_data[7:1]} : {i_data[6:0], i_data[7]}) : (i_right ? {1'b0, i_data[7:1]} : {i_data[6:0], 1'b0});  \n  assign o_data = shifted_data;  \n  assign o_n = shifted_data[7];  \n  assign o_z = (shifted_data == 8'b0);  \n  assign o_c = (i_rotate) ? i_data[0] : (i_right ? i_data[7] : i_data[0]);  \nendmodule"}
{"task_id": 360, "completion": "supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\nendmodule"}
{"task_id": 288, "completion": "localparam ALFA_COLOR = 24'hA3_49_A4;\n    localparam YRES = 480;\n    localparam PLAYER_WIDTH = 40;\n    reg [5:0] player_height;\n    reg [5:0] player_height_nxt;\n    reg [23:0] rgb_nxt;\n    reg [10:0] rom_addr_nxt;\n    \n    always @(posedge clk or posedge rst) begin\n        if(rst)\n            rom_addr    <= #1 0;\n        else\n            rom_addr    <= #1 rom_addr_nxt;\n    end\n \n    always @(posedge clk or posedge rst) begin\n        if(rst) begin\n            rgb_out     <= #1 0;\n            hcount_out  <= #1 0;\n            hsync_out   <= #1 0;\n            vcount_out  <= #1 0;\n            vsync_out   <= #1 0;\n            blnk_out    <= #1 0;\n        end\n        else begin\n            rgb_out     <= #1 rgb_nxt;\n            hcount_out  <= #1 hcount_in;\n            hsync_out   <= #1 hsync_in;         \n            vcount_out  <= #1 vcount_in;\n            vsync_out   <= #1 vsync_in;\n            blnk_out    <= #1 blnk_in;\n        end\n    end\n    \n    always @* begin\n        if(size)\n            player_height_nxt = BIG;\n        else\n            player_height_nxt = SMALL;\n    end\n    \n    always@(posedge clk or posedge rst) begin\n        if(rst) begin\n            player_height = SMALL;    \n        end\n        else begin\n            player_height = player_height_nxt;\n        end\n    end\n  \n    always @* begin\n        if(direction) begin\n            rom_addr_nxt = PLAYER_WIDTH*(vcount_in  -(YRES - ypos - player_height)) + (PLAYER_WIDTH - 1 - (hcount_in - xpos + 1)); \n        end\n        else begin\n            rom_addr_nxt = PLAYER_WIDTH*(vcount_in  -(YRES - ypos - player_height)) + ((hcount_in - xpos + 1)); \n        end\n    end\n\n    always @*\n      begin\n        if(((YRES - 1 - vcount_in) < (ypos + player_height)) && ((YRES - 1 - vcount_in) >= ypos) && (hcount_in < (xpos+PLAYER_WIDTH) ) && ((xpos) <= hcount_in)) begin\n            if(rom_data == ALFA_COLOR) \n                rgb_nxt = rgb_in;\n            else\n                rgb_nxt = rom_data;\n        end\n        else begin\n            rgb_nxt = rgb_in;\n        end\n    end\n\nendmodule"}
{"task_id": 305, "completion": "always @(sel) begin\n        case (sel)\n            3'b000 : out = a;\n            3'b001 : out = b;\n            3'b010 : out = c;\n            3'b011 : out = d;\n            3'b100 : out = e;\n            3'b101 : out = f;\n            3'b110 : out = g;\n            3'b111 : out = h;\n            default out = 3'b000;\n        endcase\n    end\nendmodule"}
{"task_id": 321, "completion": "parameter IQSEL = 0;\n  parameter CHID = 0;\n  wire            adc_pn_oos_s;\n  wire            adc_pn_err_s;\n  wire    [ 3:0]  adc_pnseq_sel_s;\n\n  axi_ad6676_pnmon i_pnmon (\n    .adc_clk (adc_clk),\n    .adc_data (adc_data),\n    .adc_pn_oos (adc_pn_oos_s),\n    .adc_pn_err (adc_pn_err_s),\n    .adc_pnseq_sel (adc_pnseq_sel_s));\n\n  assign adc_dfmt_data = adc_data;\n\n  up_adc_channel #(.PCORE_ADC_CHID(CHID)) i_up_adc_channel (\n    .adc_clk (adc_clk),\n    .adc_rst (adc_rst),\n    .adc_enable (adc_enable),\n    .adc_iqcor_enb (),\n    .adc_dcfilt_enb (),\n    .adc_dfmt_se (),\n    .adc_dfmt_type (),\n    .adc_dfmt_enable (),\n    .adc_dcfilt_offset (),\n    .adc_dcfilt_coeff (),\n    .adc_iqcor_coeff_1 (),\n    .adc_iqcor_coeff_2 (),\n    .adc_pnseq_sel (adc_pnseq_sel_s),\n    .adc_data_sel (),\n    .adc_pn_err (adc_pn_err_s),\n    .adc_pn_oos (adc_pn_oos_s),\n    .adc_or (adc_or),\n    .up_adc_pn_err (up_adc_pn_err),\n    .up_adc_pn_oos (up_adc_pn_oos),\n    .up_adc_or (up_adc_or),\n    .up_usr_datatype_be (),\n    .up_usr_datatype_signed (),\n    .up_usr_datatype_shift (),\n    .up_usr_datatype_total_bits (),\n    .up_usr_datatype_bits (),\n    .up_usr_decimation_m (),\n    .up_usr_decimation_n (),\n    .adc_usr_datatype_be (1'b0),\n    .adc_usr_datatype_signed (1'b1),\n    .adc_usr_datatype_shift (8'd0),\n    .adc_usr_datatype_total_bits (8'd16),\n    .adc_usr_datatype_bits (8'd16),\n    .adc_usr_decimation_m (16'd1),\n    .adc_usr_decimation_n (16'd1),\n    .up_rstn (up_rstn),\n    .up_clk (up_clk),\n    .up_wreq (up_wreq),\n    .up_waddr (up_waddr),\n    .up_wdata (up_wdata),\n    .up_wack (up_wack),\n    .up_rreq (up_rreq),\n    .up_raddr (up_raddr),\n    .up_rdata (up_rdata),\n    .up_rack (up_rack));\n\nendmodule"}
{"task_id": 342, "completion": "output X;\n    input  A_N;\n    input  B;\n    input  C;\n    input  D;\n    input  VPWR;\n    input  VGND;\n    input  VPB;\n    input  VNB;\n    sky130_fd_sc_ls__and4b base (\n        .X(X),\n        .A_N(A_N),\n        .B(B),\n        .C(C),\n        .D(D),\n        .VPWR(VPWR),\n        .VGND(VGND),\n        .VPB(VPB),\n        .VNB(VNB)\n    );\n\nendmodule"}
{"task_id": 367, "completion": "output        Z;\n    input  [15:0] D;\n    input  [15:0] S;\n\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB;\n    supply0 VNB;\n\nendmodule"}
{"task_id": 212, "completion": "assign op = opcode[2:0];  always @(*)  begin    rwe1 <= 1'b0;      rwe2 <= 1'b0;      rwe3 <= 1'b0;      rwe4 <= 1'b0;      swe <= 1'b0;      s_ret <= 1'b0;    sece <= 1'b0;    if (reset == 1'b1)    begin      we3 <= 1'b0;      s_inm <= 1'b0;      s_inc <= 1'b1;      sec <= 1'b0;      sece <= 1'b0;      s_es <= 1'b0;      s_rel <= 1'b0;      swe <= 1'b0;      s_ret <= 1'b0;    end    else    begin      casex (opcode)        6'bxx0xxx:        begin          we3 <= 1'b1;          s_inm <= 1'b0;          s_inc <= 1'b1;          sec <= 1'b0;          sece <= 1'b0;          s_es <= 1'b0;          s_rel <= 1'b0;        end        6'bxx1010:        begin          we3 <= 1'b1;          s_inm <= 1'b1;          s_inc <= 1'b1;          sec <= 1'b0;          sece <= 1'b0;          s_es <= 1'b0;          s_rel <= 1'b0;        end        6'bxx1001:        begin          we3 <= 1'b0;          s_inm <= 1'b0;          s_inc <= 1'b0;          sec <= 1'b0;          sece <= 1'b0;          s_es <= 1'b0;          s_rel <= 1'b0;        end        6'bxx1011:        begin          we3 <= 1'b1;          s_inm <= 1'b0;          sec <= 1'b0;          sece <= 1'b0;          s_es <= 1'b1;          s_inc <= 1'b1;          s_rel <= 1'b0;        end        6'bxx1101:        begin          we3 <= 1'b0;          s_inm <= 1'b0;          sec <= 1'b1;          sece <= 1'b1;          s_es <= 1'b0;          s_inc <= 1'b1;          s_rel <= 1'b0;          if (id_out == 2'b00)            rwe1 <= 1'b1;          else if(id_out == 2'b01)            rwe2 <= 1'b1;          else if(id_out == 2'b10)            rwe3 <= 1'b1;          else            rwe4 <= 1'b1;        end        6'bxx1110:        begin          we3 <= 1'b0;          s_inm <= 1'b0;          sec <= 1'b0;          sece <= 1'b1;          s_es <= 1'b0;          s_inc <= 1'b1;          s_rel <= 1'b0;          if (id_out == 2'b00)            rwe1 <= 1'b1;          else if(id_out == 2'b01)            rwe2 <= 1'b1;          else if(id_out == 2'b10)            rwe3 <= 1'b1;          else            rwe4 <= 1'b1;        end        6'b011111:        begin          we3 <= 1'b0;          s_inm <= 1'b0;          sec <= 1'b0;          sece <= 1'b0;          s_es <= 1'b0;          s_rel <= 1'b0;          if (z == 1'b0)            s_inc <= 1'b0;          else            s_inc <= 1'b1;        end        6'b001111:        begin          we3 <= 1'b0;          s_inm <= 1'b0;          sec <= 1'b0;          sece <= 1'b0;          s_es <= 1'b0;          s_rel <= 1'b0;          if (z == 1'b0)            s_inc <= 1'b1;          else            s_inc <= 1'b0;        end        6'b011000:        begin          we3 <= 1'b0;          s_inm <= 1'b0;          s_inc <= 1'b1;          sec <= 1'b0;          sece <= 1'b0;          s_es <= 1'b0;          s_rel <= 1'b1;        end        6'b101000:        begin          we3 <= 1'b0;          s_inm <= 1'b0;          s_inc <= 1'b0;          sec <= 1'b0;          sece <= 1'b0;          s_es <= 1'b0;          s_rel <= 1'b0;          swe <= 1'b1;        end        6'b111000:        begin          we3 <= 1'b0;          s_inm <= 1'b0;          s_inc <= 1'b0;          sec <= 1'b0;          sece <= 1'b0;          s_es <= 1'b0;          s_rel <= 1'b0;          s_ret <= 1'b1;        end        6'b111111:        begin          we3 <= 1'b0;          s_inm <= 1'b0;          s_inc <= 1'b1;          sec <= 1'b0;          sece <= 1'b0;          s_es <= 1'b0;          s_rel <= 1'b0;          s_ret <= 1'b0;        end        default:        begin          we3 <= 1'b0;          s_inm <= 1'b0;          s_inc <= 1'b1;          sec <= 1'b0;          sece <= 1'b0;          s_es <= 1'b0;          s_rel <= 1'b0;          s_ret <= 1'b0;        end      endcase    end  end  endmodule"}
{"task_id": 349, "completion": "assign icache_address = di_PC;\n\nalways @(*) begin\n    if (icache_should_stall && !icache_hit) begin\n        do_NextPC = di_PC;\n        do_IR = 0;\n    end else begin\n        do_NextPC = di_PC + 4;\n        do_IR = icache_data;\n    end\nend\n\nendmodule"}
{"task_id": 381, "completion": "output Y;\n    input  A1;\n    input  A2;\n    input  B1;\n    input  C1;\n    input  D1;\n\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB;\n    supply0 VNB;\n\nendmodule"}
{"task_id": 361, "completion": "wire             and0_out;\n    wire             nor0_out_Y;\n    wire             u_vpwr_vgnd0_out_Y;\n\n    and                          and0         (and0_out, A1, A2);\n    nor                          nor0         (nor0_out_Y, B1, and0_out);\n    sky130_fd_sc_hs__u_vpwr_vgnd u_vpwr_vgnd0 (u_vpwr_vgnd0_out_Y, nor0_out_Y, VPWR, VGND);\n    buf                          buf0         (Y, u_vpwr_vgnd0_out_Y);\n\nendmodule"}
{"task_id": 263, "completion": "output X;\n    input  A;\n    input  B;\n    input  VPWR;\n    input  VGND;\n    input  VPB ;\n    input  VNB ;\n    sky130_fd_sc_hdll__and2 base (\n        .X(X),\n        .A(A),\n        .B(B),\n        .VPWR(VPWR),\n        .VGND(VGND),\n        .VPB(VPB),\n        .VNB(VNB)\n    );\n\nendmodule"}
{"task_id": 373, "completion": "parameter ADD = 6'b000000;\n    parameter NDU = 6'b001000;\n    parameter ADC = 6'b000010;\n    parameter ADZ = 6'b000001;\n    parameter ADI = 4'b0001;\n    parameter NDC = 6'b001010;\n    parameter NDZ = 6'b001001;\n    parameter LHI = 4'b0011;\n    parameter LW  = 4'b0100;\n    parameter SW  = 4'b0101;\n    parameter LM  = 4'b0110;\n    parameter SM  = 4'b0111;\n    parameter BEQ = 4'b1100;\n    parameter JAL = 4'b1000;\n    parameter JLR = 4'b1001;\n\n    input [2:0] mem_wb_regA,mem_wb_regC,ex_mem_regA;\n    input [5:0] mem_wb_op,ex_mem_op;\n    input mem_wb_CCR_write,ex_mem_CCR_write;\n    output reg [1:0] F3;\n\n    always @(*)\n    begin\n        if(ex_mem_op[5:2] == SW) begin\n            if((ex_mem_regA == mem_wb_regC) && (mem_wb_op == ADD || mem_wb_op == NDU || mem_wb_op == ADC || mem_wb_op == ADZ || mem_wb_op == NDC || mem_wb_op == NDZ) && (mem_wb_CCR_write == 1'b0))\n                F3 = 2'd2;\n            else if((ex_mem_regA == mem_wb_regA) && (mem_wb_op[5:2] == LW))\n                F3 = 2'd3;\n            else \n                F3 = 2'b0;\n        end\n        else\n            F3 = 2'b0;\n    end\nendmodule"}
{"task_id": 382, "completion": "input  VPWR;\n    input  VGND;\n    output X   ;\n    input  A1  ;\n    input  A2  ;\n    input  B1  ;\n    input  B2  ;\n    input  C1  ;\n\n    wire    B2 and0_out          ;\n    wire    B2 and1_out          ;\n    wire    or0_out_X         ;\n    wire    u_vpwr_vgnd0_out_X;\n\n    and                          and0         (and0_out          , B1, B2                );\n    and                          and1         (and1_out          , A1, A2                );\n    or                           or0          (or0_out_X         , and1_out, and0_out, C1);\n    sky130_fd_sc_hs__u_vpwr_vgnd u_vpwr_vgnd0 (u_vpwr_vgnd0_out_X, or0_out_X, VPWR, VGND );\n    buf                          buf0         (X                 , u_vpwr_vgnd0_out_X    );\n\nendmodule"}
{"task_id": 205, "completion": "endmodule"}
{"task_id": 379, "completion": "wire SLEEP;\n\n    not not0 (SLEEP , SLEEP_B);\n    or  or0  (X     , A, SLEEP);\n\nendmodule"}
{"task_id": 396, "completion": "supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\nendmodule"}
{"task_id": 324, "completion": "output [127:0] rd1data,rd2data;\n    input [0:127] wrdata;\n    input clk;\n    input wren;\n    input rd1en, rd2en;\n    input [4:0] wraddr, rd1addr, rd2addr;\n    input [15:0] wrbyteen;\n    reg [127:0] rd1data,rd2data;\n    reg [127:0] reg_file [31:0];\n    reg [127:0] ones;\n    reg [127:0] result;\n    reg [7:0] operand;\n    always @(posedge clk)\n    begin\n        ones=128'd0;\n        ones=ones-1'd1;\n        if(wren)\n        begin\n            if(wrbyteen==16'h1)\n            begin\n                operand=wrdata[0:7];\n                result = ones & operand;\n                reg_file[wraddr] <= result;\n            end\n            else if(wrbyteen==16'h3)\n            begin\n                operand=wrdata[8:15];\n                result = ones & operand;\n                reg_file[wraddr] <= result;\n            end\n            else if(wrbyteen==16'h7)\n            begin\n                operand=wrdata[16:23];\n                result = ones & operand;\n                reg_file[wraddr] <= result;\n            end\n            else if(wrbyteen==16'hf)\n            begin\n                operand=wrdata[24:31];\n                result = ones & operand;\n                reg_file[wraddr] <= result;\n            end\n            else if(wrbyteen==16'h1f)\n            begin\n                operand=wrdata[32:39];\n                result = ones & operand;\n                reg_file[wraddr] <= result;\n            end\n            else if(wrbyteen==16'h3f)\n            begin\n                operand=wrdata[40:47];\n                result = ones & operand;\n                reg_file[wraddr] <= result;\n            end\n            else if(wrbyteen==16'h7f)\n            begin\n                operand=wrdata[48:55];\n                result = ones & operand;\n                reg_file[wraddr] <= result;\n            end\n            else if(wrbyteen==16'hff)\n            begin\n                operand=wrdata[56:63];\n                result = ones & operand;\n                reg_file[wraddr] <= result;\n            end\n            else if(wrbyteen==16'h1ff)\n            begin\n                operand=wrdata[64:71];\n                result = ones & operand;\n                reg_file[wraddr] <= result;\n            end\n            else if(wrbyteen==16'h3ff)\n            begin\n                operand=wrdata[72:79];\n                result = ones & operand;\n                reg_file[wraddr] <= result;\n            end\n            else if(wrbyteen==16'h7ff)\n            begin\n                operand=wrdata[80:87];\n                result = ones & operand;\n                reg_file[wraddr] <= result;\n            end\n            else if(wrbyteen==16'hfff)\n            begin\n                operand=wrdata[88:95];\n                result = ones & operand;\n                reg_file[wraddr] <= result;\n            end\n            else if(wrbyteen==16'h1fff)\n            begin\n                operand=wrdata[96:103];\n                result = ones & operand;\n                reg_file[wraddr] <= result;\n            end\n            else if(wrbyteen==16'h3fff)\n            begin\n                operand=wrdata[104:111];\n                result = ones & operand;\n                reg_file[wraddr] <= result;\n            end\n            else if(wrbyteen==16'h7fff)\n            begin\n                operand=wrdata[112:119];\n                result = ones & operand;\n                reg_file[wraddr] <= result;\n            end\n            else if(wrbyteen==16'hffff)\n            begin\n                operand=wrdata[120:127];\n                result = ones & operand;\n                reg_file[wraddr] <= result;\n            end\n        end\n        if(rd1en)\n        begin\n            rd1data<=reg_file[rd1addr];\n        end\n        else\n        begin\n            rd1data<=128'b0;\n        end\n        if(rd2en)\n        begin\n            rd2data<=reg_file[rd2addr];\n        end\n        else\n        begin\n            rd2data<=128'b0;\n        end\n    end\nendmodule"}
{"task_id": 302, "completion": "reg [7:0]in_port;\n    wire [7:0]out_port;\n    wire [7:0]port_id;\n    wire write_strobe;\n    wire k_write_strobe;\n    wire read_strobe;\n    wire interrupt;\n    wire [7:0]out_seg_hora,out_min_hora,out_hora_hora;\n    wire [7:0]out_dia_fecha,out_mes_fecha,out_jahr_fecha;\n    wire [7:0]out_seg_timer,out_min_timer,out_hora_timer;\n    wire hold_seg_hora; \n    wire hold_min_hora; \n    wire hold_hora_hora; \n    wire hold_dia_fecha; \n    wire hold_mes_fecha; \n    wire hold_jahr_fecha; \n    wire hold_dia_semana; \n    wire hold_seg_timer;\n    wire hold_min_timer; \n    wire hold_hora_timer;\n    wire fin_lectura_escritura;\n    wire [7:0] out_dato;\n\n    assign interrupt = 1'b0;\n\n    wire wire_sw;\n    assign wire_sw = {7'b0,sw};\n\n    microcontrolador instancia_microcontrolador \n    (\n        .clk(clk), \n        .reset(reset), \n        .interrupt(interrupt), \n        .in_port(in_port), \n        .write_strobe(write_strobe), \n        .k_write_strobe(k_write_strobe), \n        .read_strobe(read_strobe), \n        .interrupt_ack(), \n        .port_id(port_id), \n        .out_port(out_port)\n    );\n\n    controlador_VGA instancia_controlador_VGA \n    (\n        .clock(clk), \n        .reset(reset), \n        .digit0_HH(out_hora_hora[3:0]), .digit1_HH(out_hora_hora[7:4]), .digit0_MM(out_min_hora[3:0]), .digit1_MM(out_min_hora[7:4]), .digit0_SS(out_seg_hora[3:0]), .digit1_SS(out_seg_hora[7:4]),//\n         .digit0_DAY(out_dia_fecha[3:0]), .digit1_DAY(out_dia_fecha[7:4]), .digit0_MES(out_mes_fecha[3:0]), .digit1_MES(out_mes_fecha[7:4]), .digit0_YEAR(out_jahr_fecha[3:0]), .digit1_YEAR(out_jahr_fecha[7:4]),//\n         .digit0_HH_T(out_hora_timer[3:0]), .digit1_HH_T(out_hora_timer[7:4]), .digit0_MM_T(out_min_timer[3:0]), .digit1_MM_T(out_min_timer[7:4]), .digit0_SS_T(out_seg_timer[3:0]), .digit1_SS_T(out_seg_timer[7:4]),//\n        .AM_PM(1'b0), \n        .config_mode(2'b0), \n        .cursor_location(2'b0), \n        .formato_hora(1'b1), \n        .estado_alarma(1'b0), \n        .hsync(hsync), \n        .vsync(vsync), \n        .RGB(RGB)\n    );\n     \n    memoria_registros_VGA instancia_memoria_registros_VGA \n    (\n        .clk(clk), \n        .reset(reset), \n        .cs_seg_hora(1'b0), \n        .cs_min_hora(1'b0), \n        .cs_hora_hora(1'b0), \n        .cs_dia_fecha(1'b0), \n        .cs_mes_fecha(1'b0), \n        .cs_jahr_fecha(1'b0), \n        .cs_seg_timer(1'b0), \n        .cs_min_timer(1'b0), \n        .cs_hora_timer(1'b0), \n        .hold_seg_hora(hold_seg_hora), \n        .hold_min_hora(hold_min_hora), \n        .hold_hora_hora(hold_hora_hora), \n        .hold_dia_fecha(hold_dia_fecha), \n        .hold_mes_fecha(hold_mes_fecha), \n        .hold_jahr_fecha(hold_jahr_fecha), \n        .hold_seg_timer(hold_seg_timer), \n        .hold_min_timer(hold_min_timer), \n        .hold_hora_timer(hold_hora_timer), \n        .hold_banderas_config(1'b1), \n        .data_PicoBlaze(out_port), \n        .count_seg_hora(8'b0), \n        .count_min_hora(8'b0), \n        .count_hora_hora(8'b0), \n        .count_dia_fecha(8'b0), \n        .count_mes_fecha(8'b0), \n        .count_jahr_fecha(8'b0), \n        .count_seg_timer(8'b0), \n        .count_min_timer(8'b0), \n        .count_hora_timer(8'b0), \n        .out_seg_hora(out_seg_hora), \n        .out_min_hora(out_min_hora), \n        .out_hora_hora(out_hora_hora), \n        .out_dia_fecha(out_dia_fecha), \n        .out_mes_fecha(out_mes_fecha), \n        .out_jahr_fecha(out_jahr_fecha), \n        .out_seg_timer(out_seg_timer), \n        .out_min_timer(out_min_timer), \n        .out_hora_timer(out_hora_timer), \n        .out_banderas_config()\n    );\n\n    deco_hold_registros instancia_deco_hold_registros (\n        .write_strobe(write_strobe), \n        .port_id(port_id), \n        .hold_seg_hora(hold_seg_hora), \n        .hold_min_hora(hold_min_hora), \n        .hold_hora_hora(hold_hora_hora), \n        .hold_dia_fecha(hold_dia_fecha), \n        .hold_mes_fecha(hold_mes_fecha), \n        .hold_jahr_fecha(hold_jahr_fecha), \n        .hold_seg_timer(hold_seg_timer), \n        .hold_min_timer(hold_min_timer), \n        .hold_hora_timer(hold_hora_timer)\n        );\n     \n    escritor_lector_rtc_2 instancia_escritor_lector_rtc_2 (\n        .clk(clk), \n        .reset(reset), \n        .in_dato(out_port),\n\t .port_id(port_id),\n\t .write_strobe(write_strobe), \n\t .k_write_strobe(k_write_strobe),\n        .read_strobe(read_strobe),\n        .reg_a_d(AD), \n        .reg_cs(CS), \n        .reg_rd(RD), \n        .reg_wr(WR), \n        .out_dato(out_dato), \n        .flag_done(fin_lectura_escritura), \n        .dato(dato)\n        );\n     \n    always@(posedge clk)\n    begin\n\t    case (port_id) \n\t    8'h0F : in_port <= fin_lectura_escritura;\n\t    8'h10 : in_port <= out_dato;\n\t    8'h02 : in_port <= wire_sw;\n\t  default : in_port <= 8'bXXXXXXXX;  \n\tendcase\n    end\n    \nendmodule"}
{"task_id": 344, "completion": "wire  sub_wire0;\n\twire  sub_wire1;\n\twire [143:0] sub_wire2;\n\twire  empty = sub_wire0;\n\twire  full = sub_wire1;\n\twire [143:0] q = sub_wire2[143:0];\n\n\tscfifo scfifo_component (\n\t\t\t.aclr (aclr),\n\t\t\t.clock (clock),\n\t\t\t.data (data),\n\t\t\t.rdreq (rdreq),\n\t\t\t.wrreq (wrreq),\n\t\t\t.empty (sub_wire0),\n\t\t\t.full (sub_wire1),\n\t\t\t.q (sub_wire2),\n\t\t\t.almost_empty (),\n\t\t\t.almost_full (),\n\t\t\t.sclr (),\n\t\t\t.usedw ());\n\tdefparam\n\t\tscfifo_component.add_ram_output_register = \"OFF\",\n\t\tscfifo_component.intended_device_family = \"Arria II GX\",\n\t\tscfifo_component.lpm_numwords = 256,\n\t\tscfifo_component.lpm_showahead = \"OFF\",\n\t\tscfifo_component.lpm_type = \"scfifo\",\n\t\tscfifo_component.lpm_width = 144,\n\t\tscfifo_component.lpm_widthu = 8,\n\t\tscfifo_component.overflow_checking = \"ON\",\n\t\tscfifo_component.underflow_checking = \"ON\",\n\t\tscfifo_component.use_eab = \"ON\";\n\nendmodule"}
{"task_id": 402, "completion": "supply1 VPWR;    supply0 VGND;    supply1 VPB;    supply0 VNB;endmodule"}
{"task_id": 391, "completion": "sky130_fd_sc_ms__nor3b base (        .Y(Y),        .A(A),        .B(B),        .C_N(C_N),        .VPWR(VPWR),        .VGND(VGND),        .VPB(VPB),        .VNB(VNB)    );    endmodule"}
{"task_id": 401, "completion": "endmodule"}
{"task_id": 387, "completion": "output Y   ;\n    input  A1_N;\n    input  A2_N;\n    input  B1  ;\n    input  B2  ;\n    input  VPWR;\n    input  VGND;\n    input  VPB ;\n    input  VNB ;\n\n    wire and0_out         ;\n    wire nor0_out         ;\n    wire nor1_out_Y       ;\n    wire pwrgood_pp0_out_Y;\n\n    and                                and0        (and0_out         , B1, B2                );\n    nor                                nor0        (nor0_out         , A1_N, A2_N            );\n    nor                                nor1        (nor1_out_Y       , nor0_out, and0_out    );\n    sky130_fd_sc_lp__udp_pwrgood_pp$PG pwrgood_pp0 (pwrgood_pp0_out_Y, nor1_out_Y, VPWR, VGND);\n    buf                                buf0        (Y                , pwrgood_pp0_out_Y     );\n\nendmodule"}
{"task_id": 327, "completion": "parameter wb_dat_width = 32;\n   parameter wb_adr_width = 32;\n   parameter slave0_addr_width = 12;\n   parameter slave1_addr_width = 28;\n   wire [1:0] slave_sel;\n   reg watchdog_err;\n   `ifdef ARBITER_IBUS_WATCHDOG\n   reg [`ARBITER_IBUS_WATCHDOG_TIMER_WIDTH:0] watchdog_timer;\n   reg wbm_stb_r;\n   wire wbm_stb_edge;\n   reg wbm_stb_edge_r, wbm_ack_i_r;\n   always @(posedge wb_clk)\n     wbm_stb_r <= wbm_stb_o;\n   assign wbm_stb_edge = (wbm_stb_o & !wbm_stb_r);\n   always @(posedge wb_clk)\n     wbm_stb_edge_r <= wbm_stb_edge;\n   always @(posedge wb_clk)\n     wbm_ack_i_r <= wbm_ack_i;\n   always @(posedge wb_clk)\n     if (wb_rst) watchdog_timer <= 0;\n     else if (wbm_ack_i_r) watchdog_timer <= 0;\n     else if (wbm_stb_edge_r) watchdog_timer <= 1;\n     else if (|watchdog_timer) watchdog_timer <= watchdog_timer + 1;\n   always @(posedge wb_clk) \n     watchdog_err <= (&watchdog_timer);\n   `else \n   always @(posedge wb_clk) \n     watchdog_err <= 0;\n   `endif \n   assign slave_sel[0] = ~|wbm_adr_o[wb_adr_width - 1:slave0_addr_width];\n   assign slave_sel[1] = ~slave_sel[0] & ~|wbm_adr_o[wb_adr_width - 1:slave1_addr_width];\n   assign wbs0_adr_i = wbm_adr_o;\n   assign wbs0_dat_i = wbm_dat_o;\n   assign wbs0_we_i  = wbm_we_o;\n   assign wbs0_sel_i = wbm_sel_o;\n   assign wbs0_cti_i = wbm_cti_o;\n   assign wbs0_bte_i = wbm_bte_o;\n   assign wbs0_cyc_i = wbm_cyc_o & slave_sel[0];\n   assign wbs0_stb_i = wbm_stb_o & slave_sel[0];\n   assign wbs1_adr_i = wbm_adr_o;\n   assign wbs1_dat_i = wbm_dat_o;\n   assign wbs1_we_i  = wbm_we_o;\n   assign wbs1_sel_i = wbm_sel_o;\n   assign wbs1_cti_i = wbm_cti_o;\n   assign wbs1_bte_i = wbm_bte_o;\n   assign wbs1_cyc_i = wbm_cyc_o & slave_sel[1];\n   assign wbs1_stb_i = wbm_stb_o & slave_sel[1];\n   assign wbm_dat_i = slave_sel[1] ? wbs1_dat_o : wbs0_dat_o ;\n   assign wbm_ack_i = (slave_sel[0] & wbs0_ack_o) | (slave_sel[1] & wbs1_ack_o);\n   assign wbm_err_i = (slave_sel[0] & wbs0_err_o) | (slave_sel[1] & wbs1_err_o) | watchdog_err;\n   assign wbm_rty_i = (slave_sel[0] & wbs0_rty_o) | (slave_sel[1] & wbs1_rty_o);\nendmodule"}
{"task_id": 318, "completion": "`ifdef XC3S250E function integer clog2 (input integer value); begin value = value-1; for (clog2=0; value>0; clog2=clog2+1) value = value>>1; end endfunction localparam CW =  clog2(FF)+1; `else localparam CW = $clog2(FF)+1; `endif localparam G0 = {1'b1,{CW-1{1'b0}}}; function [CW-1:0] int2gry (input [CW-1:0] val); integer i; begin for (i=0; i<CW-1; i=i+1)  int2gry[i] = val[i+1] ^ val[i]; int2gry[CW-1] = val[CW-1]; end endfunction function [CW-1:0] gry2int (input [CW-1:0] val); integer i; begin gry2int[CW-1] = val[CW-1]; for (i=CW-1; i>0; i=i-1)  gry2int[i-1] = val[i-1] ^ gry2int[i]; end endfunction function [CW-1:0] gry_inc (input [CW-1:0] gry_gry); begin gry_inc = int2gry (gry2int (gry_gry) + 'd1); end endfunction wire          ffi_trn; wire          ffi_end; reg  [CW-1:0] ffi_ref; reg  [CW-1:0] ffi_gry; reg  [CW-1:0] ffi_syn [SS-1:0]; reg  [DW-1:0] cdc_mem [0:FF-1]; wire          ffo_trn; wire          ffo_end; reg  [CW-1:0] ffo_gry; reg  [CW-1:0] ffo_syn [SS-1:0]; genvar i; assign ffi_trn = ffi_vld & ffi_rdy; generate for (i=0; i<SS; i=i+1) begin : ffi_cdc if (i==0) begin always @ (posedge ffi_clk, posedge ffi_rst) if (ffi_rst)  ffi_syn [i] <= {CW{1'b0}}; else          ffi_syn [i] <= ffo_gry; end else begin always @ (posedge ffi_clk, posedge ffi_rst) if (ffi_rst)  ffi_syn [i] <= {CW{1'b0}}; else          ffi_syn [i] <= ffi_syn [i-1]; end end endgenerate always @ (posedge ffi_clk, posedge ffi_rst) if (ffi_rst)       ffi_gry <= {CW{1'b0}}; else if (ffi_trn)  ffi_gry <= ffi_end ? ffi_gry ^ G0 : gry_inc (ffi_gry); always @ (posedge ffi_clk, posedge ffi_rst) if (ffi_rst)       ffi_ref <= int2gry(-FF); else if (ffi_trn)  ffi_ref <= ffi_end ? ffi_ref ^ G0 : gry_inc (ffi_ref); assign ffi_rdy = ffi_syn [SS-1] != ffi_ref; reg  [CW-2:0] ffi_cnt; assign ffi_end = ffi_cnt == (FF-1); always @ (posedge ffi_clk, posedge ffi_rst) if (ffi_rst)       ffi_cnt <= 'b0; else if (ffi_trn)  ffi_cnt <= ffi_end ? 'b0 : ffi_cnt + 'b1; always @ (posedge ffi_clk) if (ffi_trn) cdc_mem [ffi_cnt] <= ffi_dat; reg  [CW-2:0] ffo_cnt; assign ffo_end = ffo_cnt == (FF-1); always @ (posedge ffo_clk, posedge ffo_rst) if (ffo_rst)       ffo_cnt <= 'b0; else if (ffo_trn)  ffo_cnt <= ffo_end ? 'b0 : ffo_cnt + 'b1; assign ffo_dat = cdc_mem [ffo_cnt]; assign ffo_trn = ffo_vld & ffo_rdy; generate for (i=0; i<SS; i=i+1) begin : ffo_cdc if (i==0) begin always @ (posedge ffo_clk, posedge ffo_rst) if (ffo_rst)  ffo_syn [i] <= {CW{1'b0}}; else          ffo_syn [i] <= ffi_gry; end else begin always @ (posedge ffo_clk, posedge ffo_rst) if (ffo_rst)  ffo_syn [i] <= {CW{1'b0}}; else          ffo_syn [i] <= ffo_syn [i-1]; end end endgenerate always @ (posedge ffo_clk, posedge ffo_rst) if (ffo_rst)       ffo_gry <= {CW{1'b0}}; else if (ffo_trn)  ffo_gry <= ffo_end ? ffo_gry ^ G0 : gry_inc (ffo_gry); assign ffo_vld = ffo_syn [SS-1] != ffo_gry; endmodule"}
{"task_id": 362, "completion": "wire deque = yumi_i;   wire v_o_tmp;   assign v_o = v_o_tmp;   wire enque;   logic ready_lo;   if (ready_THEN_valid_p) begin: rtv assign enque = v_i;   end else begin: rav assign enque = v_i & ready_lo;   end   localparam ptr_width_lp = `BSG_SAFE_CLOG2(els_p);   logic [ptr_width_lp-1:0] rptr_r, wptr_r;   logic full, empty;   logic [ptr_width_lp-1:0] rptr_n;   logic [width_p-1:0] data_o_mem, data_o_reg;   logic read_write_same_addr_n;   logic write_bypass_r, write_bypass_n;   bsg_fifo_tracker #(.els_p(els_p)) fts (.clk_i, .reset_i, .enq_i (enque), .deq_i (deque), .wptr_r_o (wptr_r), .rptr_r_o (rptr_r), .rptr_n_o (rptr_n), .full_o (full), .empty_o (empty));   bsg_mem_1r1w_sync #(.width_p (width_p), .els_p (els_p), .read_write_same_addr_p(0), .disable_collision_warning_p(0), .harden_p(1)) mem_1r1w_sync (.clk_i, .reset_i, .w_v_i (enque), .w_addr_i (wptr_r), .w_data_i (data_i), .r_v_i (~read_write_same_addr_n), .r_addr_i (rptr_n), .r_data_o (data_o_mem));   bsg_dff_en #(.width_p(width_p)) bypass_reg (.clk_i, .data_i(data_i), .en_i (write_bypass_n), .data_o(data_o_reg));   assign data_o = (write_bypass_r)? data_o_reg : data_o_mem;   assign read_write_same_addr_n = (wptr_r == rptr_n);   assign write_bypass_n = enque & read_write_same_addr_n;   always_ff @(posedge clk_i) write_bypass_r <= write_bypass_n;   assign ready_lo = ~full;   assign ready_o = ready_lo;   assign v_o_tmp = ~empty;   always_ff @ (negedge clk_i) begin if (ready_THEN_valid_p & full  & v_i    & ~reset_i) $display(\"%m error: enque full fifo at time %t\", $time); if (empty & yumi_i & ~reset_i) $display(\"%m error: deque empty fifo at time %t\", $time); endendmodule"}
{"task_id": 378, "completion": "output Y;    input  A;    input  VPWR;    input  VGND;    input  VPB ;    input  VNB ;    sky130_fd_sc_lp__inv base (        .Y(Y),        .A(A),        .VPWR(VPWR),        .VGND(VGND),        .VPB(VPB),        .VNB(VNB)    );\nendmodule"}
{"task_id": 377, "completion": "assign X = (S0 == 1'b0 && S1 == 1'b0) ? A0 :\n                (S0 == 1'b0 && S1 == 1'b1) ? A1 :\n                (S0 == 1'b1 && S1 == 1'b0) ? A2 :\n                A3;\nendmodule"}
{"task_id": 389, "completion": "always@(posedge clk) begin\n\t\tif(rst) begin\n\t\t\tmem_fault <= 1'b0;\n\t\t\tstk_loc [add_width-1] <= {width{1'b0}};\n\t\tend else if(push && !pop) stk_loc <= stk_loc + 1'b1;\n\t\telse if(pop && !push) stk_loc <= stk_loc - 1'b1;\n\t\telse if ((push && pop) && (stk_loc == 8'b0) || (push && (stk_loc = 8'b11111111))) mem_fault <= 1'b1;\n\tend\n\n\talways@(posedge clk) begin\n\t\trd [width-1:0] <= mem_arr[stk_loc] [width-1:0];\n\tend\n\n\talways@(posedge clk) begin\n\t\tif(push) mem_arr[stk_loc] [width-1:0] <= wr [width-1:0];\n\tend\n\nendmodule"}
{"task_id": 352, "completion": "assign spu_lsurpt_ldxa_data_out[63:0] = spu_lsurpt_ldxa_data_in[63:0];\n    assign spu_lsurpt_ldst_pckt_out[122:0] = spu_lsurpt_ldst_pckt_in[122:0];\n    assign spu_lsurpt_cpx_data_out[134:0] = spu_lsurpt_cpx_data_in[134:0];\nendmodule"}
{"task_id": 388, "completion": "wire m_access_out; wire [PW-1:0] m_packet_out; wire m_wait_out; wire s_access_out; wire [PW-1:0] s_packet_out; wire [511:0] s_spi_regs; wire s_wait_out; spi_master #(.AW(AW), .PW(PW)) spi_master ( .sclk(m_sclk), .mosi(m_mosi), .ss(m_ss), .wait_out(m_wait_out), .access_out(m_access_out), .packet_out(m_packet_out[PW-1:0]), .clk(clk), .nreset(nreset), .hw_en(hw_en), .miso(m_miso), .access_in(access_in), .packet_in(packet_in[PW-1:0]), .wait_in(wait_in)); spi_slave #(.AW(AW), .PW(PW), .UREGS(UREGS)) spi_slave ( .spi_regs(s_spi_regs[511:0]), .spi_irq(spi_irq), .miso(s_miso), .access_out(s_access_out), .packet_out(s_packet_out[PW-1:0]), .wait_out(s_wait_out), .clk(clk), .nreset(nreset), .hw_en(hw_en), .sclk(s_sclk), .mosi(s_mosi), .ss(s_ss), .wait_in(wait_in), .access_in(access_in), .packet_in(packet_in[PW-1:0])); assign wait_out = s_wait_out | m_wait_out; emesh_mux #(.N(2), .AW(AW), .PW(PW)) emesh_mux ( .wait_out(), .access_out(access_out), .packet_out(packet_out[PW-1:0]), .access_in({s_access_out,m_access_out}), .packet_in({s_packet_out[PW-1:0],m_packet_out[PW-1:0]}), .wait_in(wait_in)); endmodule"}
{"task_id": 337, "completion": "reg [23: 0] data; assign rom_data = {data[23:16], 1'b0, data[15: 8], 1'b0, data[ 7: 0], 1'b0}; always @(*) begin case (rom_address) 10 : data <= {8'h40, INPUT_CTRL}; 11 : data <= {8'h40, VIDEO_SELECTION}; 12 : data <= {8'h40, OUTPUT_CTRL}; 13 : data <= {8'h40, EXT_OUTPUT_CTRL}; 14 : data <= {8'h40, AUTODETECT}; 15 : data <= {8'h40, BRIGHTNESS}; 16 : data <= {8'h40, HUE}; 17 : data <= {8'h40, DEFAULT_VALUE_Y}; 18 : data <= {8'h40, DEFAULT_VALUE_C}; 19 : data <= {8'h40, POWER_MGMT}; 20 : data <= {8'h40, ANALOG_CLAMP_CTRL}; 21 : data <= {8'h40, DIGITAL_CLAMP_CTRL}; 22 : data <= {8'h40, SHAPING_FILTER_CTRL_1}; 23 : data <= {8'h40, SHAPING_FILTER_CTRL_2}; 24 : data <= {8'h40, COMB_FILTER_CTRL_2}; 25 : data <= {8'h40, PIXEL_DELAY_CTRL}; 26 : data <= {8'h40, MISC_GAIN_CTRL}; 27 : data <= {8'h40, AGC_MODE_CTRL}; 28 : data <= {8'h40, CHROMA_GAIN_CTRL_1}; 29 : data <= {8'h40, CHROMA_GAIN_CTRL_2}; 30 : data <= {8'h40, LUMA_GAIN_CTRL_1}; 31 : data <= {8'h40, LUMA_GAIN_CTRL_2}; 32 : data <= {8'h40, VSYNC_FIELD_CTRL_1}; 33 : data <= {8'h40, VSYNC_FIELD_CTRL_2}; 34 : data <= {8'h40, VSYNC_FIELD_CTRL_3}; 35 : data <= {8'h40, HSYNC_FIELD_CTRL_1}; 36 : data <= {8'h40, HSYNC_FIELD_CTRL_2}; 37 : data <= {8'h40, HSYNC_FIELD_CTRL_3}; 38 : data <= {8'h40, POLARITY}; 39 : data <= {8'h40, NTSC_COMB_CTRL}; 40 : data <= {8'h40, PAL_COMB_CTRL}; 41 : data <= {8'h40, ADC_CTRL}; 42 : data <= {8'h40, MANUAL_WINDOW_CTRL}; 43 : data <= {8'h40, RESAMPLE_CONTROL}; 44 : data <= {8'h40, CRC}; 45 : data <= {8'h40, ADC_SWITCH_1}; 46 : data <= {8'h40, ADC_SWITCH_2}; 47 : data <= {8'h40, LETTERBOX_CTRL_1}; 48 : data <= {8'h40, LETTERBOX_CTRL_2}; 49 : data <= {8'h40, NTSC_V_BIT_BEGIN}; 50 : data <= {8'h40, NTSC_V_BIT_END}; 51 : data <= {8'h40, NTSC_F_BIT_TOGGLE}; 52 : data <= {8'h40, PAL_V_BIT_BEGIN}; 53 : data <= {8'h40, PAL_V_BIT_END}; 54 : data <= {8'h40, PAL_F_BIT_TOGGLE}; 55 : data <= {8'h40, VBLANK_CTRL_1}; 56 : data <= {8'h40, VBLANK_CTRL_2}; default : data <= {8'h00, 16'h0000}; endcase endendmodule"}
{"task_id": 266, "completion": "wire [31:0] SEG_0,SEG_1,SEG_2,SEG_3,SEG_4,SEG_5,SEG_6,SEG_7;\n  wire [31:0] SEG_8,SEG_9,SEG_10,SEG_11,SEG_12,SEG_13,SEG_14,SEG_15;\n\n  display_module_async_16b i0(\n    .data   (data0),\n    .SEG_32 (SEG_0)\n  );\n  display_module_async_16b i1(\n    .data   (data1),\n    .SEG_32 (SEG_1)\n  );\n  display_module_async_16b i2(\n    .data   (data2),\n    .SEG_32 (SEG_2)\n  );\n  display_module_async_16b i3(\n    .data   (data3),\n    .SEG_32 (SEG_3)\n  );\n  display_module_async_16b i4(\n    .data   (data4),\n    .SEG_32 (SEG_4)\n  );\n  display_module_async_16b i5(\n    .data   (data5),\n    .SEG_32 (SEG_5)\n  );\n  display_module_async_16b i6(\n    .data   (data6),\n    .SEG_32 (SEG_6)\n  );\n  display_module_async_16b i7(\n    .data   (data7),\n    .SEG_32 (SEG_7)\n  );\n  display_module_async_16b i8(\n    .data   (data8),\n    .SEG_32 (SEG_8)\n  );\n  display_module_async_16b i9(\n    .data   (data9),\n    .SEG_32 (SEG_9)\n  );\n  display_module_async_16b i10(\n    .data   (data10),\n    .SEG_32 (SEG_10)\n  );\n  display_module_async_16b i11(\n    .data   (data11),\n    .SEG_32 (SEG_11)\n  );\n  display_module_async_16b i12(\n    .data   (data12),\n    .SEG_32 (SEG_12)\n  );\n  display_module_async_16b i13(\n    .data   (data13),\n    .SEG_32 (SEG_13)\n  );\n  display_module_async_16b i14(\n    .data   (data14),\n    .SEG_32 (SEG_14)\n  );\n  display_module_async_16b i15(\n    .data   (data15),\n    .SEG_32 (SEG_15)\n  );\n  dynamic_displayIK_16 i16(\n    .CLK     (CLK),\n    .RST     (RSTN),\n    .SEG_0   (SEG_0),\n    .SEG_1   (SEG_1),\n    .SEG_2   (SEG_2),\n    .SEG_3   (SEG_3),\n    .SEG_4   (SEG_4),\n    .SEG_5   (SEG_5),\n    .SEG_6   (SEG_6),\n    .SEG_7   (SEG_7),\n    .SEG_8   (SEG_8),\n    .SEG_9   (SEG_9),\n    .SEG_10  (SEG_10),\n    .SEG_11  (SEG_11),\n    .SEG_12  (SEG_12),\n    .SEG_13  (SEG_13),\n    .SEG_14  (SEG_14),\n    .SEG_15  (SEG_15),\n    .SEG_A   (SEG_A),\n    .SEG_B   (SEG_B),\n    .SEG_C   (SEG_C),\n    .SEG_D   (SEG_D),\n    .SEG_E   (SEG_E),\n    .SEG_F   (SEG_F),\n    .SEG_G   (SEG_G),\n    .SEG_H   (SEG_H),\n    .SEG_SEL (SEG_SEL)\n  );\nendmodule"}
{"task_id": 418, "completion": "supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\nendmodule"}
{"task_id": 405, "completion": "input  A   ;\n    input  TE_B;\n    output Z   ;\n    input  VPWR;\n    input  VGND;\n    sky130_fd_sc_hs__einvn base (\n        .A(A),\n        .TE_B(TE_B),\n        .Z(Z),\n        .VPWR(VPWR),\n        .VGND(VGND)\n    );\n\nendmodule"}
{"task_id": 230, "completion": "parameter IDLE = 0, ACTIVE = 1, INCYCLE = 2;    reg [2:0] state = IDLE, last_state = IDLE;    reg [2:0] cntr = 0;    reg rd = 0, wr = 0;    reg ack1 = 0, ack2 = 0, ack3 = 0, ack4 = 0;    assign dat_o = (ack1_o) ? dat1_i : (ack2_o) ? dat2_i : (ack3_o) ? dat3_i : (ack4_o) ? dat4_i : 16'd0;    assign dm_o = (ack1_o) ? dm1_i : (ack2_o) ? dm2_i : (ack3_o) ? dm3_i : (ack4_o) ? dm4_i : 2'd0;    always @(posedge clock_i) if( reset_i ) state <= IDLE; else case( state ) IDLE : if( ~valid_i ) begin if( req1_i & (rd1_i | wr1_i) ) begin state <= ACTIVE; ack1 <= 1'b1; adr_o <= adr1_i; if( rd1_i ) begin rd <= 1'b1; wr <= 1'b0; end else begin rd <= 1'b0; if( wr1_i ) wr <= 1'b1; else wr <= 1'b0; end end else if( req2_i & (rd2_i | wr2_i) ) begin state <= ACTIVE; adr_o <= adr2_i; ack2 <= 1'b1; if( rd2_i ) begin rd <= 1'b1; wr <= 1'b0; end else begin rd <= 1'b0; if( wr2_i ) wr <= 1'b1; else wr <= 1'b0; end end else if( req3_i & (rd3_i | wr3_i) ) begin state <= ACTIVE; adr_o <= adr3_i; ack3 <= 1'b1; if( rd3_i ) begin rd <= 1'b1; wr <= 1'b0; end else begin rd <= 1'b0; if( wr3_i ) wr <= 1'b1; else wr <= 1'b0; end end else if( req4_i & (rd4_i | wr4_i) ) begin state <= ACTIVE; adr_o <= adr4_i; ack4 <= 1'b1; if( rd4_i ) begin rd <= 1'b1; wr <= 1'b0; end else begin rd <= 1'b0; if( wr4_i ) wr <= 1'b1; else wr <= 1'b0; end end end ACTIVE : if( valid_i ) begin state <= INCYCLE; cntr <= 3'd7; end INCYCLE : begin ack1 <= 0; ack2 <= 0; ack3 <= 0; ack4 <= 0; if( cntr == 0 ) state <= IDLE; else cntr <= cntr - 1'b1; end default: state <= IDLE; endcase    reg pending_acknowledgement = 0;    always @(negedge clock_i) begin case( state ) IDLE: begin ack1_o <= 0; ack2_o <= 0; ack3_o <= 0; ack4_o <= 0; rd_o <= 0; wr_o <= 0; enable_o <= 0; last_state <= IDLE; pending_acknowledgement <= 1'b1; end ACTIVE: begin if( pending_acknowledgement ) begin ack1_o <= ack1; ack2_o <= ack2; ack3_o <= ack3; ack4_o <= ack4; rd_o <= rd; wr_o <= wr; enable_o <= 1; if( busy_i ) pending_acknowledgement <= 1'b0; end else begin enable_o <= 0; rd_o <= 0; wr_o <= 0; end end INCYCLE : begin enable_o <= 0; rd_o <= 0; wr_o <= 0; end endcase endendmodule"}
{"task_id": 408, "completion": "output Y   ;\n    input  A1  ;\n    input  A2  ;\n    input  A3  ;\n    input  B1  ;\n    input  C1  ;\n    input  VPWR;\n    input  VGND;\n    input  VPB ;\n    input  VNB ;\n    sky130_fd_sc_ms__o311ai base (\n        .Y(Y),\n        .A1(A1),\n        .A2(A2),\n        .A3(A3),\n        .B1(B1),\n        .C1(C1),\n        .VPWR(VPWR),\n        .VGND(VGND),\n        .VPB(VPB),\n        .VNB(VNB)\n    );\n\nendmodule"}
{"task_id": 414, "completion": "supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\nendmodule"}
{"task_id": 70, "completion": "wire [15:0]  wIP,wIP_temp,wIP_return; reg         rWriteEnable,rBranchTaken,rReturn,rCall; wire [27:0] wInstruction; wire [3:0]  wOperation; reg [15:0]   rResult; wire [7:0]  wSourceAddr0,wSourceAddr1,wDestination, wDestinationPrev; wire [15:0] wSourceData0,wSourceData1,wSourceData0_RAM,wSourceData1_RAM,wResultPrev,wIPInitialValue,wDestinationJump,wImmediateValue; wire wHazard0, wHazard1, wWriteEnablePrev, wIsImmediate,wPushAddr; ROM InstructionRom  ( .iAddress(     wIP          ), .oInstruction( wInstruction ) ); RAM_DUAL_READ_PORT DataRam ( .Clock(         Clock        ), .iWriteEnable(  rWriteEnable ), .iReadAddress0( wInstruction[7:0] ), .iReadAddress1( wInstruction[15:8] ), .iWriteAddress( wDestination ), .iDataIn(       rResult      ), .oDataOut0(     wSourceData0_RAM ), .oDataOut1(     wSourceData1_RAM ) ); assign wDestinationJump = (rReturn) ? wIP_return : wDestination; assign wIPInitialValue = (Reset) ? 8'b0 : wDestination; UPCOUNTER_POSEDGE IP ( .Clock(   Clock                ),  .Reset(   Reset | rBranchTaken ), .Initial( wIPInitialValue + 16'd1 ), .Enable(  1'b1                 ), .Q(       wIP_temp             ) ); assign wIP = (rBranchTaken) ? wIPInitialValue : wIP_temp; FFD_POSEDGE_SYNCRONOUS_RESET # ( 4 ) FFD1  ( .Clock(Clock), .Reset(Reset), .Enable(1'b1), .D(wInstruction[27:24]), .Q(wOperation) ); FFD_POSEDGE_SYNCRONOUS_RESET # ( 8 ) FFD2 ( .Clock(Clock), .Reset(Reset), .Enable(1'b1), .D(wInstruction[7:0]), .Q(wSourceAddr0) ); FFD_POSEDGE_SYNCRONOUS_RESET # ( 8 ) FFD3 ( .Clock(Clock), .Reset(Reset), .Enable(1'b1), .D(wInstruction[15:8]), .Q(wSourceAddr1) ); FFD_POSEDGE_SYNCRONOUS_RESET # ( 8 ) FFD4 ( .Clock(Clock), .Reset(Reset), .Enable(1'b1), .D(wInstruction[23:16]), .Q(wDestination) ); reg rFFLedEN; FFD_POSEDGE_SYNCRONOUS_RESET # ( 8 ) FF_LEDS ( .Clock(Clock), .Reset(Reset), .Enable( rFFLedEN ), .D( wSourceData1[7:0] ), .Q( oLed    ) ); assign wImmediateValue = {wSourceAddr1,wSourceAddr0}; /////////////////////////////////// // Data Hazards en el pipeline // FFD_POSEDGE_SYNCRONOUS_RESET # ( 8 ) FFD41 ( .Clock(Clock), .Reset(Reset), .Enable(1'b1), .D(wDestination), .Q(wDestinationPrev) ); FFD_POSEDGE_SYNCRONOUS_RESET # ( 16 ) FFDRES ( .Clock(Clock), .Reset(Reset), .Enable(rWriteEnable), .D(rResult), .Q(wResultPrev) ); FFD_POSEDGE_SYNCRONOUS_RESET # ( 1 ) FFDWRITE ( .Clock(Clock), .Reset(Reset), .Enable(1'b1), .D( {rWriteEnable} ), .Q( {wWriteEnablePrev} ) ); assign wIsImmediate = wOperation[3] && wOperation[2]; assign wHazard0 = ((wDestinationPrev == wSourceAddr0) && wWriteEnablePrev && ~wIsImmediate ) ? 1'b1 : 1'b0; assign wHazard1 = ((wDestinationPrev == wSourceAddr1) && wWriteEnablePrev && ~wIsImmediate ) ? 1'b1 : 1'b0; assign wSourceData0 = (wHazard0) ? wResultPrev : wSourceData0_RAM; assign wSourceData1 = (wHazard1) ? wResultPrev : wSourceData1_RAM; //                             // /////////////////////////////////// //           CALL RET          // FFD_POSEDGE_SYNCRONOUS_RESET # ( 16 ) FF_RET ( .Clock(~Clock), .Reset(Reset), .Enable( rCall ), .D( wIP_temp ), .Q( wIP_return ) ); //                             // //////////////////////////////// // VGA Controler and Memory // VGA_Controller vga ( .Clock(Clock), .Enable(1'b1), .Reset(Reset), .iPixel(`RED), .oHorizontalSync(VGA_HSYNC), .oVerticalSync(VGA_VSYNC), .oRed(VGA_RED), .oGreen(VGA_GREEN), .oBlue(VGA_BLUE) ); // Instanciar memoria aqui //                          // //////////////////////////////// always @ ( * ) begin case (wOperation) //------------------------------------- `NOP: begin rFFLedEN     <= 1'b0; rBranchTaken <= 1'b0; rWriteEnable <= 1'b0; rResult      <= 0; rReturn      <= 1'b0; rCall        <= 1'b0; end //------------------------------------- `ADD: begin rFFLedEN     <= 1'b0; rBranchTaken <= 1'b0; rWriteEnable <= 1'b1; rResult      <= wSourceData1 + wSourceData0; rReturn      <= 1'b0; rCall        <= 1'b0; end //------------------------------------- `SUB: begin rFFLedEN     <= 1'b0; rBranchTaken <= 1'b0; rWriteEnable <= 1'b1; rResult      <= wSourceData1 - wSourceData0; rReturn      <= 1'b0; rCall        <= 1'b0; end //------------------------------------- `STO: begin rFFLedEN     <= 1'b0; rWriteEnable <= 1'b1; rBranchTaken <= 1'b0; rResult      <= wImmediateValue; rReturn      <= 1'b0; rCall        <= 1'b0; end //------------------------------------- `BLE: begin rFFLedEN     <= 1'b0; rWriteEnable <= 1'b0; rResult      <= 0; if (wSourceData1 <= wSourceData0 ) rBranchTaken <= 1'b1; else rBranchTaken <= 1'b0; rReturn      <= 1'b0; rCall        <= 1'b0; end //------------------------------------- `JMP: begin rFFLedEN     <= 1'b0; rWriteEnable <= 1'b0; rResult      <= 0; rBranchTaken <= 1'b1; rReturn      <= 1'b0; rCall        <= 1'b0; end //------------------------------------- `CALL: begin rFFLedEN     <= 1'b0; rWriteEnable <= 1'b0; rResult      <= 0; rBranchTaken <= 1'b1; rReturn      <= 1'b0; rCall        <= 1'b1; end //------------------------------------- `RET: begin rFFLedEN     <= 1'b0; rWriteEnable <= 1'b0; rResult      <= 0; rBranchTaken <= 1'b1; rReturn      <= 1'b1; rCall        <= 1'b0; end //------------------------------------- `LED: begin rFFLedEN     <= 1'b1; rWriteEnable <= 1'b0; rResult      <= 0; rBranchTaken <= 1'b0; rReturn      <= 1'b0; rCall        <= 1'b0; end `WRITE_ROM : begin if (row <= 200){ }else  if(row <= 400){ }else if (row <= 600) { }else if(row <= 800) {} end //------------------------------------- default: begin rFFLedEN     <= 1'b1; rWriteEnable <= 1'b0; rResult      <= 0; rBranchTaken <= 1'b0; rReturn      <= 1'b0; rCall        <= 1'b0; end //------------------------------------- endcase end endmodule"}
{"task_id": 253, "completion": "wire [7:0] acc_address;\n    wire acc_write;\n    wire acc_read;\n    wire [31:0] acc_writedata;\n    wire [31:0] acc_readdata;\n    wire acc_waitrequest;\n\n    SGMII_TX SGMII_TX(\n        .clk(clk),\n        .reset(reset),\n        .ff_tx_clk(sgmii_clk),\n        .ff_tx_data(ff_tx_data),\n        .ff_tx_mod(ff_tx_mod),\n        .ff_tx_sop(ff_tx_sop),\n        .ff_tx_eop(ff_tx_eop),\n        .ff_tx_err(ff_tx_err),\n        .ff_tx_wren(ff_tx_wren),\n        .ff_tx_crc_fwd(ff_tx_crc_fwd),\n        .tx_ff_uflow(tx_ff_uflow),\n        .ff_tx_rdy(ff_tx_rdy),\n        .ff_tx_septy(ff_tx_septy),\n        .ff_tx_a_full(ff_tx_a_full),\n        .ff_tx_a_empty(ff_tx_a_empty),\n        .pkt_send_add(pkt_send_add),\n        .data_in_wrreq(out2_pkt_wrreq),\n        .data_in(out2_pkt),\n        .data_in_almostfull(out2_pkt_almost_full),\n        .data_in_valid_wrreq(out2_valid_wrreq),\n        .data_in_valid(out2_valid)\n    );\n\n    SGMII_RX SGMII_RX(\n        .reset(reset),\n        .ff_rx_clk(sgmii_clk),\n        .ff_rx_rdy(ff_rx_rdy),\n        .ff_rx_data(ff_rx_data),\n        .ff_rx_mod(ff_rx_mod),\n        .ff_rx_sop(ff_rx_sop),\n        .ff_rx_eop(ff_rx_eop),\n        .rx_err(rx_err),\n        .rx_err_stat(rx_err_stat),\n        .rx_frm_type(rx_frm_type),\n        .ff_rx_dsav(ff_rx_dsav),\n        .ff_rx_dval(ff_rx_dval),\n        .ff_rx_a_full(ff_rx_a_full),\n        .ff_rx_a_empty(ff_rx_a_empty),\n        .pkt_receive_add(pkt_receive_add),\n        .pkt_discard_add(pkt_discard_add),\n        .out_pkt_wrreq(out_pkt_wrreq),\n        .out_pkt(out_pkt),\n        .out_pkt_almostfull(out_pkt_almostfull),\n        .out_valid_wrreq(out_valid_wrreq),\n        .out_valid(out_valid)\n    );\n\n    wire ff_tx_clk;\n    wire [31:0] ff_tx_data;\n    wire [1:0] ff_tx_mod;\n    wire ff_tx_sop;\n    wire ff_tx_eop;\n    wire ff_tx_err;\n    wire ff_tx_wren;\n    wire ff_tx_crc_fwd;\n    wire tx_ff_uflow;\n    wire ff_tx_rdy;\n    wire ff_tx_septy;\n    wire ff_tx_a_full;\n    wire ff_tx_a_empty;\n\n    wire reset;\n    wire ff_rx_clk;\n    wire ff_rx_rdy;\n    wire [31:0] ff_rx_data;\n    wire [1:0] ff_rx_mod;\n    wire ff_rx_sop;\n    wire ff_rx_eop;\n    wire [5:0] rx_err;\n    wire [17:0] rx_err_stat;\n    wire [3:0] rx_frm_type;\n    wire ff_rx_dsav;\n    wire ff_rx_dval;\n    wire ff_rx_a_full;\n    wire ff_rx_a_empty;\n    mac_sgmii mac_sgmii(\n        .ff_tx_clk(sgmii_clk),\n        .ff_tx_data(ff_tx_data),\n        .ff_tx_mod(ff_tx_mod),\n        .ff_tx_sop(ff_tx_sop),\n        .ff_tx_eop(ff_tx_eop),\n        .ff_tx_err(ff_tx_err),\n        .ff_tx_wren(ff_tx_wren),\n        .ff_tx_crc_fwd(ff_tx_crc_fwd),\n        .tx_ff_uflow(tx_ff_uflow),\n        .ff_tx_rdy(ff_tx_rdy),\n        .ff_tx_septy(ff_tx_septy),\n        .ff_tx_a_full(ff_tx_a_full),\n        .ff_tx_a_empty(ff_tx_a_empty),\n        .ff_rx_clk(sgmii_clk),\n        .ff_rx_rdy(ff_rx_rdy),\n        .ff_rx_data(ff_rx_data),\n        .ff_rx_mod(ff_rx_mod),\n        .ff_rx_sop(ff_rx_sop),\n        .ff_rx_eop(ff_rx_eop),\n        .rx_err(rx_err),\n        .rx_err_stat(rx_err_stat),\n        .rx_frm_type(rx_frm_type),\n        .ff_rx_dsav(ff_rx_dsav),\n        .ff_rx_dval(ff_rx_dval),\n        .ff_rx_a_full(ff_rx_a_full),\n        .ff_rx_a_empty(ff_rx_a_empty),\n        .clk(ammc_clk),\n        .reg_addr(address),\n        .reg_wr(write),\n        .reg_rd(read),\n        .reg_data_in(writedata),\n        .reg_data_out(readdata),\n        .reg_busy(waitrequest),\n        .reset(~reset),\n        .rxp(rxp),\n        .txp(txp),\n        .ref_clk(ref_clk),\n        .led_an(),\n        .led_char_err(),\n        .led_link(),\n        .led_disp_err(),\n        .led_crs(),\n        .led_col(),\n        .rx_recovclkout(),\n        .pcs_pwrdn_out(),\n        .reconfig_togxb(4'b010),\n        .reconfig_fromgxb()\n    );\nendmodule"}
{"task_id": 316, "completion": "reg [reg_width-1:0] reg_synced_3 = reg_preset;\nreg [reg_width-1:0] reg_synced_2 = reg_preset;\nreg [reg_width-1:0] reg_synced_1 = reg_preset;\nreg [reg_width-1:0] reg_synced_0 = reg_preset;\n\nalways @(posedge clk or negedge nrst)\n  if (!nrst) begin\n    reg_synced_2 <= reg_preset;\n    reg_synced_1 <= reg_preset;\n    reg_synced_0 <= reg_preset;\n  end else if (clk_en) begin\n    reg_synced_2 <= reg_synced_1;\n    reg_synced_1 <= reg_synced_0;\n    reg_synced_0 <= reg_i;\n  end\n\ngenvar int_idx;\n\ngenerate \n  for (int_idx = 0; int_idx < reg_width; int_idx = int_idx+1) begin : gen_rtl\n    always @(posedge clk or negedge nrst)\n      if (!nrst) begin\n        reg_synced_3[int_idx] <= reg_preset[int_idx];\n      end else if (clk_en) begin\n        if (reg_synced_2[int_idx] == reg_synced_1[int_idx])\n          reg_synced_3[int_idx] <= reg_synced_2[int_idx];\n      end\n  end\nendgenerate\n\ngenerate\n  if (resync_stages == 4)\n    assign reg_o = reg_synced_3;\n  else if (resync_stages == 3)\n    assign reg_o = reg_synced_2;\n  else if (resync_stages == 1)\n    assign reg_o = reg_synced_0;\n  else\n    assign reg_o = reg_synced_1;\nendgenerate\n\nendmodule"}
{"task_id": 412, "completion": "localparam ASYNC_RESET = (OUTPUT_RESET_SYNC_EDGES == \"deassert\");\n\n    wire merged_reset;\n\n    assign merged_reset = (  \n                              reset_in0 |  \n                              reset_in1 |  \n                              reset_in2 |  \n                              reset_in3 |  \n                              reset_in4 |  \n                              reset_in5 |  \n                              reset_in6 |  \n                              reset_in7 |  \n                              reset_in8 |  \n                              reset_in9 |  \n                              reset_in10 |  \n                              reset_in11 |  \n                              reset_in12 |  \n                              reset_in13 |  \n                              reset_in14 |  \n                              reset_in15\n                          );\n\n    generate if (OUTPUT_RESET_SYNC_EDGES == \"none\") begin\n        assign reset_out = merged_reset;\n    end else begin\n        altera_reset_synchronizer\n        #(\n            .DEPTH      (SYNC_DEPTH),\n            .ASYNC_RESET(ASYNC_RESET)\n        )\n        alt_rst_sync_uq1\n        (\n            .clk        (clk),\n            .reset_in   (merged_reset),\n            .reset_out  (reset_out)\n        );\n    end\n    endgenerate\nendmodule"}
{"task_id": 400, "completion": "output Y;\n    input  A;\n    input  VPWR;\n    input  VGND;\n    input  VPB;\n    input  VNB;\n    sky130_fd_sc_ls__clkinv base (\n        .Y(Y),\n        .A(A),\n        .VPWR(VPWR),\n        .VGND(VGND),\n        .VPB(VPB),\n        .VNB(VNB)\n    );\n\nendmodule"}
{"task_id": 251, "completion": "input  clk, reset;                                  \n    input  [31:0] inst;                                 \n    input  [31:0] Data_I;                               \n    input  ACK;                                       \n    output [31:0] pc;                                   \n    output [31:0] Addr;                                 \n    output [31:0] Data_O;                               \n    output WE;                                          \n    output STB;                                         \n    output [31: 0] debug_next_pc;                        \n    reg           wreg;                                 \n    reg           wmem, rmem;                           \n    reg    [31:0] alu_out;                              \n    reg     [4:0] dest_rn;                              \n    reg    [31:0] next_pc;                              \n    wire   [31:0] pc_plus_4 = pc + 4;                   \n    wire  [05:00] opcode = inst[31:26];                \n    wire  [04:00] rs     = inst[25:21];                \n    wire  [04:00] rt     = inst[20:16];                \n    wire  [04:00] rd     = inst[15:11];                \n    wire  [04:00] sa     = inst[10:06];                \n    wire  [05:00] func   = inst[05:00];                \n    wire  [15:00] imm    = inst[15:00];                \n    wire  [25:00] addr   = inst[25:00];                \n    wire          sign   = inst[15];                   \n    wire  [31:00] offset = {{14{sign}},imm,2'b00};     \n    wire  [31:00] j_addr = {pc_plus_4[31:28],addr,2'b00}; \n    wire i_add  = (opcode == 6'h00) & (func == 6'h20);  \n    wire i_sub  = (opcode == 6'h00) & (func == 6'h22);  \n    wire i_and  = (opcode == 6'h00) & (func == 6'h24);  \n    wire i_or   = (opcode == 6'h00) & (func == 6'h25);  \n    wire i_xor  = (opcode == 6'h00) & (func == 6'h26);  \n    wire i_sll  = (opcode == 6'h00) & (func == 6'h00);  \n    wire i_srl  = (opcode == 6'h00) & (func == 6'h02);  \n    wire i_sra  = (opcode == 6'h00) & (func == 6'h03);  \n    wire i_jr   = (opcode == 6'h00) & (func == 6'h08);  \n    wire i_addi = (opcode == 6'h08);                    \n    wire i_andi = (opcode == 6'h0c);                    \n    wire i_ori  = (opcode == 6'h0d);                    \n    wire i_xori = (opcode == 6'h0e);                    \n    wire i_lw   = (opcode == 6'h23);                    \n    wire i_sw   = (opcode == 6'h2b);                    \n    wire i_beq  = (opcode == 6'h04);                    \n    wire i_bne  = (opcode == 6'h05);                    \n    wire i_lui  = (opcode == 6'h0f);                    \n    wire i_j    = (opcode == 6'h02);                    \n    wire i_jal  = (opcode == 6'h03);                    \n    reg [31:0] pc;                                      \n    always @ (posedge clk or posedge reset) begin       \n        if (reset) pc <= 0;                            \n        else begin                                      \n            if (STB)                                   \n                pc <= ACK ? next_pc : pc;          \n            else                                       \n                pc <= next_pc;                       \n        end                                            \n    end                                                \n    wire   [31:0] data_2_rf = i_lw ? Data_I : alu_out;\n    reg    [31:0] regfile [1:31];                       \n    wire   [31:0] a = (rs==0) ? 0 : regfile[rs];      \n    wire   [31:0] b = (rt==0) ? 0 : regfile[rt];      \n    always @ (posedge clk) begin                       \n        if (wreg && (dest_rn != 0)) begin            \n            regfile[dest_rn] <= data_2_rf;          \n        end                                            \n    end                                                \n    assign WE = wmem;                                  \n    assign Data_O = b;                                 \n    assign Addr = alu_out;                             \n    assign STB = rmem | wmem;                          \n    always @(*) begin                                  \n        alu_out = 0;                                  \n        dest_rn = rd;                                 \n        wreg    = 0;                                  \n        wmem    = 0;                                  \n        rmem    = 0;                                  \n        next_pc = pc_plus_4;                         \n        case (1'b1)                                   \n            i_add: begin                              \n                alu_out = a + b;                     \n                wreg    = 1; end                       \n            i_sub: begin                              \n                alu_out = a - b;                     \n                wreg    = 1; end                       \n            i_and: begin                              \n                alu_out = a & b;                     \n                wreg    = 1; end                       \n            i_or: begin                               \n                alu_out = a | b;                     \n                wreg    = 1; end                       \n            i_xor: begin                              \n                alu_out = a ^ b;                     \n                wreg    = 1; end                       \n            i_sll: begin                              \n                alu_out = b << sa;                   \n                wreg    = 1; end                       \n            i_srl: begin                              \n                alu_out = b >> sa;                   \n                wreg    = 1; end                       \n            i_sra: begin                              \n                alu_out = $signed(b) >>> sa;        \n                wreg    = 1; end                       \n            i_jr: begin                               \n                next_pc = a; end                      \n            i_addi: begin                             \n                alu_out = a + {{16{sign}},imm};      \n                dest_rn = rt;                        \n                wreg    = 1; end                       \n            i_andi: begin                             \n                alu_out = a & {16'h0,imm};           \n                dest_rn = rt;                        \n                wreg    = 1; end                       \n            i_ori: begin                              \n                alu_out = a | {16'h0,imm};           \n                dest_rn = rt;                        \n                wreg    = 1; end                       \n            i_xori: begin                             \n                alu_out = a ^ {16'h0,imm};           \n                dest_rn = rt;                        \n                wreg    = 1; end                       \n            i_lw: begin                               \n                alu_out = a + {{16{sign}},imm};      \n                dest_rn = rt;                        \n                rmem    = 1;                          \n                wreg    = 1; end                       \n            i_sw: begin                               \n                alu_out = a + {{16{sign}},imm};      \n                wmem    = 1; end                       \n            i_beq: begin                              \n                if (a == b)                          \n                  next_pc = pc_plus_4 + offset; end \n            i_bne: begin                              \n                if (a != b)                          \n                  next_pc = pc_plus_4 + offset; end \n            i_lui: begin                              \n                alu_out = {imm,16'h0};               \n                dest_rn = rt;                        \n                wreg    = 1; end                       \n            i_j: begin                                \n                next_pc = j_addr; end                 \n            i_jal: begin                              \n                alu_out = pc_plus_4;                \n                wreg    = 1;                          \n                dest_rn = 5'd31;                     \n                next_pc = j_addr; end               \n            default: ;                                \n        endcase                                      \n        wreg = STB ? wreg & ACK : wreg;               \n    end                                             \n    assign debug_next_pc = next_pc;                  \nendmodule"}
{"task_id": 429, "completion": "wire not0_out_Y       ;\n    wire pwrgood_pp0_out_Y;\n\n    not                                not0        (not0_out_Y       , A                     );\n    sky130_fd_sc_ms__udp_pwrgood_pp$PG pwrgood_pp0 (pwrgood_pp0_out_Y, not0_out_Y, VPWR, VGND);\n    buf                                buf0        (Y                , pwrgood_pp0_out_Y     );\n\nendmodule"}
{"task_id": 422, "completion": "supply1 VPWR;    supply0 VGND;    supply1 VPB ;    supply0 VNB ;    wire nand0_out  ;    wire nand1_out_X;    nand nand0 (nand0_out  , A2, A1         );    nand nand1 (nand1_out_X, B1_N, nand0_out);    buf  buf0  (X          , nand1_out_X    );endmodule"}
{"task_id": 133, "completion": "genvar target_cnt;\n    genvar region_cnt;\n    function  decode_address;\n      input [C_ADDR_WIDTH-1:0] base, high, addr;\n      reg   [C_ADDR_WIDTH-C_RESOLUTION-1:0] mask;\n      reg   [C_ADDR_WIDTH-C_RESOLUTION-1:0] addr_page;\n      reg   [C_ADDR_WIDTH-C_RESOLUTION-1:0] base_page;\n      reg   [C_ADDR_WIDTH-C_RESOLUTION-1:0] high_page;\n    begin\n      addr_page = addr[C_RESOLUTION+:C_ADDR_WIDTH-C_RESOLUTION];\n      base_page = base[C_RESOLUTION+:C_ADDR_WIDTH-C_RESOLUTION];\n      high_page = high[C_RESOLUTION+:C_ADDR_WIDTH-C_RESOLUTION];\n      if (base[C_ADDR_WIDTH-1] & ~high[C_ADDR_WIDTH-1]) begin\n        decode_address = 1'b0;\n      end else begin\n        mask  = base_page ^ high_page;\n        if ( (base_page & ~mask) == (addr_page & ~mask) ) begin\n          decode_address = 1'b1;\n        end else begin\n          decode_address = 1'b0;\n        end\n      end\n    end\n    endfunction\n    function [3:0] f_hot2enc(input [15:0]  one_hot);\n    begin\n      f_hot2enc[0] = |(one_hot & 16'b1010101010101010);\n      f_hot2enc[1] = |(one_hot & 16'b1100110011001100);\n      f_hot2enc[2] = |(one_hot & 16'b1111000011110000);\n      f_hot2enc[3] = |(one_hot & 16'b1111111100000000);\n    end\n    endfunction\n    wire [C_NUM_TARGETS-1:0]              TARGET_HOT_I;\n    wire [C_NUM_TARGETS*C_NUM_RANGES-1:0] ADDRESS_HIT;\n    wire [C_NUM_TARGETS*C_NUM_RANGES-1:0] ADDRESS_HIT_REG;\n    wire [C_NUM_RANGES-1:0]               REGION_HOT;\n    wire [3:0]                            TARGET_ENC_I;\n    generate\n      for (target_cnt = 0; target_cnt < C_NUM_TARGETS; target_cnt = target_cnt + 1) begin : gen_target\n        for (region_cnt = 0; region_cnt < C_NUM_RANGES; region_cnt = region_cnt + 1) begin : gen_region\n          if ((C_ADDR_WIDTH - C_RESOLUTION) > C_COMPARATOR_THRESHOLD) begin : gen_comparator_static\n            if (C_TARGET_QUAL[target_cnt] &&\n                ((C_BASE_ADDR[(target_cnt*C_NUM_RANGES+region_cnt)*64 +: C_ADDR_WIDTH] == 0) ||\n                 (C_HIGH_ADDR[(target_cnt*C_NUM_RANGES+region_cnt)*64 +: C_ADDR_WIDTH] != 0))) begin : gen_addr_range\n              generic_baseblocks_v2_1_comparator_static #\n              (\n              .C_FAMILY(\"rtl\"),\n              .C_VALUE(C_BASE_ADDR[(target_cnt*C_NUM_RANGES+region_cnt)*64+C_RESOLUTION +: C_ADDR_WIDTH-C_RESOLUTION]),\n              .C_DATA_WIDTH(C_ADDR_WIDTH-C_RESOLUTION)\n              ) addr_decode_comparator\n              (\n              .CIN(1'b1),\n              .A(ADDR[C_RESOLUTION +: C_ADDR_WIDTH-C_RESOLUTION] &\n                ~(C_BASE_ADDR[(target_cnt*C_NUM_RANGES+region_cnt)*64+C_RESOLUTION +: C_ADDR_WIDTH-C_RESOLUTION] ^\n                  C_HIGH_ADDR[(target_cnt*C_NUM_RANGES+region_cnt)*64+C_RESOLUTION +: C_ADDR_WIDTH-C_RESOLUTION)),\n              .COUT(ADDRESS_HIT[target_cnt*C_NUM_RANGES + region_cnt])\n              );\n            end else begin : gen_null_range\n              assign ADDRESS_HIT[target_cnt*C_NUM_RANGES + region_cnt] = 1'b0;\n            end\n          end else begin : gen_no_comparator_static\n            assign ADDRESS_HIT[target_cnt*C_NUM_RANGES + region_cnt] = C_TARGET_QUAL[target_cnt] ? \n                                    decode_address(\n                                      C_BASE_ADDR[(target_cnt*C_NUM_RANGES+region_cnt)*64 +: C_ADDR_WIDTH],\n                                      C_HIGH_ADDR[(target_cnt*C_NUM_RANGES+region_cnt)*64 +: C_ADDR_WIDTH],\n                                      ADDR)\n                                    : 1'b0;\n          end\n          assign ADDRESS_HIT_REG[region_cnt*C_NUM_TARGETS+target_cnt] = ADDRESS_HIT[target_cnt*C_NUM_RANGES + region_cnt];\n          assign REGION_HOT[region_cnt] = | ADDRESS_HIT_REG[region_cnt*C_NUM_TARGETS +: C_NUM_TARGETS];\n        end\n        assign TARGET_HOT_I[target_cnt]  = | ADDRESS_HIT[target_cnt*C_NUM_RANGES +: C_NUM_RANGES];\n      end\n    endgenerate\n    assign MATCH = | TARGET_HOT_I;\n    generate\n      if (C_TARGET_HOT == 1) begin : USE_TARGET_ONEHOT\n        assign TARGET_HOT = MATCH ? TARGET_HOT_I : 1;\n      end else begin : NO_TARGET_ONEHOT\n        assign TARGET_HOT = {C_NUM_TARGETS{1'b0}};\n      end\n    endgenerate\n    generate\n      if (C_TARGET_ENC == 1) begin : USE_TARGET_ENCODED\n        assign TARGET_ENC_I = f_hot2enc(TARGET_HOT_I);\n        assign TARGET_ENC   = TARGET_ENC_I[C_NUM_TARGETS_LOG-1:0];\n      end else begin : NO_TARGET_ENCODED\n        assign TARGET_ENC = {C_NUM_TARGETS_LOG{1'b0}};\n      end\n    endgenerate\n    generate\n      if (C_TARGET_ENC == 1) begin : USE_REGION_ENCODED\n        assign REGION = f_hot2enc(REGION_HOT);\n      end else begin : NO_REGION_ENCODED\n        assign REGION = 4'b0;\n      end\n    endgenerate\nendmodule"}
{"task_id": 311, "completion": "wire [3:0] col;\n    wire top_col;\n    wire [3:0] n_ascci;\n    wire top_ascci;\n    wire add_ascci;\n    wire reset_ascci;\n    wire add_col;\n    wire reset_col;\n    wire add_dirram;\n    wire reset_dirram;\n    wire leer_rom;\n    wire leer_ram;\n    wire [6:0] ascci;\n    wire [10:0] dir_rom;\n    wire wram;\n    wire [15:0] datorom;\n    wire [10:0] dir_in;\n    wire [7:0] d_ram;\n    wire [7:0] dir_ram;\n    wire done;\n\n    select_dir seldir(.clk(clk),.d_ram(d_ram),.dir_ram(dir_ram),.dir(dir),.leer_ram(leer_ram) );\n    comp_col comcol(.col(col),.top_col(top_col));\n    compn_ascci camasc (.n_ascci(n_ascci),.top_ascci(top_ascci));\n    cont_ascci aonasc (.n_ascci(n_ascci),.clk(clk),.add_ascci(add_ascci),.reset_ascci(reset_ascci));\n    cont_col aoncol(.clk(clk),.add_col(add_col),.reset_col(reset_col),.col(col));\n    cont_ram conra (.clk(clk),.add_dirram(add_dirram),.reset_dirram(reset_dirram),.dir_ram(dir_ram));\n    control_ascci contrascc (.clk(clk),.top_ascci(top_ascci),.top_col(top_col),.add_dirram(add_dirram),.reset_dirram(reset_dirram),.add_col(add_col),.reset_col(reset_col),.add_ascci(add_ascci),.reset_ascci(reset_ascci),.leer_rom(leer_rom),.leer_ram(leer_ram),.new_string(new_string),.init(init),.done(done),.run_efect(run_efect));\n    dir_ascci dirasc (.dir_in(dir_in),.clk(clk),.dir_rom(dir_rom),.col(col),.done(done));\n    m_plexor mplex(.string(string),.n_ascci(n_ascci),.ascci(ascci),.efect(efect) );\n    ram ra (.clk(clk),.direccionram(d_ram),.wram(leer_ram),.datorom(datorom),.datoram(datoram));\n    rom ro (.clk(clk),.leer_rom(leer_rom),.dir_rom(dir_rom),.dato_rom(datorom));\n    top_multiplicador mult(.clk(clk),.init(init),.A(ascci),.pp(dir_in), .done(done));\nendmodule"}
{"task_id": 261, "completion": "output wire val_r_ap_vld; input wire ap_clk; input wire ap_rst_n; input wire ap_start; output wire ap_done; output wire ap_idle; output wire ap_ready; output wire [31 : 0] ap_return; output wire [31 : 0] m_axi_gmem_AWADDR; output wire [7 : 0] m_axi_gmem_AWLEN; output wire [2 : 0] m_axi_gmem_AWSIZE; output wire [1 : 0] m_axi_gmem_AWBURST; output wire [1 : 0] m_axi_gmem_AWLOCK; output wire [3 : 0] m_axi_gmem_AWREGION; output wire [3 : 0] m_axi_gmem_AWCACHE; output wire [2 : 0] m_axi_gmem_AWPROT; output wire [3 : 0] m_axi_gmem_AWQOS; output wire m_axi_gmem_AWVALID; input wire m_axi_gmem_AWREADY; output wire [31 : 0] m_axi_gmem_WDATA; output wire [3 : 0] m_axi_gmem_WSTRB; output wire m_axi_gmem_WLAST; output wire m_axi_gmem_WVALID; input wire m_axi_gmem_WREADY; input wire [1 : 0] m_axi_gmem_BRESP; input wire m_axi_gmem_BVALID; output wire m_axi_gmem_BREADY; output wire [31 : 0] m_axi_gmem_ARADDR; output wire [7 : 0] m_axi_gmem_ARLEN; output wire [2 : 0] m_axi_gmem_ARSIZE; output wire [1 : 0] m_axi_gmem_ARBURST; output wire [1 : 0] m_axi_gmem_ARLOCK; output wire [3 : 0] m_axi_gmem_ARREGION; output wire [3 : 0] m_axi_gmem_ARCACHE; output wire [2 : 0] m_axi_gmem_ARPROT; output wire [3 : 0] m_axi_gmem_ARQOS; output wire m_axi_gmem_ARVALID; input wire m_axi_gmem_ARREADY; input wire [31 : 0] m_axi_gmem_RDATA; input wire [1 : 0] m_axi_gmem_RRESP; input wire m_axi_gmem_RLAST; input wire m_axi_gmem_RVALID; output wire m_axi_gmem_RREADY; input wire [31 : 0] data; input wire [31 : 0] key; output wire [31 : 0] val_r; get #( .C_M_AXI_GMEM_ID_WIDTH(1), .C_M_AXI_GMEM_ADDR_WIDTH(32), .C_M_AXI_GMEM_DATA_WIDTH(32), .C_M_AXI_GMEM_AWUSER_WIDTH(1), .C_M_AXI_GMEM_ARUSER_WIDTH(1), .C_M_AXI_GMEM_WUSER_WIDTH(1), .C_M_AXI_GMEM_RUSER_WIDTH(1), .C_M_AXI_GMEM_BUSER_WIDTH(1), .C_M_AXI_GMEM_USER_VALUE('H00000000), .C_M_AXI_GMEM_PROT_VALUE('B000), .C_M_AXI_GMEM_CACHE_VALUE('B0011) ) inst ( .val_r_ap_vld(val_r_ap_vld), .ap_clk(ap_clk), .ap_rst_n(ap_rst_n), .ap_start(ap_start), .ap_done(ap_done), .ap_idle(ap_idle), .ap_ready(ap_ready), .ap_return(ap_return), .m_axi_gmem_AWID(), .m_axi_gmem_AWADDR(m_axi_gmem_AWADDR), .m_axi_gmem_AWLEN(m_axi_gmem_AWLEN), .m_axi_gmem_AWSIZE(m_axi_gmem_AWSIZE), .m_axi_gmem_AWBURST(m_axi_gmem_AWBURST), .m_axi_gmem_AWLOCK(m_axi_gmem_AWLOCK), .m_axi_gmem_AWREGION(m_axi_gmem_AWREGION), .m_axi_gmem_AWCACHE(m_axi_gmem_AWCACHE), .m_axi_gmem_AWPROT(m_axi_gmem_AWPROT), .m_axi_gmem_AWQOS(m_axi_gmem_AWQOS), .m_axi_gmem_AWUSER(), .m_axi_gmem_AWVALID(m_axi_gmem_AWVALID), .m_axi_gmem_AWREADY(m_axi_gmem_AWREADY), .m_axi_gmem_WID(), .m_axi_gmem_WDATA(m_axi_gmem_WDATA), .m_axi_gmem_WSTRB(m_axi_gmem_WSTRB), .m_axi_gmem_WLAST(m_axi_gmem_WLAST), .m_axi_gmem_WUSER(), .m_axi_gmem_WVALID(m_axi_gmem_WVALID), .m_axi_gmem_WREADY(m_axi_gmem_WREADY), .m_axi_gmem_BID(1'B0), .m_axi_gmem_BRESP(m_axi_gmem_BRESP), .m_axi_gmem_BUSER(1'B0), .m_axi_gmem_BVALID(m_axi_gmem_BVALID), .m_axi_gmem_BREADY(m_axi_gmem_BREADY), .m_axi_gmem_ARID(), .m_axi_gmem_ARADDR(m_axi_gmem_ARADDR), .m_axi_gmem_ARLEN(m_axi_gmem_ARLEN), .m_axi_gmem_ARSIZE(m_axi_gmem_ARSIZE), .m_axi_gmem_ARBURST(m_axi_gmem_ARBURST), .m_axi_gmem_ARLOCK(m_axi_gmem_ARLOCK), .m_axi_gmem_ARREGION(m_axi_gmem_ARREGION), .m_axi_gmem_ARCACHE(m_axi_gmem_ARCACHE), .m_axi_gmem_ARPROT(m_axi_gmem_ARPROT), .m_axi_gmem_ARQOS(m_axi_gmem_ARQOS), .m_axi_gmem_ARUSER(), .m_axi_gmem_ARVALID(m_axi_gmem_ARVALID), .m_axi_gmem_ARREADY(m_axi_gmem_ARREADY), .m_axi_gmem_RID(1'B0), .m_axi_gmem_RDATA(m_axi_gmem_RDATA), .m_axi_gmem_RRESP(m_axi_gmem_RRESP), .m_axi_gmem_RLAST(m_axi_gmem_RLAST), .m_axi_gmem_RUSER(1'B0), .m_axi_gmem_RVALID(m_axi_gmem_RVALID), .m_axi_gmem_RREADY(m_axi_gmem_RREADY), .data(data), .key(key), .val_r(val_r) ); endmodule"}
{"task_id": 427, "completion": "output Y    ;    input  A    ;    input  KAPWR;    input  VPWR ;    input  VGND ;    input  VPB  ;    input  VNB  ;    sky130_fd_sc_hd__lpflow_clkinvkapwr base (        .Y(Y),        .A(A),        .KAPWR(KAPWR),        .VPWR(VPWR),        .VGND(VGND),        .VPB(VPB),        .VNB(VNB)    );endmodule\n\n    output Y;\n    input  A;\n\n    supply1 KAPWR;\n    supply1 VPWR ;\n    supply0 VGND ;\n    supply1 VPB  ;\n    supply0 VNB  ;\n\n    sky130_fd_sc_hd__lpflow_clkinvkapwr base (        .Y(Y),        .A(A)    );\nendmodule"}
{"task_id": 264, "completion": "FIFO_GENERATOR_V9_3 #(    .C_ADD_NGC_CONSTRAINT(0),    .C_APPLICATION_TYPE_AXIS(0),    .C_APPLICATION_TYPE_RACH(0),    .C_APPLICATION_TYPE_RDCH(0),    .C_APPLICATION_TYPE_WACH(0),    .C_APPLICATION_TYPE_WRCH(0),    .C_AXI_ADDR_WIDTH(32),    .C_AXI_ARUSER_WIDTH(1),    .C_AXI_AWUSER_WIDTH(1),    .C_AXI_BUSER_WIDTH(1),    .C_AXI_DATA_WIDTH(64),    .C_AXI_ID_WIDTH(4),    .C_AXI_RUSER_WIDTH(1),    .C_AXI_TYPE(0),    .C_AXIS_TDATA_WIDTH(64),    .C_AXIS_TDEST_WIDTH(4),    .C_AXIS_TID_WIDTH(8),    .C_AXIS_TKEEP_WIDTH(4),    .C_AXIS_TSTRB_WIDTH(4),    .C_AXIS_TUSER_WIDTH(4),    .C_AXIS_TYPE(0),    .C_COMMON_CLOCK(1),    .C_COUNT_TYPE(0),    .C_DATA_COUNT_WIDTH(9),    .C_DEFAULT_VALUE(\"BlankString\"),    .C_DIN_WIDTH(72),    .C_DIN_WIDTH_AXIS(1),    .C_DIN_WIDTH_RACH(32),    .C_DIN_WIDTH_RDCH(64),    .C_DIN_WIDTH_WACH(32),    .C_DIN_WIDTH_WDCH(64),    .C_DIN_WIDTH_WRCH(2),    .C_DOUT_RST_VAL(\"0\"),    .C_DOUT_WIDTH(72),    .C_ENABLE_RLOCS(0),    .C_ENABLE_RST_SYNC(1),    .C_ERROR_INJECTION_TYPE(0),    .C_ERROR_INJECTION_TYPE_AXIS(0),    .C_ERROR_INJECTION_TYPE_RACH(0),    .C_ERROR_INJECTION_TYPE_RDCH(0),    .C_ERROR_INJECTION_TYPE_WACH(0),    .C_ERROR_INJECTION_TYPE_WDCH(0),    .C_ERROR_INJECTION_TYPE_WRCH(0),    .C_FAMILY(\"kintex7\"),    .C_FULL_FLAGS_RST_VAL(0),    .C_HAS_ALMOST_EMPTY(0),    .C_HAS_ALMOST_FULL(0),    .C_HAS_AXI_ARUSER(0),    .C_HAS_AXI_AWUSER(0),    .C_HAS_AXI_BUSER(0),    .C_HAS_AXI_RD_CHANNEL(0),    .C_HAS_AXI_RUSER(0),    .C_HAS_AXI_WR_CHANNEL(0),    .C_HAS_AXI_WUSER(0),    .C_HAS_AXIS_TDATA(0),    .C_HAS_AXIS_TDEST(0),    .C_HAS_AXIS_TID(0),    .C_HAS_AXIS_TKEEP(0),    .C_HAS_AXIS_TLAST(0),    .C_HAS_AXIS_TREADY(1),    .C_HAS_AXIS_TSTRB(0),    .C_HAS_AXIS_TUSER(0),    .C_HAS_BACKUP(0),    .C_HAS_DATA_COUNT(0),    .C_HAS_DATA_COUNTS_AXIS(0),    .C_HAS_DATA_COUNTS_RACH(0),    .C_HAS_DATA_COUNTS_RDCH(0),    .C_HAS_DATA_COUNTS_WACH(0),    .C_HAS_DATA_COUNTS_WDCH(0),    .C_HAS_DATA_COUNTS_WRCH(0),    .C_HAS_INT_CLK(0),    .C_HAS_MASTER_CE(0),    .C_HAS_MEMINIT_FILE(0),    .C_HAS_OVERFLOW(0),    .C_HAS_PROG_FLAGS_AXIS(0),    .C_HAS_PROG_FLAGS_RACH(0),    .C_HAS_PROG_FLAGS_RDCH(0),    .C_HAS_PROG_FLAGS_WACH(0),    .C_HAS_PROG_FLAGS_WDCH(0),    .C_HAS_PROG_FLAGS_WRCH(0),    .C_HAS_RD_DATA_COUNT(0),    .C_HAS_RD_RST(0),    .C_HAS_RST(1),    .C_HAS_SLAVE_CE(0),    .C_HAS_SRST(0),    .C_HAS_UNDERFLOW(0),    .C_HAS_VALID(0),    .C_HAS_WR_ACK(0),    .C_HAS_WR_DATA_COUNT(0),    .C_HAS_WR_RST(0),    .C_IMPLEMENTATION_TYPE(6),    .C_IMPLEMENTATION_TYPE_AXIS(1),    .C_IMPLEMENTATION_TYPE_RACH(1),    .C_IMPLEMENTATION_TYPE_RDCH(1),    .C_IMPLEMENTATION_TYPE_WACH(1),    .C_IMPLEMENTATION_TYPE_WRCH(1),    .C_INIT_WR_PNTR_VAL(0),    .C_INTERFACE_TYPE(0),    .C_MEMORY_TYPE(4),    .C_MIF_FILE_NAME(\"BlankString\"),    .C_MSGON_VAL(1),    .C_OPTIMIZATION_MODE(0),    .C_OVERFLOW_LOW(0),    .C_PRELOAD_LATENCY(1),    .C_PRELOAD_REGS(0),    .C_PRIM_FIFO_TYPE(\"512x72\"),    .C_PROG_EMPTY_THRESH_ASSERT_VAL(2),    .C_PROG_EMPTY_THRESH_ASSERT_VAL_AXIS(1022),    .C_PROG_EMPTY_THRESH_ASSERT_VAL_RACH(1022),    .C_PROG_EMPTY_THRESH_ASSERT_VAL_RDCH(1022),    .C_PROG_EMPTY_THRESH_ASSERT_VAL_WACH(1022),    .C_PROG_EMPTY_THRESH_ASSERT_VAL_WDCH(1022),    .C_PROG_EMPTY_THRESH_NEGATE_VAL(3),    .C_PROG_EMPTY_TYPE(0),    .C_PROG_EMPTY_TYPE_AXIS(0),    .C_PROG_EMPTY_TYPE_RACH(0),    .C_PROG_EMPTY_TYPE_RDCH(0),    .C_PROG_EMPTY_TYPE_WACH(0),    .C_PROG_EMPTY_TYPE_WDCH(0),    .C_PROG_FULL_THRESH_ASSERT_VAL(128),    .C_PROG_FULL_THRESH_ASSERT_VAL_AXIS(1023),    .C_PROG_FULL_THRESH_ASSERT_VAL_RACH(1023),    .C_PROG_FULL_THRESH_ASSERT_VAL_RDCH(1023),    .C_PROG_FULL_THRESH_ASSERT_VAL_WACH(1023),    .C_PROG_FULL_THRESH_ASSERT_VAL_WDCH(1023),    .C_PROG_FULL_THRESH_NEGATE_VAL(127),    .C_PROG_FULL_TYPE(1),    .C_PROG_FULL_TYPE_AXIS(0),    .C_PROG_FULL_TYPE_RACH(0),    .C_PROG_FULL_TYPE_RDCH(0),    .C_PROG_FULL_TYPE_WACH(0),    .C_PROG_FULL_TYPE_WDCH(0),    .C_RACH_TYPE(0),    .C_RD_DATA_COUNT_WIDTH(9),    .C_RD_DEPTH(512),    .C_RD_FREQ(1),    .C_RD_PNTR_WIDTH(9),    .C_RDCH_TYPE(0),    .C_REG_SLICE_MODE_AXIS(0),    .C_REG_SLICE_MODE_RACH(0),    .C_REG_SLICE_MODE_RDCH(0),    .C_REG_SLICE_MODE_WACH(0),    .C_REG_SLICE_MODE_WDCH(0),    .C_REG_SLICE_MODE_WRCH(0),    .C_SYNCHRONIZER_STAGE(2),    .C_UNDERFLOW_LOW(0),    .C_USE_COMMON_OVERFLOW(0),    .C_USE_COMMON_UNDERFLOW(0),    .C_USE_DEFAULT_SETTINGS(0),    .C_USE_DOUT_RST(0),    .C_USE_ECC(0),    .C_USE_ECC_AXIS(0),    .C_USE_ECC_RACH(0),    .C_USE_ECC_RDCH(0),    .C_USE_ECC_WACH(0),    .C_USE_ECC_WDCH(0),    .C_USE_ECC_WRCH(0),    .C_USE_EMBEDDED_REG(0),    .C_USE_FIFO16_FLAGS(0),    .C_USE_FWFT_DATA_COUNT(0),    .C_VALID_LOW(0),    .C_WACH_TYPE(0),    .C_WDCH_TYPE(0),    .C_WR_ACK_LOW(0),    .C_WR_DATA_COUNT_WIDTH(9),    .C_WR_DEPTH(512),    .C_WR_DEPTH_AXIS(1024),    .C_WR_DEPTH_RACH(16),    .C_WR_DEPTH_RDCH(1024),    .C_WR_DEPTH_WACH(16),    .C_WR_DEPTH_WDCH(1024),    .C_WR_DEPTH_WRCH(16),    .C_WR_FREQ(1),    .C_WR_PNTR_WIDTH(9),    .C_WR_PNTR_WIDTH_AXIS(10),    .C_WR_PNTR_WIDTH_RACH(4),    .C_WR_PNTR_WIDTH_RDCH(10),    .C_WR_PNTR_WIDTH_WACH(4),    .C_WR_PNTR_WIDTH_WDCH(10),    .C_WR_PNTR_WIDTH_WRCH(4),    .C_WR_RESPONSE_LATENCY(1),    .C_WRCH_TYPE(0)  )  inst (    .CLK(clk),    .RST(rst),    .DIN(din),    .WR_EN(wr_en),    .RD_EN(rd_en),    .DOUT(dout),    .FULL(full),    .EMPTY(empty),    .PROG_FULL(prog_full),    .BACKUP(),    .BACKUP_MARKER(),    .SRST(),    .WR_CLK(),    .WR_RST(),    .RD_CLK(),    .RD_RST(),    .PROG_EMPTY_THRESH(),    .PROG_EMPTY_THRESH_ASSERT(),    .PROG_EMPTY_THRESH_NEGATE(),    .PROG_FULL_THRESH(),    .PROG_FULL_THRESH_ASSERT(),    .PROG_FULL_THRESH_NEGATE(),    .INT_CLK(),    .INJECTDBITERR(),    .INJECTSBITERR(),    .ALMOST_FULL(),    .WR_ACK(),    .OVERFLOW(),    .ALMOST_EMPTY(),    .VALID(),    .UNDERFLOW(),    .DATA_COUNT(),    .RD_DATA_COUNT(),    .WR_DATA_COUNT(),    .PROG_EMPTY(),    .SBITERR(),    .DBITERR(),    .M_ACLK(),    .S_ACLK(),    .S_ARESETN(),    .M_ACLK_EN(),    .S_ACLK_EN(),    .S_AXI_AWID(),    .S_AXI_AWADDR(),    .S_AXI_AWLEN(),    .S_AXI_AWSIZE(),    .S_AXI_AWBURST(),    .S_AXI_AWLOCK(),    .S_AXI_AWCACHE(),    .S_AXI_AWPROT(),    .S_AXI_AWQOS(),    .S_AXI_AWREGION(),    .S_AXI_AWUSER(),    .S_AXI_AWVALID(),    .S_AXI_AWREADY(),    .S_AXI_WID(),    .S_AXI_WDATA(),    .S_AXI_WSTRB(),    .S_AXI_WLAST(),    .S_AXI_WUSER(),    .S_AXI_WVALID(),    .S_AXI_WREADY(),    .S_AXI_BID(),    .S_AXI_BRESP(),    .S_AXI_BUSER(),    .S_AXI_BVALID(),    .S_AXI_BREADY(),    .M_AXI_AWID(),    .M_AXI_AWADDR(),    .M_AXI_AWLEN(),    .M_AXI_AWSIZE(),    .M_AXI_AWBURST(),    .M_AXI_AWLOCK(),    .M_AXI_AWCACHE(),    .M_AXI_AWPROT(),    .M_AXI_AWQOS(),    .M_AXI_AWREGION(),    .M_AXI_AWUSER(),    .M_AXI_AWVALID(),    .M_AXI_AWREADY(),    .M_AXI_WID(),    .M_AXI_WDATA(),    .M_AXI_WSTRB(),    .M_AXI_WLAST(),    .M_AXI_WUSER(),    .M_AXI_WVALID(),    .M_AXI_WREADY(),    .M_AXI_BID(),    .M_AXI_BRESP(),    .M_AXI_BUSER(),    .M_AXI_BVALID(),    .M_AXI_BREADY(),    .S_AXI_ARID(),    .S_AXI_ARADDR(),    .S_AXI_ARLEN(),    .S_AXI_ARSIZE(),    .S_AXI_ARBURST(),    .S_AXI_ARLOCK(),    .S_AXI_ARCACHE(),    .S_AXI_ARPROT(),    .S_AXI_ARQOS(),    .S_AXI_ARREGION(),    .S_AXI_ARUSER(),    .S_AXI_ARVALID(),    .S_AXI_ARREADY(),    .S_AXI_RID(),    .S_AXI_RDATA(),    .S_AXI_RRESP(),    .S_AXI_RLAST(),    .S_AXI_RUSER(),    .S_AXI_RVALID(),    .S_AXI_RREADY(),    .M_AXI_ARID(),    .M_AXI_ARADDR(),    .M_AXI_ARLEN(),    .M_AXI_ARSIZE(),    .M_AXI_ARBURST(),    .M_AXI_ARLOCK(),    .M_AXI_ARCACHE(),    .M_AXI_ARPROT(),    .M_AXI_ARQOS(),    .M_AXI_ARREGION(),    .M_AXI_ARUSER(),    .M_AXI_ARVALID(),    .M_AXI_ARREADY(),    .M_AXI_RID(),    .M_AXI_RDATA(),    .M_AXI_RRESP(),    .M_AXI_RLAST(),    .M_AXI_RUSER(),    .M_AXI_RVALID(),    .M_AXI_RREADY(),    .S_AXIS_TVALID(),    .S_AXIS_TREADY(),    .S_AXIS_TDATA(),    .S_AXIS_TSTRB(),    .S_AXIS_TKEEP(),    .S_AXIS_TLAST(),    .S_AXIS_TID(),    .S_AXIS_TDEST(),    .S_AXIS_TUSER(),    .M_AXIS_TVALID(),    .M_AXIS_TREADY(),    .M_AXIS_TDATA(),    .M_AXIS_TSTRB(),    .M_AXIS_TKEEP(),    .M_AXIS_TLAST(),    .M_AXIS_TID(),    .M_AXIS_TDEST(),    .M_AXIS_TUSER(),    .AXI_AW_INJECTSBITERR(),    .AXI_AW_INJECTDBITERR(),    .AXI_AW_PROG_FULL_THRESH(),    .AXI_AW_PROG_EMPTY_THRESH(),    .AXI_AW_DATA_COUNT(),    .AXI_AW_WR_DATA_COUNT(),    .AXI_AW_RD_DATA_COUNT(),    .AXI_AW_SBITERR(),    .AXI_AW_DBITERR(),    .AXI_AW_OVERFLOW(),    .AXI_AW_UNDERFLOW(),    .AXI_AW_PROG_FULL(),    .AXI_AW_PROG_EMPTY(),    .AXI_W_INJECTSBITERR(),    .AXI_W_INJECTDBITERR(),    .AXI_W_PROG_FULL_THRESH(),    .AXI_W_PROG_EMPTY_THRESH(),    .AXI_W_DATA_COUNT(),    .AXI_W_WR_DATA_COUNT(),    .AXI_W_RD_DATA_COUNT(),    .AXI_W_SBITERR(),    .AXI_W_DBITERR(),    .AXI_W_OVERFLOW(),    .AXI_W_UNDERFLOW(),    .AXI_B_INJECTSBITERR(),    .AXI_W_PROG_FULL(),    .AXI_W_PROG_EMPTY(),    .AXI_B_INJECTDBITERR(),    .AXI_B_PROG_FULL_THRESH(),    .AXI_B_PROG_EMPTY_THRESH(),    .AXI_B_DATA_COUNT(),    .AXI_B_WR_DATA_COUNT(),    .AXI_B_RD_DATA_COUNT(),    .AXI_B_SBITERR(),    .AXI_B_DBITERR(),    .AXI_B_OVERFLOW(),    .AXI_B_UNDERFLOW(),    .AXI_AR_INJECTSBITERR(),    .AXI_B_PROG_FULL(),    .AXI_B_PROG_EMPTY(),    .AXI_AR_INJECTDBITERR(),    .AXI_AR_PROG_FULL_THRESH(),    .AXI_AR_PROG_EMPTY_THRESH(),    .AXI_AR_DATA_COUNT(),    .AXI_AR_WR_DATA_COUNT(),    .AXI_AR_RD_DATA_COUNT(),    .AXI_AR_SBITERR(),    .AXI_AR_DBITERR(),    .AXI_AR_OVERFLOW(),    .AXI_AR_UNDERFLOW(),    .AXI_AR_PROG_FULL(),    .AXI_AR_PROG_EMPTY(),    .AXI_R_INJECTSBITERR(),    .AXI_R_INJECTDBITERR(),    .AXI_R_PROG_FULL_THRESH(),    .AXI_R_PROG_EMPTY_THRESH(),    .AXI_R_DATA_COUNT(),    .AXI_R_WR_DATA_COUNT(),    .AXI_R_RD_DATA_COUNT(),    .AXI_R_SBITERR(),    .AXI_R_DBITERR(),    .AXI_R_OVERFLOW(),    .AXI_R_UNDERFLOW(),    .AXIS_INJECTSBITERR(),    .AXI_R_PROG_FULL(),    .AXI_R_PROG_EMPTY(),    .AXIS_INJECTDBITERR(),    .AXIS_PROG_FULL_THRESH(),    .AXIS_PROG_EMPTY_THRESH(),    .AXIS_DATA_COUNT(),    .AXIS_WR_DATA_COUNT(),    .AXIS_RD_DATA_COUNT(),    .AXIS_SBITERR(),    .AXIS_DBITERR(),    .AXIS_OVERFLOW(),    .AXIS_UNDERFLOW(),    .AXIS_PROG_FULL(),    .AXIS_PROG_EMPTY()  );  endmodule"}
{"task_id": 435, "completion": "wire and0_out_X;    wire pwrgood_pp0_out_X;    and and0 (and0_out_X, C, A, B);    sky130_fd_sc_lp__udp_pwrgood_pp$PG pwrgood_pp0 (pwrgood_pp0_out_X, and0_out_X, VPWR, VGND);    buf buf0 (X, pwrgood_pp0_out_X);    endmodule"}
{"task_id": 25, "completion": "always @(*)\n\t    begin\n\t    case (Cuenta)\n\t\t    6'd0: begin\n\t\t\t           catodo1 <= 8'b00000011;\n\t\t\t\t\t\t\tcatodo2 <= 8'b00000011;\n\t\t\t\t\t\t\tcatodo3 <= 8'b00000011;\n\t\t\t\t\t\t\tcatodo4 <= 8'b00000011;\n\t\t\t        end \n\t\t 6'd1: begin\n\t\t\t\t\t\tcatodo1 <= 8'b10011111;\n\t\t\t\t\t\tcatodo2 <= 8'b00000011;\n\t\t\t\t\t\tcatodo3 <= 8'b00000011;\n\t\t\t\t\t\tcatodo4 <= 8'b00000011; \n\t\t\t        end \n\t\t 6'd2: begin\n\t\t\t\t\t\tcatodo1 <= 8'b00100101;\n\t\t\t\t\t\tcatodo2 <= 8'b00000011;\n\t\t\t\t\t\tcatodo3 <= 8'b00000011;\n\t\t\t\t\t\tcatodo4 <= 8'b00000011;\n\t\t\t        end \n\t\t 6'd3: begin\n\t\t\t\t\t\tcatodo1 <= 8'b00001101;\n\t\t\t\t\t\tcatodo2 <= 8'b00000011;\n\t\t\t\t\t\tcatodo3 <= 8'b00000011;\n\t\t\t\t\t\tcatodo4 <= 8'b00000011;\n\t\t\t        end \n\t\t 6'd4: begin\n\t\t\t\t\t\tcatodo1 <= 8'b10011001;\n\t\t\t\t\t\tcatodo2 <= 8'b00000011;\n\t\t\t\t\t\tcatodo3 <= 8'b00000011;\n\t\t\t\t\t\tcatodo4 <= 8'b00000011;\n\t\t\t        end \n\t\t 6'd5: begin\n\t\t\t\t\t\tcatodo1 <= 8'b01001001;\n\t\t\t\t\t\tcatodo2 <= 8'b00000011;\n\t\t\t\t\t\tcatodo3 <= 8'b00000011;\n\t\t\t\t\t\tcatodo4 <= 8'b00000011;\n\t\t\t        end \n\t\t 6'd6: begin\n\t\t\t\t\t\tcatodo1 <= 8'b01000001;\n\t\t\t\t\t\tcatodo2 <= 8'b00000011;\n\t\t\t\t\t\tcatodo3 <= 8'b00000011;\n\t\t\t\t\t\tcatodo4 <= 8'b00000011;\n\t\t\t        end \n\t\t 6'd7: begin\n\t\t\t\t\t\tcatodo1 <= 8'b00011111;\n\t\t\t\t\t\tcatodo2 <= 8'b00000011;\n\t\t\t\t\t\tcatodo3 <= 8'b00000011;\n\t\t\t\t\t\tcatodo4 <= 8'b00000011;\n\t\t\t        end \n\t\t 6'd8: begin\n\t\t\t\t\t\tcatodo1 <= 8'b00000001;\n\t\t\t\t\t\tcatodo2 <= 8'b00000011;\n\t\t\t\t\t\tcatodo3 <= 8'b00000011;\n\t\t\t\t\t\tcatodo4 <= 8'b00000011;\n\t\t\t        end \n\t\t 6'd9: begin\n\t\t\t\t\t\tcatodo1 <= 8'b00011001;\n\t\t\t\t\t\tcatodo2 <= 8'b00000011;\n\t\t\t\t\t\tcatodo3 <= 8'b00000011;\n\t\t\t\t\t\tcatodo4 <= 8'b00000011;\n\t\t\t        end \n\t\t 6'd10: begin\n\t\t\t\t\t\tcatodo1 <= 8'b00000011;\n\t\t\t\t\t\tcatodo2 <= 8'b10011111;\n\t\t\t\t\t\tcatodo3 <= 8'b00000011;\n\t\t\t\t\t\tcatodo4 <= 8'b00000011;\n\t\t\t        end \n\t\t 6'd11: begin\n\t\t\t\t\t\tcatodo1 <= 8'b10011111;\n\t\t\t\t\t\tcatodo2 <= 8'b10011111;\n\t\t\t\t\t\tcatodo3 <= 8'b00000011;\n\t\t\t\t\t\tcatodo4 <= 8'b00000011;\n\t\t\t        end \n\t\t 6'd12: begin\n\t\t\t\t\t\tcatodo1 <= 8'b00100101;\n\t\t\t\t\t\tcatodo2 <= 8'b10011111;\n\t\t\t\t\t\tcatodo3 <= 8'b00000011;\n\t\t\t\t\t\tcatodo4 <= 8'b00000011;\n\t\t\t        end \n\t\t 6'd13: begin\n\t\t\t\t\t\tcatodo1 <= 8'b00001101;\n\t\t\t\t\t\tcatodo2 <= 8'b10011111;\n\t\t\t\t\t\tcatodo3 <= 8'b00000011;\n\t\t\t\t\t\tcatodo4 <= 8'b00000011;\n\t\t\t        end \n\t\t 6'd14: begin\n\t\t\t\t\t\tcatodo1 <= 8'b10011001;\n\t\t\t\t\t\tcatodo2 <= 8'b10011111;\n\t\t\t\t\t\tcatodo3 <= 8'b00000011;\n\t\t\t\t\t\tcatodo4 <= 8'b00000011;\n\t\t\t        end \n\t\t 6'd15: begin\n\t\t\t\t\t\tcatodo1 <= 8'b01001001;\n\t\t\t\t\t\tcatodo2 <= 8'b10011111;\n\t\t\t\t\t\tcatodo3 <= 8'b00000011;\n\t\t\t\t\t\tcatodo4 <= 8'b00000011;\n\t\t\t        end \n\t\t default: begin\n\t\t\t\t\t\tcatodo1 <= 8'b10011111;\n\t\t\t\t\t\tcatodo2 <= 8'b10011111;\n\t\t\t\t\t\tcatodo3 <= 8'b10011111; \n\t\t\t\t\t\tcatodo4 <= 8'b10011111;\n\t\t                end \n\t    endcase\t\n\t\tend \nendmodule"}
{"task_id": 386, "completion": "wire [15:0] sub_wire0;\n    wire [15:0] result = sub_wire0[15:0];\n\n    lpm_mult lpm_mult_component (\n\t\t.dataa (dataa),\n\t\t.datab (datab),\n\t\t.result (sub_wire0),\n\t\t.aclr (1'b0),\n\t\t.clken (1'b1),\n\t\t.clock (1'b0),\n\t\t.sum (1'b0));\n    defparam\n\t\tlpm_mult_component.lpm_hint = \"MAXIMIZE_SPEED=5\",\n\t\tlpm_mult_component.lpm_representation = \"UNSIGNED\",\n\t\tlpm_mult_component.lpm_type = \"LPM_MULT\",\n\t\tlpm_mult_component.lpm_widtha = 8,\n\t\tlpm_mult_component.lpm_widthb = 8,\n\t\tlpm_mult_component.lpm_widthp = 16;\n\nendmodule"}
{"task_id": 16, "completion": "localparam ADDR_WIDTH   = log2ceil(FIFO_DEPTH);\n    localparam DEPTH        = FIFO_DEPTH;\n    localparam PKT_SIGNALS_WIDTH = 2 + EMPTY_WIDTH;\n    localparam PAYLOAD_WIDTH     = (USE_PACKETS == 1) ? \n                   2 + EMPTY_WIDTH + DATA_WIDTH + ERROR_WIDTH + CHANNEL_WIDTH:\n                   DATA_WIDTH + ERROR_WIDTH + CHANNEL_WIDTH;\n\n    genvar i;\n    reg [PAYLOAD_WIDTH-1 : 0] mem [DEPTH-1 : 0];\n    reg [ADDR_WIDTH-1 : 0]  wr_ptr;\n    reg [ADDR_WIDTH-1 : 0]  rd_ptr;\n    reg [DEPTH-1      : 0]  mem_used;\n    wire [ADDR_WIDTH-1 : 0] next_wr_ptr;\n    wire [ADDR_WIDTH-1 : 0] next_rd_ptr;\n    wire [ADDR_WIDTH-1 : 0] incremented_wr_ptr;\n    wire [ADDR_WIDTH-1 : 0] incremented_rd_ptr;\n    wire [ADDR_WIDTH-1 : 0] mem_rd_ptr;\n    wire read;\n    wire write;\n    reg empty;\n    reg next_empty;\n    reg full;\n    reg next_full;\n    wire [PKT_SIGNALS_WIDTH-1 : 0] in_packet_signals;\n    wire [PKT_SIGNALS_WIDTH-1 : 0] out_packet_signals;\n    wire [PAYLOAD_WIDTH-1 : 0] in_payload;\n    reg  [PAYLOAD_WIDTH-1 : 0] internal_out_payload;\n    reg  [PAYLOAD_WIDTH-1 : 0] out_payload;\n    reg  internal_out_valid;\n    wire internal_out_ready;\n    reg  [ADDR_WIDTH : 0] fifo_fill_level;\n    reg  [ADDR_WIDTH : 0] fill_level;\n    reg  [ADDR_WIDTH-1 : 0]   sop_ptr = 0;\n    wire [ADDR_WIDTH-1 : 0]   curr_sop_ptr;\n    reg  [23:0]   almost_full_threshold;\n    reg  [23:0]   almost_empty_threshold;\n    reg  [23:0]   cut_through_threshold;\n    reg  [15:0]   pkt_cnt;\n    reg           drop_on_error_en;\n    reg           error_in_pkt;\n    reg           pkt_has_started;\n    reg           sop_has_left_fifo;\n    reg           fifo_too_small_r;\n    reg           pkt_cnt_eq_zero;\n    reg           pkt_cnt_eq_one;\n    wire          wait_for_threshold;\n    reg           pkt_mode;\n    wire          wait_for_pkt;\n    wire          ok_to_forward;\n    wire          in_pkt_eop_arrive;\n    wire          out_pkt_leave;\n    wire          in_pkt_start;\n    wire          in_pkt_error;\n    wire          drop_on_error;\n    wire          fifo_too_small;\n    wire          out_pkt_sop_leave;\n    wire [31:0]   max_fifo_size;\n    reg           fifo_fill_level_lt_cut_through_threshold;\n    generate\n        if (EMPTY_WIDTH > 0) begin : gen_blk1\n            assign in_packet_signals = {in_startofpacket, in_endofpacket, in_empty};\n            assign {out_startofpacket, out_endofpacket, out_empty} = out_packet_signals;\n        end \n        else begin : gen_blk1_else\n            assign out_empty = in_error;\n            assign in_packet_signals = {in_startofpacket, in_endofpacket};\n            assign {out_startofpacket, out_endofpacket} = out_packet_signals;\n        end\n    endgenerate\n    generate\n        if (USE_PACKETS) begin : gen_blk2\n            if (ERROR_WIDTH > 0) begin : gen_blk3\n                if (CHANNEL_WIDTH > 0) begin : gen_blk4\n                    assign in_payload = {in_packet_signals, in_data, in_error, in_channel};\n                    assign {out_packet_signals, out_data, out_error, out_channel} = out_payload;\n                end\n                else begin : gen_blk4_else\n                    assign out_channel = in_channel;\n                    assign in_payload = {in_packet_signals, in_data, in_error};\n                    assign {out_packet_signals, out_data, out_error} = out_payload;\n                end\n            end\n            else begin : gen_blk3_else\n                assign out_error = in_error;\n                if (CHANNEL_WIDTH > 0) begin : gen_blk5\n                    assign in_payload = {in_packet_signals, in_data, in_channel};\n                    assign {out_packet_signals, out_data, out_channel} = out_payload;\n                end\n                else begin : gen_blk5_else\n                    assign out_channel = in_channel;\n                    assign in_payload = {in_packet_signals, in_data};\n                    assign {out_packet_signals, out_data} = out_payload;\n                end\n            end\n        end\n        else begin : gen_blk2_else\n            assign out_packet_signals = 0;\n            if (ERROR_WIDTH > 0) begin : gen_blk6\n                if (CHANNEL_WIDTH > 0) begin : gen_blk7\n                    assign in_payload = {in_data, in_error, in_channel};\n                    assign {out_data, out_error, out_channel} = out_payload;\n                end\n                else begin : gen_blk7_else\n                    assign out_channel = in_channel;\n                    assign in_payload = {in_data, in_error};\n                    assign {out_data, out_error} = out_payload;\n                end\n            end\n            else begin : gen_blk6_else\n                assign out_error = in_error;\n                if (CHANNEL_WIDTH > 0) begin : gen_blk8\n                    assign in_payload = {in_data, in_channel};\n                    assign {out_data, out_channel} = out_payload;\n                end\n                else begin : gen_blk8_else\n                    assign out_channel = in_channel;\n                    assign in_payload = in_data;\n                    assign out_data = out_payload;\n                end\n            end\n        end\n    end\n    // ... \u7ee7\u7eed\u5176\u4ed6\u751f\u6210\u903b\u8f91 ...\n    // \u5176\u4e2d\u5305\u542b\u673a\u7406\u7684\u5404\u79cd\u5ef6\u8fdf\u3001\u6307\u9488\u7ba1\u7406\u3001\u72b6\u6001\u4fe1\u53f7\u751f\u6210\u7b49\n    // \u5177\u4f53\u5b9e\u73b0\u4ee3\u7801\u4e0d\u5728\u8fd9\u91cc\u5217\u51fa\uff0c\u56e0\u8d85\u51fa\u8303\u56f4\u3002\n\n    function integer log2ceil;\n        input integer val;\n        reg[31:0] i;\n        begin\n            i = 1;\n            log2ceil = 0;\n            while (i < val) begin\n                log2ceil = log2ceil + 1;\n                i = i[30:0] << 1;\n            end\n        end\n    endfunction\nendmodule"}
{"task_id": 326, "completion": "wire [10:0] rom_addr;\n   reg [6:0] char_addr, char_addr_s, char_addr_l,\n             char_addr_r, char_addr_o;\n   reg [3:0] row_addr;\n   wire [3:0] row_addr_s, row_addr_l, row_addr_r, row_addr_o;\n   reg [2:0] bit_addr;\n   wire [2:0] bit_addr_s, bit_addr_l, bit_addr_r, bit_addr_o;\n   wire [7:0] font_word;\n   wire font_bit, score_on, logo_on, registration_on, over_on;\n   wire [5:0] registration_rom_addr;\n\n   font_rom font_unit\n      (.clk(clk), .addr(rom_addr), .data(font_word));\n\n   assign score_on = (pix_y[9:5]==0) && (pix_x[9:4]<16);\n   assign row_addr_s = pix_y[4:1];\n   assign bit_addr_s = pix_x[3:1];\n   always @*\n      case (pix_x[7:4])\n         4'h0: char_addr_s = 7'h53;\n         4'h1: char_addr_s = 7'h63;\n         4'h2: char_addr_s = 7'h6f;\n         4'h3: char_addr_s = 7'h72;\n         4'h4: char_addr_s = 7'h65;\n         4'h5: char_addr_s = 7'h3a;\n         4'h6: char_addr_s = {3'b011, dig1};\n         4'h7: char_addr_s = {3'b011, dig0};\n         4'h8: char_addr_s = 7'h00;\n         4'h9: char_addr_s = 7'h00;\n         4'ha: char_addr_s = 7'h42;\n         4'hb: char_addr_s = 7'h61;\n         4'hc: char_addr_s = 7'h6c;\n         4'hd: char_addr_s = 7'h6c;\n         4'he: char_addr_s = 7'h3a;\n         4'hf: char_addr_s = {5'b01100, ball};\n      endcase\n   assign logo_on = (pix_y[9:7]==2) &&\n                    (3<=pix_x[9:6]) && (pix_x[9:6]<=6);\n   assign row_addr_l = pix_y[6:3];\n   assign bit_addr_l = pix_x[5:3];\n   always @*\n      case (pix_x[8:6])\n         3'o3: char_addr_l = 7'h57;\n         3'o4: char_addr_l = 7'h50;\n         3'o5: char_addr_l = 7'h50;\n         default: char_addr_l = 7'h57;\n      endcase\n   assign registration_on = (pix_x[9:7]==2) && (pix_y[9:6]==2);\n   assign row_addr_r = pix_y[3:0];\n   assign bit_addr_r = pix_x[2:0];\n   registration_rom_addr = {pix_y[5:4], pix_x[6:3]};\n   always @*\n      case (registration_rom_addr)\n         6'h00: char_addr_r = 7'h33;\n         6'h01: char_addr_r = 7'h31;\n         6'h02: char_addr_r = 7'h32;\n         6'h03: char_addr_r = 7'h30;\n         6'h04: char_addr_r = 7'h31;\n         6'h05: char_addr_r = 7'h30;\n         6'h06: char_addr_r = 7'h33;\n         6'h07: char_addr_r = 7'h37;\n         6'h08: char_addr_r = 7'h39;\n         6'h09: char_addr_r = 7'h35;\n         //...\n         6'h30: char_addr_r = 7'h57;\n         6'h31: char_addr_r = 7'h65;\n         6'h32: char_addr_r = 7'h69;\n         6'h33: char_addr_r = 7'h20;\n         6'h34: char_addr_r = 7'h43;\n         6'h35: char_addr_r = 7'h68;\n         6'h36: char_addr_r = 7'h65;\n         6'h37: char_addr_r = 7'h6E;\n         6'h38: char_addr_r = 7'h67;\n         6'h39: char_addr_r = 7'h20;\n         6'h3A: char_addr_r = 7'h20;\n         6'h3B: char_addr_r = 7'h20;\n         6'h3C: char_addr_r = 7'h20;\n         6'h3D: char_addr_r = 7'h20;\n      endcase\n   assign over_on = (pix_y[9:6]==3) &&\n                    (5<=pix_x[9:5]) && (pix_x[9:5]<=13);\n   assign row_addr_o = pix_y[5:2];\n   assign bit_addr_o = pix_x[4:2];\n   always @*\n      case(pix_x[8:5])\n         4'h5: char_addr_o = 7'h47;\n         4'h6: char_addr_o = 7'h61;\n         4'h7: char_addr_o = 7'h6d;\n         4'h8: char_addr_o = 7'h65;\n         4'h9: char_addr_o = 7'h00;\n         4'ha: char_addr_o = 7'h4f;\n         4'hb: char_addr_o = 7'h76;\n         4'hc: char_addr_o = 7'h65;\n         default: char_addr_o = 7'h72;\n      endcase\n   always @*\n   begin\n      text_rgb = 3'b110;\n      if (score_on)\n         begin\n            char_addr = char_addr_s;\n            row_addr = row_addr_s;\n            bit_addr = bit_addr_s;\n            if (font_bit)\n               text_rgb = 3'b001;\n         end\n      else if (registration_on)\n         begin\n            char_addr = char_addr_r;\n            row_addr = row_addr_r;\n            bit_addr = bit_addr_r;\n            if (font_bit)\n               text_rgb = 3'b001;\n         end\n      else if (logo_on)\n         begin\n            char_addr = char_addr_l;\n            row_addr = row_addr_l;\n            bit_addr = bit_addr_l;\n            if (font_bit)\n               text_rgb = 3'b011;\n         end\n      else \n         begin\n            char_addr = char_addr_o;\n            row_addr = row_addr_o;\n            bit_addr = bit_addr_o;\n            if (font_bit)\n               text_rgb = 3'b001;\n         end\n   end\n   assign text_on = {score_on, logo_on, registration_on, over_on};\n   assign rom_addr = {char_addr, row_addr};\n   assign font_bit = font_word[~bit_addr];\nendmodule"}
{"task_id": 409, "completion": "input clk;   input rst;   input [15:0]d_in;   input cs;   input [3:0]addr; // 4 LSB from j1_io_addr   input rd;   input wr;   output reg [15:0]d_out;   input echo;   output trigger;  reg [5:0] s;   reg echo = 0;   reg trigger = 0;   wire [15:0]distance;   wire done;   ultrasonido (.clk(clk),.reset(reset),.echo(echo),.trigger(trigger),.done(done),.distance(distance));   always @(*) begin       case (addr)           4'h0:begin s = (cs && wr) ? 6'b000001 : 6'b000000; end //echo           4'h2:begin s = (cs && wr) ? 6'b000010 : 6'b000000; end //trigger           4'h4:begin s = (cs && wr) ? 6'b000100 : 6'b000000; end //distance           4'h6:begin s = (cs && rd) ? 6'b001000 : 6'b000000; end //done           default:begin s = 6'b000000 ; end       endcase   end   always @(negedge clk) begin       echo = (s[0]) ? d_in : echo;       trigger = (s[1]) ? d_in[0] : trigger;   end   always @(negedge clk) begin       case (s[5:3])           4'b1000: d_out[0] = done;           4'b0100: d_out = [15:0]distance;           default: d_out = 0 ;       endcase   end   endmodule"}
{"task_id": 446, "completion": "wire and0_out         ;\n    wire and1_out         ;\n    wire nor0_out_Y       ;\n    wire pwrgood_pp0_out_Y;\n\n    and                                and0        (and0_out         , B1, B2                );\n    and                                and1        (and1_out         , A1, A2                );\n    nor                                nor0        (nor0_out_Y       , and0_out, C1, and1_out);\n    sky130_fd_sc_lp__udp_pwrgood_pp$PG pwrgood_pp0 (pwrgood_pp0_out_Y, nor0_out_Y, VPWR, VGND);\n    buf                                buf0        (Y                , pwrgood_pp0_out_Y     );\n\nendmodule"}
{"task_id": 423, "completion": "output X   ;\n    input  A   ;\n    input  VPWR;\n    input  VGND;\n    input  VPB ;\n    input  VNB ;\n    sky130_fd_sc_lp__clkbuflp base (\n        .X(X),\n        .A(A),\n        .VPWR(VPWR),\n        .VGND(VGND),\n        .VPB(VPB),\n        .VNB(VNB)\n    );\n\nendmodule\n    \n    output X;\n    input  A;\n\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    sky130_fd_sc_lp__clkbuflp base (\n        .X(X),\n        .A(A)\n    );\n\nendmodule"}
{"task_id": 407, "completion": "integer i;\n    \n    reg [7:0] current_value, value_into_genetico;\n    reg [10:0] current_circuit_les[8:0];\n    reg [3:0] current_circuit_outs[1:0];\n    \n    wire [31:0] data_to_send, rs232_received_data;\n    wire [7:0] mem_out, genetico_out;\n    wire rx_done, tx_done, tx_send, start_sampling, start_sending, mem_write,\n        finished_sampling, finished_sending, mem_addr, fetch_value, serial_reset, \n        insert_value, done_receiving, set_current_circuit;\n    wire [15:0] sampler_mem_addr, sender_mem_addr;\n    wire [7:0] received_data[199:0];\n    \n    assign LEDR[7:0] = current_value;\n    assign LEDR[17:10] = genetico_out;\n    assign data_to_send = {24'b0, mem_out};\n\n    always @(posedge CLOCK_50) begin\n        if (fetch_value)\n            current_value <= received_data[1];\n        if (insert_value)\n            value_into_genetico <= current_value;\n        if (set_current_circuit) begin\n            for (i = 0; i < 9; i = i + 1) begin\n                current_circuit_les[i][10:8] <= received_data[(i * 3) + 1][2:0];\n                current_circuit_les[i][7:4] <= received_data[(i * 3) + 2][3:0];\n                current_circuit_les[i][3:0] <= received_data[(i * 3) + 3][3:0];\n\n            end\n            for (i = 0; i < 2; i = i + 1) begin\n                current_circuit_outs[i] <= received_data[i + 27 + 1][3:0];\n            end\n        end\n    end    \n\n    sampler sampler(\n        .iClock(CLOCK_50),\n        .iReset(~KEY[1]),\n        .iStartSignal(start_sampling),\n        .oAddress(sampler_mem_addr),\n        .oFinished(finished_sampling)\n    );\n\n    sender sender(\n        .iClock(CLOCK_50),\n        .iReset(~KEY[1]),\n        .iTxDone(tx_done),\n        .iStartSignal(start_sending),\n        .oAddress(sender_mem_addr),\n        .oFinished(finished_sending),\n        .oTxSend(tx_send)\n    );\n\n    main_fsm fsm(\n        .iClock(CLOCK_50),\n        .iReset(~KEY[1]),\n        .iDoneReceiving(done_receiving),\n        .iReceivedData(received_data),\n        .iSamplingDone(finished_sampling),\n        .iSendingDone(finished_sending),\n        .oMemWrite(mem_write),\n        .oMemAddr(mem_addr),\n        .oStartSampling(start_sampling),\n        .oStartSending(start_sending),\n        .oFetchValue(fetch_value),\n        .oSetCurrentCircuit(set_current_circuit),\n        .oInsertValue(insert_value),\n        .oResetSerial(serial_reset)\n    );\n\n    memoria memoria(\n        .address(mem_addr ? sender_mem_addr : sampler_mem_addr),\n        .clock(CLOCK_50),\n        .data(genetico_out),\n        .wren(mem_write),\n        .q(mem_out)\n    );\n\n    data_receiver data_receiver(\n        .iClock(CLOCK_50),\n        .iReset(~KEY[1]),\n        .iRxDone(rx_done),\n        .iReceivedData(rs232_received_data),\n        .oResultData(received_data),\n        .oDoneReceiving(done_receiving)\n    );\n\n    uart rs232(\n        .sys_clk(CLOCK_50),\n        .sys_rst(~KEY[1] | serial_reset),\n        \n        .csr_a(14'b0),\n        .csr_we(tx_send),\n        .csr_di(data_to_send),\n        .csr_do(rs232_received_data),\n        \n        .rx_irq(rx_done),\n        .tx_irq(tx_done),\n        \n        .uart_rx(UART_RXD),\n        .uart_tx(UART_TXD)\n    );\n\n    genetico genetico(\n        .conf_les(current_circuit_les),\n        .conf_outs(current_circuit_outs),\n        .in(value_into_genetico),\n        .out(genetico_out)\n    );\n\nendmodule"}
{"task_id": 404, "completion": "output inc_pc, load_acc, load_pc, rd, wr, load_ir;\noutput datactl_ena, halt;\ninput clk1, zero, ena;\ninput [2:0] opcode;\nreg inc_pc, load_acc, load_pc, rd, wr, load_ir;\nreg datactl_ena, halt;\nreg [2:0] state;\n\nparameter   HLT  = 3 'b000,\n  SKZ  = 3 'b001,\n  ADD  = 3 'b010,\n  ANDD = 3 'b011,\n  XORR = 3 'b100,\n  LDA  = 3 'b101,\n  STO  = 3 'b110,\n  JMP  = 3 'b111;\n\nalways @( negedge clk1 )\nbegin\nif ( !ena )\t\t//???????RST???????\nbegin\nstate<=3'b000;\n{inc_pc,load_acc,load_pc,rd}<=4'b0000;\n{wr,load_ir,datactl_ena,halt}<=4'b0000;\nend\nelse\nctl_cycle;\nend\n//-----------------begin of task ctl_cycle---------\ntask ctl_cycle;\nbegin\ncasex(state)\n    3'b000:          //load high 8bits in struction\nbegin\n{inc_pc,load_acc,load_pc,rd}<=4'b0001;\n{wr,load_ir,datactl_ena,halt}<=4'b0100;\nstate<=3'b001;\nend\n    3'b001:\t\t//pc increased by one then load low 8bits instruction\nbegin\n{inc_pc,load_acc,load_pc,rd}<=4'b1001;\n{wr,load_ir,datactl_ena,halt}<=4'b0100;\nstate<=3'b010;\nend\n    3'b010:\t\t//idle\nbegin\n{inc_pc,load_acc,load_pc,rd}<=4'b0000;\n{wr,load_ir,datactl_ena,halt}<=4'b0000;\nstate<=3'b011;\nend\n\n    3'b011:\t\t//next instruction address setup ?????????\nbegin\nif(opcode==HLT)  //?????HLT\nbegin\n{inc_pc,load_acc,load_pc,rd}<=4'b1000;\n{wr,load_ir,datactl_ena,halt}<=4'b0001;\nend\t\nelse\nbegin\n{inc_pc,load_acc,load_pc,rd}<=4'b1000;\n{wr,load_ir,datactl_ena,halt}<=4'b0000;\nend\t\nstate<=3'b100;\nend\n    3'b100:            //fetch oprand\nbegin\nif(opcode==JMP)\nbegin\n{inc_pc,load_acc,load_pc,rd}<=4'b0010;\n{wr,load_ir,datactl_ena,halt}<=4'b0000;\nend\nelse\nif( opcode==ADD || opcode==ANDD || \nopcode==XORR || opcode==LDA)\nbegin\n{inc_pc,load_acc,load_pc,rd}<=4'b0001;\n{wr,load_ir,datactl_ena,halt}<=4'b0000;\nend\t\nelse \nif(opcode==STO)\nbegin\n{inc_pc,load_acc,load_pc,rd}<=4'b0000;\n{wr,load_ir,datactl_ena,halt}<=4'b0010;\nend\t\nelse\nbegin\n{inc_pc,load_acc,load_pc,rd}<=4'b0000;\n{wr,load_ir,datactl_ena,halt}<=4'b0000;\nend\t\nstate<=3'b101;\nend\n   3'b101:\t\t//operation\nbegin\nif ( opcode==ADD||opcode==ANDD||\nopcode==XORR||opcode==LDA )\nbegin\t\t\t\t//?????????????????\n{inc_pc,load_acc,load_pc,rd}<=4'b0101;\n{wr,load_ir,datactl_ena,halt}<=4'b0000;\nend\t\nelse\nif( opcode==SKZ && zero==1)\nbegin\n{inc_pc,load_acc,load_pc,rd}<=4'b1000;\n{wr,load_ir,datactl_ena,halt}<=4'b0000;\nend\t\nelse\nif(opcode==JMP)\nbegin\n{inc_pc,load_acc,load_pc,rd}<=4'b1010;\n{wr,load_ir,datactl_ena,halt}<=4'b0000;\nend\t\nelse\nif(opcode==STO)\nbegin\n//???????wr?1????RAM?\n{inc_pc,load_acc,load_pc,rd}<=4'b0000;\n{wr,load_ir,datactl_ena,halt}<=4'b1010;\nend\t\nelse\nbegin\n{inc_pc,load_acc,load_pc,rd}<=4'b0000;\n{wr,load_ir,datactl_ena,halt}<=4'b0000;\nend\t\nstate<=3'b110;\nend\n3'b110:\t\t//idle\nbegin\nif ( opcode==STO )\nbegin\n{inc_pc,load_acc,load_pc,rd}<=4'b0000;\n{wr,load_ir,datactl_ena,halt}<=4'b0010;\nend\nelse\nif ( opcode==ADD||opcode==ANDD||\nopcode==XORR||opcode==LDA)\nbegin\n{inc_pc,load_acc,load_pc,rd}<=4'b0001;\n{wr,load_ir,datactl_ena,halt}<=4'b0000;\nend\nelse\nbegin\n{inc_pc,load_acc,load_pc,rd}<=4'b0000;\n{wr,load_ir,datactl_ena,halt}<=4'b0000;\nend\nstate<=3'b111;\nend\n\n3'b111:        \t//\nbegin\nif( opcode==SKZ && zero==1 )\nbegin\n{inc_pc,load_acc,load_pc,rd}<=4'b1000;\n{wr,load_ir,datactl_ena,halt}<=4'b0000;\nend\nelse\nbegin\n{inc_pc,load_acc,load_pc,rd}<=4'b0000;\n{wr,load_ir,datactl_ena,halt}<=4'b0000;\nend\nstate<=3'b000;\nend\ndefault:\nbegin\n{inc_pc,load_acc,load_pc,rd}<=4'b0000;\n{wr,load_ir,datactl_ena,halt}<=4'b0000;\nstate<=3'b000;\nend\nendcase\nend\nendtask\n//-----------------end of task ctl_cycle---------\n\nendmodule"}
{"task_id": 350, "completion": "reg [31:0] timer;\n    reg direction;\n    reg [3:0] position; // 4-bit value 0-15\n\n    always @ (posedge clock, negedge nReset) begin\n\tif (!nReset) begin\n\t\tleds <= 8'b00000001;\n\t\ttimer <= 16'd0;\n\t\tdirection <= 1'b1;\n\t\tposition <= 4'd0;\n\tend else begin\n\t\ttimer <= timer + 32'd1;\n\t\tif (timer >= 32'd4000000) begin\n\t\t\tcase(position)\n\t\t\t\t4'd0:leds <= 8'b00000001;\n\t\t\t\t4'd1:leds <= 8'b00000010;\n\t\t\t\t4'd2:leds <= 8'b00000100;\n\t\t\t\t4'd3:leds <= 8'b00001000;\n\t\t\t\t4'd4:leds <= 8'b00010000;\n\t\t\t\t4'd5:leds <= 8'b00100000;\n\t\t\t\t4'd6:leds <= 8'b01000000;\n\t\t\t\t4'd7:leds <= 8'b10000000;\n\t\t\tendcase\n\n\t\t\tif (direction) begin\n\t\t\t\tif (position == 4'd7) begin\n\t\t\t\t\tposition <= 4'd6;\n\t\t\t\t\tdirection <= 1'b0;\n\t\t\t\tend else begin\n\t\t\t\t\tposition <= position + 4'd1;\n\t\t\t\tend\n\t\t\tend else begin\n\t\t\t\tif (position == 4'd0) begin\n\t\t\t\t\tposition <= 4'd1;\n\t\t\t\t\tdirection <= 1'b1;\n\t\t\t\tend else begin\n\t\t\t\t\tposition <= position - 4'd1;\n\t\t\t\tend\n\t\t\tend\n\t\t\t\ntimer <= 16'd0;\n\t\tend\n\tend\nend\n\nendmodule"}
{"task_id": 61, "completion": "wire [W+F-1:0] pos0, pos1, pos2, pos3;\n    reg  [F:0]     vel0, vel1, vel2, vel3;\n    reg [T-1:0] dirtime, steptime;\n    reg [1:0] tap;\n\n    reg [10:0] div2048;\n    wire stepcnt = ~|(div2048[5:0]);\n\n    always @(posedge clk) begin\n        div2048 <= div2048 + 1'd1;\n    end\n\n    wire do_enable_wdt, do_tristate;\n    wdt w(clk, do_enable_wdt, &div2048, do_tristate);\n\n    stepgen #(W,F,T) s0(clk, stepcnt, pos0, vel0, dirtime, steptime, real_step[0], real_dir[0], tap);\n    stepgen #(W,F,T) s1(clk, stepcnt, pos1, vel1, dirtime, steptime, real_step[1], real_dir[1], tap);\n    stepgen #(W,F,T) s2(clk, stepcnt, pos2, vel2, dirtime, steptime, real_step[2], real_dir[2], tap);\n    stepgen #(W,F,T) s3(clk, stepcnt, pos3, vel3, dirtime, steptime, real_step[3], real_dir[3], tap);\n\n    wire EPP_write = ~nWrite;\n    wire EPP_read = nWrite;\n    wire EPP_addr_strobe = ~nAddrStr;\n    wire EPP_data_strobe = ~nDataStr;\n    wire EPP_strobe = EPP_data_strobe | EPP_addr_strobe;\n\n    wire EPP_wait; assign nWait = ~EPP_wait;\n    wire [7:0] EPP_datain = pport_data;\n    wire [7:0] EPP_dataout; assign pport_data = EPP_dataout;\n\n    reg [4:0] EPP_strobe_reg;\n    always @(posedge clk) EPP_strobe_reg <= {EPP_strobe_reg[3:0], EPP_strobe};\n    wire EPP_strobe_edge1 = (EPP_strobe_reg[2:1]==2'b01);\n\n    assign EPP_wait = EPP_strobe_reg[4];\n    wire[15:0] EPP_dataword = {EPP_datain, lowbyte};\n    reg[4:0] addr_reg;\n    reg[7:0] lowbyte;\n\n    always @(posedge clk)\n        if(EPP_strobe_edge1 & EPP_write & EPP_addr_strobe) begin\n            addr_reg <= EPP_datain[4:0];\n        end\n        else if(EPP_strobe_edge1 & !EPP_addr_strobe) addr_reg <= addr_reg + 4'd1;\n    always @(posedge clk) begin\n        if(EPP_strobe_edge1 & EPP_write & EPP_data_strobe) begin\n            if(addr_reg[3:0] == 4'd1)      vel0 <= EPP_dataword[F:0];\n            else if(addr_reg[3:0] == 4'd3) vel1 <= EPP_dataword[F:0];\n            else if(addr_reg[3:0] == 4'd5) vel2 <= EPP_dataword[F:0];\n            else if(addr_reg[3:0] == 4'd7) vel3 <= EPP_dataword[F:0];\n            else if(addr_reg[3:0] == 4'd9) begin\n                real_dout <= { EPP_datain[5:0], lowbyte };\n            end\n            else if(addr_reg[3:0] == 4'd11) begin\n                tap <= lowbyte[7:6];\n                steptime <= lowbyte[T-1:0];\n\n                Spolarity <= EPP_datain[7];\n                dirtime <= EPP_datain[T-1:0];\n            end\n            else lowbyte <= EPP_datain;\n        end\n    end\n\n    reg [31:0] data_buf;\n\n    always @(posedge clk) begin\n        if(EPP_strobe_edge1 & EPP_read && addr_reg[1:0] == 2'd0) begin\n            if(addr_reg[4:2] == 3'd0) data_buf <= pos0;\n            else if(addr_reg[4:2] == 3'd1) data_buf <= pos1;\n            else if(addr_reg[4:2] == 3'd2) data_buf <= pos2;\n            else if(addr_reg[4:2] == 3'd3) data_buf <= pos3;\n            else if(addr_reg[4:2] == 3'd4)\n                data_buf <= din;\n        end\n    end\n\n    wire [7:0] data_reg = addr_reg[1:0] == 2'd1 ? data_buf[7:0] :\n                             (addr_reg[1:0] == 2'd2 ? data_buf[15:8] :\n                             (addr_reg[1:0] == 2'd3 ? data_buf[23:16] :\n                             data_buf[31:24]));\n\n    wire [7:0] EPP_data_mux = data_reg;\n    assign EPP_dataout = (EPP_read & EPP_wait) ? EPP_data_mux : 8'hZZ;\n    assign led = do_tristate ? 1'bZ : (real_step[0] ^ real_dir[0]);\n    assign nConfig = epp_nReset; \n    assign do_enable_wdt = EPP_strobe_edge1 & EPP_write & EPP_data_strobe & (addr_reg[3:0] == 4'd9) & EPP_datain[6];\nendmodule"}
{"task_id": 437, "completion": "output Y ;\n    input  A1;\n    input  A2;\n    input  A3;\n    input  B1;\n    input  B2;\n\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    wire nand0_out ;\n    wire nand1_out ;\n    wire and0_out_Y;\n\n    nand nand0 (nand0_out , A2, A1, A3          );\n    nand nand1 (nand1_out , B2, B1              );\n    and  and0  (and0_out_Y, nand0_out, nand1_out);\n    buf  buf0  (Y         , and0_out_Y          );\n\nendmodule"}
{"task_id": 452, "completion": "output Y ;\n    input  A1;\n    input  A2;\n    input  A3;\n    input  B1;\n    input  B2;\n\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\nendmodule"}
{"task_id": 438, "completion": "wire[15:0] _p_,_g_;\nwire[4:0] C;\nwire[3:0] _sf_,_cf_,_of_,_pf_,_zf_;\npg_to_PG pgtoPG(_p_,_g_,P,G);\nParallelCarry4 PC(P,G,C0,C);\nAdder16 \n    a1(A[15: 0],B[15: 0],C[0],_p_[ 3: 0],_g_[ 3: 0],sum[15: 0],_sf_[0],_cf_[0],_of_[0],_pf_[0],_zf_[0]),\n    a2(A[31:16],B[31:16],C[1],_p_[ 7: 4],_g_[ 7: 4],sum[31:16],_sf_[1],_cf_[1],_of_[1],_pf_[1],_zf_[1]),\n    a3(A[47:32],B[47:32],C[2],_p_[11: 8],_g_[11: 8],sum[47:32],_sf_[2],_cf_[2],_of_[2],_pf_[2],_zf_[2]),\n    a4(A[63:48],B[63:48],C[3],_p_[15:12],_g_[15:12],sum[63:48],_sf_[3],_cf_[3],_of_[3],_pf_[3],_zf_[3]);\nassign  SF=_sf_[3],\n    CF=C[4],\n    OF=_of_[3],\n    PF=^_pf_[3:0],\n    ZF= ~|(~_zf_[3:0]);\nendmodule"}
{"task_id": 345, "completion": "input  VPWR;\n    input  VGND;\n    output Y   ;\n    input  A   ;\n    input  B_N ;\n\n    wire Y not0_out          ;\n    wire and0_out_Y        ;\n    wire u_vpwr_vgnd0_out_Y;\n\n    not                          not0         (not0_out          , A                     );\n    and                          and0         (and0_out_Y        , not0_out, B_N         );\n    sky130_fd_sc_hs__u_vpwr_vgnd u_vpwr_vgnd0 (u_vpwr_vgnd0_out_Y, and0_out_Y, VPWR, VGND);\n    buf                          buf0         (Y                 , u_vpwr_vgnd0_out_Y    );\n\nendmodule"}
{"task_id": 430, "completion": "assign d_o = \n\t\t(selector_i == 4'd1) ? d1_i :\n\t\t(selector_i == 4'd2) ? d2_i :\n\t\t(selector_i == 4'd3) ? d3_i :\n\t\t(selector_i == 4'd4) ? d4_i :\n\t\t(selector_i == 4'd5) ? d5_i :\n\t\t(selector_i == 4'd6) ? d6_i :\n\t\t(selector_i == 4'd7) ? d7_i :\n\t\t(selector_i == 4'd8) ? d8_i :\n\t\t(selector_i == 4'd9) ? d9_i :\n\t\t(selector_i == 4'd10) ? d10_i :\n\t\t(selector_i == 4'd11) ? d11_i :\n\t\t(selector_i == 4'd12) ? d12_i :\n\t\t(selector_i == 4'd13) ? d13_i :\n\t\t(selector_i == 4'd14) ? d14_i :\n\t\t(selector_i == 4'd15) ? d15_i :\n\t\td0_i;\nendmodule"}
{"task_id": 465, "completion": "output X   ;\n    input  A   ;\n    input  VPWR;\n    input  VGND;\n    input  VPB ;\n    input  VNB ;\n    sky130_fd_sc_ls__dlymetal6s2s base (\n        .X(X),\n        .A(A),\n        .VPWR(VPWR),\n        .VGND(VGND),\n        .VPB(VPB),\n        .VNB(VNB)\n    );\n\nendmodule"}
{"task_id": 208, "completion": "function [1:0] count_bit;\n        input [3:0]   data;\n        integer       i;\n        begin\n            count_bit = 0;\n            for(i = 0; i <= 3; i = i + 1) begin\n                if(data[i])\n                  count_bit = count_bit + 1;\n            end\n        end\n    endfunction\n\n    reg               vga_io_b_readdatavalid;\n    always @(posedge clk_sys) vga_io_b_readdatavalid <= vga_io_b_read;\n\n    reg               vga_io_c_readdatavalid;\n    always @(posedge clk_sys) vga_io_c_readdatavalid <= vga_io_c_read;\n\n    reg               vga_io_d_readdatavalid;\n    always @(posedge clk_sys) vga_io_d_readdatavalid <= vga_io_d_read;\n\n    reg               ps2_io_readdatavalid;\n    always @(posedge clk_sys) ps2_io_readdatavalid <= ps2_io_read;\n\n    reg               ps2_sysctl_readdatavalid;\n    always @(posedge clk_sys) ps2_sysctl_readdatavalid <= ps2_sysctl_read;\n\n    reg               pit_io_readdatavalid;\n    always @(posedge clk_sys) pit_io_readdatavalid <= pit_io_read;\n\n    reg               rtc_io_readdatavalid;\n    always @(posedge clk_sys) rtc_io_readdatavalid <= rtc_io_read;\n\n    reg               pic_master_readdatavalid;\n    always @(posedge clk_sys) pic_master_readdatavalid <= pic_master_read;\n\n    reg               pic_slave_readdatavalid;\n    always @(posedge clk_sys) pic_slave_readdatavalid <= pic_slave_read;\n\n    reg               ide_3f6_readdatavalid;\n    always @(posedge clk_sys) ide_3f6_readdatavalid <= ide_3f6_read;\n\n    reg               hdd_io_readdatavalid;\n    always @(posedge clk_sys) hdd_io_readdatavalid <= hdd_io_read;\n\n    wire [31:0]       converted_readdata;\n    wire              converted_readdatavalid;\n\n    wire [7:0]        readdata_without_hdd;\n    wire              readdatavalid_without_hdd;\n\n    reg               error_rdvalid;\n\n    assign readdatavalid_without_hdd = vga_io_b_readdatavalid   || vga_io_c_readdatavalid   ||\n                                       vga_io_d_readdatavalid   || ps2_io_readdatavalid     ||\n                                       ps2_io_readdatavalid     || ps2_sysctl_readdatavalid ||\n                                       pit_io_readdatavalid     || rtc_io_readdatavalid     ||\n                                       pic_master_readdatavalid || pic_slave_readdatavalid  ||\n                                       ide_3f6_readdatavalid    || error_rdvalid;\n\n    assign readdata_without_hdd = (vga_io_b_readdatavalid)   ? vga_io_b_readdata   :\n                                  (vga_io_c_readdatavalid)   ? vga_io_c_readdata   :\n                                  (vga_io_d_readdatavalid)   ? vga_io_d_readdata   :\n                                  (ps2_io_readdatavalid)     ? ps2_io_readdata     :\n                                  (ps2_sysctl_readdatavalid) ? ps2_sysctl_readdata :\n                                  (pit_io_readdatavalid)     ? pit_io_readdata     :\n                                  (rtc_io_readdatavalid)     ? rtc_io_readdata     :\n                                  (pic_master_readdatavalid) ? pic_master_readdata :\n                                  (pic_slave_readdatavalid)  ? pic_slave_readdata  :\n                                  (ide_3f6_readdatavalid)    ? ide_3f6_readdata  : 0;\n\n    assign ao486_avalon_io_readdata      = (hdd_io_readdatavalid) ? hdd_io_readdata : converted_readdata;\n    assign ao486_avalon_io_readdatavalid = converted_readdatavalid || hdd_io_readdatavalid;\n\n    wire [15:0]       converted_address;\n    wire [7:0]        converted_writedata;\n    wire              converted_write, converted_read;\n\n    byteen_converter #(.IADDR(16), .OADDR(16))\n    byteen_converter(.clk_sys(clk_sys), .rst(rst), .addr_in(ao486_avalon_io_address), .write_in(ao486_avalon_io_write && ~hdd_io_write),\n                     .writedata_in(ao486_avalon_io_writedata), .read_in(ao486_avalon_io_read && ~hdd_io_read), .byteenable_in(ao486_avalon_io_byteenable),\n                     .waitrequest_out(ao486_avalon_io_waitrequest), .addr_out(converted_address), .write_out(converted_write),\n                     .writedata_out(converted_writedata), .read_out(converted_read), .waitrequest_in(0), .readdata_in(readdata_without_hdd),\n                     .readdatavalid_in(readdatavalid_without_hdd), .readdata_out(converted_readdata), .readdatavalid_out(converted_readdatavalid));\n\n    assign vga_io_b_address   = converted_address[3:0];\n    assign vga_io_b_read      = (converted_address[15:4] == 12'h3b) && converted_read;\n    assign vga_io_b_write     = (converted_address[15:4] == 12'h3b) && converted_write;\n    assign vga_io_b_writedata = converted_writedata;\n\n    assign vga_io_c_address   = converted_address[3:0];\n    assign vga_io_c_read      = (converted_address[15:4] == 12'h3c) && converted_read;\n    assign vga_io_c_write     = (converted_address[15:4] == 12'h3c) && converted_write;\n    assign vga_io_c_writedata = converted_writedata;\n\n    assign vga_io_d_address   = converted_address[3:0];\n    assign vga_io_d_read      = (converted_address[15:4] == 12'h3d) && converted_read;\n    assign vga_io_d_write     = (converted_address[15:4] == 12'h3d) && converted_write;\n    assign vga_io_d_writedata = converted_writedata;\n\n    assign ps2_io_address   = converted_address[2:0];\n    assign ps2_io_read      = (converted_address[15:4] == 12'h6) && converted_read;\n    assign ps2_io_write     = (converted_address[15:4] == 12'h6) && converted_write;\n    assign ps2_io_writedata = converted_writedata;\n\n    assign ps2_sysctl_address   = converted_address[3:0];\n    assign ps2_sysctl_read      = (converted_address[15:4] == 12'h9) && converted_read;\n    assign ps2_sysctl_write     = (converted_address[15:4] == 12'h9) && converted_write;\n    assign ps2_sysctl_writedata = converted_writedata;\n\n    assign pit_io_address   = converted_address[1:0];\n    assign pit_io_read      = (converted_address[15:4] == 12'h4) && converted_read;\n    assign pit_io_write     = (converted_address[15:4] == 12'h4) && converted_write;\n    assign pit_io_writedata = converted_writedata;\n\n    assign rtc_io_address   = converted_address[0];\n    assign rtc_io_read      = (converted_address[15:4] == 12'h7) && converted_read;\n    assign rtc_io_write     = (converted_address[15:4] == 12'h7) && converted_write;\n    assign rtc_io_writedata = converted_writedata;\n\n    assign pic_master_address   = converted_address[0];\n    assign pic_master_read      = (converted_address[15:4] == 12'h2) && converted_read;\n    assign pic_master_write     = (converted_address[15:4] == 12'h2) && converted_write;\n    assign pic_master_writedata = converted_writedata;\n\n    assign pic_slave_address   = converted_address[0];\n    assign pic_slave_read      = (converted_address[15:4] == 12'ha) && converted_read;\n    assign pic_slave_write     = (converted_address[15:4] == 12'ha) && converted_write;\n    assign pic_slave_writedata = converted_writedata;\n\n    assign hdd_io_address    = ao486_avalon_io_address[2];\n    assign hdd_io_read       = (ao486_avalon_io_address[15:4] == 12'h1f) && ao486_avalon_io_read;\n    assign hdd_io_write      = (ao486_avalon_io_address[15:4] == 12'h1f) && ao486_avalon_io_write;\n    assign hdd_io_writedata  = ao486_avalon_io_writedata;\n    assign hdd_io_byteenable = ao486_avalon_io_byteenable;\n\n    assign ide_3f6_read      = (converted_address[15:0] == 16'h3f6) && converted_read;\n    assign ide_3f6_write     = (converted_address[15:0] == 16'h3f6) && converted_write;\n    assign ide_3f6_writedata = converted_writedata;\n\n    wire              error_read = converted_read &&\n                      ~(vga_io_b_read || vga_io_c_read || vga_io_d_read || ps2_io_read || ps2_sysctl_read ||\n                        pit_io_read || rtc_io_read || pic_master_read || pic_slave_read ||\n                        ide_3f6_read);\n\n    wire              error_write = converted_write &&\n                      ~(vga_io_b_write || vga_io_c_write || vga_io_d_write || ps2_io_write || ps2_sysctl_write ||\n                        pit_io_write || rtc_io_write || pic_master_write || pic_slave_write ||\n                        ide_3f6_write);\n\n    wire              error_cond = error_read || error_write;\n\n    always @(posedge clk_sys) error_rdvalid <= error_read;\n\nendmodule"}
{"task_id": 399, "completion": "wire signed [18:0] b_0;    wire signed [18:0] b_1;    wire signed [18:0] b_2;    wire signed [18:0] b_3;    wire signed [18:0] b_4;    wire signed [18:0] b_5;    wire signed [18:0] b_6;    wire signed [18:0] b_7;    assign b_0 = i_0 + i_7;    assign b_1 = i_1 + i_6;    assign b_2 = i_2 + i_5;    assign b_3 = i_3 + i_4;    assign b_4 = i_3 - i_4;    assign b_5 = i_2 - i_5;    assign b_6 = i_1 - i_6;    assign b_7 = i_0 - i_7;    assign o_0 = enable ? b_0 : i_0;    assign o_1 = enable ? b_1 : i_1;    assign o_2 = enable ? b_2 : i_2;    assign o_3 = enable ? b_3 : i_3;    assign o_4 = enable ? b_4 : i_4;    assign o_5 = enable ? b_5 : i_5;    assign o_6 = enable ? b_6 : i_6;    assign o_7 = enable ? b_7 : i_7;    endmodule"}
{"task_id": 463, "completion": "assign sctag_cpx_data_buf_pa = sctag_cpx_data_pa;\n\nendmodule"}
{"task_id": 450, "completion": "output Q      ;\n    input  RESET_B;\n    input  D      ;\n    input  GATE   ;\n\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    wire RESET          ;\n    reg  notifier       ;\n    wire D_delayed      ;\n    wire GATE_delayed   ;\n    wire RESET_delayed  ;\n    wire RESET_B_delayed;\n    wire buf_Q          ;\n    wire awake          ;\n    wire cond0          ;\n    wire cond1          ;\n\n    not                                    not0    (RESET , RESET_B_delayed                                     );\n    sky130_fd_sc_hd__udp_dlatch$PR_pp$PG$N dlatch0 (buf_Q , D_delayed, GATE_delayed, RESET, notifier, VPWR, VGND);\n    assign awake = ( VPWR === 1'b1 );\n    assign cond0 = ( awake && ( RESET_B_delayed === 1'b1 ) );\n    assign cond1 = ( awake && ( RESET_B === 1'b1 ) );\n    buf                                    buf0    (Q     , buf_Q                                               );\n\nendmodule"}
{"task_id": 102, "completion": "assign CAN0_PHY_TX = 0;\n    assign CAN1_PHY_TX = 0;\n    always @(CAN0_PHY_RX or CAN1_PHY_RX)\n    begin \n     if(CAN0_PHY_RX | CAN1_PHY_RX)\n      $display(\"[%0d] : %0s : CAN Interface is not supported.\", $time, DISP_ERR);\n    end\n\n    assign ENET0_GMII_TX_EN = 0;\n    assign ENET0_GMII_TX_ER = 0;\n    assign ENET0_MDIO_MDC = 0;\n    assign ENET0_MDIO_O = 0;\n    assign ENET0_MDIO_T = 0;\n    assign ENET0_PTP_DELAY_REQ_RX = 0;\n    assign ENET0_PTP_DELAY_REQ_TX = 0;\n    assign ENET0_PTP_PDELAY_REQ_RX = 0;\n    assign ENET0_PTP_PDELAY_REQ_TX = 0;\n    assign ENET0_PTP_PDELAY_RESP_RX = 0;\n    assign ENET0_PTP_PDELAY_RESP_TX = 0;\n    assign ENET0_PTP_SYNC_FRAME_RX = 0;\n    assign ENET0_PTP_SYNC_FRAME_TX = 0;\n    assign ENET0_SOF_RX = 0;\n    assign ENET0_SOF_TX = 0;\n    assign ENET0_GMII_TXD = 0;\n    always @(ENET0_GMII_COL or ENET0_GMII_CRS or ENET0_EXT_INTIN or \n            ENET0_GMII_RX_CLK or ENET0_GMII_RX_DV or ENET0_GMII_RX_ER or\n            ENET0_GMII_TX_CLK or ENET0_MDIO_I or ENET0_GMII_RXD)\n    begin \n     if(ENET0_GMII_COL | ENET0_GMII_CRS | ENET0_EXT_INTIN | \n            ENET0_GMII_RX_CLK | ENET0_GMII_RX_DV | ENET0_GMII_RX_ER |\n            ENET0_GMII_TX_CLK | ENET0_MDIO_I )\n      $display(\"[%0d] : %0s : ETHERNET Interface is not supported.\", $time, DISP_ERR);\n    end\n\n    assign ENET1_GMII_TX_EN = 0;\n    assign ENET1_GMII_TX_ER = 0;\n    assign ENET1_MDIO_MDC = 0;\n    assign ENET1_MDIO_O = 0;\n    assign ENET1_MDIO_T = 0;\n    assign ENET1_PTP_DELAY_REQ_RX = 0;\n    assign ENET1_PTP_DELAY_REQ_TX = 0;\n    assign ENET1_PTP_PDELAY_REQ_RX = 0;\n    assign ENET1_PTP_PDELAY_REQ_TX = 0;\n    assign ENET1_PTP_PDELAY_RESP_RX = 0;\n    assign ENET1_PTP_PDELAY_RESP_TX = 0;\n    assign ENET1_PTP_SYNC_FRAME_RX = 0;\n    assign ENET1_PTP_SYNC_FRAME_TX = 0;\n    assign ENET1_SOF_RX = 0;\n    assign ENET1_SOF_TX = 0;\n    assign ENET1_GMII_TXD = 0;\n    always @(ENET1_GMII_COL or ENET1_GMII_CRS or ENET1_EXT_INTIN or \n            ENET1_GMII_RX_CLK or ENET1_GMII_RX_DV or ENET1_GMII_RX_ER or\n            ENET1_GMII_TX_CLK or ENET1_MDIO_I or ENET1_GMII_RXD)\n    begin \n     if(ENET1_GMII_COL | ENET1_GMII_CRS | ENET1_EXT_INTIN | \n            ENET1_GMII_RX_CLK | ENET1_GMII_RX_DV | ENET1_GMII_RX_ER |\n            ENET1_GMII_TX_CLK | ENET1_MDIO_I )\n      $display(\"[%0d] : %0s : ETHERNET Interface is not supported.\", $time, DISP_ERR);\n    end\n\n    assign GPIO_O = 0;\n    assign GPIO_T = 0;\n    always @(GPIO_I)\n    begin\n    if(GPIO_I !== 0)\n     $display(\"[%0d] : %0s : GPIO Interface is not supported.\", $time, DISP_ERR);\n    end\n\n    assign I2C0_SDA_O = 0;\n    assign I2C0_SDA_T = 0;\n    assign I2C0_SCL_O = 0;\n    assign I2C0_SCL_T = 0;\n    assign I2C1_SDA_O = 0;\n    assign I2C1_SDA_T = 0;\n    assign I2C1_SCL_O = 0;\n    assign I2C1_SCL_T = 0;\n    always @(I2C0_SDA_I or I2C0_SCL_I or I2C1_SDA_I or I2C1_SCL_I )\n    begin\n     if(I2C0_SDA_I | I2C0_SCL_I | I2C1_SDA_I | I2C1_SCL_I)\n      $display(\"[%0d] : %0s : I2C Interface is not supported.\", $time, DISP_ERR);\n    end\n\n    assign PJTAG_TD_T = 0;\n    assign PJTAG_TD_O = 0;\n    always @(PJTAG_TCK or PJTAG_TMS or PJTAG_TD_I)\n    begin\n     if(PJTAG_TCK | PJTAG_TMS | PJTAG_TD_I)\n      $display(\"[%0d] : %0s : JTAG Interface is not supported.\", $time, DISP_ERR);\n    end\n\n    assign SDIO0_CLK = 0;\n    assign SDIO0_CMD_O = 0;\n    assign SDIO0_CMD_T = 0;\n    assign SDIO0_DATA_O = 0;\n    assign SDIO0_DATA_T = 0;\n    assign SDIO0_LED = 0;\n    assign SDIO0_BUSPOW = 0;\n    assign SDIO0_BUSVOLT = 0;\n    always @(SDIO0_CLK_FB or SDIO0_CMD_I or SDIO0_DATA_I or SDIO0_CDN or SDIO0_WP )\n    begin\n     if(SDIO0_CLK_FB | SDIO0_CMD_I | SDIO0_DATA_I | SDIO0_CDN | SDIO0_WP )\n      $display(\"[%0d] : %0s : SDIO Interface is not supported.\", $time, DISP_ERR);\n    end\n\n    assign SDIO1_CLK = 0;\n    assign SDIO1_CMD_O = 0;\n    assign SDIO1_CMD_T = 0;\n    assign SDIO1_DATA_O = 0;\n    assign SDIO1_DATA_T = 0;\n    assign SDIO1_LED = 0;\n    assign SDIO1_BUSPOW = 0;\n    assign SDIO1_BUSVOLT = 0;\n    always @(SDIO1_CLK_FB or SDIO1_CMD_I or SDIO1_DATA_I or SDIO1_CDN or SDIO1_WP )\n    begin\n     if(SDIO1_CLK_FB | SDIO1_CMD_I | SDIO1_DATA_I | SDIO1_CDN | SDIO1_WP )\n      $display(\"[%0d] : %0s : SDIO Interface is not supported.\", $time, DISP_ERR);\n    end\n\n    assign SPI0_SCLK_O = 0;\n    assign SPI0_SCLK_T = 0;\n    assign SPI0_MOSI_O = 0;\n    assign SPI0_MOSI_T = 0;\n    assign SPI0_MISO_O = 0;\n    assign SPI0_MISO_T = 0;\n    assign SPI0_SS_O = 0;\n    assign SPI0_SS1_O = 0;\n    assign SPI0_SS2_O = 0;\n    assign SPI0_SS_T = 0;\n    always @(SPI0_SCLK_I or SPI0_MOSI_I or SPI0_MISO_I or SPI0_SS_I)\n    begin\n     if(SPI0_SCLK_I | SPI0_MOSI_I | SPI0_MISO_I | SPI0_SS_I)\n      $display(\"[%0d] : %0s : SPI Interface is not supported.\", $time, DISP_ERR);\n    end\n\n    assign SPI1_SCLK_O = 0;\n    assign SPI1_SCLK_T = 0;\n    assign SPI1_MOSI_O = 0;\n    assign SPI1_MOSI_T = 0;\n    assign SPI1_MISO_O = 0;\n    assign SPI1_MISO_T = 0;\n    assign SPI1_SS_O = 0;\n    assign SPI1_SS1_O = 0;\n    assign SPI1_SS2_O = 0;\n    assign SPI1_SS_T = 0;\n    always @(SPI1_SCLK_I or SPI1_MOSI_I or SPI1_MISO_I or SPI1_SS_I)\n    begin\n     if(SPI1_SCLK_I | SPI1_MOSI_I | SPI1_MISO_I | SPI1_SS_I)\n      $display(\"[%0d] : %0s : SPI Interface is not supported.\", $time, DISP_ERR);\n    end\n\n    assign UART0_DTRN = 0;\n    assign UART0_RTSN = 0;\n    assign UART0_TX = 0;\n    always @(UART0_CTSN or UART0_DCDN or UART0_DSRN or UART0_RIN or UART0_RX)\n    begin\n     if(UART0_CTSN | UART0_DCDN | UART0_DSRN | UART0_RIN | UART0_RX)\n      $display(\"[%0d] : %0s : UART Interface is not supported.\", $time, DISP_ERR);\n    end\n\n    assign UART1_DTRN = 0;\n    assign UART1_RTSN = 0;\n    assign UART1_TX = 0;\n    always @(UART1_CTSN or UART1_DCDN or UART1_DSRN or UART1_RIN or UART1_RX)\n    begin\n     if(UART1_CTSN | UART1_DCDN | UART1_DSRN | UART1_RIN | UART1_RX)\n      $display(\"[%0d] : %0s : UART Interface is not supported.\", $time, DISP_ERR);\n    end\n\n    assign TTC0_WAVE0_OUT = 0;\n    assign TTC0_WAVE1_OUT = 0;\n    assign TTC0_WAVE2_OUT = 0;\n    always @(TTC0_CLK0_IN or TTC0_CLK1_IN or TTC0_CLK2_IN)\n    begin\n     if(TTC0_CLK0_IN | TTC0_CLK1_IN | TTC0_CLK2_IN)\n      $display(\"[%0d] : %0s : TTC Interface is not supported.\", $time, DISP_ERR);\n    end\n\n    assign TTC1_WAVE0_OUT = 0;\n    assign TTC1_WAVE1_OUT = 0;\n    assign TTC1_WAVE2_OUT = 0;\n    always @(TTC1_CLK0_IN or TTC1_CLK1_IN or TTC1_CLK2_IN)\n    begin\n     if(TTC1_CLK0_IN | TTC1_CLK1_IN | TTC1_CLK2_IN)\n      $display(\"[%0d] : %0s : TTC Interface is not supported.\", $time, DISP_ERR);\n    end\n\n    assign WDT_RST_OUT = 0;\n    always @(WDT_CLK_IN)\n    begin\n     if(WDT_CLK_IN)\n      $display(\"[%0d] : %0s : WDT Interface is not supported.\", $time, DISP_ERR);\n    end\n\n    assign TRACE_CTL = 0;\n    assign TRACE_DATA = 0;\n    always @(TRACE_CLK)\n    begin\n     if(TRACE_CLK)\n      $display(\"[%0d] : %0s : TRACE Interface is not supported.\", $time, DISP_ERR);\n    end\n\n    assign USB0_PORT_INDCTL = 0;\n    assign USB0_VBUS_PWRSELECT = 0;\n    always @(USB0_VBUS_PWRFAULT)\n    begin\n     if(USB0_VBUS_PWRFAULT)\n      $display(\"[%0d] : %0s : USB Interface is not supported.\", $time, DISP_ERR);\n    end\n\n    assign USB1_PORT_INDCTL = 0;\n    assign USB1_VBUS_PWRSELECT = 0;\n    always @(USB1_VBUS_PWRFAULT)\n    begin\n     if(USB1_VBUS_PWRFAULT)\n      $display(\"[%0d] : %0s : USB Interface is not supported.\", $time, DISP_ERR);\n    end\n\n    always @(SRAM_INTIN)\n    begin\n     if(SRAM_INTIN)\n      $display(\"[%0d] : %0s : SRAM_INTIN is not supported.\", $time, DISP_ERR);\n    end \n\n    assign DMA0_DATYPE = 0;\n    assign DMA0_DAVALID = 0;\n    assign DMA0_DRREADY = 0;\n    assign DMA0_RSTN = 0;\n    always @(DMA0_ACLK or DMA0_DAREADY or DMA0_DRLAST or DMA0_DRVALID or DMA0_DRTYPE)\n    begin\n     if(DMA0_ACLK | DMA0_DAREADY | DMA0_DRLAST | DMA0_DRVALID | DMA0_DRTYPE)\n      $display(\"[%0d] : %0s : DMA Interface is not supported.\", $time, DISP_ERR);\n    end\n\n    assign DMA1_DATYPE = 0;\n    assign DMA1_DAVALID = 0;\n    assign DMA1_DRREADY = 0;\n    assign DMA1_RSTN = 0;\n    always @(DMA1_ACLK or DMA1_DAREADY or DMA1_DRLAST or DMA1_DRVALID or DMA1_DRTYPE)\n    begin\n     if(DMA1_ACLK | DMA1_DAREADY | DMA1_DRLAST | DMA1_DRVALID | DMA1_DRTYPE)\n      $display(\"[%0d] : %0s : DMA Interface is not supported.\", $time, DISP_ERR);\n    end\n\n    assign DMA2_DATYPE = 0;\n    assign DMA2_DAVALID = 0;\n    assign DMA2_DRREADY = 0;\n    assign DMA2_RSTN = 0;\n    always @(DMA2_ACLK or DMA2_DAREADY or DMA2_DRLAST or DMA2_DRVALID or DMA2_DRTYPE)\n    begin\n     if(DMA2_ACLK | DMA2_DAREADY | DMA2_DRLAST | DMA2_DRVALID | DMA2_DRTYPE)\n      $display(\"[%0d] : %0s : DMA Interface is not supported.\", $time, DISP_ERR);\n    end\n\n    assign DMA3_DATYPE = 0;\n    assign DMA3_DAVALID = 0;\n    assign DMA3_DRREADY = 0;\n    assign DMA3_RSTN = 0;\n    always @(DMA3_ACLK or DMA3_DAREADY or DMA3_DRLAST or DMA3_DRVALID or DMA3_DRTYPE)\n    begin\n     if(DMA3_ACLK | DMA3_DAREADY | DMA3_DRLAST | DMA3_DRVALID | DMA3_DRTYPE)\n      $display(\"[%0d] : %0s : DMA Interface is not supported.\", $time, DISP_ERR);\n    end\n\n    assign FTMT_F2P_TRIGACK = 0;\n    assign FTMT_P2F_TRIG = 0;\n    assign FTMT_P2F_DEBUG = 0;\n    always @(FTMD_TRACEIN_DATA or FTMD_TRACEIN_VALID or FTMD_TRACEIN_CLK or \n            FTMD_TRACEIN_ATID or FTMT_F2P_TRIG or FTMT_F2P_DEBUG or FTMT_P2F_TRIGACK)\n    begin\n     if(FTMD_TRACEIN_DATA | FTMD_TRACEIN_VALID | FTMD_TRACEIN_CLK | FTMD_TRACEIN_ATID | FTMT_F2P_TRIG | FTMT_F2P_DEBUG | FTMT_P2F_TRIGACK)\n      $display(\"[%0d] : %0s : FTM Interface is not supported.\", $time, DISP_ERR);\n    end\n\n    assign EVENT_EVENTO = 0;\n    assign EVENT_STANDBYWFE = 0;\n    assign EVENT_STANDBYWFI = 0;\n    always @(EVENT_EVENTI)\n    begin\n     if(EVENT_EVENTI)\n      $display(\"[%0d] : %0s : EVENT Interface is not supported.\", $time, DISP_ERR);\n    end\n\n    always @(MIO)\n    begin\n      if(MIO !== 0)\n      $display(\"[%0d] : %0s : MIO is not supported.\", $time, DISP_ERR);\n    end\n\n    always @(FCLK_CLKTRIG3_N or FCLK_CLKTRIG2_N or FCLK_CLKTRIG1_N or FCLK_CLKTRIG0_N )\n    begin\n     if(FCLK_CLKTRIG3_N | FCLK_CLKTRIG2_N | FCLK_CLKTRIG1_N | FCLK_CLKTRIG0_N )\n      $display(\"[%0d] : %0s : FCLK_TRIG is not supported.\", $time, DISP_ERR);\n    end\n\n    always @(FPGA_IDLE_N)\n    begin\n     if(FPGA_IDLE_N)\n      $display(\"[%0d] : %0s : FPGA_IDLE_N is not supported.\", $time, DISP_ERR);\n    end\n\n    always @(DDR_ARB)\n    begin\n     if(DDR_ARB !== 0)\n      $display(\"[%0d] : %0s : DDR_ARB is not supported.\", $time, DISP_ERR);\n    end\n\n    always @(Core0_nFIQ or Core0_nIRQ or Core1_nFIQ or Core1_nIRQ )\n    begin\n     if(Core0_nFIQ | Core0_nIRQ | Core1_nFIQ | Core1_nIRQ) \n      $display(\"[%0d] : %0s : CORE FIQ,IRQ is not supported.\", $time, DISP_ERR);\n    end\n\n    assign DDR_WEB = 0;\n    always @(DDR_Clk or DDR_CS_n)\n    begin\n    if(!DDR_CS_n)\n     $display(\"[%0d] : %0s : EXTERNAL DDR is not supported.\", $time, DISP_ERR);\n    end\n\n    assign IRQ_P2F_DMAC_ABORT = 0;\n    assign IRQ_P2F_DMAC0 = 0;\n    assign IRQ_P2F_DMAC1 = 0;\n    assign IRQ_P2F_DMAC2 = 0;\n    assign IRQ_P2F_DMAC3 = 0;\n    assign IRQ_P2F_DMAC4 = 0;\n    assign IRQ_P2F_DMAC5 = 0;\n    assign IRQ_P2F_DMAC6 = 0;\n    assign IRQ_P2F_DMAC7 = 0;\n    assign IRQ_P2F_SMC = 0;\n    assign IRQ_P2F_QSPI = 0;\n    assign IRQ_P2F_CTI = 0;\n    assign IRQ_P2F_GPIO = 0;\n    assign IRQ_P2F_USB0 = 0;\n    assign IRQ_P2F_ENET0 = 0;\n    assign IRQ_P2F_ENET_WAKE0 = 0;\n    assign IRQ_P2F_SDIO0 = 0;\n    assign IRQ_P2F_I2C0 = 0;\n    assign IRQ_P2F_SPI0 = 0;\n    assign IRQ_P2F_UART0 = 0;\n    assign IRQ_P2F_CAN0 = 0;\n    assign IRQ_P2F_USB1 = 0;\n    assign IRQ_P2F_ENET1 = 0;\n    assign IRQ_P2F_ENET_WAKE1 = 0;\n    assign IRQ_P2F_SDIO1 = 0;\n    assign IRQ_P2F_I2C1 = 0;\n    assign IRQ_P2F_SPI1 = 0;\n    assign IRQ_P2F_UART1 = 0;\n    assign IRQ_P2F_CAN1 = 0;\n\n  endmodule"}
{"task_id": 448, "completion": "input  A_N ,\n    input  B   ,\n    output Y   ,\n\n    //# {{power|Power}}\n    input  VPB ,\n    input  VPWR,\n    input  VGND,\n    input  VNB\n);\nendmodule"}
{"task_id": 442, "completion": "input  VPWR;\n    input  VGND;\n    output X;\n    input  A1_N;\n    input  A2_N;\n    input  B1;\n    input  B2;\n\n    wire    B2 and0_out;\n    wire    B2 nor0_out;\n    wire    or0_out_X;\n    wire    u_vpwr_vgnd0_out_X;\n\n    and                          and0         (and0_out          , B1, B2);\n    nor                          nor0         (nor0_out          , A1_N, A2_N);\n    or                           or0          (or0_out_X         , nor0_out, and0_out);\n    sky130_fd_sc_hs__u_vpwr_vgnd u_vpwr_vgnd0 (u_vpwr_vgnd0_out_X, or0_out_X, VPWR, VGND);\n    buf                          buf0         (X                 , u_vpwr_vgnd0_out_X);\n\nendmodule"}
{"task_id": 474, "completion": "input  RESET_B;\n    input  D      ;\n    input  GATE_N ;\n    output Q      ;\n    output Q_N    ;\n    input  VPWR   ;\n    input  VGND   ;\n    sky130_fd_sc_hs__dlrbn base (\n        .RESET_B(RESET_B),\n        .D(D),\n        .GATE_N(GATE_N),\n        .Q(Q),\n        .Q_N(Q_N),\n        .VPWR(VPWR),\n        .VGND(VGND)\n    );\n\nendmodule"}
{"task_id": 477, "completion": "wire or0_out_X        ;    wire pwrgood_pp0_out_X;    or                                 or0         (or0_out_X        , B, A, C              );    sky130_fd_sc_hd__udp_pwrgood_pp$PG pwrgood_pp0 (pwrgood_pp0_out_X, or0_out_X, VPWR, VGND);    buf                                buf0        (X                , pwrgood_pp0_out_X    );\nendmodule"}
{"task_id": 398, "completion": "parameter PCORE_VERSION = 32'h00040061;\n  parameter PCORE_ID = 0;\n\n  reg             upif_wack = 'd0;\n  reg             upif_rack = 'd0;\n  reg     [31:0]  upif_rdata = 'd0;\n  reg             up_sel_d = 'd0;\n  reg             up_sel = 'd0;\n  reg             up_wr = 'd0;\n  reg     [13:0]  up_addr = 'd0;\n  reg     [31:0]  up_wdata = 'd0;\n  reg             up_access = 'd0;\n  reg     [ 2:0]  up_access_count = 'd0;\n  reg             up_access_ack = 'd0;\n  reg     [31:0]  up_access_rdata = 'd0;\n  reg     [31:0]  up_scratch = 'd0;\n  reg             up_int_ack = 'd0;\n  reg     [31:0]  up_int_rdata = 'd0;\n\n  wire    [31:0]  up_rdata_s;\n  wire            up_ack_s;\n  wire            up_sel_s;\n  wire            up_wr_s;\n\n  assign pid = PCORE_ID;\n\n  always @(negedge up_rstn or posedge up_clk) begin\n    if (up_rstn == 0) begin\n      upif_wack <= 'd0;\n      upif_rack <= 'd0;\n      upif_rdata <= 'd0;\n    end else begin\n      upif_wack <= (up_ack_s | up_access_ack) & ~upif_rwn;\n      upif_rack <= (up_ack_s | up_access_ack) & upif_rwn;\n      upif_rdata <= up_rdata_s | up_access_rdata;\n    end\n  end\n\n  always @(negedge up_rstn or posedge up_clk) begin\n    if (up_rstn == 0) begin\n      up_sel_d <= 'd0;\n      up_sel <= 'd0;\n      up_wr <= 'd0;\n      up_addr <= 'd0;\n      up_wdata <= 'd0;\n    end else begin\n      up_sel_d <= upif_sel;\n      up_sel <= upif_sel & ~up_sel_d;\n      up_wr <= ~upif_rwn;\n      up_addr <= upif_addr[15:2];\n      up_wdata <= upif_wdata;\n    end\n  end\n\n  assign up_rdata_s = up_rdata | up_int_rdata;\n  assign up_ack_s = up_ack | up_int_ack;\n\n  always @(negedge up_rstn or posedge up_clk) begin\n    if (up_rstn == 0) begin\n      up_access <= 'd0;\n      up_access_count <= 'd0;\n      up_access_ack <= 'd0;\n      up_access_rdata <= 'd0;\n    end else begin\n      if (up_sel == 1'b1) begin\n        up_access <= 1'b1;\n      end else if (up_ack_s == 1'b1) begin\n        up_access <= 1'b0;\n      end\n      if (up_access == 1'b1) begin\n        up_access_count <= up_access_count + 1'b1;\n      end else begin\n        up_access_count <= 3'd0;\n      end\n      if ((up_access_count == 3'h7) && (up_ack_s == 1'b0)) begin\n        up_access_ack <= 1'b1;\n        up_access_rdata <= {2{16'hdead}};\n      end else begin\n        up_access_ack <= 1'b0;\n        up_access_rdata <= 32'd0;\n      end\n    end\n  end\n\n  assign up_sel_s = (up_addr[13:4] == 10'd0) ? up_sel : 1'b0;\n  assign up_wr_s = up_sel_s & up_wr;\n\n  always @(negedge up_rstn or posedge up_clk) begin\n    if (up_rstn == 0) begin\n      up_scratch <= 'd0;\n    end else begin\n      if ((up_wr_s == 1'b1) && (up_addr[3:0] == 4'h2)) begin\n        up_scratch <= up_wdata;\n      end\n    end\n  end\n\n  always @(negedge up_rstn or posedge up_clk) begin\n    if (up_rstn == 0) begin\n      up_int_ack <= 'd0;\n      up_int_rdata <= 'd0;\n    end else begin\n      up_int_ack <= up_sel_s;\n      if (up_sel_s == 1'b1) begin\n        case (up_addr[3:0])\n          4'h0: up_int_rdata <= PCORE_VERSION;\n          4'h1: up_int_rdata <= PCORE_ID;\n          4'h2: up_int_rdata <= up_scratch;\n          default: up_int_rdata <= 32'd0;\n        endcase\n      end else begin\n        up_int_rdata <= 32'd0;\n      end\n    end\n  end\n\nendmodule"}
{"task_id": 455, "completion": "output X   ;\n    input  A1  ;\n    input  A2  ;\n    input  B1  ;\n    input  VPWR;\n    input  VGND;\n    input  VPB ;\n    input  VNB ;\n    sky130_fd_sc_hd__o21a base (\n        .X(X),\n        .A1(A1),\n        .A2(A2),\n        .B1(B1),\n        .VPWR(VPWR),\n        .VGND(VGND),\n        .VPB(VPB),\n        .VNB(VNB)\n    );\n\nendmodule"}
{"task_id": 482, "completion": "sky130_fd_sc_hdll__mux2 base (\n        .X(X),\n        .A0(A0),\n        .A1(A1),\n        .S(S),\n        .VPWR(VPWR),\n        .VGND(VGND),\n        .VPB(VPB),\n        .VNB(VNB)\n    );\n\nendmodule"}
{"task_id": 483, "completion": "sky130_fd_sc_hs__or3b base (        .X(X),        .A(A),        .B(B),        .C_N(C_N),        .VPWR(VPWR),        .VGND(VGND)    );\n\nendmodule\n\n\n    sky130_fd_sc_hs__or3b base (        .X(X),        .A(A),        .B(B),        .C_N(C_N)    );\n\nendmodule"}
{"task_id": 472, "completion": "parameter MASTER_GROUP_8 = 0;\n    reg [68:0] rin;\n    reg [68:0] rout;\n\n    assign rcn_out = rout;\n\n    wire [2:0] my_id = MASTER_GROUP_8;\n\n    wire my_resp = rin[68] && !rin[67] && (rin[65:63] == MASTER_GROUP_8);\n\n    wire req_valid;\n    wire [68:0] req;\n\n    always @ (posedge clk or posedge rst)\n        if (rst)\n        begin\n            rin <= 69'd0;\n            rout <= 69'd0;\n        end\n        else\n        begin\n            rin <= rcn_in;\n            rout <= (req_valid) ? req : (my_resp) ? 69'd0 : rin;\n        end\n\n    assign busy = rin[68] && !my_resp;\n    assign req_valid = cs && !(rin[68] && !my_resp);\n    assign req = {1'b1, 1'b1, wr, my_id, seq[4:2], mask, addr[23:2], seq[1:0], wdata};\n\n    assign rdone = my_resp && !rin[66];\n    assign wdone = my_resp && rin[66];\n    assign rsp_seq = {rin[62:60], rin[33:32]};\n    assign rsp_mask = rin[59:56];\n    assign rsp_addr = {rin[55:34], 2'd0};\n    assign rsp_data = rin[31:0];\n\nendmodule"}
{"task_id": 441, "completion": "`define DLY #1\n    reg       [0:63]     TX_PE_DATA;\n    reg                  TX_PE_DATA_V;\n    reg                  in_frame_r;\n    wire                 in_frame_c;\n    wire                 ll_valid_c;\n    wire      [0:63]     tx_pe_data_c;\n    assign ll_valid_c =  s_axi_tx_tvalid & s_axi_tx_tready;\n    always @(posedge USER_CLK)\n        if(!CHANNEL_UP)\n            in_frame_r <=  `DLY    1'b0;\n        else if(ll_valid_c)\n        begin\n            if(s_axi_tx_tvalid && !s_axi_tx_tlast)\n                in_frame_r <=  `DLY    1'b1;\n            else if(s_axi_tx_tlast)\n                in_frame_r <=  `DLY    1'b0;\n        end\n    assign in_frame_c =   ll_valid_c  & (in_frame_r  | s_axi_tx_tvalid);\n    assign  tx_pe_data_c =  s_axi_tx_tdata;\n    always @(posedge USER_CLK)\n    begin\n        TX_PE_DATA <=  `DLY    tx_pe_data_c;\n        TX_PE_DATA_V <=  `DLY    in_frame_c;\n    end\nendmodule"}
{"task_id": 458, "completion": "`ifndef NO_IP\n    mp mp(\n      .clk(clk),\n      .a(mpcand_i),\n      .b(mplier_i),\n      .p(mprod_o));\n    `else\n    reg [23:0] delay_a[4:0];\n    reg [23:0] delay_b[4:0];\n\n    always @(posedge clk) begin\n        delay_a[0] <= mpcand_i;\n        delay_a[1] <= delay_a[0];\n        delay_a[2] <= delay_a[1];\n        delay_a[3] <= delay_a[2];\n        delay_a[4] <= delay_a[3];\n\n        delay_b[0] <= mplier_i;\n        delay_b[1] <= delay_b[0];\n        delay_b[2] <= delay_b[1];\n        delay_b[3] <= delay_b[2];\n        delay_b[4] <= delay_b[3];\n    end\n    wire [23:0] delayed_a = delay_a[4];\n    wire [23:0] delayed_b = delay_b[4];\n\n    wire [46:0] prod_full = $signed(delayed_a) * $signed(delayed_b);\n    assign mprod_o = prod_full[46:19];\n    `endif\nendmodule\n\nmodule mpemu_scale(\n    input wire clk,\n    input wire [23:0] mpcand_i,\n    input wire [31:0] scale_i,\n    output wire [31:0] mprod_o);\n    `ifndef NO_IP\n    mp_scale mp_scale(\n      .clk(clk),\n      .a(mpcand_i),\n      .b(scale_i),\n      .p(mprod_o));\n    `else\n    reg [23:0] delay_a[6:0];\n    reg [31:0] delay_b[6:0];\n\n    always @(posedge clk) begin\n        delay_a[0] <= mpcand_i;\n        delay_a[1] <= delay_a[0];\n        delay_a[2] <= delay_a[1];\n        delay_a[3] <= delay_a[2];\n        delay_a[4] <= delay_a[3];\n        delay_a[5] <= delay_a[4];\n        delay_a[6] <= delay_a[5];\n\n        delay_b[0] <= scale_i;\n        delay_b[1] <= delay_b[0];\n        delay_b[2] <= delay_b[1];\n        delay_b[3] <= delay_b[2];\n        delay_b[4] <= delay_b[3];\n        delay_b[5] <= delay_b[4];\n    end\n    wire [23:0] delayed_a = delay_a[5];\n    wire [31:0] delayed_b = delay_b[5];\n    wire signed [32:0] delayed_b_signed = {1'b0, delay_b[5]};\n\n    wire [23:0] delayed_a2 = delay_a[6];\n    wire [31:0] delayed_b2 = delay_b[6];\n\n    wire signed [55:0] prod_full = $signed(delayed_a) * $signed(delayed_b_signed);\n    assign mprod_o = prod_full[55:24];\n    `endif\nendmodule"}
{"task_id": 492, "completion": "// \u4e58\u6cd5\u5b9e\u73b0\u7684\u5177\u4f53\u903b\u8f91\n        // (\u7701\u7565\u5177\u4f53\u5b9e\u73b0\u4ee3\u7801)\n    \nendmodule"}
{"task_id": 491, "completion": "endmodule"}
{"task_id": 487, "completion": "wire buf_Q  ;\n    wire mux_out;\n\n    sky130_fd_sc_hs__u_mux_2_1             u_mux_20   (mux_out, D, SCD, SCE             );\n    sky130_fd_sc_hs__u_df_p_pg `UNIT_DELAY u_df_p_pg0 (buf_Q  , mux_out, CLK, VPWR, VGND);\n    buf                                    buf0       (Q      , buf_Q                   );\n\nendmodule"}
{"task_id": 364, "completion": "wire cin_b;    wire cin_buf;    wire mbc_sleep_b_int;    wire mbc_isolate_b_int;    wire mbc_reset_b_int;    wire next_mbc_isolate;    wire next_mbc_isolate_b;    wire sleep_req_isol;    wire sleep_req_b_isol;    wire mbc_isolate_int;    wire mbc_sleep_int;    wire goingsleep;    wire mbc_reset_int;    wire clr_ext_int_iso;    wire RESETn_local;    wire RESETn_local2;    wire mbus_busy_b_isol;    wire int_busy;    wire int_busy_b;    wire ext_int_dout;    wire cout_from_bus_iso;    wire cout_int;    wire cout_unbuf;    wire dout_from_bus_iso;    wire dout_int_1;    wire dout_int_0;    wire dout_unbuf;    wire addr_clr_b_iso;    wire [3:0] addr_in_iso;    wire RESETn_local3;    wire addr_update;    INVX1DG_TJ65IOH  INV_cin_b   (.Y(cin_b), .A(CIN));    INVX2DG_TJ65IOH  INV_cin_buf (.Y(cin_buf), .A(cin_b));    INVX1DG_TJ65IOH INV_mbc_sleep_b_int (.Y(mbc_sleep_b_int), .A(mbc_sleep_int));    INVX8DG_TJ65IOH INV_MBC_SLEEP       (.Y(MBC_SLEEP),       .A(mbc_sleep_b_int));    INVX8DG_TJ65IOH INV_MBC_SLEEP_B     (.Y(MBC_SLEEP_B),     .A(mbc_sleep_int));    INVX1DG_TJ65IOH INV_mbc_isolate_b_int (.Y(mbc_isolate_b_int), .A(mbc_isolate_int));    INVX8DG_TJ65IOH INV_MBC_ISOLATE       (.Y(MBC_ISOLATE),       .A(mbc_isolate_b_int));    INVX8DG_TJ65IOH INV_MBC_ISOLATE_B     (.Y(MBC_ISOLATE_B),     .A(mbc_isolate_int));    INVX1DG_TJ65IOH INV_mbc_reset_b_int (.Y(mbc_reset_b_int), .A(mbc_reset_int));    INVX8DG_TJ65IOH INV_MBC_RESET       (.Y(MBC_RESET),       .A(mbc_reset_b_int));    INVX8DG_TJ65IOH INV_MBC_RESET_B     (.Y(MBC_RESET_B),     .A(mbc_reset_int));    INVX1DG_TJ65IOH  INV_next_mbc_isolate    (.Y(next_mbc_isolate), .A(next_mbc_isolate_b));    NOR3X1DG_TJ65IOH NOR3_next_mbc_isolate_b (.C(goingsleep), .B(sleep_req_isol), .A(mbc_sleep_int), .Y(next_mbc_isolate_b));    INVX1DG_TJ65IOH   INV_next_goingsleep      (.Y(sleep_req_isol), .A(sleep_req_b_isol));    NAND2X1DG_TJ65IOH NAND2_next_goingsleep_b  (.Y(sleep_req_b_isol), .A(SLEEP_REQ), .B(mbc_isolate_b_int));    DFFSRX1DG_TJ65IOH DFFSR_mbc_isolate_int (.SN(RESETn), .RN(1'b1),   .CK(cin_buf), .Q(mbc_isolate_int), .QN(), .D(next_mbc_isolate));    DFFSRX1DG_TJ65IOH DFFSR_mbc_sleep_int   (.SN(RESETn), .RN(1'b1),   .CK(cin_buf), .Q(mbc_sleep_int),   .QN(), .D(goingsleep));    DFFSRX1DG_TJ65IOH DFFSR_goingsleep      (.SN(1'b1),   .RN(RESETn), .CK(cin_buf), .Q(goingsleep),      .QN(), .D(sleep_req_isol));    DFFSRX1DG_TJ65IOH DFFSR_mbc_reset_int   (.SN(RESETn), .RN(1'b1),   .CK(cin_b),   .Q(mbc_reset_int),   .QN(), .D(mbc_isolate_int));    AND2X1DG_TJ65IOH AND2_clr_ext_int_iso (.Y(clr_ext_int_iso), .A(MBC_ISOLATE_B), .B(CLR_EXT_INT));    INVX1DG_TJ65IOH  INV_clr_ext_int_b    (.Y(clr_ext_int_b),   .A(clr_ext_int_iso));    AND2X1DG_TJ65IOH AND2_RESETn_local (.Y(RESETn_local), .A(CIN), .B(RESETn));    AND2X1DG_TJ65IOH AND2_RESETn_local2 (.Y(RESETn_local2), .A(clr_ext_int_b), .B(RESETn));    NAND2X1DG_TJ65IOH NAND2_mbus_busy_b_isol (.A(MBUS_BUSY), .B(mbc_reset_b_int), .Y(mbus_busy_b_isol));    NAND3X1DG_TJ65IOH NAND3_int_busy_b (.A(WAKEUP_REQ), .B(mbus_busy_b_isol), .C(LRC_SLEEP), .Y(int_busy_b));    INVX2DG_TJ65IOH   INV_int_busy     (.Y(int_busy), .A(int_busy_b));    DFFRX1DG_TJ65IOH DFFR_ext_int_dout (.RN(RESETn_local), .CK(int_busy), .Q(ext_int_dout), .QN(), .D(1'b1));    DFFRX1DG_TJ65IOH DFFR_EXTERNAL_INT (.RN(RESETn_local2), .CK(int_busy), .Q(EXTERNAL_INT), .QN(), .D(1'b1));    OR2X1DG_TJ65IOH    OR2_cout_from_bus_iso (.Y(cout_from_bus_iso), .A(COUT_FROM_BUS), .B(MBC_ISOLATE));    MUX2X1DG_TJ65IOH   MUX2_cout_int         (.S(MBC_ISOLATE), .A(cout_from_bus_iso), .Y(cout_int), .B(CIN));    MUX2X1DG_TJ65IOH   MUX2_cout_unbuf       (.S(RESETn), .A(1'b1), .Y(cout_unbuf), .B(cout_int));    BUFX4DG_TJ65IOH    BUF_COUT              (.A(cout_unbuf), .Y(COUT));    OR2X1DG_TJ65IOH    OR2_dout_from_bus_iso (.Y(dout_from_bus_iso), .A(DOUT_FROM_BUS), .B(MBC_ISOLATE));    MUX2X1DG_TJ65IOH   MUX2_dout_int_1       (.S(MBC_ISOLATE), .A(dout_from_bus_iso), .Y(dout_int_1),    .B(DIN));    MUX2X1DG_TJ65IOH   MUX2_dout_int_0       (.S(ext_int_dout), .A(dout_int_1), .Y(dout_int_0), .B(1'b0));    MUX2X1DG_TJ65IOH   MUX2_dout_unbuf       (.S(RESETn), .A(1'b1), .Y(dout_unbuf), .B(dout_int_0));    BUFX4DG_TJ65IOH    BUF_DOUT              (.A(dout_unbuf), .Y(DOUT));    OR2X1DG_TJ65IOH  AND2_addr_clr_b_iso (.A(MBC_ISOLATE),   .B(ADDR_CLR_B),  .Y(addr_clr_b_iso));    AND2X1DG_TJ65IOH AND2_addr_in_iso_0  (.A(MBC_ISOLATE_B), .B(ADDR_IN[0]), .Y(addr_in_iso[0]));    AND2X1DG_TJ65IOH AND2_addr_in_iso_1  (.A(MBC_ISOLATE_B), .B(ADDR_IN[1]), .Y(addr_in_iso[1]));    AND2X1DG_TJ65IOH AND2_addr_in_iso_2  (.A(MBC_ISOLATE_B), .B(ADDR_IN[2]), .Y(addr_in_iso[2]));    AND2X1DG_TJ65IOH AND2_addr_in_iso_3  (.A(MBC_ISOLATE_B), .B(ADDR_IN[3]), .Y(addr_in_iso[3]));    AND2X1DG_TJ65IOH AND2_RESETn_local3 (.A(RESETn),      .B(addr_clr_b_iso), .Y(RESETn_local3));    AND2X1DG_TJ65IOH AND2_addr_update (.A(MBC_ISOLATE_B), .B(ADDR_WR_EN), .Y(addr_update));    DFFSX1DG_TJ65IOH DFFS_ADDR_OUT_0 (.CK(addr_update), .D(addr_in_iso[0]), .SN(RESETn_local3), .Q(ADDR_OUT[0]), .QN());    DFFSX1DG_TJ65IOH DFFS_ADDR_OUT_1 (.CK(addr_update), .D(addr_in_iso[1]), .SN(RESETn_local3), .Q(ADDR_OUT[1]), .QN());    DFFSX1DG_TJ65IOH DFFS_ADDR_OUT_2 (.CK(addr_update), .D(addr_in_iso[2]), .SN(RESETn_local3), .Q(ADDR_OUT[2]), .QN());    DFFSX1DG_TJ65IOH DFFS_ADDR_OUT_3 (.CK(addr_update), .D(addr_in_iso[3]), .SN(RESETn_local3), .Q(ADDR_OUT[3]), .QN());    DFFRX1DG_TJ65IOH DFFR_ADDR_VALID (.CK(addr_update), .D(1'b1),           .RN(RESETn_local3), .Q(ADDR_VALID),  .QN());endmodule"}
{"task_id": 420, "completion": "wire clk_in,rst,pa,pb,pc,ddd,ddd0;     reg clk0,clk1,clk2,clk3;     reg rst0,rst1,rst2,rst3;     reg p0,p1,p2,p00,p01,p02,ps,pd,ph;     reg df,df_0;     always@(sell)     begin         case (sell)         0:          begin             clk0=clk_in;             rst0=rst;             p0=pa;             p1=pb;             p2=pc;             clk1=0;             rst1=1;             p00=1;             p01=1;             p02=1;             clk2=0;             rst2=0;             ps=1;             pd=1;             ph=1;             df=0;             df_0=0;             clk3=0;             rst3=0;         end         1:          begin             clk1=clk_in;             rst1=rst;             p00=pa;             p01=pb;             p02=pc;             clk0=clk_in;             rst0=1;             p0=1;             p1=1;             p2=1;             clk2=0;             rst2=0;             ps=1;             pd=1;             ph=1;             df=0;             df_0=0;             clk3=0;             rst3=0;         end         2 :          begin             clk2=clk_in;             rst2=rst;             ps=pa;             pd=pb;             ph=pc;             df=ddd;             df_0=ddd0;             clk0=0;             rst0=0;             p00=1;             p01=1;             p02=1;             clk1=0;             rst1=0;             p0=1;             p1=1;             p2=1;             clk3=0;             rst3=0;         end         3 :          begin             clk3=clk_in;             rst3=rst;             clk0=0;             rst0=0;             p00=1;             p01=1;             p02=1;             clk1=0;             rst1=0;             p0=1;             p1=1;             p2=1;             clk2=0;             rst2=0;             ps=1;             pd=1;             ph=1;             df=0;             df_0=0;         end     endcase     end     assign sel_o = sell; endmodule"}
{"task_id": 436, "completion": "reg [ADDR_WIDTH:0] wr_ptr = {ADDR_WIDTH+1{1'b0}}, wr_ptr_next;\n    reg [ADDR_WIDTH:0] wr_ptr_gray = {ADDR_WIDTH+1{1'b0}};\n    reg [ADDR_WIDTH:0] rd_ptr = {ADDR_WIDTH+1{1'b0}}, rd_ptr_next;\n    reg [ADDR_WIDTH:0] rd_ptr_gray = {ADDR_WIDTH+1{1'b0}};\n\n    reg [ADDR_WIDTH:0] wr_ptr_gray_sync1 = {ADDR_WIDTH+1{1'b0}};\n    reg [ADDR_WIDTH:0] wr_ptr_gray_sync2 = {ADDR_WIDTH+1{1'b0}};\n    reg [ADDR_WIDTH:0] rd_ptr_gray_sync1 = {ADDR_WIDTH+1{1'b0}};\n    reg [ADDR_WIDTH:0] rd_ptr_gray_sync2 = {ADDR_WIDTH+1{1'b0}};\n\n    reg input_rst_sync1 = 1;\n    reg input_rst_sync2 = 1;\n    reg output_rst_sync1 = 1;\n    reg output_rst_sync2 = 1;\n\n    reg [DATA_WIDTH+KEEP_WIDTH+2-1:0] data_out_reg = {1'b0, 1'b0, {KEEP_WIDTH{1'b0}}, {DATA_WIDTH{1'b0}}};\n\n    //(* RAM_STYLE=\"BLOCK\" *)\n    reg [DATA_WIDTH+KEEP_WIDTH+2-1:0] mem[(2**ADDR_WIDTH)-1:0];\n\n    reg output_read = 1'b0;\n\n    reg output_axis_tvalid_reg = 1'b0;\n\n    wire [DATA_WIDTH+KEEP_WIDTH+2-1:0] data_in = {input_axis_tlast, input_axis_tuser, input_axis_tkeep, input_axis_tdata};\n\n    wire full = ((wr_ptr_gray[ADDR_WIDTH] != rd_ptr_gray_sync2[ADDR_WIDTH]) &&\n                 (wr_ptr_gray[ADDR_WIDTH-1] != rd_ptr_gray_sync2[ADDR_WIDTH-1]) &&\n                 (wr_ptr_gray[ADDR_WIDTH-2:0] == rd_ptr_gray_sync2[ADDR_WIDTH-2:0]));\n    wire empty = rd_ptr_gray == wr_ptr_gray_sync2;\n\n    wire write = input_axis_tvalid & ~full;\n    wire read = (output_axis_tready | ~output_axis_tvalid_reg) & ~empty;\n\n    assign {output_axis_tlast, output_axis_tuser, output_axis_tkeep, output_axis_tdata} = data_out_reg;\n\n    assign input_axis_tready = ~full;\n    assign output_axis_tvalid = output_axis_tvalid_reg;\n\n    always @(posedge input_clk or posedge input_rst or posedge output_rst) begin\n        if (input_rst | output_rst) begin\n            input_rst_sync1 <= 1;\n            input_rst_sync2 <= 1;\n        end else begin\n            input_rst_sync1 <= 0;\n            input_rst_sync2 <= input_rst_sync1;\n        end\n    end\n\n    always @(posedge output_clk or posedge input_rst or posedge output_rst) begin\n        if (input_rst | output_rst) begin\n            output_rst_sync1 <= 1;\n            output_rst_sync2 <= 1;\n        end else begin\n            output_rst_sync1 <= 0;\n            output_rst_sync2 <= output_rst_sync1;\n        end\n    end\n\n    always @(posedge input_clk or posedge input_rst_sync2) begin\n        if (input_rst_sync2) begin\n            wr_ptr <= 0;\n        end else if (write) begin\n            mem[wr_ptr[ADDR_WIDTH-1:0]] <= data_in;\n            wr_ptr_next = wr_ptr + 1;\n            wr_ptr <= wr_ptr_next;\n            wr_ptr_gray <= wr_ptr_next ^ (wr_ptr_next >> 1);\n        end\n    end\n\n    always @(posedge input_clk or posedge input_rst_sync2) begin\n        if (input_rst_sync2) begin\n            rd_ptr_gray_sync1 <= 0;\n            rd_ptr_gray_sync2 <= 0;\n        end else begin\n            rd_ptr_gray_sync1 <= rd_ptr_gray;\n            rd_ptr_gray_sync2 <= rd_ptr_gray_sync1;\n        end\n    end\n\n    always @(posedge output_clk or posedge output_rst_sync2) begin\n        if (output_rst_sync2) begin\n            rd_ptr <= 0;\n        end else if (read) begin\n            data_out_reg <= mem[rd_ptr[ADDR_WIDTH-1:0]];\n            rd_ptr_next = rd_ptr + 1;\n            rd_ptr <= rd_ptr_next;\n            rd_ptr_gray <= rd_ptr_next ^ (rd_ptr_next >> 1);\n        end\n    end\n\n    always @(posedge output_clk or posedge output_rst_sync2) begin\n        if (output_rst_sync2) begin\n            wr_ptr_gray_sync1 <= 0;\n            wr_ptr_gray_sync2 <= 0;\n        end else begin\n            wr_ptr_gray_sync1 <= wr_ptr_gray;\n            wr_ptr_gray_sync2 <= wr_ptr_gray_sync1;\n        end\n    end\n\n    always @(posedge output_clk or posedge output_rst_sync2) begin\n        if (output_rst_sync2) begin\n            output_axis_tvalid_reg <= 1'b0;\n        end else if (output_axis_tready | ~output_axis_tvalid_reg) begin\n            output_axis_tvalid_reg <= ~empty;\n        end else begin\n            output_axis_tvalid_reg <= output_axis_tvalid_reg;\n        end\n    end\n\nendmodule"}
{"task_id": 471, "completion": "localparam FUNCT_NOP_OH     = 10'b0000000000;    localparam FUNCT_ADD_OH     = 10'b0000000001;    localparam FUNCT_SUB_OH     = 10'b0000000010;    localparam FUNCT_OR_OH      = 10'b0000000100;    localparam FUNCT_XOR_OH     = 10'b0000001000;    localparam FUNCT_AND_OH     = 10'b0000010000;    localparam FUNCT_STL_OH     = 10'b0000100000;    localparam FUNCT_STLU_OH    = 10'b0001000000;    localparam FUNCT_SLL_OH     = 10'b0010000000;    localparam FUNCT_SRL_OH     = 10'b0100000000;    localparam FUNCT_SRA_OH     = 10'b1000000000;    wire [31:0] op1_st1;    wire [31:0] op2_st1;    wire [31:0] op1_st2;    wire [31:0] op2_st2;    wire [31:0] result_nxt;    wire        flip_op2_st2;    wire [31:0] neg_op2_st2;    wire [5:0]  shft_amnt;    assign op1_st1 = (id_ex_mux1_cntl) ? id_ex_pc    : ct_ex_op1_st2;    assign op2_st1 = (id_ex_mux2_cntl) ? id_ex_immed : ct_ex_op2_st2;    assign op1_st2 = op1_st1;    assign op2_st2 = (flip_op2) ? neg_op2 : op2_st1;    assign flip_op2 == (id_ex_funct == FUNCT_SUB_OH) ? 1'b1 : 1'b0;    assign neg_op2 = (~op2_st1)+1;    assign shft_amnt = op2_st1 & 'h1f;    assign ex_mem_result = result_ff;    always @ (*) begin        case (id_ex_funct)         FUNCT_ADD_OH ,         FUNCT_SUB_OH : result_nxt = op1_st2 + op2_st2;        FUNCT_OR_OH  : result_nxt = op1_st2 | op2_st2;        FUNCT_XOR_OH : result_nxt = op1_st2 ^ op2_st2;        FUNCT_AND_OH : result_nxt = op1_st2 & op2_st2;        FUNCT_STL_OH : result_nxt = ($signed(op1_st2) < $signed(op2_st2)) ? 1'b1 : 1'b0;        FUNCT_STLU_OH: result_nxt = (op1_st2 < op2_st2) ? 1'b1 : 1'b0;        FUNCT_SLL_OH : result_nxt = op1_st2 << shft_amnt;        FUNCT_SRL_OH : result_nxt = op1_st2 >> shft_amnt;        FUNCT_SRA_OH : result_nxt = op1_st2 >>> shft_amnt;        default      : result_nxt = 32'b0;        endcase    end    always @ (posedge clk or negedge rstn) begin        if (~rstn) begin            result_ff <= 0;        end        else begin            result_ff <= result_nxt;        end    endendmodule"}
{"task_id": 485, "completion": "cluster_header I0 (/*AUTOINST*/\n                   // Outputs\n                   .dbginit_l           (dbginit_l),\n                   .cluster_grst_l      (cluster_grst_l),\n                   .rclk                (rclk),\n                   .so                  (so),\n                   // Inputs\n                   .gclk                (gclk),\n                   .cluster_cken        (cluster_cken),\n                   .arst_l              (arst_l),\n                   .grst_l              (grst_l),\n                   .adbginit_l          (adbginit_l),\n                   .gdbginit_l          (gdbginit_l),\n                   .si                  (si),\n                   .se                  (se));\n\nendmodule"}
{"task_id": 500, "completion": "reg Q_internal;\n    assign Q = (GATE) ? Q_internal : 1'b0;\n\n    always @(posedge GATE or negedge RESET) begin\n        if (!RESET) begin\n            Q_internal <= 1'b0;\n        end else begin\n            Q_internal <= D;\n        end\n    end\nendmodule"}
{"task_id": 495, "completion": "altera_pll #(\n\t\t.fractional_vco_multiplier(\"false\"),\n\t\t.reference_clock_frequency(\"50.0 MHz\"),\n\t\t.operation_mode(\"normal\"),\n\t\t.number_of_clocks(1),\n\t\t.output_clock_frequency0(\"100.000000 MHz\"),\n\t\t.phase_shift0(\"0 ps\"),\n\t\t.duty_cycle0(50),\n\t\t.pll_type(\"General\"),\n\t\t.pll_subtype(\"General\")\n\t) altera_pll_i (\n\t\t.rst\t(rst),\n\t\t.outclk\t({outclk_0}),\n\t\t.locked\t(locked),\n\t\t.fboutclk\t( ),\n\t\t.fbclk\t(1'b0),\n\t\t.refclk\t(refclk)\n\t);\n\nendmodule"}
{"task_id": 479, "completion": "wire [INDEX-1:0] wr1_a_d1;\n   wire [INDEX-1:0] wr2_a_d1;\n   wire din1_d1;\n   wire din2_d1;\n   wire wen1_d1;\n   wire wen2_d1;\n   wire [WIDTH-1:0] wr1_a_dec_d1;\n   wire [WIDTH-1:0] wr2_a_dec_d1;\n   wire [WIDTH-1:0] wen1_dec_d1;\n   wire [WIDTH-1:0] wen2_dec_d1;\n   wire [WIDTH-1:0] vec;\n   reg [WIDTH-1:0] vec_next;\n   wire [INDEX-1:0] rd_a_d1;\n   wire [WIDTH-1:0] rd_a_dec_d1;\n   wire dout;\n   integer i;\n\n   dff_ns #(INDEX) wr1_a_d1_ff (.din(wr1_a),\n\t\t\t\t    .clk(clk),\n\t\t\t\t    .q(wr1_a_d1));\n\n   dff_ns #(INDEX) wr2_a_d1_ff (.din(wr2_a),\n\t\t\t\t    .clk(clk),\n\t\t\t\t    .q(wr2_a_d1));\n\n   dff_ns #(1) din1_d1_ff (.din(din1),\n\t\t\t\t    .clk(clk),\n\t\t\t\t    .q(din1_d1));\n\n   dff_ns #(1) din2_d1_ff (.din(din2),\n\t\t\t\t    .clk(clk),\n\t\t\t\t    .q(din2_d1));\n\n   dff_ns #(1) wen1_d1_ff (.din(wen1),\n\t\t\t\t    .clk(clk),\n\t\t\t\t    .q(wen1_d1));\n\n   dff_ns #(1) wen2_d1_ff (.din(wen2),\n\t\t\t\t    .clk(clk),\n\t\t\t\t    .q(wen2_d1));\n\n   assign wr1_a_dec_d1 = 1'b1 << wr1_a_d1;\n   assign wr2_a_dec_d1 = 1'b1 << wr2_a_d1;\n   assign wen1_dec_d1 = {WIDTH{wen1_d1}} & wr1_a_dec_d1;\n   assign wen2_dec_d1 = {WIDTH{wen2_d1}} & wr2_a_dec_d1;\n\n   always @(din1_d1 or din2_d1 or rst_l or vec\n\t\t\t\t\t\t\t     or wen1_dec_d1 or wen2_dec_d1)\n     begin\n   \tfor (i=0; i<WIDTH; i=i+1)\n\t\t begin\n\t\t    vec_next[i] = ~rst_l ? 1'b0 :\n\t\t\t\t    wen1_dec_d1[i] ? din1_d1 :\n\t\t\t\t    wen2_dec_d1[i] ? din2_d1 :\n\t\t\t\t\t\t\t\t      vec[i];\n\t\t end\n     end\n\n   dff_ns #(WIDTH) vec_ff (.din(vec_next),\n\t\t\t\t\t\t .clk(clk),\n\t\t\t\t\t\t .q(vec));\n   dffe_ns #(WIDTH) dout_vec_ff (.din(vec),\n\t\t\t\t\t\t .en(tx_en),\n\t\t\t\t\t\t .clk(clk),\n\t\t\t\t\t\t .q(dout_vec));\n   dff_ns #(INDEX) rd_a_d1_ff (.din(rd_a),\n\t\t\t\t\t   .clk(clk),\n\t\t\t\t\t   .q(rd_a_d1));\n   assign rd_a_dec_d1 = 1'b1 << rd_a_d1;\n   assign dout = |(vec & rd_a_dec_d1);\nendmodule"}
{"task_id": 459, "completion": "// synthesis translate_off\n\n  BLK_MEM_GEN_V7_3 #(\n    .C_ADDRA_WIDTH(14),\n    .C_ADDRB_WIDTH(14),\n    .C_ALGORITHM(1),\n    .C_AXI_ID_WIDTH(4),\n    .C_AXI_SLAVE_TYPE(0),\n    .C_AXI_TYPE(1),\n    .C_BYTE_SIZE(9),\n    .C_COMMON_CLK(0),\n    .C_DEFAULT_DATA(\"0\"),\n    .C_DISABLE_WARN_BHV_COLL(0),\n    .C_DISABLE_WARN_BHV_RANGE(0),\n    .C_ENABLE_32BIT_ADDRESS(0),\n    .C_FAMILY(\"spartan6\"),\n    .C_HAS_AXI_ID(0),\n    .C_HAS_ENA(0),\n    .C_HAS_ENB(0),\n    .C_HAS_INJECTERR(0),\n    .C_HAS_MEM_OUTPUT_REGS_A(0),\n    .C_HAS_MEM_OUTPUT_REGS_B(0),\n    .C_HAS_MUX_OUTPUT_REGS_A(0),\n    .C_HAS_MUX_OUTPUT_REGS_B(0),\n    .C_HAS_REGCEA(0),\n    .C_HAS_REGCEB(0),\n    .C_HAS_RSTA(0),\n    .C_HAS_RSTB(0),\n    .C_HAS_SOFTECC_INPUT_REGS_A(0),\n    .C_HAS_SOFTECC_OUTPUT_REGS_B(0),\n    .C_INIT_FILE(\"BlankString\"),\n    .C_INIT_FILE_NAME(\"Ram.mif\"),\n    .C_INITA_VAL(\"0\"),\n    .C_INITB_VAL(\"0\"),\n    .C_INTERFACE_TYPE(0),\n    .C_LOAD_INIT_FILE(1),\n    .C_MEM_TYPE(0),\n    .C_MUX_PIPELINE_STAGES(0),\n    .C_PRIM_TYPE(1),\n    .C_READ_DEPTH_A(16384),\n    .C_READ_DEPTH_B(16384),\n    .C_READ_WIDTH_A(32),\n    .C_READ_WIDTH_B(32),\n    .C_RST_PRIORITY_A(\"CE\"),\n    .C_RST_PRIORITY_B(\"CE\"),\n    .C_RST_TYPE(\"SYNC\"),\n    .C_RSTRAM_A(0),\n    .C_RSTRAM_B(0),\n    .C_SIM_COLLISION_CHECK(\"ALL\"),\n    .C_USE_BRAM_BLOCK(0),\n    .C_USE_BYTE_WEA(0),\n    .C_USE_BYTE_WEB(0),\n    .C_USE_DEFAULT_DATA(0),\n    .C_USE_ECC(0),\n    .C_USE_SOFTECC(0),\n    .C_WEA_WIDTH(1),\n    .C_WEB_WIDTH(1),\n    .C_WRITE_DEPTH_A(16384),\n    .C_WRITE_DEPTH_B(16384),\n    .C_WRITE_MODE_A(\"WRITE_FIRST\"),\n    .C_WRITE_MODE_B(\"WRITE_FIRST\"),\n    .C_WRITE_WIDTH_A(32),\n    .C_WRITE_WIDTH_B(32),\n    .C_XDEVICEFAMILY(\"spartan6\")\n  )\n  inst (\n    .CLKA(clka),\n    .WEA(wea),\n    .ADDRA(addra),\n    .DINA(dina),\n    .DOUTA(douta),\n    .RSTA(),\n    .ENA(),\n    .REGCEA(),\n    .CLKB(),\n    .RSTB(),\n    .ENB(),\n    .REGCEB(),\n    .WEB(),\n    .ADDRB(),\n    .DINB(),\n    .DOUTB(),\n    .INJECTSBITERR(),\n    .INJECTDBITERR(),\n    .SBITERR(),\n    .DBITERR(),\n    .RDADDRECC(),\n    .S_ACLK(),\n    .S_ARESETN(),\n    .S_AXI_AWID(),\n    .S_AXI_AWADDR(),\n    .S_AXI_AWLEN(),\n    .S_AXI_AWSIZE(),\n    .S_AXI_AWBURST(),\n    .S_AXI_AWVALID(),\n    .S_AXI_AWREADY(),\n    .S_AXI_WDATA(),\n    .S_AXI_WSTRB(),\n    .S_AXI_WLAST(),\n    .S_AXI_WVALID(),\n    .S_AXI_WREADY(),\n    .S_AXI_BID(),\n    .S_AXI_BRESP(),\n    .S_AXI_BVALID(),\n    .S_AXI_BREADY(),\n    .S_AXI_ARID(),\n    .S_AXI_ARADDR(),\n    .S_AXI_ARLEN(),\n    .S_AXI_ARSIZE(),\n    .S_AXI_ARBURST(),\n    .S_AXI_ARVALID(),\n    .S_AXI_ARREADY(),\n    .S_AXI_RID(),\n    .S_AXI_RDATA(),\n    .S_AXI_RRESP(),\n    .S_AXI_RLAST(),\n    .S_AXI_RVALID(),\n    .S_AXI_RREADY(),\n    .S_AXI_INJECTSBITERR(),\n    .S_AXI_INJECTDBITERR(),\n    .S_AXI_SBITERR(),\n    .S_AXI_DBITERR(),\n    .S_AXI_RDADDRECC()\n  );\n\n  // synthesis translate_on\n\nendmodule"}
{"task_id": 516, "completion": "wire   buf0_out_X        ;\n    wire   u_vpwr_vgnd0_out_X;\n\n    buf                          buf0         (buf0_out_X        , A                     );\n    sky130_fd_sc_hs__u_vpwr_vgnd u_vpwr_vgnd0 (u_vpwr_vgnd0_out_X, buf0_out_X, VPWR, VGND);\n    buf                          buf1         (X                 , u_vpwr_vgnd0_out_X    );\n\nendmodule"}
{"task_id": 510, "completion": "output COUT;    output SUM ;    input  A   ;    input  B   ;    input  VPWR;    input  VGND;    input  VPB ;    input  VNB ;    sky130_fd_sc_ls__ha base (        .COUT(COUT),        .SUM(SUM),        .A(A),        .B(B),        .VPWR(VPWR),        .VGND(VGND),        .VPB(VPB),        .VNB(VNB)    );    endmodule"}
{"task_id": 515, "completion": "always @(x) begin: RECTIFIER_RELU\n        reg signed [16-1:0] zero;\n        reg signed [16-1:0] leaky;\n        if ((x > zero)) begin\n            y = x;\n        end\n        else begin\n            y = fixbv((leaky * x));\n        end\n    end\n\n    always @(x) begin: RECTIFIER_RELU_DX\n        reg signed [16-1:0] zero;\n        reg signed [16-1:0] leaky;\n        reg signed [16-1:0] one;\n        if ((x > zero)) begin\n            y_dx = one;\n        end\n        else begin\n            y_dx = leaky;\n        end\n    end\n\nendmodule"}
{"task_id": 431, "completion": "wire [5:0] state; assign LED[0] = GPIO_o[0]; assign LED[1] = GPIO_o[1]; assign LED[2] = GPIO_o[2]; assign LED[3] = GPIO_o[3]; assign LED[4] = GPIO_o[4]; assign LED[5] = GPIO_o[5]; assign LED[6] = GPIO_o[6]; assign LED[7] = GPIO_o[7]; wire core0_tf_push_o; wire [7:0] core0_print_data_o; wire [15:0] core_id; wire [7:0] openRISC_RSTN; wire [7:0] openRISC_STALL; wire [7:0] openRISC_ram_we; wire [15:0] openRISC_ram_addr; wire [31:0] openRISC_data_o; reg [31:0] openRISC_data_i,_openRISC_data_i; wire [31:0] openRISC_pc_0; wire [31:0] openRISC_pc_1; wire [31:0] openRISC_pc_2; wire [31:0] openRISC_pc_3; wire [31:0] openRISC_pc_4; wire [31:0] openRISC_pc_5; wire [31:0] openRISC_pc_6; wire [31:0] openRISC_pc_7; wire [31:0] openRISC_RAM_DATA_O_0, openRISC_RAM_DATA_O_1, openRISC_RAM_DATA_O_2, openRISC_RAM_DATA_O_3; wire [31:0] openRISC_RAM_DATA_O_4, openRISC_RAM_DATA_O_5, openRISC_RAM_DATA_O_6, openRISC_RAM_DATA_O_7; always@(posedge SDK_CLK or negedge SDK_RSTN) begin if(~SDK_RSTN) openRISC_data_i <= 32'd0; else openRISC_data_i <= _openRISC_data_i; end always@* begin case(core_id[3:0]) 4'd0: _openRISC_data_i = openRISC_RAM_DATA_O_0; 4'd1: _openRISC_data_i = openRISC_RAM_DATA_O_1; 4'd2: _openRISC_data_i = openRISC_RAM_DATA_O_2; 4'd3: _openRISC_data_i = openRISC_RAM_DATA_O_3; 4'd4: _openRISC_data_i = openRISC_RAM_DATA_O_4; 4'd5: _openRISC_data_i = openRISC_RAM_DATA_O_5; 4'd6: _openRISC_data_i = openRISC_RAM_DATA_O_6; 4'd7: _openRISC_data_i = openRISC_RAM_DATA_O_7; default: _openRISC_data_i = openRISC_RAM_DATA_O_0; endcase end OpenRISC_Interface OR_Interface0( .SDK_CLK(SDK_CLK), .SDK_RSTN(SDK_RSTN), .core0_tf_push_i(core0_tf_push_o), .core0_print_data_i(core0_print_data_o), .SDK_FIFO_RD(SDK_FIFO_RD), .SDK_FIFO_DI(SDK_FIFO_DI), .SDK_FIFO_Empty(SDK_FIFO_Empty), .SDK_FIFO_WR(SDK_FIFO_WR), .SDK_FIFO_DO(SDK_FIFO_DO), .SDK_FIFO_Full(SDK_FIFO_Full), .SDK_Interrupt(SDK_Interrupt), .openRISC_RSTN(openRISC_RSTN), .openRISC_STALL(openRISC_STALL), .openRISC_ram_we(openRISC_ram_we), .openRISC_ram_addr(openRISC_ram_addr), .openRISC_data_o(openRISC_data_o), .openRISC_data_i(openRISC_data_i), .core_id(core_id), .openRISC_pc_0(openRISC_pc_0), .openRISC_pc_1(openRISC_pc_1), .openRISC_pc_2(openRISC_pc_2), .openRISC_pc_3(openRISC_pc_3), .openRISC_pc_4(openRISC_pc_4), .openRISC_pc_5(openRISC_pc_5), .openRISC_pc_6(openRISC_pc_6), .openRISC_pc_7(openRISC_pc_7), .state_o(state) ); or1200_sopc or1200_sopc_inst_0 ( .CLOCK_48(SDK_CLK), .rst_n(openRISC_RSTN[0]), .openRISC_STALL(openRISC_STALL[0]), .openRISC_pc(openRISC_pc_0), .RAM_WE(openRISC_ram_we[0]), .RAM_ADDR(openRISC_ram_addr), .RAM_DATA_I(openRISC_data_o), .RAM_DATA_O(openRISC_RAM_DATA_O_0), .UART_TXD(core0_UART_TXD), .UART_RXD(core0_UART_RXD), .print_data_o(core0_print_data_o), .tf_push_o(core0_tf_push_o), .GPIO_o(GPIO_o), .GPIO_i(GPIO_i) ); endmodule"}
{"task_id": 548, "completion": "output Y   ;\n    input  A1_N;\n    input  A2_N;\n    input  B1  ;\n    input  B2  ;\n\n    supply1 VPWR;\n    supply0 VGND;\n\nendmodule"}
{"task_id": 513, "completion": "wire    dm_out;    wire    dm_ce_r;    FDRSE_1 u_dm_ce      (     .Q    (dm_ce_r),     .C    (clk90),     .CE   (1'b1),     .D    (dm_ce),     .R   (1'b0),     .S   (1'b0)     ) /* synthesis syn_preserve=1 */;    ODDR #    (     .SRTYPE(\"SYNC\"),     .DDR_CLK_EDGE(\"SAME_EDGE\")     )    u_oddr_dm      (       .Q  (dm_out),       .C  (clk90),       .CE (dm_ce_r),       .D1 (mask_data_rise),       .D2 (mask_data_fall),       .R  (1'b0),       .S  (1'b0)       );    OBUF u_obuf_dm      (     .I (dm_out),     .O (ddr_dm)     );endmodule"}
{"task_id": 525, "completion": "assign X = (A1 | A2) & B1 & C1 & D1;\nendmodule"}
{"task_id": 541, "completion": "supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\nendmodule"}
{"task_id": 445, "completion": "v7_ethernet_top v7_et\n(\n.glbl_rst(i_rst),\n.i_clk_200(i_clk_200),\n.phy_resetn(phy_resetn),\n.gtrefclk_p(gtrefclk_p),\n.gtrefclk_n(gtrefclk_n),\n.txp(txp),\n.txn(txn),\n.rxp(rxp),\n.rxn(rxn),\n.synchronization_done(synchronization_done),\n.linkup(linkup),\n.mdio_i(mdio_in),\n.mdio_o(mdio_out),\n.mdio_t(mdio_t),\n.mdc(mdc_out),\n.i_enet_enable(i_enet_enable),\n.i_enet_loopback(i_enet_loopback),\n.i_enet_ddr_source_addr(i_enet_ddr_source_addr),\n.i_enet_ddr_dest_addr(i_enet_ddr_dest_addr),\n.i_enet_rcv_data_size(i_enet_rcv_data_size),\n.i_enet_snd_data_size(i_enet_snd_data_size),\n.o_enet_rx_cnt(o_enet_rx_cnt),\n.o_enet_tx_cnt(o_enet_tx_cnt),\n.o_enet_rx_done(o_enet_rx_done),\n.o_enet_tx_done(o_enet_tx_done),\n.o_ddr_wr_req(o_ddr_wr_req),\n.o_ddr_rd_req(o_ddr_rd_req),\n.o_ddr_wr_data(o_ddr_wr_data),\n.o_ddr_wr_be(o_ddr_wr_be),\n.o_ddr_wr_addr(o_ddr_wr_addr),\n.o_ddr_rd_addr(o_ddr_rd_addr),\n.i_ddr_rd_data(i_ddr_rd_data),\n.i_ddr_wr_ack(i_ddr_wr_ack),\n.i_ddr_rd_ack(i_ddr_rd_ack),\n.i_ddr_rd_data_valid(i_ddr_rd_data_valid)\n);\n\nendmodule"}
{"task_id": 511, "completion": "module hls_contrast_streeOg_DSP48_3(\n    input  [9 - 1:0] in0,\n    input  [23 - 1:0] in1,\n    input  [31 - 1:0] in2,\n    output [32 - 1:0]  dout);\n\nwire signed [25 - 1:0]     a;\nwire signed [18 - 1:0]     b;\nwire signed [48 - 1:0]     c;\nwire signed [43 - 1:0]     m;\nwire signed [48 - 1:0]     p;\n\nassign a  = $unsigned(in1);\nassign b  = $signed(in0);\nassign c  = $unsigned(in2);\n\nassign m  = a * b;\nassign p  = m + c;\n\nassign dout = p;\n\nendmodule"}
{"task_id": 424, "completion": "reg  [6:0]  Emit_Counter;\n  reg  [6:0]  Delay_Counter;\n  always @(posedge Transmit_CLK or negedge RX_Gate)\n  begin\n   if(~RX_Gate) begin\n\t\tEmit_Counter <= 7'd0;\n\t\tDelay_Counter <= 8'd0;\n\t\tTXP <= 1'b1;\n\t\tTXN <= 1'b1;\n   end\n   else\n\t\tbegin\n\t\t  if(Delay_Counter < EmitDelay[6:0] ) begin\n\t\t\tDelay_Counter <= Delay_Counter + 1'b1;\n\t\t\tTXP <= 1'b1;\n\t\t\tTXN <= 1'b1;\n\t\t  end\n   \t\t  else begin\n\t\t\tif(~EmitDelay[7]) begin  //enble Emit\n\t\t\t\tif(Emit_Counter <Emit_Width)begin                        // Positive Pulse\n\t\t\t\t\tTXP <= 1'b1;\n\t\t\t\t\tTXN <= 1'b0;\n\t\t\t\t\tEmit_Counter <= Emit_Counter + 1'b1;\n\t\t\t\tend\n\t\t\t\telse if(Emit_Counter <{Emit_Width,1'b0})begin           // Negetive Pulse\n\t\t\t\t\tTXP <= 1'b0;\n\t\t\t\t\tTXN <= 1'b1;\n\t\t\t\t\tEmit_Counter <= Emit_Counter + 1'b1;\n\t\t\t\tend\n\t\t\t\telse if(Emit_Counter <({Emit_Width,2'b0}+Emit_Width))begin             //Return to Zero (RTZ)\n\t\t\t\t\tTXP <= 1'b0;\n\t\t\t\t\tTXN <= 1'b0;\n\t\t\t\t\tEmit_Counter <= Emit_Counter + 1'b1;\n\t\t\t\tend\n\t\t\t\telse begin                                                \n\t\t\t\t\tTXP <= 1'b1;\n\t\t\t\t\tTXN <= 1'b1;\n\t\t\t\tend\n\t\t\tend\n\t\t\telse begin              //disable Emit\n\t\t\t\tTXP <= 1'b1;\n\t\t\t\tTXN <= 1'b1;\n\t\t\tend\n\t\t  end\n\t\tend\n  end\nendmodule"}
{"task_id": 524, "completion": "// Voltage supply signals\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB;\n    supply0 VNB;\n\nendmodule"}
{"task_id": 530, "completion": "output Y   ;\n    input  A1  ;\n    input  A2  ;\n    input  B1  ;\n    input  VPWR;\n    input  VGND;\n    input  VPB ;\n    input  VNB ;\n\n    wire and0_out         ;\n    wire nor0_out_Y       ;\n    wire pwrgood_pp0_out_Y;\n\n    and                                 and0        (and0_out         , A1, A2                );\n    nor                                 nor0        (nor0_out_Y       , B1, and0_out          );\n    sky130_fd_sc_hvl__udp_pwrgood_pp$PG pwrgood_pp0 (pwrgood_pp0_out_Y, nor0_out_Y, VPWR, VGND);\n    buf                                 buf0        (Y                , pwrgood_pp0_out_Y     );\n\nendmodule"}
{"task_id": 547, "completion": "reg [11:0] data_buf;     always@(posedge clk or negedge reset_n)    begin                if (!reset_n)                    begin                              data_buf <= 0;                    end                else if (data_buf < 511)                      data_buf <= data_buf + 1'b1;                else                    data_buf <= 0;        end       assign Data_A = data_buf;      assign Data_B = Data_A + 1;      assign Data_C = Data_B + 1;      assign Data_D = Data_C + 1;       assign Data_E = data_buf;      assign Data_F = Data_E + 1;      assign Data_G = Data_F + 1;      assign Data_H = Data_G + 1;endmodule"}
{"task_id": 523, "completion": "reg [3:0] \t\tstate;\n   reg [15:0] \t\tbitCount;\n   reg [15:0] \t\tclkCounter;\n\n   // Generate SPI clock\n   // ADC operates from 0.8 to 3.2 MHz\n   always @ (posedge clk) begin\n      clkCounter = clkCounter + 1;\n      if (clkCounter == 33) begin\n         SCLK <= !SCLK;\n      end\n   end\n\n   always @ (SCLK) begin\n      if (!resn) begin\n         SS <= 1;\n         MOSI <= 0;\n         state <= 0;\n         bitCount <= 0;\n      end else begin\n         case (state)\n           0: begin\n              // Idle\n              if (trig) begin\n                 if (SCLK == 0) begin\n                    // SS should be lowered on the first falling edge of SCLK\n                    SS <= 0;\n                    state <= 1;\n                    bitCount <= 15;\n                 end\n              end\n           end\n\n           1: begin\n              if (SCLK == 0) begin\n                 // In order to avoid potential race conditions, the\n                 // user should generate MOSI on the negative edges of SCLK.\n                 MOSI <= wrData[bitCount];\n                 bitCount <= bitCount - 1;\n                 if (bitCount == 0) begin\n                    state <= 2;\n                 end\n              end else begin\n                 // Capture data bits on the rising edge of SCLK.\n                 rdData[bitCount] <= MISO;\n              end\n           end\n\n           2: begin\n              if (SCLK == 1) begin\n                 // SS should be raised on the last rising edge of an operational frame.\n                 SS <= 1;\n                 MOSI <= 0;\n                 state <= 0;\n                 bitCount <= 0;\n              end\n           end\n\n           default: ;\n         endcase\n      end\n   end\n\n   assign done = SS;\nendmodule"}
{"task_id": 473, "completion": "wire\tport_ac_2;\n\n\t// Internal signals\n\n\t// Generated Signal List\n\n\t\n\n\t// %COMPILER_OPTS%\n\n\t// Generated Signal Assignments\n\n\t\n\n\t// Generated Instances\n\t// wiring ...\n\n\t// Generated Instances and Port Mappings\n\nendmodule"}
{"task_id": 238, "completion": "reg             dac_enable = 'd0;\n  reg     [63:0]  dac_data = 'd0;\n  reg     [63:0]  dac_pn7_data = 'd0;\n  reg     [63:0]  dac_pn15_data = 'd0;\n  reg     [63:0]  dac_pn23_data = 'd0;\n  reg     [63:0]  dac_pn31_data = 'd0;\n  reg     [15:0]  dac_dds_phase_0_0 = 'd0;\n  reg     [15:0]  dac_dds_phase_0_1 = 'd0;\n  reg     [15:0]  dac_dds_phase_1_0 = 'd0;\n  reg     [15:0]  dac_dds_phase_1_1 = 'd0;\n  reg     [15:0]  dac_dds_phase_2_0 = 'd0;\n  reg     [15:0]  dac_dds_phase_2_1 = 'd0;\n  reg     [15:0]  dac_dds_phase_3_0 = 'd0;\n  reg     [15:0]  dac_dds_phase_3_1 = 'd0;\n  reg     [15:0]  dac_dds_incr_0 = 'd0;\n  reg     [15:0]  dac_dds_incr_1 = 'd0;\n  reg     [63:0]  dac_dds_data = 'd0;\n  wire    [15:0]  dac_dds_data_0_s;\n  wire    [15:0]  dac_dds_data_1_s;\n  wire    [15:0]  dac_dds_data_2_s;\n  wire    [15:0]  dac_dds_data_3_s;\n  wire    [15:0]  dac_dds_scale_1_s;\n  wire    [15:0]  dac_dds_init_1_s;\n  wire    [15:0]  dac_dds_incr_1_s;\n  wire    [15:0]  dac_dds_scale_2_s;\n  wire    [15:0]  dac_dds_init_2_s;\n  wire    [15:0]  dac_dds_incr_2_s;\n  wire    [15:0]  dac_pat_data_1_s;\n  wire    [15:0]  dac_pat_data_2_s;\n  wire    [ 3:0]  dac_data_sel_s;\n  function [63:0] pn7;\n    input [63:0] din;\n    reg   [63:0] dout;\n    begin\n      dout[63] = din[ 7] ^ din[ 6];\n      // ...\n      pn7 = dout;\n    end\n  endfunction\n  function [63:0] pn15;\n    input [63:0] din;\n    reg   [63:0] dout;\n    begin\n      dout[63] = din[15] ^ din[14];\n      // ...\n      pn15 = dout;\n    end\n  endfunction\n  function [63:0] pn23;\n    input [63:0] din;\n    reg   [63:0] dout;\n    begin\n      dout[63] = din[23] ^ din[18];\n      // ...\n      pn23 = dout;\n    end\n  endfunction\n  function [63:0] pn31;\n    input [63:0] din;\n    reg   [63:0] dout;\n    begin\n      dout[63] = din[31] ^ din[28];\n      // ...\n      pn31 = dout;\n    end\n  endfunction\n  always @(posedge dac_clk) begin\n    dac_enable <= (dac_data_sel_s == 4'h2) ? 1'b1 : 1'b0;\n    case (dac_data_sel_s)\n      4'h7: dac_data <= dac_pn31_data;\n      // ...\n      default: dac_data <= dac_dds_data;\n    endcase\n  end\n  always @(posedge dac_clk) begin\n    if (dac_data_sync == 1'b1) begin\n      dac_pn7_data <= {64{1'd1}};\n      // ...\n    end else begin\n      dac_pn7_data <= pn7(dac_pn7_data);\n      // ...\n    end\n  end\n  always @(posedge dac_clk) begin\n    // ...\n  end\n  generate\n  if (DP_DISABLE == 1) begin\n  assign dac_dds_data_0_s = 16'd0;\n  // ...\n  end\n  endgenerate\n  up_dac_channel #(.PCORE_DAC_CHID(CHID)) i_up_dac_channel (\n    .dac_clk (dac_clk),\n    .dac_rst (dac_rst),\n    // ...\n  );\nendmodule"}
{"task_id": 505, "completion": "tri1\tclock;\n\n\twire [11:0] sub_wire0;\n\twire [11:0] q = sub_wire0[11:0];\n\n\taltsyncram\taltsyncram_component (\n\t\t\t.address_a (address),\n\t\t\t.clock0 (clock),\n\t\t\t.q_a (sub_wire0),\n\t\t\t.aclr0 (1'b0),\n\t\t\t.aclr1 (1'b0),\n\t\t\t.address_b (1'b1),\n\t\t\t.addressstall_a (1'b0),\n\t\t\t.addressstall_b (1'b0),\n\t\t\t.byteena_a (1'b1),\n\t\t\t.byteena_b (1'b1),\n\t\t\t.clock1 (1'b1),\n\t\t\t.clocken0 (1'b1),\n\t\t\t.clocken1 (1'b1),\n\t\t\t.clocken2 (1'b1),\n\t\t\t.clocken3 (1'b1),\n\t\t\t.data_a ({12{1'b1}}),\n\t\t\t.data_b (1'b1),\n\t\t\t.eccstatus (),\n\t\t\t.q_b (),\n\t\t\t.rden_a (1'b1),\n\t\t\t.rden_b (1'b1),\n\t\t\t.wren_a (1'b0),\n\t\t\t.wren_b (1'b0));\n\tdefparam\n\t\taltsyncram_component.address_aclr_a = \"NONE\",\n\t\taltsyncram_component.clock_enable_input_a = \"BYPASS\",\n\t\taltsyncram_component.clock_enable_output_a = \"BYPASS\",\n\t\taltsyncram_component.init_file = \"./sprites/reading.mif\",\n\t\taltsyncram_component.intended_device_family = \"Cyclone V\",\n\t\taltsyncram_component.lpm_hint = \"ENABLE_RUNTIME_MOD=NO\",\n\t\taltsyncram_component.lpm_type = \"altsyncram\",\n\t\taltsyncram_component.numwords_a = 4096,\n\t\taltsyncram_component.operation_mode = \"ROM\",\n\t\taltsyncram_component.outdata_aclr_a = \"NONE\",\n\t\taltsyncram_component.outdata_reg_a = \"UNREGISTERED\",\n\t\taltsyncram_component.widthad_a = 12,\n\t\taltsyncram_component.width_a = 12,\n\t\taltsyncram_component.width_byteena_a = 1;\n\nendmodule"}
{"task_id": 543, "completion": "always @(posedge clk) begin\n        if(reset)\n            rd_pointer <= 0;\n        else if(read && !empty) begin\n            if(rd_pointer == DEPTH-1'b1)\n                rd_pointer <= 0;\n            else\n                rd_pointer <= rd_pointer + 1'b1;\n        end\n    end\n\n    always @(*) begin\n        rd_tmp = rd_pointer;\n        if(read && !empty) begin\n            if(rd_pointer == DEPTH-1'b1)\n                rd_tmp = 0;\n            else\n                rd_tmp = rd_pointer + 1'b1;\n        end\n    end\n\n    always @(posedge clk) begin\n        if(reset)\n            wr_pointer <= 0;\n        else if(write && !full) begin\n            if(wr_pointer == DEPTH-1'b1)\n                wr_pointer <= 0;\n            else\n                wr_pointer <= wr_pointer + 1;\n        end\n    end\n\n    always @(posedge clk)\n        if (reset)\n            empty <= 1;\n        else if(read && !empty)\n            if(rd_pointer == DEPTH-1'b1)\n                empty <= (wr_pointer == 0);\n            else\n                empty <= (wr_pointer == rd_pointer+1'b1);\n        else\n            empty <= empty_loc;\n\n    assign empty_loc = (wr_pointer == rd_pointer);\n    assign full = ((wr_pointer==(DEPTH-1'b1) && rd_pointer==0) || (wr_pointer!=(DEPTH-1'b1) && wr_pointer+1'b1 == rd_pointer));\n\n    always @(posedge clk)\n        if(write && !full)\n            mem[wr_pointer] <= data_in;\n\n    always @(posedge clk)\n        data_out <= mem[rd_tmp];\n\n    always @(*) begin\n        if(wr_pointer >= rd_pointer)\n            size = wr_pointer - rd_pointer;\n        else\n            size = wr_pointer + (DEPTH-rd_pointer);\n    end\nendmodule"}
{"task_id": 478, "completion": "wire  [9:0]                 mux_o;    wire  [SIZE*10 - 1:0]  proc_unit_o;    genvar i;    generate        for(i = 0; i < SIZE; i = i + 1) begin: PU            processing_unit #(            .PRV_SIZE        (PRV_SIZE),             .PRV_LOOP        (PRV_LOOP),             .BIAS            (BIAS),             .WEIGHT_WIDTH    (WEIGHT_WIDTH))            PU(                .clk_i            (clk_i),                .rst_i            (rst),                .en_i            (en_i),                .weight_i        (weight_bus_i[`IDX(i, WEIGHT_WIDTH)]),                .data_i            (data_i),                .proc_unit_o    (proc_unit_o[`ID10(i)])            );        end    endgenerate    sig_mux #(        .SIZE(SIZE),         .WIDTH(10)    )    sig_mux(        .sel(sig_mux_sel_i),        .mux_i(proc_unit_o),        .mux_o(mux_o)    );    sig_368p sig_368p(        .sig_i(mux_o),        .sig_o(data_o)    );endmodule"}
{"task_id": 493, "completion": "input clk, wclk, rst;\ninput ps_ce;\ninput resume;\noutput suspended;\noutput sync;\noutput [5:0] out_le;\noutput [2:0] in_valid;\noutput ld;\noutput valid;\n\nreg [7:0] cnt;\nreg sync_beat;\nreg sync_resume;\nreg [5:0] out_le;\nreg ld;\nreg valid;\nreg [2:0] in_valid;\nreg bit_clk_capture;\nreg bit_clk_capture_r;\nreg bit_clk_e;\nreg suspended;\nwire to;\nreg [5:0] to_cnt;\nreg [3:0] res_cnt;\nwire resume_done;\n\nassign sync = sync_beat | sync_resume;\n\nalways @(posedge clk or negedge rst)\n\tif(!rst) cnt <= #1 8'hff;\n\telse if(suspended) cnt <= #1 8'hff;\n\telse cnt <= #1 cnt + 8'h1;\n\nalways @(posedge clk)\n\tld <= #1 (cnt == 8'h00);\n\nalways @(posedge clk)\n\tsync_beat <= #1 (cnt == 8'h00) | ((cnt > 8'h00) & (cnt < 8'h10));\n\nalways @(posedge clk)\n\tvalid <= #1 (cnt > 8'h39);\n\nalways @(posedge clk)\n\tout_le[0] <= #1 (cnt == 8'h11);\n\nalways @(posedge clk)\n\tout_le[1] <= #1 (cnt == 8'h25);\n\nalways @(posedge clk)\n\tout_le[2] <= #1 (cnt == 8'h39);\n\nalways @(posedge clk)\n\tout_le[3] <= #1 (cnt == 8'h4d);\n\nalways @(posedge clk)\n\tout_le[4] <= #1 (cnt == 8'h61);\n\nalways @(posedge clk)\n\tout_le[5] <= #1 (cnt == 8'h89);\n\nalways @(posedge clk)\n\tin_valid[0] <= #1 (cnt > 8'h4d);\n\nalways @(posedge clk)\n\tin_valid[1] <= #1 (cnt > 8'h61);\n\nalways @(posedge clk)\n\tin_valid[2] <= #1 (cnt > 8'h89);\n\nalways @(clk or bit_clk_e)\n\tif(clk) bit_clk_capture <= #1 1'b1;\n\telse if(bit_clk_e) bit_clk_capture <= #1 1'b0;\n\nalways @(posedge wclk)\n\tbit_clk_capture_r <= #1 bit_clk_capture;\nalways @(posedge wclk)\n\tbit_clk_e <= #1 bit_clk_capture_r;\nalways @(posedge wclk)\n\tsuspended <= #1 to;\n\nassign to = (to_cnt == `AC97_SUSP_DET);\n\nalways @(posedge wclk or negedge rst)\n\tif(!rst) to_cnt <= #1 6'h0;\n\telse if(bit_clk_e) to_cnt <= #1 6'h0;\n\telse if(!to) to_cnt <= #1 to_cnt + 6'h1;\n\nalways @(posedge wclk or negedge rst)\n\tif(!rst) sync_resume <= #1 1'b0;\n\telse if(resume_done) sync_resume <= #1 1'b0;\n\telse if(suspended & resume) sync_resume <= #1 1'b1;\n\nassign resume_done = (res_cnt == `AC97_RES_SIG);\n\nalways @(posedge wclk)\n\tif(!sync_resume) res_cnt <= #1 4'h0;\n\telse if(ps_ce) res_cnt <= #1 res_cnt + 4'h1;\n\nendmodule"}
{"task_id": 520, "completion": "always @(posedge clock)\n\nbegin\n  if(wren)\n  ac_mem[wraddress] <= data;\n  q <= ac_mem[rdaddress];\n\nend\n\n\nendmodule"}
{"task_id": 544, "completion": "output X   ;\n    input  A1  ;\n    input  A2  ;\n    input  A3  ;\n    input  B1  ;\n    input  VPWR;\n    input  VGND;\n    sky130_fd_sc_hs__a31o base (\n        .X(X),\n        .A1(A1),\n        .A2(A2),\n        .A3(A3),\n        .B1(B1),\n        .VPWR(VPWR),\n        .VGND(VGND)\n    );\n\nendmodule"}
{"task_id": 432, "completion": "wire  reg_0_rst;\n  wire  reg_0_clk;\n  wire  reg_0_en;\n  wire  reg_0_q;\n  wire  reg_0_d;\n  wire  reg_1_rst;\n  wire  reg_1_clk;\n  wire  reg_1_en;\n  wire  reg_1_q;\n  wire  reg_1_d;\n  wire  reg_2_rst;\n  wire  reg_2_clk;\n  wire  reg_2_en;\n  wire  reg_2_q;\n  wire  reg_2_d;\n  wire  T_8;\n  wire  T_9;\n  wire  T_10;\n  wire [1:0] T_11;\n  wire [2:0] T_12;\n  sirv_AsyncResetReg reg_0 (\n    .rst(reg_0_rst),\n    .clk(reg_0_clk),\n    .en(reg_0_en),\n    .q(reg_0_q),\n    .d(reg_0_d)\n  );\n  sirv_AsyncResetReg reg_1 (\n    .rst(reg_1_rst),\n    .clk(reg_1_clk),\n    .en(reg_1_en),\n    .q(reg_1_q),\n    .d(reg_1_d)\n  );\n  sirv_AsyncResetReg reg_2 (\n    .rst(reg_2_rst),\n    .clk(reg_2_clk),\n    .en(reg_2_en),\n    .q(reg_2_q),\n    .d(reg_2_d)\n  );\n  assign io_q = T_12;\n  assign reg_0_rst = reset;\n  assign reg_0_clk = clock;\n  assign reg_0_en = io_en;\n  assign reg_0_d = T_8;\n  assign reg_1_rst = reset;\n  assign reg_1_clk = clock;\n  assign reg_1_en = io_en;\n  assign reg_1_d = T_9;\n  assign reg_2_rst = reset;\n  assign reg_2_clk = clock;\n  assign reg_2_en = io_en;\n  assign reg_2_d = T_10;\n  assign T_8 = io_d[0];\n  assign T_9 = io_d[1];\n  assign T_10 = io_d[2];\n  assign T_11 = {reg_2_q,reg_1_q};\n  assign T_12 = {T_11,reg_0_q};\nendmodule"}
{"task_id": 531, "completion": "localparam RATIO_SLOPE_DURATOIN = DIRECT_SLOPE_DURATION / REVERSE_SLOPE_DURATION;\n    reg dir;\n    reg [15:0] counter;\n \n    always @ (posedge clk)\n    begin\n         if (!areset_n) \n         begin\n              out_value <= 0;\n              counter <=0;\n              dir <= 0;\n         end \n         else\n         begin\n              counter <= counter + 1;\n            if(dir == 0)\n            begin\n                    if (counter == CHANNEL_DURATION)\n                     begin  \n                    out_value <= out_value + 1;\n                          counter <= 0;\n                     end\n                if(out_value == DIRECT_SLOPE_DURATION)\n                    dir <= 1;\n            end\n            else\n            begin\n                    if (counter == CHANNEL_DURATION)\n                     begin\n                    out_value <= out_value > RATIO_SLOPE_DURATOIN ? out_value - RATIO_SLOPE_DURATOIN : 0;\n                          counter <= 0;\n                     end\n                if(out_value == 0)\n                    dir <= 0;\n            end\n          end\n    end\n\nendmodule"}
{"task_id": 554, "completion": "reg [31:0] counter;\n\n    always @(posedge usb_clk) begin\n\tif(usb_rst) begin\n\t\tcounter <= 32'd0;\n\t\tio_do <= 32'd0;\n\tend else begin\n\t\tio_do <= 32'd0;\n\t\tcase(io_a)\n\t\t\t6'h11: io_do <= counter[7:0];\n\t\t\t6'h12: io_do <= counter[15:8];\n\t\t\t6'h13: io_do <= counter[23:16];\n\t\t\t6'h14: io_do <= counter[31:24];\n\t\tendcase\n\t\tif(io_we & ((io_a == 6'h11)|(io_a == 6'h12)|(io_a == 6'h13)|(io_a == 6'h14)))\n\t\t\tcounter <= 32'd0;\n\t\telse\n\t\t\tcounter <= counter + 32'd1;\n\tend\nend\n\nendmodule"}
{"task_id": 372, "completion": "wire [4:0] sub_wire0;\n    wire [0:0] sub_wire8 = 1'h0;\n    wire [4:4] sub_wire5 = sub_wire0[4:4];\n    wire [3:3] sub_wire4 = sub_wire0[3:3];\n    wire [2:2] sub_wire3 = sub_wire0[2:2];\n    wire [1:1] sub_wire2 = sub_wire0[1:1];\n    wire [0:0] sub_wire1 = sub_wire0[0:0];\n    wire  c0 = sub_wire1;\n    wire  c1 = sub_wire2;\n    wire  c2 = sub_wire3;\n    wire  c3 = sub_wire4;\n    wire  c4 = sub_wire5;\n    wire  sub_wire6 = inclk0;\n    wire [1:0] sub_wire7 = {sub_wire8, sub_wire6};\n\n    tes_pll_altpll tes_pll_altpll_component (\n        .areset (areset),\n        .inclk (sub_wire7),\n        .clk (sub_wire0));\n\nendmodule"}
{"task_id": 555, "completion": "reg clk_y;\n\treg [3:0] clk_cnt_y;\n\n\talways@(posedge clk_i,negedge reset_n_i)\n\tbegin\n\t\tif (!reset_n_i)\n\t\tbegin\n\t\t\tclk_cnt_y <= 0;\n\t\t\tclk_y <= 0;\n\t\tend\n\t\telse if(clk_en)\n\t\tbegin\n\t\t\tif(clk_cnt_y == clk_div_i-1)\n\t\t\tbegin\n\t\t\t\tclk_y <= ~clk_y; \n\t\t\t\tclk_cnt_y <= 0;\n\t\t\tend\n\t\t\telse \n\t\t\t\tclk_cnt_y <= clk_cnt_y +1;\n\t\tend\n\t\telse\n\t\t\tclk_y <= 0;\n\tend\n\n\tassign clk_o = (clk_div_i==0) ? clk_i : clk_y;\n\nendmodule"}
{"task_id": 451, "completion": "parameter GetData = 2'b00;parameter DataP = 2'b01;parameter DataN = 2'b10;reg [1:0]ps;reg [1:0]ns;wire clk_blf_n;wire en_mil_out;wire m2o;wire mp_complete;wire me_start;reg [5:0]mp_end;reg [5:0]mp_cnt;reg m_cnt;reg m1o;reg [1:0]data_select;reg [1:0]fg_comp_cnt;assign clk_blf_n = ~clk_blf;assign en_mil_out = (mp_cnt > 6'h0)? 1'b1 : 1'b0;assign miller_data = (en_mil_out & ~mil_complete)? m2o : 1'b0;assign m2o = mp_complete? m1o : clk_blf;assign mp_complete = (mp_cnt == mp_end)? 1'b1 : 1'b0;assign me_start = (mp_cnt > mp_end - 6'h2)? 1'b1 : 1'b0; always@(*) begin if(~trext) mp_end = 6'h9;else mp_end = 6'h21;end always@(posedge clk_mil or negedge rst_for_new_package) begin if(~rst_for_new_package) mp_cnt <= 6'h0;else begin if(mp_cnt == mp_end) mp_cnt <= mp_cnt;else if(~en_fm0 & st_enc) mp_cnt <= mp_cnt + 6'h1; end end always@(posedge clk_mil or negedge rst_for_new_package) begin if(~rst_for_new_package) m_cnt <= 1'b0;else if(me_start) m_cnt <= m_cnt + 1'b1; end always@(posedge clk_mil or negedge rst_for_new_package) begin if(~rst_for_new_package) ps <= GetData;else if(st_enc) ps <= ns; end always@(*) begin case(ps) GetData : if(~en_fm0 & me_start) ns = DataP;else ns = GetData; DataP : if(~send_data) ns = DataP;else begin if(~m_cnt) ns = DataP;else ns = DataN; end DataN : if(~send_data) ns = DataN;else begin if(~m_cnt) ns = DataN;else ns = DataP; end default : ns = GetData; endcase end always@(*) begin case(ps) GetData : data_select = 2'h0; DataP : data_select = 2'h1; DataN : data_select = 2'h2; default : data_select = 2'h0; endcase end always@(*) begin case(data_select) 2'h0 : m1o = 1'b0; 2'h1 : m1o = clk_blf; 2'h2 : m1o = clk_blf_n; default : m1o = 1'b0; endcase end always@(posedge clk_mil or negedge rst_for_new_package) begin if(~rst_for_new_package) fg_comp_cnt <= 2'b0;else begin if(fg_comp_cnt == 2'b11) fg_comp_cnt <= fg_comp_cnt;else if(~en_fm0 & fg_complete) fg_comp_cnt <= fg_comp_cnt + 2'b1; end end assign mil_complete = (fg_comp_cnt == 2'b11)? 1'b1 : 1'b0;endmodule"}
{"task_id": 374, "completion": "localparam [7:0] OP_NOP                  = 8'h00; localparam [7:0] OP_DBG_BRK              = 8'h01; localparam [7:0] OP_DBG_RUN              = 8'h02; localparam [7:0] OP_QUERY_DBG_BRK        = 8'h03; localparam [7:0] OP_CPU_MEM_RD           = 8'h04; localparam [7:0] OP_CPU_MEM_WR           = 8'h05; localparam [7:0] OP_CPU_REG_RD           = 8'h06; localparam [7:0] OP_CPU_REG_WR           = 8'h07; localparam [7:0] OP_PPU_MEM_RD           = 8'h08; localparam [7:0] OP_PPU_MEM_WR           = 8'h09; localparam [7:0] OP_PPU_DISABLE          = 8'h0A; localparam [7:0] OP_CART_SET_CFG         = 8'h0B; localparam [4:0] S_DISABLED             = 5'h00; localparam [4:0] S_DECODE               = 5'h01; localparam [4:0] S_CPU_MEM_RD           = 5'h02; localparam [4:0] S_CPU_MEM_WR           = 5'h03; localparam [4:0] S_CPU_REG_RD           = 5'h04; localparam [4:0] S_CPU_REG_WR           = 5'h05; localparam [4:0] S_PPU_MEM_RD           = 5'h06; localparam [4:0] S_PPU_MEM_WR           = 5'h07; localparam [4:0] S_PPU_DISABLE_STG_0    = 5'h08; localparam [4:0] S_PPU_DISABLE_STG_1    = 5'h09; localparam [4:0] S_PPU_DISABLE_STG_2    = 5'h0A; localparam [4:0] S_PPU_DISABLE_STG_3    = 5'h0B; localparam [4:0] S_PPU_DISABLE_STG_4    = 5'h0C; localparam [4:0] S_PPU_DISABLE_STG_5    = 5'h0D; localparam [4:0] S_CART_SET_CFG         = 5'h0E; localparam       OS_OK                  = 32'h00000001; localparam       OS_ERROR               = 32'h00000002; localparam       OS_UNKNOWN_OPCODE      = 32'h00000004; localparam       OS_COUNT_IS_ZERO       = 32'h00000008; reg         [4:0]   state; reg         [15:0]  r_execute_count; reg                 r_host_one_shot; reg         [15:0]  r_address; assign              o_dbg_active        = (state != S_DISABLED); always @ (posedge clk) begin if (rst || i_reset_sm) begin state             <=  S_DECODE; o_opcode_ack      <=  0; o_opcode_status   <=  0; r_execute_count   <=  0; o_hci_ready       <=  0; o_data_strobe     <=  0; o_data            <=  0; o_cpu_address     <=  0; o_cpu_dout        <=  0; o_cpu_r_nw        <=  1; o_cpu_dbg_reg_wr  <=  0; o_cpu_dbg_reg_sel <=  0; o_cpu_dbg_reg_dout<=  0; o_ppu_vram_wr     <=  0; o_ppu_vram_dout   <=  0; o_ppu_vram_address<=  0; o_cart_cfg        <=  0; o_cart_cfg_update <=  0; r_host_one_shot   <=  0; r_address         <=  0; end else begin o_opcode_ack      <=  0; o_opcode_status   <=  0; o_hci_ready       <=  0; o_cart_cfg_update <=  0; o_cpu_r_nw        <=  1; o_ppu_vram_wr     <=  0; o_data_strobe     <=  0; o_cpu_dbg_reg_wr  <=  0; case (state) S_DISABLED: begin o_hci_ready                   <=  1; if (i_cpu_break) begin state                       <=  S_DECODE; end else if (i_opcode_strobe) begin case (i_opcode) OP_DBG_BRK: begin state                   <=  S_DECODE; o_opcode_status         <=  OS_OK; o_opcode_ack            <=  1; end OP_QUERY_DBG_BRK: begin o_opcode_status         <=  OS_ERROR; o_opcode_ack            <=  1; end OP_NOP: begin o_opcode_status         <=  OS_OK; o_opcode_ack            <=  1; end endcase end end S_DECODE: begin o_hci_ready                   <=  1; r_execute_count               <=  0; r_address                     <=  i_address; o_cpu_address                 <=  0; o_ppu_vram_address            <=  0; o_cpu_dbg_reg_sel             <=  4'h0; o_cpu_dbg_reg_sel             <=  i_address[3:0]; r_host_one_shot               <=  1; if (i_opcode_strobe) begin case (i_opcode) OP_CPU_MEM_RD:  begin o_cpu_address           <=  i_address; state                   <= S_CPU_MEM_RD; end OP_CPU_MEM_WR:     state  <= S_CPU_MEM_WR; OP_CPU_REG_RD:     state  <= S_CPU_REG_RD; OP_CPU_REG_WR:     state  <= S_CPU_REG_WR; OP_PPU_MEM_RD: begin o_ppu_vram_address      <=  i_address; state                   <= S_PPU_MEM_RD; end OP_PPU_MEM_WR:     state  <= S_PPU_MEM_WR; OP_CART_SET_CFG:   state  <= S_CART_SET_CFG; OP_DBG_BRK:        state  <= S_DECODE; OP_PPU_DISABLE:    state  <= S_PPU_DISABLE_STG_0; OP_DBG_RUN: begin state                 <=  S_DISABLED; o_opcode_status       <=  OS_OK; o_opcode_ack          <=  1; end OP_QUERY_DBG_BRK: begin o_opcode_status       <=  OS_OK; o_opcode_ack          <=  1; end OP_NOP: begin o_opcode_status       <=  OS_OK; o_opcode_ack          <=  1; end default: begin o_opcode_status       <=  OS_UNKNOWN_OPCODE | OS_ERROR; o_opcode_ack          <=  1; end endcase end end S_CPU_MEM_RD: begin if (r_execute_count >= i_count) begin o_opcode_status             <=  OS_OK; o_opcode_ack                <=  1; state                       <=  S_DECODE; end if (i_host_ready && r_host_one_shot) begin o_data                      <=  i_cpu_din; o_data_strobe               <=  1; r_host_one_shot             <=  0; end if (o_data_strobe) begin r_execute_count             <=  r_execute_count + 32'h00000001; o_cpu_address               <=  o_cpu_address + 16'h0001; end if (!i_host_ready) begin r_host_one_shot             <=  1; end end S_CPU_MEM_WR: begin if (r_execute_count >= i_count) begin o_opcode_status             <=  OS_OK; o_opcode_ack                <=  1; state                       <=  S_DECODE; end else if (i_data_strobe) begin o_cpu_dout                  <=  i_data; o_cpu_r_nw                  <=  0; o_cpu_address               <=  r_address; end else begin o_hci_ready                 <=  1; end if (!o_cpu_r_nw) begin r_execute_count             <=  r_execute_count + 32'h00000001; r_address                   <=  r_address + 16'h0001; end end S_CPU_REG_RD: begin if (i_host_ready) begin o_data                      <=  i_cpu_dbg_reg_din; o_data_strobe               <=  1; o_opcode_status             <=  OS_OK; o_opcode_ack                <=  1; state                       <=  S_DECODE; end end S_CPU_REG_WR: begin o_hci_ready                   <=  1; if (i_data_strobe) begin o_cpu_dbg_reg_wr            <=  1; o_cpu_dbg_reg_dout          <=  i_data; o_opcode_status             <=  OS_OK; o_opcode_ack                <=  1; state                       <=  S_DECODE; end end S_PPU_MEM_RD: begin if (r_execute_count >= i_count) begin o_opcode_status             <=  OS_OK; o_opcode_ack                <=  1; state                       <=  S_DECODE; end else if (i_host_ready && r_host_one_shot) begin o_data                      <=  i_ppu_vram_din; o_data_strobe               <=  1; r_host_one_shot             <=  0; end if (o_data_strobe) begin r_execute_count             <=  r_execute_count + 32'h00000001; o_ppu_vram_address          <=  o_ppu_vram_address + 16'h0001; end if (!i_host_ready) begin r_host_one_shot             <=  1; end end S_PPU_MEM_WR: begin if (r_execute_count >= i_count) begin o_opcode_status             <=  OS_OK; o_opcode_ack                <=  1; state                       <=  S_DECODE; end else if (i_data_strobe) begin o_ppu_vram_dout             <=  i_data; o_ppu_vram_wr               <=  1; o_ppu_vram_address          <=  r_address; end else begin o_hci_ready                 <=  1; end if (o_ppu_vram_wr) begin r_execute_count             <=  r_execute_count + 32'h00000001; r_address                   <=  r_address + 16'h0001; end end S_PPU_DISABLE_STG_0: begin o_cpu_address                 <=  16'h2000; state                         <=  S_PPU_DISABLE_STG_1; end S_PPU_DISABLE_STG_1: begin o_cpu_r_nw                    <=  1; o_cpu_dout                    <=  8'h00; o_cpu_address                 <=  16'h0000; state                         <=  S_PPU_DISABLE_STG_2; end S_PPU_DISABLE_STG_2: begin o_cpu_address                 <=  16'h2001; state                         <=  S_PPU_DISABLE_STG_3; end S_PPU_DISABLE_STG_3: begin o_cpu_r_nw                    <=  1; o_cpu_dout                    <=  8'h00; o_cpu_address                 <=  16'h0000; state                         <=  S_PPU_DISABLE_STG_4; end S_PPU_DISABLE_STG_4: begin o_cpu_address                 <=  16'h2002; state                         <=  S_PPU_DISABLE_STG_5; end S_PPU_DISABLE_STG_5: begin o_cpu_address                 <=  16'h0000; o_opcode_status               <=  OS_OK; o_opcode_ack                  <=  1; state                         <=  S_DECODE; end S_CART_SET_CFG: begin if (r_execute_count >= 4) begin o_opcode_status             <=  OS_OK; o_opcode_ack                <=  1; state                       <=  S_DECODE; o_cart_cfg_update           <=  1; end else if (i_data_strobe && o_hci_ready) begin o_hci_ready                 <=  0; r_execute_count             <=  r_execute_count + 32'h00000001; o_cart_cfg                  <=  {o_cart_cfg[31:0], i_data}; end else begin o_hci_ready                 <=  1; end end default: begin state                         <=  S_DECODE; end endcase end end endmodule"}
{"task_id": 583, "completion": "always @*        begin            case(select)                2'b00: data_out <= {W{1'b0}};                2'b01: data_out <= ch_0;                2'b10: data_out <= ch_1;                2'b11: data_out <= ch_2;                default : data_out <= ch_0;            endcase        endendmodule"}
{"task_id": 509, "completion": "output Q      ;\n    output Q_N    ;\n    input  CLK    ;\n    input  D      ;\n    input  SCD    ;\n    input  SCE    ;\n    input  RESET_B;\n    sky130_fd_sc_ls__sdfrbp base (\n        .Q(Q),\n        .Q_N(Q_N),\n        .CLK(CLK),\n        .D(D),\n        .SCD(SCD),\n        .SCE(SCE),\n        .RESET_B(RESET_B),\n        .VPWR(VPWR),\n        .VGND(VGND),\n        .VPB(VPB),\n        .VNB(VNB)\n    );\n\nendmodule"}
{"task_id": 579, "completion": "endmodule"}
{"task_id": 571, "completion": "wire [4:0] n;\n    wire [8:0] data;\n    counter count(mclock, resetn, n);\n    memory memory_control(n, mclock, data);\n    proc processor(data, resetn, pclock, run, done, bus);\nendmodule"}
{"task_id": 444, "completion": "reg [NUM_PORTS-1:0] dout_s;\n   reg  [CLK_DIVIDER_WIDTH-1:0]  clk_count;\n   wire [CLK_DIVIDER_WIDTH-1:0]  next_clk_count = clk_count + 1;\n   wire pulse = next_clk_count == (clk_divider >> 1);\n   reg    state;\n\n`ifdef verilator\n   localparam LOG2_DATA_WIDTH = $clog2(DATA_WIDTH+1);\n`else\n   function integer log2;\n      input integer value;\n      integer       count;\n      begin\n         value = value-1;\n         for (count=0; value>0; count=count+1)\n           value = value>>1;\n      end\n   endfunction\n   localparam LOG2_DATA_WIDTH = log2(DATA_WIDTH+1);\n`endif\n\n   reg [LOG2_DATA_WIDTH:0] shift_count;\n\n   wire start = shift_count == 0;\n   /* verilator lint_off WIDTH */\n   wire [31:0] stop_detect = ((half_cycle_n)+1)*DATA_WIDTH-1;\n   wire stop  = shift_count >= stop_detect;\n   /* verilator lint_on WIDTH */\n\n   localparam IDLE_STATE = 0,\n              RUN_STATE = 1;\n\n   sro #(.DATA_WIDTH(DATA_WIDTH)) sro[NUM_PORTS-1:0]\n     (.clk(clk),\n      .resetb(resetb),\n      .shift(pulse && !csb && (shift_count[0] == 0)),\n      .dout(dout),\n      .datao(datao));\n\n   sri #(.DATA_WIDTH(DATA_WIDTH)) sri[NUM_PORTS-1:0]\n     (.clk(clk),\n      .resetb(resetb),\n      .datai(half_cycle_n ? datai : {datai[DATA_WIDTH/2-1:0], {DATA_WIDTH/2{1'b0}}}),\n      .sample(go && (state == IDLE_STATE)),\n      .shift(pulse && !csb && (shift_count[0] == 1)),\n      .din(din));\n\n`ifdef SYNC_RESET\n   always @(posedge clk) begin\n`else\n   always @(posedge clk or negedge resetb) begin\n`endif\n      if(!resetb) begin\n         clk_count <= 0;\n         shift_count <= 0;\n         sclk  <= 1;\n         csb   <= 1;\n         state <= IDLE_STATE;\n         busy  <= 0;\n         done  <= 0;\n      end else begin\n         if(pulse) begin\n            clk_count <= 0;\n         end else begin\n            clk_count <= next_clk_count;\n         end\n\n         if(state == IDLE_STATE) begin\n            csb  <= 1;\n            shift_count <= 0;\n            done <= 0;\n            if(go && !busy) begin\n               state  <= RUN_STATE;\n               busy   <= 1;\n            end else begin\n               busy   <= 0;\n            end\n         end else begin\n            if(pulse) begin\n               if(stop) begin\n                  csb <= 1;\n                  state <= IDLE_STATE;\n                  done  <= 1;\n               end else begin\n                  csb <= 0;\n                  if(!csb) begin \n                     shift_count <= shift_count + 1;\n                  end\n               end\n            end\n         end\n\n         if(pulse) begin\n            if((CPHA==1 && state==RUN_STATE && !stop) || \n               (CPHA==0 && !csb)) begin\n               sclk <= !sclk;\n            end else begin\n               sclk <= CPOL;\n            end\n         end\n      end\n   end\nendmodule // spi_master\n\nmodule sri\n  #(parameter DATA_WIDTH=16)\n  (input clk,\n   input resetb,\n   input [DATA_WIDTH-1:0] datai,\n   input sample,\n   input shift,\n   output din\n   );\n\n   reg [DATA_WIDTH-1:0] sr_reg;\n   assign din = sr_reg[DATA_WIDTH-1];\n\n`ifdef SYNC_RESET\n   always @(posedge clk) begin\n`else\n   always @(posedge clk or negedge resetb) begin\n`endif\n      if(!resetb) begin\n         sr_reg <= 0;\n      end else begin\n         if(sample) begin\n            sr_reg <= datai;\n         end else if(shift) begin\n            sr_reg <= sr_reg << 1;\n         end\n      end\n   end\nendmodule\n\nmodule sro\n  #(parameter DATA_WIDTH=16)\n  (input clk,\n   input resetb,\n   input shift,\n   input dout,\n   output reg [DATA_WIDTH-1:0] datao\n   );\n   reg                     dout_s;\n   \n`ifdef SYNC_RESET\n   always @(posedge clk) begin\n`else      \n   always @(posedge clk or negedge resetb) begin\n`endif      \n      if(!resetb) begin\n         dout_s <= 0;\n         datao <= 0;\n      end else begin\n         dout_s <= dout;\n         if(shift) begin\n            datao <= { datao[DATA_WIDTH-2:0], dout_s };\n         end\n      end\n   end\nendmodule"}
{"task_id": 403, "completion": "reg [ 5:0] curr_ch;\n\twire       stop = curr_ch[5];\n\n\treg [3:0] st;\n\treg [3:0] next_st;\n\n\twire ch_ena = ch_enas[curr_ch[4:0]];\n\n\treg [31:0] offset;\n\treg        off_cy;\n\treg oversize;\n\n\treg [5:0] vol_left;\n\treg [5:0] vol_right;\n\treg loopena;\n\treg surround;\n\treg [21:0] base;\n\n\treg [1:0] addr_emit;\n\n\tlocalparam ST_BEGIN     = 4'd0;\n\tlocalparam ST_GETOFFS   = 4'd1;\n\tlocalparam ST_GETADDVOL = 4'd2;\n\tlocalparam ST_GETSIZE   = 4'd3;\n\tlocalparam ST_GETLOOP   = 4'd4;\n\tlocalparam ST_SAVEOFFS  = 4'd5;\n\tlocalparam ST_NEXT = 4'd14;\n\tlocalparam ST_WAIT = 4'd15;\n\t\n\talways @(posedge clk)\n\t\t if( st==ST_WAIT )\n\t\t\tcurr_ch[5:0] <= 6'd0;\n\t\t else if( st==ST_NEXT )\n\t\t\tcurr_ch[5:0] <= curr_ch[5:0] + 6'd1;\n\n\talways @(posedge clk, negedge rst_n)\n\t\tif( !rst_n )\n\t\t\tst <= ST_WAIT;\n\t\t else\n\t\t\tst <= next_st;\n\t\n\talways @*\n\tcase( st )\n\tST_BEGIN:\n\tif( stop )\n\t\tnext_st = ST_WAIT;\n\telse if( !ch_ena )\n\t\tnext_st = ST_NEXT;\n\telse\n\t\tnext_st = ST_GETOFFS;\n\tST_GETOFFS:\n\t\tnext_st = ST_GETADDVOL;\n\tST_GETADDVOL:\n\t\tnext_st = ST_GETSIZE;\n\tST_GETSIZE:\n\t\tnext_st = ST_GETLOOP;\n\tST_GETLOOP:\n\t\tnext_st = ST_SAVEOFFS;\n\tST_SAVEOFFS:\n\t\tnext_st = ST_NEXT;\n\tST_NEXT:\n\t\tnext_st = ST_BEGIN;\n\tST_WAIT:\n\tif( sync_stb )\n\t\tnext_st = ST_BEGIN;\n\t else\n\t\tnext_st = ST_WAIT;\n\tdefault: next_st = ST_WAIT;\n\tendcase\n\n\talways @*\n\t\trd_addr[6:2] <= curr_ch[4:0];\n\talways @*\n\t\twr_addr[6:2] <= curr_ch[4:0];\n\talways @(posedge clk)\n\t\twr_addr[1:0] <= 2'd0;\n\talways @(posedge clk)\n\t\tif( st==ST_NEXT || st==ST_WAIT )\n\t\t\trd_addr[1:0] <= 2'd0;\n\t\t else if( st==ST_BEGIN || st==ST_GETOFFS || st==ST_GETADDVOL )\n\t\t\trd_addr[1:0] <= rd_addr[1:0] + 2'd1;\n\talways @(posedge clk)\n\t\tif( st==ST_GETOFFS )\n\t\t\toffset <= rd_data;\n\t\t else if( st==ST_GETADDVOL )\n\t\t\t{off_cy, offset} <= {1'b0, offset} + {1'b0, 14'd0, rd_data[31:14]};\n\t\t else if( st==ST_GETLOOP )\n\t\t\toffset[31:12] <= oversize ? (offset[31:12]+rd_data[27:8]) : offset[31:12];\n\talways @(posedge clk)\n\t\tif( st==ST_GETSIZE )\n\t\t\tover B<= ( {off_cy,offset[31:12]} >= {1'b0, rd_data[27:8]} );\n\talways @(posedge clk)\n\t\twr_stb <= st==ST_SAVEOFFS;\n\tassign wr_data = offset;\n\talways @(posedge clk)\n\t\tif( st==ST_GETADDVOL )\n\t\tbegin\n\t\t\tvol_left  <= rd_data[11:6];\n\t\t\tvol_right <= rd_data[ 5:0];\n\n\t\t\tloopena  <= rd_data[13];\n\t\t\tsurround <= rd_data[12];\n\tend\n\talways @(posedge clk)\n\t\tif( st==ST_GETSIZE )\n\t\t\tbase[15:8] <= rd_data[7:0];\n\t\t else if( st==ST_GETLOOP )\n\t\t\tbase[21:16] <= rd_data[5:0];\n\t\t else if( st==ST_SAVEOFFS )\n\t\t begin\n\t\t\tbase[7:0] <= offset[19:12];\n\t\t\tbase[21:8] <= base[21:8] + {2'd0,offset[31:20]};\n\t\t end\n\talways @(posedge clk, negedge rst_n)\n\t\tif( !rst_n )\n\t\t\taddr_emit <= 2'd0;\n\t\t else\n\t\t\taddr_emit[1:0] <= {addr_emit[0], st==ST_NEXT};\n\talways @(posedge clk)\n\t\t if( st==ST_GETSIZE )\n\t\t\tout_data <= offset[11:4];\n\t\t else if( st==ST_GETLOOP )\n\t\t\tout_data <= {2'd0, vol_left[5:0]};\n\t\t else if( st==ST_SAVEOFFS )\n\t\t\tout_data <= {2'd0, vol_right[5:0] ^ {6{surround}}};\n\t\t else if( st==ST_NEXT )\n\t\t\tout_data <= {2'd0, base[21:16]};\n\t\t else if( addr_emit[0] )\n\t\t\tout_data <= base[15:8];\n\t\t else\n\t\t\tout_data <= base[7:0];\n\talways @(posedge clk, negedge rst_n)\n\t\tif( !rst_n )\n\t\t\tout_stb_mix <= 1'b0;\n\t\t else\n\t\t\tout_stb_mix <= (st==ST_GETSIZE)  || (st==ST_GETLOOP)  || (st==ST_SAVEOFFS) ;\n\talways @(posedge clk, negedge rst_n)\n\t\tif( !rst_n )\n\t\t\tout_stb_addr <= 1'b0;\n\t\t else\n\t\t\tout_stb_addr <= (st==ST_NEXT) || addr_emit;\nendmodule"}
{"task_id": 416, "completion": "localparam AVL_BE_WIDTH = AVL_DATA_WIDTH / 8;\n    reg   [AVL_SIZE_WIDTH-1:0] burst_count;\n    wire                       int_ready;\n    wire                       itf_cmd;\n    wire                       itf_wr_if_ready;\n    wire  [LOCAL_ID_WIDTH-1:0] itf_cmd_id;\n    wire                       itf_wr_data_begin;\n    wire                       itf_wr_data_last;\n    wire  [LOCAL_ID_WIDTH-1:0] itf_wr_data_id;\n    reg                        data_pass;\n    reg   [AVL_SIZE_WIDTH-1:0] burst_counter;\n    reg                          avl_read_req_reg;\n    reg                          avl_write_req_reg;\n    reg   [AVL_SIZE_WIDTH-1:0]   avl_size_reg;\n    reg                          avl_burstbegin_reg;\n    reg   [AVL_ADDR_WIDTH-1:0]   avl_addr_reg;\n    reg   [AVL_DATA_WIDTH-1:0]   avl_wdata_reg;\n    reg   [AVL_DATA_WIDTH/8-1:0] avl_be_reg;\n    reg                          itf_rd_data_valid_reg;\n    reg   [AVL_DATA_WIDTH-1:0]   itf_rd_data_reg;\n    reg   [3:0]                  itf_rd_data_error_reg;\n    reg                          local_multicast_reg;\n    reg                          local_autopch_req_reg;\n    reg                          local_priority_reg;\n    generate\n        if (CFG_MM_ST_CONV_REG == 1)\n        begin\n            always @ (posedge ctl_clk or negedge ctl_reset_n)\n            begin\n                if (!ctl_reset_n)\n                begin\n                    avl_read_req_reg            <= 1'b0;\n                    avl_write_req_reg           <= 1'b0;\n                    avl_size_reg                <= {AVL_SIZE_WIDTH{1'b0}};\n                    avl_burstbegin_reg          <= 1'b0;\n                    avl_addr_reg                <= {AVL_ADDR_WIDTH{1'b0}};\n                    avl_wdata_reg               <= {AVL_DATA_WIDTH{1'b0}};\n                    avl_be_reg                  <= {AVL_BE_WIDTH{1'b0}};\n                    itf_rd_data_valid_reg       <= 1'b0;\n                    itf_rd_data_reg             <= {AVL_DATA_WIDTH{1'b0}};\n                    itf_rd_data_error_reg       <= 4'b0;\n                    local_multicast_reg         <= 1'b0;\n                    local_autopch_req_reg       <= 1'b0;\n                    local_priority_reg          <= 1'b0;\n                end else\n                begin\n                    if (int_ready)\n                    begin\n                        avl_read_req_reg        <= avl_read_req;\n                        avl_write_req_reg       <= avl_write_req;\n                        avl_size_reg            <= avl_size;\n                        avl_burstbegin_reg      <= avl_burstbegin;\n                        avl_addr_reg            <= avl_addr;\n                        avl_wdata_reg           <= avl_wdata;\n                        avl_be_reg              <= avl_be;\n                        local_multicast_reg     <= local_multicast;\n                        local_autopch_req_reg   <= local_autopch_req;\n                        local_priority_reg      <= local_priority;\n                    end\n                        itf_rd_data_valid_reg   <= itf_rd_data_valid;\n                        itf_rd_data_reg         <= itf_rd_data;\n                        itf_rd_data_error_reg   <= itf_rd_data_error;\n                end\n            end\n        end else \n        begin\n            always @ (*)\n            begin\n                avl_read_req_reg            = avl_read_req;\n                avl_write_req_reg           = avl_write_req;\n                avl_size_reg                = avl_size;\n                avl_burstbegin_reg          = avl_burstbegin;\n                avl_addr_reg                = avl_addr;\n                avl_wdata_reg               = avl_wdata;\n                avl_be_reg                  = avl_be;\n                itf_rd_data_valid_reg       = itf_rd_data_valid;\n                itf_rd_data_reg             = itf_rd_data;\n                itf_rd_data_error_reg       = {4{itf_rd_data_error}};\n                local_multicast_reg         = local_multicast;\n                local_autopch_req_reg       = local_autopch_req;\n                local_priority_reg          = local_priority;\n            end\n        end\n    endgenerate\n    assign itf_cmd_valid = avl_read_req_reg | itf_wr_if_ready;\n    assign itf_wr_if_ready = itf_wr_data_ready & avl_write_req_reg & ~data_pass;\n    assign avl_ready = int_ready;\n    assign itf_rd_data_ready = 1'b1;\n    assign itf_cmd_address = avl_addr_reg ;\n    assign itf_cmd_burstlen = avl_size_reg ;\n    assign itf_cmd_autopercharge = local_autopch_req_reg ;\n    assign itf_cmd_priority = local_priority_reg ;\n    assign itf_cmd_multicast = local_multicast_reg ;\n    assign itf_cmd = avl_write_req_reg;\n    assign itf_cmd_id = {LOCAL_ID_WIDTH{1'b0}};\n    assign itf_wr_data_begin = 1'b0;\n    assign itf_wr_data_last = 1'b0;\n    assign itf_wr_data_id = {LOCAL_ID_WIDTH{1'b0}};\n    assign itf_wr_data_valid = (data_pass) ? avl_write_req_reg : itf_cmd_ready & avl_write_req_reg;\n    assign itf_wr_data = avl_wdata_reg ;\n    assign itf_wr_data_byte_en = avl_be_reg ;\n    assign avl_rdata_valid = itf_rd_data_valid_reg;\n    assign avl_rdata =  itf_rd_data_reg;\n    assign local_rdata_error = itf_rd_data_error_reg;\n    assign int_ready = (data_pass) ? itf_wr_data_ready : ((itf_cmd) ? (itf_wr_data_ready & itf_cmd_ready) : itf_cmd_ready);\n    always @(posedge ctl_clk, negedge ctl_reset_n)\n        begin\n            if (!ctl_reset_n)\n                burst_counter  <=  {AVL_SIZE_WIDTH{1'b0}};\n            else\n                begin\n                    if (itf_wr_if_ready && avl_size_reg > 1 && itf_cmd_ready)\n                        burst_counter   <=  avl_size_reg - 1'b1;\n                    else if (avl_write_req_reg && itf_wr_data_ready)\n                        burst_counter   <=  burst_counter - 1'b1;\n                end\n        end\n    always @(posedge ctl_clk, negedge ctl_reset_n)\n        begin\n            if (!ctl_reset_n)\n                data_pass  <=  1'b0;\n            else\n                begin\n                    if (itf_wr_if_ready && avl_size_reg > 1 && itf_cmd_ready)\n                        data_pass  <=  1'b1;\n                    else if (burst_counter == 1 && avl_write_req_reg && itf_wr_data_ready)\n                        data_pass  <=  1'b0;\n                end\n        end\n    endmodule"}
{"task_id": 581, "completion": "// 4-stage delay logic implementation goes here\nendmodule"}
{"task_id": 540, "completion": "SRAM_16Bit_512K sram (        .iCLK      (iCLK),      //                   clk.clk        .SRAM_DQ   (SRAM_DQ),   // avalon_slave_0_export.export        .SRAM_ADDR (SRAM_ADDR), //                      .export        .SRAM_UB_N (SRAM_UB_N), //                      .export        .SRAM_LB_N (SRAM_LB_N), //                      .export        .SRAM_WE_N (SRAM_WE_N), //                      .export        .SRAM_CE_N (SRAM_CE_N), //                      .export        .SRAM_OE_N (SRAM_OE_N), //                      .export        .iDATA     (iDATA),     //        avalon_slave_0.writedata        .oDATA     (oDATA),     //                      .readdata        .iADDR     (iADDR),     //                      .address        .iWE_N     (iWE_N),     //                      .write_n        .iOE_N     (iOE_N),     //                      .read_n        .iCE_N     (iCE_N),     //                      .chipselect_n        .iBE_N     (iBE_N),     //                      .byteenable_n        .iRST_N    (iRST_N)     //               reset_n.reset_n    );endmodule"}
{"task_id": 568, "completion": "wire buf_Q  ;\n    wire SET    ;\n    wire mux_out;\n\n    not                                             not0      (SET    , SET_B                          );\n    sky130_fd_sc_hd__udp_mux_2to1                   mux_2to10 (mux_out, D, SCD, SCE                    );\n    sky130_fd_sc_hd__udp_dff$PS_pp$PG$N `UNIT_DELAY dff0      (buf_Q  , mux_out, CLK, SET, , VPWR, VGND);\n    buf                                             buf0      (Q      , buf_Q                          );\n\nendmodule"}
{"task_id": 359, "completion": "wire [31:0] dummy;\n\nRAM16X1D ram16x1_0 (\n  .A0(addr0[0]), .A1(addr0[1]), .A2(addr0[2]), .A3(addr0[3]),\n  .D(data0_in[0]), .WCLK(clk), .WE(we),\n  .DPRA0(addr1[0]), .DPRA1(addr1[1]), .DPRA2(addr1[2]),\n  .DPRA3(addr1[3]),\n  .SPO(dummy[0]), .DPO(data1_out[0])\n);\nRAM16X1D ram16x1_1 (\n  .A0(addr0[0]), .A1(addr0[1]), .A2(addr0[2]), .A3(addr0[3]),\n  .D(data0_in[1]), .WCLK(clk), .WE(we),\n  .DPRA0(addr1[0]), .DPRA1(addr1[1]), .DPRA2(addr1[2]),\n  .DPRA3(addr1[3]),\n  .SPO(dummy[1]), .DPO(data1_out[1])\n);\nRAM16X1D ram16x1_2 (\n  .A0(addr0[0]), .A1(addr0[1]), .A2(addr0[2]), .A3(addr0[3]),\n  .D(data0_in[2]), .WCLK(clk), .WE(we),\n  .DPRA0(addr1[0]), .DPRA1(addr1[1]), .DPRA2(addr1[2]),\n  .DPRA3(addr1[3]),\n  .SPO(dummy[2]), .DPO(data1_out[2])\n);\nRAM16X1D ram16x1_3 (\n  .A0(addr0[0]), .A1(addr0[1]), .A2(addr0[2]), .A3(addr0[3]),\n  .D(data0_in[3]), .WCLK(clk), .WE(we),\n  .DPRA0(addr1[0]), .DPRA1(addr1[1]), .DPRA2(addr1[2]),\n  .DPRA3(addr1[3]),\n  .SPO(dummy[3]), .DPO(data1_out[3])\n);\nRAM16X1D ram16x1_4 (\n  .A0(addr0[0]), .A1(addr0[1]), .A2(addr0[2]), .A3(addr0[3]),\n  .D(data0_in[4]), .WCLK(clk), .WE(we),\n  .DPRA0(addr1[0]), .DPRA1(addr1[1]), .DPRA2(addr1[2]),\n  .DPRA3(addr1[3]),\n  .SPO(dummy[4]), .DPO(data1_out[4])\n);\nRAM16X1D ram16x1_5 (\n  .A0(addr0[0]), .A1(addr0[1]), .A2(addr0[2]), .A3(addr0[3]),\n  .D(data0_in[5]), .WCLK(clk), .WE(we),\n  .DPRA0(addr1[0]), .DPRA1(addr1[1]), .DPRA2(addr1[2]),\n  .DPRA3(addr1[3]),\n  .SPO(dummy[5]), .DPO(data1_out[5])\n);\nRAM16X1D ram16x1_6 (\n  .A0(addr0[0]), .A1(addr0[1]), .A2(addr0[2]), .A3(addr0[3]),\n  .D(data0_in[6]), .WCLK(clk), .WE(we),\n  .DPRA0(addr1[0]), .DPRA1(addr1[1]), .DPRA2(addr1[2]),\n  .DPRA3(addr1[3]),\n  .SPO(dummy[6]), .DPO(data1_out[6])\n);\nRAM16X1D ram16x1_7 (\n  .A0(addr0[0]), .A1(addr0[1]), .A2(addr0[2]), .A3(addr0[3]),\n  .D(data0_in[7]), .WCLK(clk), .WE(we),\n  .DPRA0(addr1[0]), .DPRA1(addr1[1]), .DPRA2(addr1[2]),\n  .DPRA3(addr1[3]),\n  .SPO(dummy[7]), .DPO(data1_out[7])\n);\nRAM16X1D ram16x1_8 (\n  .A0(addr0[0]), .A1(addr0[1]), .A2(addr0[2]), .A3(addr0[3]),\n  .D(data0_in[8]), .WCLK(clk), .WE(we),\n  .DPRA0(addr1[0]), .DPRA1(addr1[1]), .DPRA2(addr1[2]),\n  .DPRA3(addr1[3]),\n  .SPO(dummy[8]), .DPO(data1_out[8])\n);\nRAM16X1D ram16x1_9 (\n  .A0(addr0[0]), .A1(addr0[1]), .A2(addr0[2]), .A3(addr0[3]),\n  .D(data0_in[9]), .WCLK(clk), .WE(we),\n  .DPRA0(addr1[0]), .DPRA1(addr1[1]), .DPRA2(addr1[2]),\n  .DPRA3(addr1[3]),\n  .SPO(dummy[9]), .DPO(data1_out[9])\n);\nRAM16X1D ram16x1_10 (\n  .A0(addr0[0]), .A1(addr0[1]), .A2(addr0[2]), .A3(addr0[3]),\n  .D(data0_in[10]), .WCLK(clk), .WE(we),\n  .DPRA0(addr1[0]), .DPRA1(addr1[1]), .DPRA2(addr1[2]),\n  .DPRA3(addr1[3]),\n  .SPO(dummy[10]), .DPO(data1_out[10])\n);\nRAM16X1D ram16x1_11 (\n  .A0(addr0[0]), .A1(addr0[1]), .A2(addr0[2]), .A3(addr0[3]),\n  .D(data0_in[11]), .WCLK(clk), .WE(we),\n  .DPRA0(addr1[0]), .DPRA1(addr1[1]), .DPRA2(addr1[2]),\n  .DPRA3(addr1[3]),\n  .SPO(dummy[11]), .DPO(data1_out[11])\n);\nRAM16X1D ram16x1_12 (\n  .A0(addr0[0]), .A1(addr0[1]), .A2(addr0[2]), .A3(addr0[3]),\n  .D(data0_in[12]), .WCLK(clk), .WE(we),\n  .DPRA0(addr1[0]), .DPRA1(addr1[1]), .DPRA2(addr1[2]),\n  .DPRA3(addr1[3]),\n  .SPO(dummy[12]), .DPO(data1_out[12])\n);\nRAM16X1D ram16x1_13 (\n  .A0(addr0[0]), .A1(addr0[1]), .A2(addr0[2]), .A3(addr0[3]),\n  .D(data0_in[13]), .WCLK(clk), .WE(we),\n  .DPRA0(addr1[0]), .DPRA1(addr1[1]), .DPRA2(addr1[2]),\n  .DPRA3(addr1[3]),\n  .SPO(dummy[13]), .DPO(data1_out[13])\n);\nRAM16X1D ram16x1_14 (\n  .A0(addr0[0]), .A1(addr0[1]), .A2(addr0[2]), .A3(addr0[3]),\n  .D(data0_in[14]), .WCLK(clk), .WE(we),\n  .DPRA0(addr1[0]), .DPRA1(addr1[1]), .DPRA2(addr1[2]),\n  .DPRA3(addr1[3]),\n  .SPO(dummy[14]), .DPO(data1_out[14])\n);\nRAM16X1D ram16x1_15 (\n  .A0(addr0[0]), .A1(addr0[1]), .A2(addr0[2]), .A3(addr0[3]),\n  .D(data0_in[15]), .WCLK(clk), .WE(we),\n  .DPRA0(addr1[0]), .DPRA1(addr1[1]), .DPRA2(addr1[2]),\n  .DPRA3(addr1[3]),\n  .SPO(dummy[15]), .DPO(data1_out[15])\n);\nRAM16X1D ram16x1_16 (\n  .A0(addr0[0]), .A1(addr0[1]), .A2(addr0[2]), .A3(addr0[3]),\n  .D(data0_in[16]), .WCLK(clk), .WE(we),\n  .DPRA0(addr1[0]), .DPRA1(addr1[1]), .DPRA2(addr1[2]),\n  .DPRA3(addr1[3]),\n  .SPO(dummy[16]), .DPO(data1_out[16])\n);\nRAM16X1D ram16x1_17 (\n  .A0(addr0[0]), .A1(addr0[1]), .A2(addr0[2]), .A3(addr0[3]),\n  .D(data0_in[17]), .WCLK(clk), .WE(we),\n  .DPRA0(addr1[0]), .DPRA1(addr1[1]), .DPRA2(addr1[2]),\n  .DPRA3(addr1[3]),\n  .SPO(dummy[17]), .DPO(data1_out[17])\n);\nRAM16X1D ram16x1_18 (\n  .A0(addr0[0]), .A1(addr0[1]), .A2(addr0[2]), .A3(addr0[3]),\n  .D(data0_in[18]), .WCLK(clk), .WE(we),\n  .DPRA0(addr1[0]), .DPRA1(addr1[1]), .DPRA2(addr1[2]),\n  .DPRA3(addr1[3]),\n  .SPO(dummy[18]), .DPO(data1_out[18])\n);\nRAM16X1D ram16x1_19 (\n  .A0(addr0[0]), .A1(addr0[1]), .A2(addr0[2]), .A3(addr0[3]),\n  .D(data0_in[19]), .WCLK(clk), .WE(we),\n  .DPRA0(addr1[0]), .DPRA1(addr1[1]), .DPRA2(addr1[2]),\n  .DPRA3(addr1[3]),\n  .SPO(dummy[19]), .DPO(data1_out[19])\n);\nRAM16X1D ram16x1_20 (\n  .A0(addr0[0]), .A1(addr0[1]), .A2(addr0[2]), .A3(addr0[3]),\n  .D(data0_in[20]), .WCLK(clk), .WE(we),\n  .DPRA0(addr1[0]), .DPRA1(addr1[1]), .DPRA2(addr1[2]),\n  .DPRA3(addr1[3]),\n  .SPO(dummy[20]), .DPO(data1_out[20])\n);\nRAM16X1D ram16x1_21 (\n  .A0(addr0[0]), .A1(addr0[1]), .A2(addr0[2]), .A3(addr0[3]),\n  .D(data0_in[21]), .WCLK(clk), .WE(we),\n  .DPRA0(addr1[0]), .DPRA1(addr1[1]), .DPRA2(addr1[2]),\n  .DPRA3(addr1[3]),\n  .SPO(dummy[21]), .DPO(data1_out[21])\n);\nRAM16X1D ram16x1_22 (\n  .A0(addr0[0]), .A1(addr0[1]), .A2(addr0[2]), .A3(addr0[3]),\n  .D(data0_in[22]), .WCLK(clk), .WE(we),\n  .DPRA0(addr1[0]), .DPRA1(addr1[1]), .DPRA2(addr1[2]),\n  .DPRA3(addr1[3]),\n  .SPO(dummy[22]), .DPO(data1_out[22])\n);\nRAM16X1D ram16x1_23 (\n  .A0(addr0[0]), .A1(addr0[1]), .A2(addr0[2]), .A3(addr0[3]),\n  .D(data0_in[23]), .WCLK(clk), .WE(we),\n  .DPRA0(addr1[0]), .DPRA1(addr1[1]), .DPRA2(addr1[2]),\n  .DPRA3(addr1[3]),\n  .SPO(dummy[23]), .DPO(data1_out[23])\n);\nRAM16X1D ram16x1_24 (\n  .A0(addr0[0]), .A1(addr0[1]), .A2(addr0[2]), .A3(addr0[3]),\n  .D(data0_in[24]), .WCLK(clk), .WE(we),\n  .DPRA0(addr1[0]), .DPRA1(addr1[1]), .DPRA2(addr1[2]),\n  .DPRA3(addr1[3]),\n  .SPO(dummy[24]), .DPO(data1_out[24])\n);\nRAM16X1D ram16x1_25 (\n  .A0(addr0[0]), .A1(addr0[1]), .A2(addr0[2]), .A3(addr0[3]),\n  .D(data0_in[25]), .WCLK(clk), .WE(we),\n  .DPRA0(addr1[0]), .DPRA1(addr1[1]), .DPRA2(addr1[2]),\n  .DPRA3(addr1[3]),\n  .SPO(dummy[25]), .DPO(data1_out[25])\n);\nRAM16X1D ram16x1_26 (\n  .A0(addr0[0]), .A1(addr0[1]), .A2(addr0[2]), .A3(addr0[3]),\n  .D(data0_in[26]), .WCLK(clk), .WE(we),\n  .DPRA0(addr1[0]), .DPRA1(addr1[1]), .DPRA2(addr1[2]),\n  .DPRA3(addr1[3]),\n  .SPO(dummy[26]), .DPO(data1_out[26])\n);\nRAM16X1D ram16x1_27 (\n  .A0(addr0[0]), .A1(addr0[1]), .A2(addr0[2]), .A3(addr0[3]),\n  .D(data0_in[27]), .WCLK(clk), .WE(we),\n  .DPRA0(addr1[0]), .DPRA1(addr1[1]), .DPRA2(addr1[2]),\n  .DPRA3(addr1[3]),\n  .SPO(dummy[27]), .DPO(data1_out[27])\n);\nRAM16X1D ram16x1_28 (\n  .A0(addr0[0]), .A1(addr0[1]), .A2(addr0[2]), .A3(addr0[3]),\n  .D(data0_in[28]), .WCLK(clk), .WE(we),\n  .DPRA0(addr1[0]), .DPRA1(addr1[1]), .DPRA2(addr1[2]),\n  .DPRA3(addr1[3]),\n  .SPO(dummy[28]), .DPO(data1_out[28])\n);\nRAM16X1D ram16x1_29 (\n  .A0(addr0[0]), .A1(addr0[1]), .A2(addr0[2]), .A3(addr0[3]),\n  .D(data0_in[29]), .WCLK(clk), .WE(we),\n  .DPRA0(addr1[0]), .DPRA1(addr1[1]), .DPRA2(addr1[2]),\n  .DPRA3(addr1[3]),\n  .SPO(dummy[29]), .DPO(data1_out[29])\n);\nRAM16X1D ram16x1_30 (\n  .A0(addr0[0]), .A1(addr0[1]), .A2(addr0[2]), .A3(addr0[3]),\n  .D(data0_in[30]), .WCLK(clk), .WE(we),\n  .DPRA0(addr1[0]), .DPRA1(addr1[1]), .DPRA2(addr1[2]),\n  .DPRA3(addr1[3]),\n  .SPO(dummy[30]), .DPO(data1_out[30])\n);\nRAM16X1D ram16x1_31 (\n  .A0(addr0[0]), .A1(addr0[1]), .A2(addr0[2]), .A3(addr0[3]),\n  .D(data0_in[31]), .WCLK(clk), .WE(we),\n  .DPRA0(addr1[0]), .DPRA1(addr1[1]), .DPRA2(addr1[2]),\n  .DPRA3(addr1[3]),\n  .SPO(dummy[31]), .DPO(data1_out[31])\n);\n\nendmodule"}
{"task_id": 572, "completion": "sky130_fd_sc_hs__edfxtp base (\n        .Q(Q),\n        .CLK(CLK),\n        .D(D),\n        .DE(DE),\n        .VPWR(VPWR),\n        .VGND(VGND)\n    );\n\nendmodule"}
{"task_id": 597, "completion": "reg [31:0] rf [31:0];\n    \n    always @(wd3) begin\n        if (we3 && wa3 != 0) begin\n            rf[wa3] = wd3;\n        end\n    end\n    \n    assign rd1 = (ra1 == 0 ? 0 : rf[ra1]);\n    assign rd2 = (ra2 == 0 ? 0 : rf[ra2]);\n\nendmodule"}
{"task_id": 411, "completion": "localparam M = `BCH_M(P);    localparam [`MAX_M*(1<<(`MAX_M-1))-1:0] TBL = syndrome_build_table(M, `BCH_T(P));    `include \"bch_syndrome.vh\"    localparam TCQ = 1;    genvar idx;    localparam CYCLES = PIPELINE_STAGES + (`BCH_CODE_BITS(P)+BITS-1) / BITS;    localparam DONE = lfsr_count(M, CYCLES - 2);    localparam REM = `BCH_CODE_BITS(P) % BITS;    localparam RUNT = BITS - REM;    localparam SYN_COUNT = TBL[0+:`MAX_M];    wire [M-1:0] count;    wire [BITS-1:0] data_pipelined;    wire [BITS-1:0] shifted_in;    wire [BITS-1:0] shifted_pipelined;    wire start_pipelined;    reg busy = 0;    if (CYCLES > 2) begin : COUNTER        lfsr_counter #(M) u_counter(            .clk(clk),            .reset(start && ce),            .ce(busy && ce),            .count(count)        );    end else        assign count = DONE;    assign ready = !busy;    always @(posedge clk) begin        if (ce) begin            if (start) begin                done <= #TCQ CYCLES == 1;                busy <= #TCQ CYCLES > 1;            end else if (busy && count == DONE) begin                done <= #TCQ 1;                busy <= #TCQ 0;            end else                done <= #TCQ 0;        end    end    generate        if (REM) begin            reg [RUNT-1:0] runt = 0;            assign shifted_in = {start ? {RUNT{1'b0}} : runt, data_in[BITS-1:RUNT]};            always @(posedge clk)                if (ce)                    runt <= #TCQ data_in;        end else            assign shifted_in = data_in;    endgenerate    pipeline_ce #(PIPELINE_STAGES > 1) u_data_pipeline [BITS-1:0] (        .clk(clk),        .ce(ce),        .i(data_in),        .o(data_pipelined)    );    pipeline_ce #(PIPELINE_STAGES > 0) u_shifted_pipeline [BITS-1:0] (        .clk(clk),        .ce(ce),        .i(shifted_in),        .o(shifted_pipelined)    );    pipeline_ce #(PIPELINE_STAGES > 1) u_start_pipeline (        .clk(clk),        .ce(ce),        .i(start),        .o(start_pipelined)    );    generate        for (idx = 0; idx < SYN_COUNT; idx = idx + 1) begin : SYNDROMES            localparam SYN = idx2syn(idx);            if (syndrome_method(`BCH_T(P), SYN) == 0) begin : METHOD1                dsynN_method1 #(P, SYN, BITS, REG_RATIO, PIPELINE_STAGES) u_syn1a(                    .clk(clk),                    .start(start),                    .start_pipelined(start_pipelined),                    .ce((busy || start) && ce),                    .data_pipelined(data_pipelined),                    .synN(syndromes[idx*M+:M])                );            end else begin : METHOD2                dsynN_method2 #(P, SYN, syndrome_degree(M, SYN), BITS, PIPELINE_STAGES) u_syn2a(                    .clk(clk),                    .start(start),                    .start_pipelined(start_pipelined),                    .ce((busy || start) && ce),                    .data_in(shifted_in),                    .data_pipelined(shifted_pipelined),                    .synN(syndromes[idx*M+:M])                );            end        end    endgenerateendmodule\nmodule bch_syndrome_shuffle #(    parameter [`BCH_PARAM_SZ-1:0] P = `BCH_SANE) (    input clk,    input start,        input ce,        input [`BCH_SYNDROMES_SZ(P)-1:0] syndromes,    output reg [(2*`BCH_T(P)-1)*`BCH_M(P)-1:0] syn_shuffled = 0);    localparam M = `BCH_M(P);    localparam [`MAX_M*(1<<(`MAX_M-1))-1:0] TBL = syndrome_build_table(M, `BCH_T(P));    `include \"bch_syndrome.vh\"    localparam TCQ = 1;    localparam T = `BCH_T(P);    genvar i;    wire [(2*T-1)*M-1:0] bypass_in_shifted;    wire [(2*T-1)*M-1:0] syndromes_pre_expand;    wire [(2*T-1)*M-1:0] expand_in;    wire [(2*T-1)*M-1:0] expand_in1;    wire [(2*T-1)*M-1:0] syn_expanded;    for (i = 0; i < 2 * T - 1; i = i + 1) begin : ASSIGN        assign syndromes_pre_expand[i*M+:M] = syndromes[dat2idx(i+1)*M+:M] & {M{start}};    end    rotate_right #((2*T-1)*M, 3*M) u_rol_e(syndromes_pre_expand, expand_in1);    reverse_words #(M, 2*T-1) u_rev(expand_in1, expand_in);    rotate_left #((2*T-1)*M, 2*M) u_rol_b(syn_shuffled, bypass_in_shifted);    for (i = 0; i < 2 * T - 1; i = i + 1) begin : EXPAND        localparam PRE = (2 * T - 1 + 2 - i) % (2 * T - 1);        if (syndrome_method(T, dat2syn(PRE + 1)) == 0) begin : METHOD1            syndrome_expand_method1 #(P) u_expand(                .in(expand_in[i*M+:M]),                .out(syn_expanded[i*M+:M])            );        end else begin : METHOD2            syndrome_expand_method2 #(P, PRE + 1) u_expand(                .in(expand_in[i*M+:M]),                .out(syn_expanded[i*M+:M])            );        end    end    always @(posedge clk)        if (start || ce)            syn_shuffled <= #TCQ syn_expanded ^ ({(2*T-1)*M{!start}} & bypass_in_shifted);endmodule\nmodule bch_errors_present #(    parameter [`BCH_PARAM_SZ-1:0] P = `BCH_SANE,    parameter PIPELINE_STAGES = 0) (    input clk,    input start,    input [`BCH_SYNDROMES_SZ(P)-1:0] syndromes,    output done,    output errors_present            /* Valid during done cycle */);    localparam M = `BCH_M(P);    genvar i;    wire [(`BCH_SYNDROMES_SZ(P)/M)-1:0] syndrome_zero;    wire [(`BCH_SYNDROMES_SZ(P)/M)-1:0] syndrome_zero_pipelined;    generate        for (i = 0; i < `BCH_SYNDROMES_SZ(P)/M; i = i + 1) begin : ZEROS            assign syndrome_zero[i] = |syndromes[i*M+:M];        end    endgenerate    pipeline #(PIPELINE_STAGES > 0) u_sz_pipeline [`BCH_SYNDROMES_SZ(P)/M-1:0] (        .clk(clk),        .i(syndrome_zero),        .o(syndrome_zero_pipelined)    );    pipeline #(PIPELINE_STAGES > 1) u_present_pipeline (        .clk(clk),        .i(|syndrome_zero_pipelined),        .o(errors_present)    );    pipeline #(PIPELINE_STAGES) u_done_pipeline (        .clk(clk),        .i(start),        .o(done)    );endmodule"}
{"task_id": 566, "completion": "wire [6:0] m1;\n    wire [6:0] m2;\n    wire [6:0] m3;\n    wire [3:0] ahl;\n    wire [3:0] bhl;\n\n    Bks4 ksm1(a[3:0], b[3:0], m2);\n    Bks4 ksm2(a[7:4], b[7:4], m1);\n    assign ahl[3:0] = a[7:4] ^ a[3:0];\n    assign bhl[3:0] = b[7:4] ^ b[3:0];\n    Bks4 ksm3(ahl, bhl, m3);\n\n    assign  d[00] = m2[00];\n    assign  d[01] = m2[01];\n    assign  d[02] = m2[02];\n    assign  d[03] = m2[03];\n    assign  d[04] = m2[04] ^ m1[00] ^ m2[00] ^ m3[00];\n    assign  d[05] = m2[05] ^ m1[01] ^ m2[01] ^ m3[01];\n    assign  d[06] = m2[06] ^ m1[02] ^ m2[02] ^ m3[02];\n    assign  d[07] = m1[03] ^ m2[03] ^ m3[03];\n    assign  d[08] = m1[04] ^ m2[04] ^ m3[04] ^ m1[00];\n    assign  d[09] = m1[05] ^ m2[05] ^ m3[05] ^ m1[01];\n    assign  d[10] = m1[06] ^ m2[06] ^ m3[06] ^ m1[02];\n    assign  d[11] = m1[03];\n    assign  d[12] = m1[04];\n    assign  d[13] = m1[05];\n    assign  d[14] = m1[06];\nendmodule"}
{"task_id": 592, "completion": "output Q      ;\n    input  RESET_B;\n    input  D      ;\n    input  GATE_N ;\n\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    wire RESET          ;\n    wire intgate        ;\n    reg  notifier       ;\n    wire D_delayed      ;\n    wire GATE_N_delayed ;\n    wire RESET_delayed  ;\n    wire RESET_B_delayed;\n    wire buf_Q          ;\n    wire awake          ;\n    wire cond0          ;\n    wire cond1          ;\n\n    not                                    not0    (RESET  , RESET_B_delayed                                );\n    not                                    not1    (intgate, GATE_N_delayed                                 );\n    sky130_fd_sc_hd__udp_dlatch$PR_pp$PG$N dlatch0 (buf_Q  , D_delayed, intgate, RESET, notifier, VPWR, VGND);\n    assign awake = ( VPWR === 1'b1 );\n    assign cond0 = ( awake && ( RESET_B_delayed === 1'b1 ) );\n    assign cond1 = ( awake && ( RESET_B === 1'b1 ) );\n    buf                                    buf0    (Q      , buf_Q                                          );\n\nendmodule"}
{"task_id": 481, "completion": "input clk;\n    input enter; \n    input virgul;\n    input cEne, cEnter;\n    input cDelete;\n    input cCounter;\n    input new;\n    input reset;\n    input cNum;\n    output reg complete;\n    output reg delete;\n    output reg add;\n    output reg load;\n    output reg addEnhe;\n    output reg change;\n    output reg changeVirgul;\n\n    reg [2:0] next_state;\n\n    parameter init=3'b000, new_data=3'b001, Add=3'b010, Delete=3'b011, ChangeVirgul=3'b100, AddEnhe=3'b101, Enter=3'b110, effect=3'b111;\n\n    always @( negedge clk )\n    begin\n        if (reset) next_state<=init;\n        else \n            case (next_state)\n                init:  next_state<=new_data;\n                new_data: begin\n                    if (cNum==1'b1 & enter==1'b1) next_state<=effect;\n                    else if(cEnter==1'b1) next_state<=Enter; \n                    else if((new==1'b0 | cCounter==1'b1) |  (cNum==1'b0 & enter==1'b1)) next_state<=new_data; \n                    else if (virgul==1'b1 & cEne==0) next_state<=ChangeVirgul; \n                    else if((cDelete==1'b1 | (cEne==1'b1 & virgul==1'b1))) next_state<=Delete; \n                    else next_state<=Add; \n                end \n                Add:  next_state<=new_data;\n                Delete: begin \n                    if (cEne==1'b1 & virgul==1) next_state<=AddEnhe;\n                    else    next_state<=new_data;\n                end\n                AddEnhe:    next_state<=new_data;\n                Enter:      next_state<=new_data;\n                effect:     next_state<=init;\n                default:    next_state<=new_data;\n            endcase\n    end \n\n    always @( next_state or cEne or virgul)\n    begin\n        case (next_state)\n            init: begin\n                complete=1'b0;\n                delete=1'b0;\n                add=1'b0;\n                load=1'b1;\n                addEnhe=1'b0;\n                change=1'b0;\n                changeVirgul=1'b0;            \n            end    \n            new_data: begin\n                complete=1'b0;\n                delete=1'b0;\n                add=1'b0;\n                load=1'b0;\n                addEnhe=1'b0;\n                change=1'b0;        \n                changeVirgul=1'b0;            \n            end        \n            Add: begin \n                complete=1'b0;\n                delete=1'b0;\n                add=1'b1;\n                load=1'b0;\n                addEnhe=1'b0;\n                change=1'b1;\n                changeVirgul=1'b0;            \n            end\n            Delete: begin\n                complete=1'b0;\n                delete=1'b1;\n                add=1'b0;\n                load=1'b0;\n                addEnhe=1'b0;\n                change=1'b1;\n                changeVirgul=1'b0;            \n            end\n            ChangeVirgul: begin \n                complete=1'b0;\n                delete=1'b0;\n                add=1'b1;\n                load=1'b0;\n                addEnhe=1'b0;\n                change=1'b1;\n                changeVirgul=1'b1;\n            end\n            AddEnhe: begin     \n                complete=1'b0;\n                delete=1'b0;\n                add=1'b1;\n                load=1'b0;\n                addEnhe=1'b1;\n                change=1'b1;\n                changeVirgul=1'b0;            \n            end\n            Enter: begin \n                complete=1'b0;\n                delete=1'b0;\n                add=1'b0;\n                load=1'b0;\n                addEnhe=1'b0;\n                change=1'b1;\n                changeVirgul=1'b0;            \n            end\n            effect: begin \n                complete=1'b1;\n                delete=1'b0;\n                add=1'b1;\n                load=1'b0;\n                addEnhe=1'b0;\n                change=1'b1;\n                changeVirgul=1'b0;            \n            end        \n            default: begin\n                complete=1'b0;\n                delete=1'b0;\n                add=1'b0;\n                load=1'b0;\n                addEnhe=1'b0;\n                change=1'b0;\n                changeVirgul=1'b0;            \n            end\n        endcase        \n    end \n\nendmodule"}
{"task_id": 512, "completion": "parameter StateCPU = 4'd00; parameter StateMAC0 = 4'd01; parameter StateMAC1 = 4'd02; reg [3:0] CurrentState; reg [3:0] NextState; reg [3:0] CurrentState_reg; reg [4:0] StepCounter; reg [31:0] DoutaReg; reg [5:0] Addra; reg [31:0] Dina; reg Reg_next_0; reg Reg_next_1; reg Write; reg Read; reg Pipeline; reg [31:0] CPU_rd_dout; reg CPU_rd_apply_reg; always @(posedge Clk or posedge Reset) if (Reset) CurrentState <= StateMAC0; else CurrentState <= NextState; always @(posedge Clk or posedge Reset) if (Reset) CurrentState_reg <= StateMAC0; else if (CurrentState != StateCPU) CurrentState_reg <= CurrentState; always @(CurrentState or CPU_rd_apply_reg or Reg_apply_0 or CurrentState_reg or Reg_apply_1 or StepCounter) case(CurrentState) StateMAC0: if(!Reg_apply_0 && CPU_rd_apply_reg) NextState = StateCPU; else if(!Reg_apply_0) NextState = StateMAC1; else NextState = CurrentState; StateMAC1: if(!Reg_apply_1 && CPU_rd_apply_reg) NextState = StateCPU; else if(!Reg_apply_1) NextState = StateMAC0; else NextState = CurrentState; StateCPU: if (StepCounter == 3) case (CurrentState_reg) StateMAC0: NextState = StateMAC0; StateMAC1: NextState = StateMAC1; default: NextState = StateMAC0; endcase else NextState = CurrentState; default: NextState = StateMAC0; endcase always @(posedge Clk or posedge Reset) if (Reset) StepCounter <= 0; else if (NextState != CurrentState) StepCounter <= 0; else if (StepCounter != 4'hf) StepCounter <= StepCounter + 1; always @(StepCounter) if( StepCounter == 1 || StepCounter == 4 || StepCounter == 7 || StepCounter == 10) Read = 1; else Read = 0; always @(StepCounter or CurrentState) if( StepCounter == 2 || StepCounter == 5 || StepCounter == 8 || StepCounter == 11) Pipeline = 1; else Pipeline = 0; always @(StepCounter or CurrentState) if( StepCounter == 3 || StepCounter == 6 || StepCounter == 9 || StepCounter == 12) Write = 1; else Write = 0; always @(posedge Clk or posedge Reset) if (Reset) DoutaReg <= 0; else if (Read) DoutaReg <= Douta; always @(*) case(CurrentState) StateMAC0: Addra = {1'd0, Reg_addr_0}; StateMAC1: Addra = {1'd1, Reg_addr_1}; StateCPU: Addra = CPU_rd_addr; default: Addra = 0; endcase always @(posedge Clk or posedge Reset) if (Reset) Dina <= 0; else case(CurrentState) StateMAC0: Dina <= Douta + Reg_data_0; StateMAC1: Dina <= Douta + Reg_data_1; StateCPU: Dina <= 0; default: Dina <= 0; endcase assign Wea = Write; always @(CurrentState or Pipeline) if(CurrentState == StateMAC0) Reg_next_0 = Pipeline; else Reg_next_0 = 0; always @(CurrentState or Pipeline) if(CurrentState == StateMAC1) Reg_next_1 = Pipeline; else Reg_next_1 = 0; reg CPU_rd_apply_dl1; reg CPU_rd_apply_dl2; always @ (posedge Clk or posedge Reset) if (Reset) begin CPU_rd_apply_dl1 <= 0; CPU_rd_apply_dl2 <= 0; end else begin CPU_rd_apply_dl1 <= CPU_rd_apply; CPU_rd_apply_dl2 <= CPU_rd_apply_dl1; end always @ (posedge Clk or posedge Reset) if (Reset) CPU_rd_apply_reg <= 0; else if (CPU_rd_apply_dl1 & !CPU_rd_apply_dl2) CPU_rd_apply_reg <= 1; else if (CurrentState == StateCPU && Write) CPU_rd_apply_reg <= 0; assign CPU_rd_grant = !CPU_rd_apply_reg; always @ (posedge Clk or posedge Reset) if (Reset) CPU_rd_dout <= 0; else if (Pipeline && CurrentState == StateCPU) CPU_rd_dout <= Douta; endmodule"}
{"task_id": 496, "completion": "wire       nrst;\n    wire [7:0] ps2_data_o;\n    wire [7:0] ps2_data_i;\n    wire       ibf_clr;\n    wire       obf_set;\n    wire       ibf;\n    wire       obf;\n    wire       frame_err;\n    wire       parity_err;\n    wire       busy;\n    wire       err_clr;\n    wire       wdt;\n\n    wire [7:0] status_reg;\n    reg  [7:0] control_reg;\n\n    wire irq_rx_enb;\n    wire irq_tx_enb;\n\n    ps2 ps2_uart(\n        .clk_i        (wb_clk_i),\n        .rst_i        (nrst),\n        .data_o       (ps2_data_o),\n        .data_i       (ps2_data_i),\n        .ibf_clr_i    (ibf_clr),\n        .obf_set_i    (obf_set),\n        .ibf_o        (ibf),\n        .obf_o        (obf),\n        .frame_err_o  (frame_err),\n        .parity_err_o (parity_err),\n        .busy_o       (busy),\n        .err_clr_i    (err_clr),\n        .wdt_o        (wdt),\n        .ps2_clk_io   (ps2_clk),\n        .ps2_data_io  (ps2_dat)\n    );\n\n    assign nrst = !wb_rst_i;\n\n    // clear error flags when clear it's\n    assign err_clr = wb_stb_i & wb_we_i & wb_adr_i & !wb_dat_i[3];\n\n    // clear In Buffer Full (IBF) flag when clear it\n    assign ibf_clr = wb_stb_i & wb_we_i & wb_adr_i & !wb_dat_i[0];\n\n    // set Out Buffer Full when write to data register\n    assign obf_set = wb_stb_i & wb_we_i & !wb_adr_i[0];\n\n    // Status register\n    assign status_reg[7]   = irq_tx_enb;\n    assign status_reg[6]   = irq_rx_enb;\n    assign status_reg[5:4] = 2'b0;\n    assign status_reg[3]   = parity_err | frame_err;\n    assign status_reg[2]   = obf;\n    assign status_reg[1]   = ibf;\n    assign status_reg[0]   = busy;\n\n    // Control register\n    assign irq_rx_enb = control_reg[6];\n    assign irq_tx_enb = control_reg[7];\n\n    // purpose: Control register latch\n    always @(posedge wb_clk_i)\n        if (wb_rst_i)\n            control_reg[7:6] <= 0;\n        else if (wb_stb_i & wb_we_i & wb_adr_i) // control_write\n            control_reg[7:6] <= wb_dat_i[7:6];\n\n    // output data/status\n    assign wb_dat_o   = wb_adr_i[0] ? status_reg : ps2_data_o;\n    assign ps2_data_i = wb_dat_i;\n\n    // Irq generation\n    assign irq_o = (ibf & irq_rx_enb) | (!obf & irq_tx_enb);\n\n    // no wait states for all acceses\n    assign wb_ack_o = wb_stb_i;\n\nendmodule"}
{"task_id": 517, "completion": "input [63:0]GPIO_I;\n  output [63:0]GPIO_O;\n  output [63:0]GPIO_T;\n  input SDIO0_WP;\n  output TTC0_WAVE0_OUT;\n  output TTC0_WAVE1_OUT;\n  output TTC0_WAVE2_OUT;\n  output [1:0]USB0_PORT_INDCTL;\n  output USB0_VBUS_PWRSELECT;\n  input USB0_VBUS_PWRFAULT;\n  output M_AXI_GP0_ARVALID;\n  output M_AXI_GP0_AWVALID;\n  output M_AXI_GP0_BREADY;\n  output M_AXI_GP0_RREADY;\n  output M_AXI_GP0_WLAST;\n  output M_AXI_GP0_WVALID;\n  output [11:0]M_AXI_GP0_ARID;\n  output [11:0]M_AXI_GP0_AWID;\n  output [11:0]M_AXI_GP0_WID;\n  output [1:0]M_AXI_GP0_ARBURST;\n  output [1:0]M_AXI_GP0_ARLOCK;\n  output [2:0]M_AXI_GP0_ARSIZE;\n  output [1:0]M_AXI_GP0_AWBURST;\n  output [1:0]M_AXI_GP0_AWLOCK;\n  output [2:0]M_AXI_GP0_AWSIZE;\n  output [2:0]M_AXI_GP0_ARPROT;\n  output [2:0]M_AXI_GP0_AWPROT;\n  output [31:0]M_AXI_GP0_ARADDR;\n  output [31:0]M_AXI_GP0_AWADDR;\n  output [31:0]M_AXI_GP0_WDATA;\n  output [3:0]M_AXI_GP0_ARCACHE;\n  output [3:0]M_AXI_GP0_ARLEN;\n  output [3:0]M_AXI_GP0_ARQOS;\n  output [3:0]M_AXI_GP0_AWCACHE;\n  output [3:0]M_AXI_GP0_AWLEN;\n  output [3:0]M_AXI_GP0_AWQOS;\n  output [3:0]M_AXI_GP0_WSTRB;\n  input M_AXI_GP0_ACLK;\n  input M_AXI_GP0_ARREADY;\n  input M_AXI_GP0_AWREADY;\n  input M_AXI_GP0_BVALID;\n  input M_AXI_GP0_RLAST;\n  input M_AXI_GP0_RVALID;\n  input M_AXI_GP0_WREADY;\n  input [11:0]M_AXI_GP0_BID;\n  input [11:0]M_AXI_GP0_RID;\n  input [1:0]M_AXI_GP0_BRESP;\n  input [1:0]M_AXI_GP0_RRESP;\n  input [31:0]M_AXI_GP0_RDATA;\n  input [0:0]IRQ_F2P;\n  output FCLK_CLK0;\n  output FCLK_RESET0_N;\n  inout [53:0]MIO;\n  inout DDR_CAS_n;\n  inout DDR_CKE;\n  inout DDR_Clk_n;\n  inout DDR_Clk;\n  inout DDR_CS_n;\n  inout DDR_DRSTB;\n  inout DDR_ODT;\n  inout DDR_RAS_n;\n  inout DDR_WEB;\n  inout [2:0]DDR_BankAddr;\n  inout [14:0]DDR_Addr;\n  inout DDR_VRN;\n  inout DDR_VRP;\n  inout [3:0]DDR_DM;\n  inout [31:0]DDR_DQ;\n  inout [3:0]DDR_DQS_n;\n  inout [3:0]DDR_DQS;\n  inout PS_SRSTB;\n  inout PS_CLK;\n  inout PS_PORB;\nendmodule"}
{"task_id": 610, "completion": "output Q      ;\n    input  CLK_N  ;\n    input  D      ;\n    input  RESET_B;\n\n    wire buf_Q ;\n    wire RESET ;\n    wire intclk;\n\n    not                                     not0 (RESET , RESET_B         );\n    not                                     not1 (intclk, CLK_N           );\n    sky130_fd_sc_hd__udp_dff$PR `UNIT_DELAY dff0 (buf_Q , D, intclk, RESET);\n    buf                                     buf0 (Q     , buf_Q           );\n\nendmodule"}
{"task_id": 585, "completion": "parameter num_pls_global = 4; parameter num_pls_local  = 4; parameter only_allocate_pl_when_empty = 0; logic [num_pls_global-1:0] pl_alloc_status_reg; pl_t fifo_out; fifov_flags_t fifo_flags; logic push; integer i; generate always@(posedge clk) begin if (!rst_n) begin for (i=0; i<num_pls_global; i++) begin:forpls2 pl_alloc_status_reg[i] <= (i<num_pls_local); end end else begin for (i=0; i<num_pls_global; i++) begin:forpls if (pl_allocated[i]) pl_alloc_status_reg[i]<=1'b0; if (flits_valid[i] && flits_tail[i]) begin assert (!pl_alloc_status_reg[i]); pl_alloc_status_reg[i]<=1'b1; end end end end end // always@ (posedge clk) if (only_allocate_pl_when_empty) begin assign pl_alloc_status = pl_alloc_status_reg & pl_empty; end else begin assign pl_alloc_status = pl_alloc_status_reg; end endgenerate endmodule"}
{"task_id": 613, "completion": "supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\nendmodule"}
{"task_id": 454, "completion": "wire        pcSrc;\n    wire        regDst;\n    wire        regWrite;\n    wire        aluSrc;\n    wire        aluZero;\n    wire [ 3:0] aluControl;\n    wire        exControl;\n\n    wire [31:0] pc;\n    wire [31:0] pcBranch;\n    wire [31:0] pcNext  = pc + 1;\n    wire [31:0] pc_new   = ~pcSrc ? pcNext : pcBranch;\n    sm_register r_pc(clk, rst_n, pc_new, pc);\n\n    assign imAddr = pc;\n    wire [31:0] instr = imData;\n\n    wire [31:0] rd0;\n    assign regData = (regAddr != 0) ? rd0 : pc;\n\n    wire [ 4:0] a3  = regDst ? instr[15:11] : instr[20:16];\n    wire [31:0] rd1;\n    wire [31:0] rd2;\n    wire [31:0] wd3;\n\n    sm_register_file rf\n    (\n        .clk        ( clk          ),\n        .a0         ( regAddr      ),\n        .a1         ( instr[25:21] ),\n        .a2         ( instr[20:16] ),\n        .a3         ( a3           ),\n        .rd0        ( rd0          ),\n        .rd1        ( rd1          ),\n        .rd2        ( rd2          ),\n        .wd3        ( wd3          ),\n        .we3        ( regWrite     )\n    );\n\n    wire signExtend;\n    wire [31:0] signImm = (exControl) ? {{24 { exData[7] }}, exData[7:0] } \n    : (~signExtend) ? { {16 { instr[15] }}, instr[15:0] } : { {16 {1'b0}}, instr[15:0] };\n    assign pcBranch = pcNext + signImm;\n\n    wire [31:0] srcB = aluSrc ? signImm : rd2;\n\n    sm_alu alu\n    (\n        .srcA       ( (exControl) ? 32'b0: rd1 ),\n        .srcB       ( srcB         ),\n        .oper       ( aluControl   ),\n        .shift      ( instr[10:6 ] ),\n        .sign       ( aluZero      ),\n        .result     ( wd3          ) \n    );\n\n    sm_control sm_control\n    (\n        .cmdOper    ( instr[31:26] ),\n        .cmdFunk    ( instr[ 5:0 ] ),\n        .aluZero    ( aluZero      ),\n        .pcSrc      ( pcSrc        ), \n        .regDst     ( regDst       ), \n        .regWrite   ( regWrite     ), \n        .aluSrc     ( aluSrc       ),\n        .aluControl ( aluControl   ),\n        .exControl  ( exControl    )\n    );\nendmodule"}
{"task_id": 614, "completion": "output Q;\n    input  CLK;\n    input  D;\n    input  RESET_B;\n\n    wire buf_Q;\n    wire RESET;\n\n    not not0 (RESET , RESET_B);\n    sky130_fd_sc_hvl__udp_dff$PR `UNIT_DELAY dff0 (buf_Q , D, CLK, RESET);\n    buf buf0 (Q , buf_Q);\n\nendmodule"}
{"task_id": 605, "completion": "wire or0_out;    wire or1_out;    wire and0_out_X;    wire pwrgood_pp0_out_X;    or or0 (or0_out, A2, A1);    or or1 (or1_out, B2, B1);    and and0 (and0_out_X, or0_out, or1_out);    sky130_fd_sc_hdll__udp_pwrgood_pp$PG pwrgood_pp0 (pwrgood_pp0_out_X, and0_out_X, VPWR, VGND);    buf buf0 (X, pwrgood_pp0_out_X);    endmodule"}
{"task_id": 612, "completion": "output X   ;\n    input  A1  ;\n    input  A2  ;\n    input  A3  ;\n    input  B1  ;\n    input  B2  ;\n    input  VPWR;\n    input  VGND;\n    input  VPB ;\n    input  VNB ;\n    sky130_fd_sc_ls__a32o base (\n        .X(X),\n        .A1(A1),\n        .A2(A2),\n        .A3(A3),\n        .B1(B1),\n        .B2(B2),\n        .VPWR(VPWR),\n        .VGND(VGND),\n        .VPB(VPB),\n        .VNB(VNB)\n    );\n\nendmodule"}
{"task_id": 532, "completion": "IBUFG #(.IOSTANDARD(\"DEFAULT\") ) pck0b(        .O(pck0),        .I(pck0i)    );    IBUFG #(.IOSTANDARD(\"DEFAULT\") ) spckb(        .O(spck),        .I(spcki)    );    reg [15:0] shift_reg;    reg [7:0] divisor;    reg [7:0] conf_word;    always @(posedge ncs)    begin        case(shift_reg[15:12])            4'b0001: conf_word <= shift_reg[7:0];            4'b0010: divisor <= shift_reg[7:0];        endcase    end    always @(posedge spck)    begin        if(~ncs)        begin            shift_reg[15:1] <= shift_reg[14:0];            shift_reg[0] <= mosi;        end    end    wire [2:0] major_mode;    assign major_mode = conf_word[7:5];    wire lo_is_125khz;    assign lo_is_125khz = conf_word[3];    wire hi_read_tx_shallow_modulation;    assign hi_read_tx_shallow_modulation = conf_word[0];    wire hi_read_rx_xcorr_848;    assign hi_read_rx_xcorr_848 = conf_word[0];    wire hi_read_rx_xcorr_snoop;    assign hi_read_rx_xcorr_snoop = conf_word[1];    wire hi_read_rx_xcorr_quarter;    assign hi_read_rx_xcorr_quarter = conf_word[2];    wire [2:0] hi_simulate_mod_type;    assign hi_simulate_mod_type = conf_word[2:0];    lo_read lr(        pck0, ck_1356meg, ck_1356megb,        lr_pwr_lo, lr_pwr_hi, lr_pwr_oe1, lr_pwr_oe2, lr_pwr_oe3, lr_pwr_oe4,        adc_d, lr_adc_clk,        lr_ssp_frame, lr_ssp_din, ssp_dout, lr_ssp_clk,        cross_hi, cross_lo,        lr_dbg,        lo_is_125khz, divisor    );    lo_passthru lp(        pck0, ck_1356meg, ck_1356megb,        lp_pwr_lo, lp_pwr_hi, lp_pwr_oe1, lp_pwr_oe2, lp_pwr_oe3, lp_pwr_oe4,        adc_d, lp_adc_clk,        lp_ssp_frame, lp_ssp_din, ssp_dout, lp_ssp_clk,        cross_hi, cross_lo,        lp_dbg, divisor    );    lo_simulate ls(        pck0, ck_1356meg, ck_1356megb,        ls_pwr_lo, ls_pwr_hi, ls_pwr_oe1, ls_pwr_oe2, ls_pwr_oe3, ls_pwr_oe4,        adc_d, ls_adc_clk,        ls_ssp_frame, ls_ssp_din, ssp_dout, ls_ssp_clk,        cross_hi, cross_lo,        ls_dbg, divisor    );    hi_read_tx ht(        pck0, ck_1356meg, ck_1356megb,        ht_pwr_lo, ht_pwr_hi, ht_pwr_oe1, ht_pwr_oe2, ht_pwr_oe3, ht_pwr_oe4,        adc_d, ht_adc_clk,        ht_ssp_frame, ht_ssp_din, ssp_dout, ht_ssp_clk,        cross_hi, cross_lo,        ht_dbg,        hi_read_tx_shallow_modulation    );    hi_read_rx_xcorr hrxc(        pck0, ck_1356meg, ck_1356megb,        hrxc_pwr_lo, hrxc_pwr_hi, hrxc_pwr_oe1, hrxc_pwr_oe2, hrxc_pwr_oe3, hrxc_pwr_oe4,        adc_d, hrxc_adc_clk,        hrxc_ssp_frame, hrxc_ssp_din, ssp_dout, hrxc_ssp_clk,        cross_hi, cross_lo,        hrxc_dbg,        hi_read_rx_xcorr_848, hi_read_rx_xcorr_snoop, hi_read_rx_xcorr_quarter    );    hi_simulate hs(        pck0, ck_1356meg, ck_1356megb,        hs_pwr_lo, hs_pwr_hi, hs_pwr_oe1, hs_pwr_oe2, hs_pwr_oe3, hs_pwr_oe4,        adc_d, hs_adc_clk,        hs_ssp_frame, hs_ssp_din, ssp_dout, hs_ssp_clk,        cross_hi, cross_lo,        hs_dbg,        hi_simulate_mod_type    );    hi_iso14443a hisn(        pck0, ck_1356meg, ck_1356megb,        hisn_pwr_lo, hisn_pwr_hi, hisn_pwr_oe1, hisn_pwr_oe2, hisn_pwr_oe3, hisn_pwr_oe4,        adc_d, hisn_adc_clk,        hisn_ssp_frame, hisn_ssp_din, ssp_dout, hisn_ssp_clk,        cross_hi, cross_lo,        hisn_dbg,        hi_simulate_mod_type    );    mux8 mux_ssp_clk(major_mode, ssp_clk, lr_ssp_clk, ls_ssp_clk, ht_ssp_clk, hrxc_ssp_clk, hs_ssp_clk, hisn_ssp_clk, lp_ssp_clk, 1'b0);    mux8 mux_ssp_din(major_mode, ssp_din, lr_ssp_din, ls_ssp_din, ht_ssp_din, hrxc_ssp_din, hs_ssp_din, hisn_ssp_din, lp_ssp_din, 1'b0);    mux8 mux_ssp_frame(major_mode, ssp_frame, lr_ssp_frame, ls_ssp_frame, ht_ssp_frame, hrxc_ssp_frame, hs_ssp_frame, hisn_ssp_frame, lp_ssp_frame, 1'b0);    mux8 mux_pwr_oe1(major_mode, pwr_oe1, lr_pwr_oe1, ls_pwr_oe1, ht_pwr_oe1, hrxc_pwr_oe1, hs_pwr_oe1, hisn_pwr_oe1, lp_pwr_oe1, 1'b0);    mux8 mux_pwr_oe2(major_mode, pwr_oe2, lr_pwr_oe2, ls_pwr_oe2, ht_pwr_oe2, hrxc_pwr_oe2, hs_pwr_oe2, hisn_pwr_oe2, lp_pwr_oe2, 1'b0);    mux8 mux_pwr_oe3(major_mode, pwr_oe3, lr_pwr_oe3, ls_pwr_oe3, ht_pwr_oe3, hrxc_pwr_oe3, hs_pwr_oe3, hisn_pwr_oe3, lp_pwr_oe3, 1'b0);    mux8 mux_pwr_oe4(major_mode, pwr_oe4, lr_pwr_oe4, ls_pwr_oe4, ht_pwr_oe4, hrxc_pwr_oe4, hs_pwr_oe4, hisn_pwr_oe4, lp_pwr_oe4, 1'b0);    mux8 mux_pwr_lo(major_mode, pwr_lo, lr_pwr_lo, ls_pwr_lo, ht_pwr_lo, hrxc_pwr_lo, hs_pwr_lo, hisn_pwr_lo, lp_pwr_lo, 1'b0);    mux8 mux_pwr_hi(major_mode, pwr_hi, lr_pwr_hi, ls_pwr_hi, ht_pwr_hi, hrxc_pwr_hi, hs_pwr_hi, hisn_pwr_hi, lp_pwr_hi, 1'b0);    mux8 mux_adc_clk(major_mode, adc_clk, lr_adc_clk, ls_adc_clk, ht_adc_clk, hrxc_adc_clk, hs_adc_clk, hisn_adc_clk, lp_adc_clk, 1'b0);    mux8 mux_dbg(major_mode, dbg, lr_dbg, ls_dbg, ht_dbg, hrxc_dbg, hs_dbg, hisn_dbg, lp_dbg, 1'b0);    assign adc_noe = 1'b0;endmodule"}
{"task_id": 618, "completion": "output Y;\n    input  A;\n    input  B;\n\n    // Voltage supply signals\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB;\n    supply0 VNB;\n\n    sky130_fd_sc_hd__nand2 base (\n        .Y(Y),\n        .A(A),\n        .B(B)\n    );\n\nendmodule"}
{"task_id": 582, "completion": "input aclr;\n    input [65:0] data;\n    input rdclk;\n    input rdreq;\n    input wrclk;\n    input wrreq;\n    output [65:0] q;\n    output rdempty;\n    output wrfull;\n    tri0 aclr;\n\n    wire sub_wire0;\n    wire [65:0] sub_wire1;\n    wire sub_wire2;\n    wire wrfull = sub_wire0;\n    wire [65:0] q = sub_wire1[65:0];\n    wire rdempty = sub_wire2;\n\n    dcfifo dcfifo_component (\n                .rdclk (rdclk),\n                .wrclk (wrclk),\n                .wrreq (wrreq),\n                .aclr (aclr),\n                .data (data),\n                .rdreq (rdreq),\n                .wrfull (sub_wire0),\n                .q (sub_wire1),\n                .rdempty (sub_wire2),\n                .rdfull (),\n                .rdusedw (),\n                .wrempty (),\n                .wrusedw ());\n    defparam\n        dcfifo_component.intended_device_family = \"Stratix V\",\n        dcfifo_component.lpm_numwords = 32,\n        dcfifo_component.lpm_showahead = \"OFF\",\n        dcfifo_component.lpm_type = \"dcfifo\",\n        dcfifo_component.lpm_width = 66,\n        dcfifo_component.lpm_widthu = 5,\n        dcfifo_component.overflow_checking = \"ON\",\n        dcfifo_component.rdsync_delaypipe = 4,\n        dcfifo_component.read_aclr_synch = \"OFF\",\n        dcfifo_component.underflow_checking = \"ON\",\n        dcfifo_component.use_eab = \"ON\",\n        dcfifo_component.write_aclr_synch = \"OFF\",\n        dcfifo_component.wrsync_delaypipe = 4;\n\nendmodule"}
{"task_id": 617, "completion": "pullup   pullup0   (HI    );\n    pulldown pulldown0 (LO    );\nendmodule"}
{"task_id": 503, "completion": "BLK_MEM_GEN_V7_3 #(\n    .C_ADDRA_WIDTH(11),\n    .C_ADDRB_WIDTH(11),\n    .C_ALGORITHM(1),\n    .C_AXI_ID_WIDTH(4),\n    .C_AXI_SLAVE_TYPE(0),\n    .C_AXI_TYPE(1),\n    .C_BYTE_SIZE(9),\n    .C_COMMON_CLK(0),\n    .C_DEFAULT_DATA(\"0\"),\n    .C_DISABLE_WARN_BHV_COLL(0),\n    .C_DISABLE_WARN_BHV_RANGE(0),\n    .C_ENABLE_32BIT_ADDRESS(0),\n    .C_FAMILY(\"virtex5\"),\n    .C_HAS_AXI_ID(0),\n    .C_HAS_ENA(1),\n    .C_HAS_ENB(1),\n    .C_HAS_INJECTERR(0),\n    .C_HAS_MEM_OUTPUT_REGS_A(0),\n    .C_HAS_MEM_OUTPUT_REGS_B(0),\n    .C_HAS_MUX_OUTPUT_REGS_A(0),\n    .C_HAS_MUX_OUTPUT_REGS_B(0),\n    .C_HAS_REGCEA(0),\n    .C_HAS_REGCEB(0),\n    .C_HAS_RSTA(0),\n    .C_HAS_RSTB(0),\n    .C_HAS_SOFTECC_INPUT_REGS_A(0),\n    .C_HAS_SOFTECC_OUTPUT_REGS_B(0),\n    .C_INIT_FILE(\"BlankString\"),\n    .C_INIT_FILE_NAME(\"no_coe_file_loaded\"),\n    .C_INITA_VAL(\"0\"),\n    .C_INITB_VAL(\"0\"),\n    .C_INTERFACE_TYPE(0),\n    .C_LOAD_INIT_FILE(0),\n    .C_MEM_TYPE(1),\n    .C_MUX_PIPELINE_STAGES(0),\n    .C_PRIM_TYPE(1),\n    .C_READ_DEPTH_A(2048),\n    .C_READ_DEPTH_B(2048),\n    .C_READ_WIDTH_A(32),\n    .C_READ_WIDTH_B(32),\n    .C_RST_PRIORITY_A(\"CE\"),\n    .C_RST_PRIORITY_B(\"CE\"),\n    .C_RST_TYPE(\"SYNC\"),\n    .C_RSTRAM_A(0),\n    .C_RSTRAM_B(0),\n    .C_SIM_COLLISION_CHECK(\"ALL\"),\n    .C_USE_BRAM_BLOCK(0),\n    .C_USE_BYTE_WEA(0),\n    .C_USE_BYTE_WEB(0),\n    .C_USE_DEFAULT_DATA(0),\n    .C_USE_ECC(0),\n    .C_USE_SOFTECC(0),\n    .C_WEA_WIDTH(1),\n    .C_WEB_WIDTH(1),\n    .C_WRITE_DEPTH_A(2048),\n    .C_WRITE_DEPTH_B(2048),\n    .C_WRITE_MODE_A(\"WRITE_FIRST\"),\n    .C_WRITE_MODE_B(\"WRITE_FIRST\"),\n    .C_WRITE_WIDTH_A(32),\n    .C_WRITE_WIDTH_B(32),\n    .C_XDEVICEFAMILY(\"virtex5\")\n  )\n  inst (\n    .CLKA(clka),\n    .ENA(ena),\n    .WEA(wea),\n    .ADDRA(addra),\n    .DINA(dina),\n    .CLKB(clkb),\n    .ENB(enb),\n    .ADDRB(addrb),\n    .DOUTB(doutb),\n    .RSTA(),\n    .REGCEA(),\n    .DOUTA(),\n    .RSTB(),\n    .REGCEB(),\n    .WEB(),\n    .DINB(),\n    .INJECTSBITERR(),\n    .INJECTDBITERR(),\n    .SBITERR(),\n    .DBITERR(),\n    .RDADDRECC(),\n    .S_ACLK(),\n    .S_ARESETN(),\n    .S_AXI_AWID(),\n    .S_AXI_AWADDR(),\n    .S_AXI_AWLEN(),\n    .S_AXI_AWSIZE(),\n    .S_AXI_AWBURST(),\n    .S_AXI_AWVALID(),\n    .S_AXI_AWREADY(),\n    .S_AXI_WDATA(),\n    .S_AXI_WSTRB(),\n    .S_AXI_WLAST(),\n    .S_AXI_WVALID(),\n    .S_AXI_WREADY(),\n    .S_AXI_BID(),\n    .S_AXI_BRESP(),\n    .S_AXI_BVALID(),\n    .S_AXI_BREADY(),\n    .S_AXI_ARID(),\n    .S_AXI_ARADDR(),\n    .S_AXI_ARLEN(),\n    .S_AXI_ARSIZE(),\n    .S_AXI_ARBURST(),\n    .S_AXI_ARVALID(),\n    .S_AXI_ARREADY(),\n    .S_AXI_RID(),\n    .S_AXI_RDATA(),\n    .S_AXI_RRESP(),\n    .S_AXI_RLAST(),\n    .S_AXI_RVALID(),\n    .S_AXI_RREADY(),\n    .S_AXI_INJECTSBITERR(),\n    .S_AXI_INJECTDBITERR(),\n    .S_AXI_SBITERR(),\n    .S_AXI_DBITERR(),\n    .S_AXI_RDADDRECC()\n  );\n\nendmodule"}
{"task_id": 588, "completion": "output GCLK;\n    input  SCE;\n    input  GATE;\n    input  CLK;\n    input  VPWR;\n    input  VGND;\n    input  VPB;\n    input  VNB;\n\n    wire m0;\n    wire m0n;\n    wire clkn;\n    wire CLK_delayed;\n    wire SCE_delayed;\n    wire GATE_delayed;\n    wire SCE_gate_delayed;\n    wire GCLK_b;\n    reg  notifier;\n    wire awake;\n    wire SCE_awake;\n    wire GATE_awake;\n\n    not not0 (m0n, m0);\n    not not1 (clkn, CLK_delayed);\n    nor nor0 (SCE_gate_delayed, GATE_delayed, SCE_delayed);\n    sky130_fd_sc_hvl__udp_dlatch$P_pp$PG$N dlatch0 (m0, SCE_gate_delayed, clkn, notifier, VPWR, VGND);\n    and and0 (GCLK_b, m0n, CLK_delayed);\n    sky130_fd_sc_hvl__udp_pwrgood_pp$PG pwrgood_pp0 (GCLK, GCLK_b, VPWR, VGND);\n    assign awake = ( VPWR === 1'b1 );\n    assign SCE_awake = ( ( GATE_delayed === 1'b0 ) & awake );\n    assign GATE_awake = ( ( SCE_delayed === 1'b0 ) & awake );\n\nendmodule"}
{"task_id": 619, "completion": "assign X = A_N & B & C;\nendmodule"}
{"task_id": 631, "completion": "endmodule"}
{"task_id": 625, "completion": "wire buf0_out_X;\n\n    buf buf0 (buf0_out_X, A              );\n    buf buf1 (X         , buf0_out_X     );\n\nendmodule"}
{"task_id": 622, "completion": "assign out = in + 4'b0011;\nendmodule"}
{"task_id": 587, "completion": "wire and0_out ;\n    wire and1_out ;\n    wire nor0_out_Y ;\n    wire pwrgood_pp0_out_Y;\n\n    and and0 (and0_out , B1, B2 );\n    and and1 (and1_out , A1, A2 );\n    nor nor0 (nor0_out_Y , and0_out, C1, and1_out);\n    sky130_fd_sc_hdll__udp_pwrgood_pp$PG pwrgood_pp0 (pwrgood_pp0_out_Y, nor0_out_Y, VPWR, VGND);\n    buf buf0 (Y , pwrgood_pp0_out_Y );\n\nendmodule"}
{"task_id": 599, "completion": "// MMU \u903b\u8f91\u5b9e\u73b0\u90e8\u5206\u4ee3\u7801   endmodule"}
{"task_id": 642, "completion": "supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\nendmodule"}
{"task_id": 647, "completion": "supply1 VPWR;\n    supply0 VGND;\nendmodule"}
{"task_id": 650, "completion": "supply1 VPWR;\n    supply1 VPB;\n    supply0 VNB;\n\n    wire vgnd;\n\n    pulldown pulldown0 (vgnd);\n    bufif0   bufif00   (VIRTPWR, VPWR, SLEEP);\n\nendmodule"}
{"task_id": 646, "completion": "assign X = (A1 | A2) & ~B1_N;\nendmodule"}
{"task_id": 69, "completion": "genvar target_cnt;\n  genvar region_cnt;\n\n  function decode_address;\n    input [C_ADDR_WIDTH-1:0] base, high, addr;\n    reg [C_ADDR_WIDTH-C_RESOLUTION-1:0] mask;\n    reg [C_ADDR_WIDTH-C_RESOLUTION-1:0] addr_page;\n    reg [C_ADDR_WIDTH-C_RESOLUTION-1:0] base_page;\n    reg [C_ADDR_WIDTH-C_RESOLUTION-1:0] high_page;\n  begin\n    addr_page = addr[C_RESOLUTION+:C_ADDR_WIDTH-C_RESOLUTION];\n    base_page = base[C_RESOLUTION+:C_ADDR_WIDTH-C_RESOLUTION];\n    high_page = high[C_RESOLUTION+:C_ADDR_WIDTH-C_RESOLUTION];\n    if (base[C_ADDR_WIDTH-1] & ~high[C_ADDR_WIDTH-1]) begin\n      decode_address = 1'b0;\n    end else begin\n      mask = base_page ^ high_page;\n      if ((base_page & ~mask) == (addr_page & ~mask)) begin\n        decode_address = 1'b1;\n      end else begin\n        decode_address = 1'b0;\n      end\n    end\n  end\n  endfunction\n\n  function [3:0] f_hot2enc;\n    input [15:0] one_hot;\n  begin\n    f_hot2enc[0] = |(one_hot & 16'b1010101010101010);\n    f_hot2enc[1] = |(one_hot & 16'b1100110011001100);\n    f_hot2enc[2] = |(one_hot & 16'b1111000011110000);\n    f_hot2enc[3] = |(one_hot & 16'b1111111100000000);\n  end\n  endfunction\n\n  wire [C_NUM_TARGETS-1:0] TARGET_HOT_I;\n  wire [C_NUM_TARGETS*C_NUM_RANGES-1:0] ADDRESS_HIT;\n  wire [C_NUM_TARGETS*C_NUM_RANGES-1:0] ADDRESS_HIT_REG;\n  wire [C_NUM_RANGES-1:0] REGION_HOT;\n  wire [3:0] TARGET_ENC_I;\n\n  generate\n    for (target_cnt = 0; target_cnt < C_NUM_TARGETS; target_cnt = target_cnt + 1) begin : gen_target\n      for (region_cnt = 0; region_cnt < C_NUM_RANGES; region_cnt = region_cnt + 1) begin : gen_region\n        if ((C_ADDR_WIDTH - C_RESOLUTION) > C_COMPARATOR_THRESHOLD) begin : gen_comparator_static\n          if (C_TARGET_QUAL[target_cnt] &&\n              ((C_BASE_ADDR[(target_cnt*C_NUM_RANGES+region_cnt)*64 +: C_ADDR_WIDTH] == 0) ||\n               (C_HIGH_ADDR[(target_cnt*C_NUM_RANGES+region_cnt)*64 +: C_ADDR_WIDTH] != 0))) begin : gen_addr_range\n            generic_baseblocks_v2_1_comparator_static #\n            (\n            .C_FAMILY(\"rtl\"),\n            .C_VALUE(C_BASE_ADDR[(target_cnt*C_NUM_RANGES+region_cnt)*64+C_RESOLUTION +: C_ADDR_WIDTH-C_RESOLUTION]),\n            .C_DATA_WIDTH(C_ADDR_WIDTH-C_RESOLUTION)\n            ) addr_decode_comparator\n            (\n            .CIN(1'b1),\n            .A(ADDR[C_RESOLUTION +: C_ADDR_WIDTH-C_RESOLUTION] &\n              ~(C_BASE_ADDR[(target_cnt*C_NUM_RANGES+region_cnt)*64+C_RESOLUTION +: C_ADDR_WIDTH-C_RESOLUTION] ^\n                C_HIGH_ADDR[(target_cnt*C_NUM_RANGES+region_cnt)*64+C_RESOLUTION +: C_ADDR_WIDTH-C_RESOLUTION)),\n            .COUT(ADDRESS_HIT[target_cnt*C_NUM_RANGES + region_cnt])\n            );\n          end else begin : gen_null_range\n            assign ADDRESS_HIT[target_cnt*C_NUM_RANGES + region_cnt] = 1'b0;\n          end\n        end else begin : gen_no_comparator_static\n          assign ADDRESS_HIT[target_cnt*C_NUM_RANGES + region_cnt] = C_TARGET_QUAL[target_cnt] ? \n                                    decode_address(\n                                      C_BASE_ADDR[(target_cnt*C_NUM_RANGES+region_cnt)*64 +: C_ADDR_WIDTH],\n                                      C_HIGH_ADDR[(target_cnt*C_NUM_RANGES+region_cnt)*64 +: C_ADDR_WIDTH],\n                                      ADDR)\n                                    : 1'b0;\n        end\n        assign ADDRESS_HIT_REG[region_cnt*C_NUM_TARGETS+target_cnt] = ADDRESS_HIT[target_cnt*C_NUM_RANGES + region_cnt];\n        assign REGION_HOT[region_cnt] = | ADDRESS_HIT_REG[region_cnt*C_NUM_TARGETS +: C_NUM_TARGETS];\n      end\n      assign TARGET_HOT_I[target_cnt]  = | ADDRESS_HIT[target_cnt*C_NUM_RANGES +: C_NUM_RANGES];\n    end\n  endgenerate\n\n  assign MATCH = | TARGET_HOT_I;\n\n  generate\n    if (C_TARGET_HOT == 1) begin : USE_TARGET_ONEHOT\n      assign TARGET_HOT = MATCH ? TARGET_HOT_I : 1;\n    end else begin : NO_TARGET_ONEHOT\n      assign TARGET_HOT = {C_NUM_TARGETS{1'b0}};\n    end\n  endgenerate\n\n  generate\n    if (C_TARGET_ENC == 1) begin : USE_TARGET_ENCODED\n      assign TARGET_ENC_I = f_hot2enc(TARGET_HOT_I);\n      assign TARGET_ENC   = TARGET_ENC_I[C_NUM_TARGETS_LOG-1:0];\n    end else begin : NO_TARGET_ENCODED\n      assign TARGET_ENC = {C_NUM_TARGETS_LOG{1'b0}};\n    end\n  endgenerate\n\n  generate\n    if (C_TARGET_ENC == 1) begin : USE_REGION_ENCODED\n      assign REGION = f_hot2enc(REGION_HOT);\n    end else begin : NO_REGION_ENCODED\n      assign REGION = 4'b0;\n    end\n  endgenerate\n\nendmodule"}
{"task_id": 661, "completion": "supply1 VPWR;\n    supply0 VGND;\nendmodule"}
{"task_id": 611, "completion": "assign seled_v=(v_i_m_areg==1'b1)?3'b100:(v_d_m_areg==1'b1)?3'b010:(v_mem_download==1'b1)?3'b001:3'b000;\n\n always@(*)\n begin\n   //default values\n\t{ack_i_m_areg,ack_d_m_areg,ack_m_download}=3'b000;\n\t{v_i_m_areg_m,v_d_m_areg_m,v_m_download_m}=3'b000;\n\tnstate=state;\n   case(state)\n     arbiter_idle:\n       begin\n           {ack_i_m_areg,ack_d_m_areg,ack_m_download}=seled_v;\n           {v_i_m_areg_m,v_d_m_areg_m,v_m_download_m}=seled_v;\n           if(seled_v==3'b100)\n             nstate=i_m_areg_busy;\n           else \n           if(seled_v==3'b010)\n             nstate=d_m_areg_busy;\n           else \n           if(seled_v==3'b001)\n             nstate=m_download_busy;\n       end   \n     i_m_areg_busy:\n       begin\n         if(mem_access_done)\n           begin\n             nstate=arbiter_idle;\n           end\n         {ack_i_m_areg,ack_d_m_areg,ack_m_download}=3'b100;\n         {v_i_m_areg_m,v_d_m_areg_m,v_m_download_m}=3'b100;\n       end \n     d_m_areg_busy:\n       begin\n         if(mem_access_done)\n           begin\n             nstate=arbiter_idle;\n           end\n         {ack_i_m_areg,ack_d_m_areg,ack_m_download}=3'b010;\n         {v_i_m_areg_m,v_d_m_areg_m,v_m_download_m}=3'b010;\n       end\n     m_download_busy:\n       begin\n         if(mem_access_done)\n           begin\n             nstate=arbiter_idle;\n           end\n         {ack_i_m_areg,ack_d_m_areg,ack_m_download}=3'b001;\n         {v_i_m_areg_m,v_d_m_areg_m,v_m_download_m}=3'b001;\n       end        \n endcase\nend       \n /// state reg\n always@(posedge clk)\nbegin\n  if(rst)\n    state<=2'b00;\n  else \n    state<=nstate;\nend                         \nendmodule"}
{"task_id": 662, "completion": "// Voltage supply signals\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\nendmodule"}
{"task_id": 608, "completion": "xlconcat_v2_1_1_xlconcat #(\n    .IN0_WIDTH(1),\n    .IN1_WIDTH(1),\n    .IN2_WIDTH(1),\n    .IN3_WIDTH(1),\n    .IN4_WIDTH(1),\n    .IN5_WIDTH(1),\n    .IN6_WIDTH(1),\n    .IN7_WIDTH(1),\n    .IN8_WIDTH(1),\n    .IN9_WIDTH(1),\n    .IN10_WIDTH(1),\n    .IN11_WIDTH(1),\n    .IN12_WIDTH(1),\n    .IN13_WIDTH(1),\n    .IN14_WIDTH(1),\n    .IN15_WIDTH(1),\n    .IN16_WIDTH(1),\n    .IN17_WIDTH(1),\n    .IN18_WIDTH(1),\n    .IN19_WIDTH(1),\n    .IN20_WIDTH(1),\n    .IN21_WIDTH(1),\n    .IN22_WIDTH(1),\n    .IN23_WIDTH(1),\n    .IN24_WIDTH(1),\n    .IN25_WIDTH(1),\n    .IN26_WIDTH(1),\n    .IN27_WIDTH(1),\n    .IN28_WIDTH(1),\n    .IN29_WIDTH(1),\n    .IN30_WIDTH(1),\n    .IN31_WIDTH(1),\n    .dout_width(2),\n    .NUM_PORTS(2)\n  ) inst (\n    .In0(In0),\n    .In1(In1),\n    .In2(1'B0),\n    .In3(1'B0),\n    .In4(1'B0),\n    .In5(1'B0),\n    .In6(1'B0),\n    .In7(1'B0),\n    .In8(1'B0),\n    .In9(1'B0),\n    .In10(1'B0),\n    .In11(1'B0),\n    .In12(1'B0),\n    .In13(1'B0),\n    .In14(1'B0),\n    .In15(1'B0),\n    .In16(1'B0),\n    .In17(1'B0),\n    .In18(1'B0),\n    .In19(1'B0),\n    .In20(1'B0),\n    .In21(1'B0),\n    .In22(1'B0),\n    .In23(1'B0),\n    .In24(1'B0),\n    .In25(1'B0),\n    .In26(1'B0),\n    .In27(1'B0),\n    .In28(1'B0),\n    .In29(1'B0),\n    .In30(1'B0),\n    .In31(1'B0),\n    .dout(dout)\n  );\nendmodule"}
{"task_id": 567, "completion": "wire [3:0]    syndrome;\n\n    assign #`DEL syndrome[0] = edc_in[3] ^ data_in[7] ^ data_in[6] ^ data_in[4] ^ data_in[3] ^ data_in[1];\n    assign #`DEL syndrome[1] = edc_in[2] ^ data_in[7] ^ data_in[5] ^ data_in[4] ^ data_in[2] ^ data_in[1];\n    assign #`DEL syndrome[2] = edc_in[1] ^ data_in[6] ^ data_in[5] ^ data_in[4] ^ data_in[0];\n    assign #`DEL syndrome[3] = edc_in[0] ^ data_in[3] ^ data_in[2] ^ data_in[1] ^ data_in[0];\n\n    always @(syndrome or data_in) begin\n        data_out = data_in;\n\n        case (syndrome)     // synthesis parallel_case full_case\n            4'h0: begin\n                error = 0;\n            end\n            4'h1: begin\n                error = 1;\n            end\n            4'h2: begin\n                error = 1;\n            end\n            4'h4: begin\n                error = 1;\n            end\n            4'h8: begin\n                error = 1;\n            end\n            4'h3: begin\n                data_out[7] = ~data_in[7];\n                error = 1;\n            end\n            4'h5: begin\n                data_out[6] = ~data_in[6];\n                error = 1;\n            end\n            4'h6: begin\n                data_out[5] = ~data_in[5];\n                error = 1;\n            end\n            4'h7: begin\n                data_out[4] = ~data_in[4];\n                error = 1;\n            end\n            4'h9: begin\n                data_out[3] = ~data_in[3];\n                error = 1;\n            end\n            4'ha: begin\n                data_out[2] = ~data_in[2];\n                error = 1;\n            end\n            4'hb: begin\n                data_out[1] = ~data_in[1];\n                error = 1;\n            end\n            4'hc: begin\n                data_out[0] = ~data_in[0];\n                error = 1;\n            end\n        endcase\n    end\nendmodule"}
{"task_id": 462, "completion": "wire [31:0] pc_next;\n    wire [31:0] pc;\n\n    ProgramCounter ProgramCounter_0 (\n        .clock(clock),\n        .reset(reset),\n        .Stall(Stall),\n        .pc_next(pc_next),\n        .pc(pc)\n    );\n\n    wire [31:0] pc_plus_four;\n\n    PCPlus4 PCPlus4_0 (\n        .pc(pc),\n        .pc_plus_four(pc_plus_four)\n    );\n\n    wire [31:0] instruction;\n\n    InstructionMemory #(\n        .SIZE(INSTR_MEM_SIZE)\n    ) InstructionMemory_0 (\n        .Address(pc),\n        .Instruction(instruction)\n    );\n\n    wire [31:0] ID_pc_plus_four;\n    wire [31:0] ID_instruction;\n\n    IF_ID IF_ID_0 (\n        .clock(clock),\n        .WriteEnable(~Stall),\n        .Flush(0),\n        .pc_plus_four(pc_plus_four),\n        .ID_pc_plus_four(ID_pc_plus_four),\n        .instruction(instruction),\n        .ID_instruction(ID_instruction)\n    );\n\n    wire [5:0] opcode;\n    assign opcode = ID_instruction[31:26];\n    wire [4:0] rs;\n    assign rs = ID_instruction[25:21];\n    wire [4:0] rt;\n    assign rt = ID_instruction[20:16];\n    wire [4:0] rd;\n    assign rd = ID_instruction[15:11];\n    wire [5:0] funct;\n    assign funct = ID_instruction[5:0];\n    wire [15:0] immediate;\n    assign immediate = ID_instruction[15:0];\n\n    wire Stall;\n\n    HazardDetection HazardDetection_0 (\n        .EX_MemRead(EX_MemRead),\n        .rs(rs),\n        .rt(rt),\n        .EX_rt(EX_rt),\n        .Stall(Stall)\n    );\n\n    wire RegWrite;\n    wire RegDst;\n    wire MemRead;\n    wire MemWrite;\n    wire MemToReg;\n    wire Branch;\n    wire ALUSrc;\n    wire [1:0] ALUOp;\n\n    Control Control_0 (\n        .Opcode(opcode),\n        .RegWrite(RegWrite),\n        .RegDst(RegDst),\n        .MemRead(MemRead),\n        .MemWrite(MemWrite),\n        .MemToReg(MemToReg),\n        .Branch(Branch),\n        .ALUSrc(ALUSrc),\n        .ALUOp(ALUOp)\n    );\n\n    wire [8:0] BufferedControl;\n\n    mux2to1 #(\n        .WIDTH(9)\n    ) MuxControlStall (\n        .inA( {RegWrite, RegDst, MemRead, MemWrite, MemToReg, Branch, ALUSrc,\n            ALUOp} ),\n        .inB(9'b0),\n        .select(Stall),\n        .out(BufferedControl)\n    );\n\n    wire [31:0] RegReadDataA;\n    wire [31:0] RegReadDataB;\n    wire [31:0] RegWriteData;\n\n    Registers Registers_0 (\n        .clock(clock),\n        .reset(reset),\n        .ReadAddressA(rs),\n        .ReadDataA(RegReadDataA),\n        .ReadAddressB(rt),\n        .ReadDataB(RegReadDataB),\n        .WriteEnable(WB_RegWrite),\n        .WriteAddress(WB_RegWriteAddress),\n        .WriteData(RegWriteData)\n    );\n\n    wire [31:0] extended;\n\n    SignExtender SignExtender_0 (\n        .immediate(immediate),\n        .extended(extended)\n    );\n\n    wire [31:0] EX_instruction;\n\n    wire [31:0] EX_pc_plus_four;\n    wire [31:0] EX_RegReadDataA;\n    wire [31:0] EX_RegReadDataB;\n    wire [31:0] EX_extended;\n\n    wire EX_RegWrite;\n    wire EX_RegDst;\n    wire EX_MemRead;\n    wire EX_MemWrite;\n    wire EX_MemToReg;\n    wire EX_Branch;\n    wire EX_ALUSrc;\n    wire [1:0] EX_ALUOp;\n\n    wire [4:0] EX_rs;\n    wire [4:0] EX_rt;\n    wire [4:0] EX_rd;\n\n    ID_EX ID_EX_0 (\n        .clock(clock),\n        .ID_instruction(ID_instruction),\n        .EX_instruction(EX_instruction),\n        .ID_pc_plus_four(ID_pc_plus_four),\n        .EX_pc_plus_four(EX_pc_plus_four),\n        .RegReadDataA(RegReadDataA),\n        .EX_RegReadDataA(EX_RegReadDataA),\n        .RegReadDataB(RegReadDataB),\n        .EX_RegReadDataB(EX_RegReadDataB),\n        .extended(extended),\n        .EX_extended(EX_extended),\n        .RegWrite(BufferedControl[8]),\n        .EX_RegWrite(EX_RegWrite),\n        .RegDst(BufferedControl[7]),\n        .EX_RegDst(EX_RegDst),\n        .MemRead(BufferedControl[6]),\n        .EX_MemRead(EX_MemRead),\n        .MemWrite(BufferedControl[5]),\n        .EX_MemWrite(EX_MemWrite),\n        .MemToReg(BufferedControl[4]),\n        .EX_MemToReg(EX_MemToReg),\n        .Branch(BufferedControl[3]),\n        .EX_Branch(EX_Branch),\n        .ALUSrc(BufferedControl[2]),\n        .EX_ALUSrc(EX_ALUSrc),\n        .ALUOp(BufferedControl[1:0]),\n        .EX_ALUOp(EX_ALUOp),\n        .rs(rs),\n        .EX_rs(EX_rs),\n        .rt(rt),\n        .EX_rt(EX_rt),\n        .rd(rd),\n        .EX_rd(EX_rd)\n    );\n\n    wire [1:0] ForwardA;\n    wire [31:0] ALUArgA;\n\n    mux4to1 #(\n        .WIDTH(32)\n    ) MuxForwardA (\n        .inA(EX_RegReadDataA),\n        .inB(RegWriteData),\n        .inC(MEM_ALUResult),\n        .inD(32'b0),\n        .select(ForwardA),\n        .out(ALUArgA)\n    );\n\n    wire [1:0] ForwardB;\n    wire [31:0] ForwardBOut;\n\n    mux4to1 #(\n        .WIDTH(32)\n    ) MuxForwardB (\n        .inA(EX_RegReadDataB),\n        .inB(RegWriteData),\n        .inC(MEM_ALUResult),\n        .inD(32'b0),\n        .select(ForwardB),\n        .out(ForwardBOut)\n    );\n\n    wire [31:0] ALUArgB;\n\n    mux2to1 #(\n        .WIDTH(32)\n    ) MuxALUSrc (\n        .inA(ForwardBOut),\n        .inB(EX_extended),\n        .select(EX_ALUSrc),\n        .out(ALUArgB)\n    );\n\n    wire [31:0] ALUResult;\n    wire Zero;\n\n    ALU #(\n        .WIDTH(32)\n    ) ALU_0 (\n        .op(ALUCtrl),\n        .inA(ALUArgA),\n        .inB(ALUArgB),\n        .out(ALUResult),\n        .zero(Zero)\n    );\n\n    wire [5:0] EX_funct;\n    assign EX_funct = EX_extended[5:0];\n\n    wire [3:0] ALUCtrl;\n\n    ALUControl ALUControl_0 (\n        .Funct(EX_funct),\n        .ALUOp(EX_ALUOp),\n        .ALUCtrl(ALUCtrl)\n    );\n\n    wire [4:0] RegWriteAddress;\n\n    mux2to1 #(\n        .WIDTH(5)\n    ) MuxRegDst (\n        .inA(EX_rt),\n        .inB(EX_rd),\n        .select(EX_RegDst),\n        .out(RegWriteAddress)\n    );\n\n    wire [31:0] branch_address;\n\n    BranchAdder BranchAdder_0 (\n        .pc_plus_four(EX_pc_plus_four),\n        .extended_times_four(EX_extended << 2),\n        .branch_address(branch_address)\n    );\n\n    wire bneOne;\n    assign bneOne = ID_instruction[26];\n\n    wire [31:0] MEM_instruction;\n\n    wire [31:0] MEM_branch_address;\n    wire MEM_Zero;\n    wire [31:0] MEM_ALUResult;\n    wire [31:0] MEM_ForwardBOut;\n    wire [4:0] MEM_RegWriteAddress;\n    wire MEM_RegWrite;\n    wire MEM_MemRead;\n    wire MEM_MemWrite;\n    wire MEM_MemToReg;\n    wire MEM_Branch;\n    wire MEM_bneOne;\n\n    Forwarding Forwarding_0 (\n        .EX_rs(EX_rs),\n        .EX_rt(EX_rt),\n        .MEM_rd(MEM_rd),\n        .WB_rd(WB_rd),\n        .MEM_RegWrite(MEM_RegWrite),\n        .WB_RegWrite(WB_RegWrite),\n        .ForwardA(ForwardA),\n        .ForwardB(ForwardB)\n    );\n\n    EX_MEM EX_MEM_0 (\n        .clock(clock),\n        .EX_instruction(EX_instruction),\n        .MEM_instruction(MEM_instruction),\n        .branch_address(branch_address),\n        .MEM_branch_address(MEM_branch_address),\n        .Zero(Zero),\n        .MEM_Zero(MEM_Zero),\n        .ALUResult(ALUResult),\n        .MEM_ALUResult(MEM_ALUResult),\n        .ForwardBOut(ForwardBOut),\n        .MEM_ForwardBOut(MEM_ForwardBOut),\n        .RegWriteAddress(RegWriteAddress),\n        .MEM_RegWriteAddress(MEM_RegWriteAddress),\n        .EX_RegWrite(EX_RegWrite),\n        .MEM_RegWrite(MEM_RegWrite),\n        .EX_MemRead(EX_MemRead),\n        .MEM_MemRead(MEM_MemRead),\n        .EX_MemWrite(EX_MemWrite),\n        .MEM_MemWrite(MEM_MemWrite),\n        .EX_MemToReg(EX_MemToReg),\n        .MEM_MemToReg(MEM_MemToReg),\n        .EX_Branch(EX_Branch),\n        .MEM_Branch(MEM_Branch),\n        .bneOne(bneOne),\n        .MEM_bneOne(MEM_bneOne)\n    );\n\n    wire pc_chooser;\n\n    mux2to1 #(\n        .WIDTH(1)\n    ) MuxBeqBne (\n        .inA(MEM_Zero),\n        .inB(~MEM_Zero),\n        .select(MEM_bneOne),\n        .out(pc_chooser)\n    );\n\n    mux2to1 #(\n        .WIDTH(32)\n    ) MuxPCNext (\n        .inA(pc_plus_four),\n        .inB(MEM_branch_address),\n        .select(MEM_Branch && pc_chooser),\n        .out(pc_next)\n    );\n\n    wire [31:0] MemReadData;\n\n    Memory #(\n        .SIZE(DATA_MEM_SIZE)\n    ) DataMemory_0 (\n        .clock(clock),\n        .Address(MEM_ALUResult),\n        .ReadEnable(MEM_MemRead),\n        .ReadData(MemReadData),\n        .WriteEnable(MEM_MemWrite),\n        .WriteData(MEM_ForwardBOut)\n    );\n\n    wire [4:0] MEM_rd;\n    assign MEM_rd = MEM_RegWriteAddress;\n\n    wire [31:0] WB_instruction;\n\n    wire [31:0] WB_MemReadData;\n    wire [31:0] WB_ALUResult;\n    wire [4:0] WB_RegWriteAddress;\n\n    wire WB_RegWrite;\n    wire WB_MemToReg;\n\n    MEM_WB MEM_WB_0 (\n        .clock(clock),\n        .MEM_instruction(MEM_instruction),\n        .WB_instruction(WB_instruction),\n        .MemReadData(MemReadData),\n        .WB_MemReadData(WB_MemReadData),\n        .MEM_ALUResult(MEM_ALUResult),\n        .WB_ALUResult(WB_ALUResult),\n        .MEM_RegWriteAddress(MEM_RegWriteAddress),\n        .WB_RegWriteAddress(WB_RegWriteAddress),\n        .MEM_RegWrite(MEM_RegWrite),\n        .WB_RegWrite(WB_RegWrite),\n        .MEM_MemToReg(MEM_MemToReg),\n        .WB_MemToReg(WB_MemToReg)\n    );\n\n    mux2to1 #(\n        .WIDTH(32)\n    ) MuxMemtoReg (\n        .inA(WB_ALUResult),\n        .inB(WB_MemReadData),\n        .select(WB_MemToReg),\n        .out(RegWriteData)\n    );\n\n    wire [4:0] WB_rd;\n    assign WB_rd = WB_RegWriteAddress;\nendmodule"}
{"task_id": 558, "completion": "parameter DELAY_DATA_WIDTH = 16;\n  parameter DW = DELAY_DATA_WIDTH - 1;\n\n  reg p1_sign = 'd0;\n  reg [DW:0] p1_ddata = 'd0;\n  reg [23:0] p1_data_p_0 = 'd0;\n  reg [23:0] p1_data_p_1 = 'd0;\n  reg [23:0] p1_data_p_2 = 'd0;\n  reg [23:0] p1_data_p_3 = 'd0;\n  reg [23:0] p1_data_p_4 = 'd0;\n  reg p2_sign = 'd0;\n  reg [DW:0] p2_ddata = 'd0;\n  reg [23:0] p2_data_p_0 = 'd0;\n  reg [23:0] p2_data_p_1 = 'd0;\n  reg p3_sign = 'd0;\n  reg [DW:0] p3_ddata = 'd0;\n  reg [23:0] p3_data_p_0 = 'd0;\n  reg [DW:0] ddata_out = 'd0;\n  reg [24:0] data_p = 'd0;\n\n  wire [16:0] p1_data_a_1p_17_s;\n  wire [16:0] p1_data_a_1n_17_s;\n  wire [23:0] p1_data_a_1p_s;\n  wire [23:0] p1_data_a_1n_s;\n  wire [23:0] p1_data_a_2p_s;\n  wire [23:0] p1_data_a_2n_s;\n\n  assign p1_data_a_1p_17_s = {1'b0, data_a[15:0]};\n  assign p1_data_a_1n_17_s = ~p1_data_a_1p_17_s + 1'b1;\n\n  assign p1_data_a_1p_s = {{7{p1_data_a_1p_17_s[16]}}, p1_data_a_1p_17_s};\n  assign p1_data_a_1n_s = {{7{p1_data_a_1n_17_s[16]}}, p1_data_a_1n_17_s};\n  assign p1_data_a_2p_s = {{6{p1_data_a_1p_17_s[16]}}, p1_data_a_1p_17_s, 1'b0};\n  assign p1_data_a_2n_s = {{6{p1_data_a_1n_17_s[16]}}, p1_data_a_1n_17_s, 1'b0};\n\n  always @(posedge clk) begin\n    p1_sign <= data_a[16];\n    p1_ddata <= ddata_in;\n    case (data_b[1:0])\n      2'b11: p1_data_p_0 <= p1_data_a_1n_s;\n      2'b10: p1_data_p_0 <= p1_data_a_2n_s;\n      2'b01: p1_data_p_0 <= p1_data_a_1p_s;\n      default: p1_data_p_0 <= 24'd0;\n    endcase\n    case (data_b[3:1])\n      3'b011: p1_data_p_1 <= {p1_data_a_2p_s[21:0], 2'd0};\n      3'b100: p1_data_p_1 <= {p1_data_a_2n_s[21:0], 2'd0};\n      3'b001: p1_data_p_1 <= {p1_data_a_1p_s[21:0], 2'd0};\n      3'b010: p1_data_p_1 <= {p1_data_a_1p_s[21:0], 2'd0};\n      3'b101: p1_data_p_1 <= {p1_data_a_1n_s[21:0], 2'd0};\n      3'b110: p1_data_p_1 <= {p1_data_a_1n_s[21:0], 2'd0};\n      default: p1_data_p_1 <= 24'd0;\n    endcase\n    case (data_b[5:3])\n      3'b011: p1_data_p_2 <= {p1_data_a_2p_s[19:0], 4'd0};\n      3'b100: p1_data_p_2 <= {p1_data_a_2n_s[19:0], 4'd0};\n      3'b001: p1_data_p_2 <= {p1_data_a_1p_s[19:0], 4'd0};\n      3'b010: p1_data_p_2 <= {p1_data_a_1p_s[19:0], 4'd0};\n      3'b101: p1_data_p_2 <= {p1_data_a_1n_s[19:0], 4'd0};\n      3'b110: p1_data_p_2 <= {p1_data_a_1n_s[19:0], 4'd0};\n      default: p1_data_p_2 <= 24'd0;\n    endcase\n    case (data_b[7:5])\n      3'b011: p1_data_p_3 <= {p1_data_a_2p_s[17:0], 6'd0};\n      3'b100: p1_data_p_3 <= {p1_data_a_2n_s[17:0], 6'd0};\n      3'b001: p1_data_p_3 <= {p1_data_a_1p_s[17:0], 6'd0};\n      3'b010: p1_data_p_3 <= {p1_data_a_1p_s[17:0], 6'd0};\n      3'b101: p1_data_p_3 <= {p1_data_a_1n_s[17:0], 6'd0};\n      3'b110: p1_data_p_3 <= {p1_data_a_1n_s[17:0], 6'd0};\n      default: p1_data_p_3 <= 24'd0;\n    endcase\n    case (data_b[7])\n      1'b1: p1_data_p_4 <= {p1_data_a_1p_s[15:0], 8'd0};\n      default: p1_data_p_4 <= 24'd0;\n    endcase\n  end\n\n  always @(posedge clk) begin\n    p2_sign <= p1_sign;\n    p2_ddata <= p1_ddata;\n    p2_data_p_0 <= p1_data_p_0 + p1_data_p_1 + p1_data_p_4;\n    p2_data_p_1 <= p1_data_p_2 + p1_data_p_3;\n  end\n\n  always @(posedge clk) begin\n    p3_sign <= p2_sign;\n    p3_ddata <= p2_ddata;\n    p3_data_p_0 <= p2_data_p_0 + p2_data_p_1;\n  end\n\n  always @(posedge clk) begin\n    ddata_out <= p3_ddata;\n    data_p <= {p3_sign, p3_data_p_0};\n  end\n\nendmodule"}
{"task_id": 598, "completion": "localparam PCORE_VERSION = 'h00040261;\nreg [31:0] up_rdata = 32'h00;\nreg up_wack = 1'b0;\nreg up_rack = 1'b0;\nwire up_wreq;\nwire up_rreq;\nwire [31:0] up_wdata;\nwire [8:0] up_waddr;\nwire [8:0] up_raddr;\nwire [31:0] up_rdata_request;\nreg [31:0] up_scratch = 32'h00;\nwire up_eot;\nwire up_sot;\nreg [1:0] up_irq_mask = 2'h3;\nreg [1:0] up_irq_source = 2'h0;\nwire [1:0] up_irq_pending;\nwire [1:0] up_irq_trigger;\nwire [1:0] up_irq_source_clear;\nassign up_irq_pending = ~up_irq_mask & up_irq_source;\nassign up_irq_trigger  = {up_eot, up_sot};\nassign up_irq_source_clear = (up_wreq == 1'b1 && up_waddr == 9'h021) ? up_wdata[1:0] : 2'b00;\nalways @(posedge s_axi_aclk) begin\n  if (s_axi_aresetn == 1'b0) begin\n    irq <= 1'b0;\n  end else begin\n    irq <= |up_irq_pending;\n  end\nend\nalways @(posedge s_axi_aclk) begin\n  if (s_axi_aresetn == 1'b0) begin\n    up_irq_source <= 2'b00;\n  end else begin\n    up_irq_source <= up_irq_trigger | (up_irq_source & ~up_irq_source_clear);\n  end\nend\nalways @(posedge s_axi_aclk) begin\n  if (s_axi_aresetn == 1'b0) begin\n    ctrl_enable <= 1'b0;\n    ctrl_pause <= 1'b0;\n    up_irq_mask <= 2'b11;\n    up_scratch <= 32'h00;\n    up_wack <= 1'b0;\n  end else begin\n    up_wack <= up_wreq;\n    if (up_wreq == 1'b1) begin\n      case (up_waddr)\n      9'h002: up_scratch <= up_wdata;\n      9'h020: up_irq_mask <= up_wdata[1:0];\n      9'h100: {ctrl_pause, ctrl_enable} <= up_wdata[1:0];\n      endcase\n    end\n  end\nend\nalways @(posedge s_axi_aclk) begin\n  if (s_axi_aresetn == 1'b0) begin\n    up_rack <= 'd0;\n  end else begin\n    up_rack <= up_rreq;\n  end\nend\nalways @(posedge s_axi_aclk) begin\n  if (up_rreq == 1'b1) begin\n    case (up_raddr)\n    9'h000: up_rdata <= PCORE_VERSION;\n    9'h001: up_rdata <= ID;\n    9'h002: up_rdata <= up_scratch;\n    9'h003: up_rdata <= 32'h444d4143;\n    9'h020: up_rdata <= up_irq_mask;\n    9'h021: up_rdata <= up_irq_pending;\n    9'h022: up_rdata <= up_irq_source;\n    9'h100: up_rdata <= {ctrl_pause, ctrl_enable};\n    9'h10d: up_rdata <= DISABLE_DEBUG_REGISTERS ? 32'h00 : dbg_dest_addr;\n    9'h10e: up_rdata <= DISABLE_DEBUG_REGISTERS ? 32'h00 : dbg_src_addr;\n    9'h10f: up_rdata <= DISABLE_DEBUG_REGISTERS ? 32'h00 : dbg_status;\n    9'h110: up_rdata <= DISABLE_DEBUG_REGISTERS ? 32'h00 : dbg_ids0;\n    9'h111: up_rdata <= DISABLE_DEBUG_REGISTERS ? 32'h00 : dbg_ids1;\n    default: up_rdata <= up_rdata_request;\n    endcase\n  end\nend\naxi_dmac_regmap_request #(\n  .DISABLE_DEBUG_REGISTERS(DISABLE_DEBUG_REGISTERS),\n  .BYTES_PER_BEAT_WIDTH_DEST(BYTES_PER_BEAT_WIDTH_DEST),\n  .BYTES_PER_BEAT_WIDTH_SRC(BYTES_PER_BEAT_WIDTH_SRC),\n  .BYTES_PER_BURST_WIDTH(BYTES_PER_BURST_WIDTH),\n  .DMA_AXI_ADDR_WIDTH(DMA_AXI_ADDR_WIDTH),\n  .DMA_LENGTH_WIDTH(DMA_LENGTH_WIDTH),\n  .DMA_LENGTH_ALIGN(DMA_LENGTH_ALIGN),\n  .DMA_CYCLIC(DMA_CYCLIC),\n  .HAS_DEST_ADDR(HAS_DEST_ADDR),\n  .HAS_SRC_ADDR(HAS_SRC_ADDR),\n  .DMA_2D_TRANSFER(DMA_2D_TRANSFER),\n  .SYNC_TRANSFER_START(SYNC_TRANSFER_START)\n) i_regmap_request (\n  .clk(s_axi_aclk),\n  .reset(~s_axi_aresetn),\n  .up_sot(up_sot),\n  .up_eot(up_eot),\n  .up_wreq(up_wreq),\n  .up_rreq(up_rreq),\n  .up_waddr(up_waddr),\n  .up_wdata(up_wdata),\n  .up_raddr(up_raddr),\n  .up_rdata(up_rdata_request),\n  .ctrl_enable(ctrl_enable),\n  .request_valid(request_valid),\n  .request_ready(request_ready),\n  .request_dest_address(request_dest_address),\n  .request_src_address(request_src_address),\n  .request_x_length(request_x_length),\n  .request_y_length(request_y_length),\n  .request_dest_stride(request_dest_stride),\n  .request_src_stride(request_src_stride),\n  .request_sync_transfer_start(request_sync_transfer_start),\n  .request_last(request_last),\n  .response_eot(response_eot),\n  .response_measured_burst_length(response_measured_burst_length),\n  .response_partial(response_partial),\n  .response_valid(response_valid),\n  .response_ready(response_ready)\n);\nup_axi #(\n  .AXI_ADDRESS_WIDTH (12),\n  .ADDRESS_WIDTH (9)\n) i_up_axi (\n  .up_rstn(s_axi_aresetn),\n  .up_clk(s_axi_aclk),\n  .up_axi_awvalid(s_axi_awvalid),\n  .up_axi_awaddr(s_axi_awaddr),\n  .up_axi_awready(s_axi_awready),\n  .up_axi_wvalid(s_axi_wvalid),\n  .up_axi_wdata(s_axi_wdata),\n  .up_axi_wstrb(s_axi_wstrb),\n  .up_axi_wready(s_axi_wready),\n  .up_axi_bvalid(s_axi_bvalid),\n  .up_axi_bresp(s_axi_bresp),\n  .up_axi_bready(s_axi_bready),\n  .up_axi_arvalid(s_axi_arvalid),\n  .up_axi_araddr(s_axi_araddr),\n  .up_axi_arready(s_axi_arready),\n  .up_axi_rvalid(s_axi_rvalid),\n  .up_axi_rresp(s_axi_rresp),\n  .up_axi_rdata(s_axi_rdata),\n  .up_axi_rready(s_axi_rready),\n  .up_wreq(up_wreq),\n  .up_waddr(up_waddr),\n  .up_wdata(up_wdata),\n  .up_wack(up_wack),\n  .up_rreq(up_rreq),\n  .up_raddr(up_raddr),\n  .up_rdata(up_rdata),\n  .up_rack(up_rack)\n);\nendmodule"}
{"task_id": 626, "completion": "integer  cyc=0;\n   reg [63:0]  crc;\n   reg [63:0]  sum;\n\n   wire  rst;\n   data_t  iii_in = crc[5:0];\n   data_t  jjj_in = crc[11:6];\n   data_t  iii_out;\n   data_t  jjj_out;\n   logic [1:0] ctl0 = crc[63:62];\n\n   aaa aaa (.*);\n\n   wire [63:0] result = {64'h0};\n\n   always @ (posedge clk) begin\n`ifdef TEST_VERBOSE\n      $write(\"[%0t] cyc==%0d crc=%x result=%x\\n\",$time, cyc, crc, result);\n`endif\n      cyc <= cyc + 1;\n      crc <= {crc[62:0], crc[63]^crc[2]^crc[0]};\n      sum <= result ^ {sum[62:0],sum[63]^sum[2]^sum[0]};\n      if (cyc==0) begin\n\t crc <= 64'h5aef0c8d_d70a4497;\n\t sum <= 64'h0;\n\t rst <= 1'b0;\n      end\n      else if (cyc<10) begin\n\t sum <= 64'h0;\n\t rst <= 1'b1;\n      end\n      else if (cyc<90) begin\n\t rst <= 1'b0;\n      end\n      else if (cyc==99) begin\n\t $write(\"[%0t] cyc==%0d crc=%x sum=%x\\n\",$time, cyc, crc, sum);\n\t if (crc !== 64'hc77bb9b3784ea091) $stop;\n`define EXPECTED_SUM 64'h4afe43fb79d7b71e\n\t if (sum !== `EXPECTED_SUM) $stop;\n\t $write(\"*-* All Finished *-*\\n\");\n\t $finish;\n      end\n   end\n\nendmodule"}
{"task_id": 518, "completion": "parameter ARST_LVL = 1'b0;    input        wb_clk_i;     input        wb_rst_i;     input        arst_i;     input  [2:0] wb_adr_i;     input  [7:0] wb_dat_i;     output [7:0] wb_dat_o;     input        wb_we_i;      input        wb_stb_i;     input        wb_cyc_i;     output       wb_ack_o;     output       wb_inta_o;    reg [7:0] wb_dat_o;    reg wb_ack_o;    reg wb_inta_o;    input  scl_pad_i;       output scl_pad_o;       output scl_padoen_o;    input  sda_pad_i;       output sda_pad_o;       output sda_padoen_o;    reg  [15:0] prer;    reg  [ 7:0] ctr;    reg  [ 7:0] txr;    wire [ 7:0] rxr;    reg  [ 7:0] cr;    wire [ 7:0] sr;    wire done;    wire core_en;    wire ien;    wire irxack;    reg  rxack;    reg  tip;    reg  irq_flag;    wire i2c_busy;    wire i2c_al;    reg  al;    wire rst_i = arst_i ^ ARST_LVL;    wire wb_wacc = wb_we_i & wb_ack_o;    always @(posedge wb_clk_i)      wb_ack_o <= #1 wb_cyc_i & wb_stb_i & ~wb_ack_o;    always @(posedge wb_clk_i)    begin      case (wb_adr_i)        3'b000: wb_dat_o <= #1 prer[ 7:0];        3'b001: wb_dat_o <= #1 prer[15:8];        3'b010: wb_dat_o <= #1 ctr;        3'b011: wb_dat_o <= #1 rxr;        3'b100: wb_dat_o <= #1 sr;        3'b101: wb_dat_o <= #1 txr;        3'b110: wb_dat_o <= #1 cr;        3'b111: wb_dat_o <= #1 0;      endcase    end    always @(posedge wb_clk_i or negedge rst_i)      if (!rst_i)        begin          prer <= #1 16'hffff;          ctr  <= #1  8'h0;          txr  <= #1  8'h0;        end      else if (wb_rst_i)        begin          prer <= #1 16'hffff;          ctr  <= #1  8'h0;          txr  <= #1  8'h0;        end      else        if (wb_wacc)          case (wb_adr_i)            3'b000 : prer [ 7:0] <= #1 wb_dat_i;            3'b001 : prer [15:8] <= #1 wb_dat_i;            3'b010 : ctr         <= #1 wb_dat_i;            3'b011 : txr         <= #1 wb_dat_i;            default: ;          endcase    always @(posedge wb_clk_i or negedge rst_i)      if (!rst_i)        cr <= #1 8'h0;      else if (wb_rst_i)        cr <= #1 8'h0;      else if (wb_wacc)        begin          if (core_en & (wb_adr_i == 3'b100) )            cr <= #1 wb_dat_i;        end      else        begin          if (done | i2c_al)            cr[7:4] <= #1 4'h0;            cr[2:1] <= #1 2'b0;            cr[0]   <= #1 1'b0;        end    wire sta  = cr[7];    wire sto  = cr[6];    wire rd   = cr[5];    wire wr   = cr[4];    wire ack  = cr[3];    wire iack = cr[0];    assign core_en = ctr[7];    assign ien = ctr[6];    i2c_master_byte_ctrl byte_controller (      .clk      ( wb_clk_i     ),      .rst      ( wb_rst_i     ),      .nReset   ( rst_i        ),      .ena      ( core_en      ),      .clk_cnt  ( prer         ),      .start    ( sta          ),      .stop     ( sto          ),      .read     ( rd           ),      .write    ( wr           ),      .ack_in   ( ack          ),      .din      ( txr          ),      .cmd_ack  ( done         ),      .ack_out  ( irxack       ),      .dout     ( rxr          ),      .i2c_busy ( i2c_busy     ),      .i2c_al   ( i2c_al       ),      .scl_i    ( scl_pad_i    ),      .scl_o    ( scl_pad_o    ),      .scl_oen  ( scl_padoen_o ),      .sda_i    ( sda_pad_i    ),      .sda_o    ( sda_pad_o    ),      .sda_oen  ( sda_padoen_o )    );    always @(posedge wb_clk_i or negedge rst_i)      if (!rst_i)        begin          al       <= #1 1'b0;          rxack    <= #1 1'b0;          tip      <= #1 1'b0;          irq_flag <= #1 1'b0;        end      else if (wb_rst_i)        begin          al       <= #1 1'b0;          rxack    <= #1 1'b0;          tip      <= #1 1'b0;          irq_flag <= #1 1'b0;        end      else        begin          al       <= #1 i2c_al | (al & ~sta);          rxack    <= #1 irxack;          tip      <= #1 (rd | wr);          irq_flag <= #1 (done | i2c_al | irq_flag) & ~iack;        end    always @(posedge wb_clk_i or negedge rst_i)      if (!rst_i)        wb_inta_o <= #1 1'b0;      else if (wb_rst_i)        wb_inta_o <= #1 1'b0;      else        wb_inta_o <= #1 irq_flag && ien;    assign sr[7]   = rxack;    assign sr[6]   = i2c_busy;    assign sr[5]   = al;    assign sr[4:2] = 3'h0;    assign sr[1]   = tip;    assign sr[0]   = irq_flag;endmodule"}
{"task_id": 672, "completion": "wire\t\t\tgr_we, pc_we, pc_ie, zf;\nwire\t[`STGW-1:0]\tcs;\nwire\t[`REGO-1:0]\tgr_raddr1, gr_raddr2, gr_waddr;\nwire\t[`REGW-1:0]\trdata1, rdata2, dout;\n\nassign mem_waddr = rdata1;\nassign mem_wdata = rdata2;\n\n/* instances */\nstage_con stage_con(\n\t.clk(clk),\n\t.rst(rst),\n\t.cs(cs)\n);\nstages stages(\n\t.ins(ins),\n\t.cs(cs),\n\t.gr_raddr1(gr_raddr1),\n\t.gr_raddr2(gr_raddr2),\n\t.gr_waddr(gr_waddr),\n\t.gr_we(gr_we),\n\t.pc_we(pc_we),\n\t.mem_we(mem_we),\n\t.pc_ie(pc_ie),\n\t.zf(zf)\n);\npc pc(\n\t.clk(clk),\n\t.rst(rst),\n\t.we(pc_we),\n\t.ie(pc_ie),\n\t.waddr(rdata1),\n\t.paddr(paddr)\n);\nalu alu(\n\t.ins(ins),\n\t.din1(rdata1),\n\t.din2(rdata2),\n\t.dout(dout),\n\t.zf(zf)\n);\ngr gr(\n\t.clk(clk),\n\t.rst(rst),\n\t.we(gr_we),\n\t.raddr1(gr_raddr1),\n\t.raddr2(gr_raddr2),\n\t.waddr(gr_waddr),\n\t.wdata(dout),\n\t.rdata1(rdata1),\n\t.rdata2(rdata2)\n);\n\nendmodule"}
{"task_id": 651, "completion": "wire VPulse_conn;\n    wire VRP_Timer_Timeout_conn;\n    wire LRI_Timer_Timeout_conn;\n    wire VVI_LRI_VPace_conn;\n    wire VVI_VRP_VRefractory_conn;\n    wire VVI_VRP_VRP_Start_Timer_conn;\n    wire VVI_LRI_LRI_Timer_Start_conn;\n    wire VVI_LRI_LRI_Timer_Stop_conn;\n    wire VVI_VRP_VSense_conn;\n\n    wire signed [15:0] VVI_VRP_VRP_Timeout_Value_conn;\n    wire signed [15:0] VVI_LRI_LRI_Timeout_Value_conn;\n\n    assign VPulse_conn = VPulse_eI;\n    assign VRP_Timer_Timeout_conn = VRP_Timer_Timeout_eI;\n    assign LRI_Timer_Timeout_conn = LRI_Timer_Timeout_eI;\n\n    assign VPace_eO = VVI_LRI_VPace_conn;\n    assign VRefractory_eO = VVI_VRP_VRefractory_conn;\n    assign VRP_Start_Timer_eO = VVI_VRP_VRP_Start_Timer_conn;\n    assign LRI_Timer_Start_eO = VVI_LRI_LRI_Timer_Start_conn;\n    assign LRI_Timer_Stop_eO = VVI_LRI_LRI_Timer_Stop_conn;\n\n    assign VRP_Timeout_Value_O = VVI_VRP_VRP_Timeout_Value_conn;\n    assign LRI_Timeout_Value_O = VVI_LRI_LRI_Timeout_Value_conn;\n\n    FB_VVI_LRI VVI_LRI (\n        .clk(clk),\n        .VPace_eO(VVI_LRI_VPace_conn),\n        .LRI_Timer_Start_eO(VVI_LRI_LRI_Timer_Start_conn),\n        .LRI_Timer_Stop_eO(VVI_LRI_LRI_Timer_Stop_conn),\n        .LRI_Timer_Timeout_eI(LRI_Timer_Timeout_conn), \n        .VSense_eI(VVI_VRP_VSense_conn), \n        .LRI_Timeout_Value_O(VVI_LRI_LRI_Timeout_Value_conn), \n        .reset(reset)\n    );\n\n    FB_VVI_VRP VVI_VRP (\n        .clk(clk),\n        .VRefractory_eO(VVI_VRP_VRefractory_conn),\n        .VRP_Start_Timer_eO(VVI_VRP_VRP_Start_Timer_conn),\n        .VSense_eO(VVI_VRP_VSense_conn),\n        .VPulse_eI(VPulse_conn), \n        .VRP_Timer_Timeout_eI(VRP_Timer_Timeout_conn), \n        .VPace_eI(VVI_LRI_VPace_conn), \n        .VRP_Timeout_Value_O(VVI_VRP_VRP_Timeout_Value_conn), \n        .reset(reset)\n    );\n\nendmodule"}
{"task_id": 652, "completion": "localparam                  FIFO_LENGTH= 1<<ADDR_WIDTH;\n  reg[FIFO_LENGTH-1:0]        mem;\n  reg                         wr_shift;\n  reg[ADDR_WIDTH:WDATA_WIDTH] wr_addr_no2bytes;\n  reg[ADDR_WIDTH:WDATA_WIDTH] wr_addr;\n  reg[ADDR_WIDTH:RDATA_WIDTH] rd_addr;\n\n  generate\n  genvar k;\n  for(k=0; k<(1<<RDATA_WIDTH); k=k+1)\n    begin:loopk\n    assign rd_data[k]= mem[ (rd_addr[ADDR_WIDTH-1:RDATA_WIDTH]<<\n                             RDATA_WIDTH)+k ];\n    end\n  if(WDATA_WIDTH>RDATA_WIDTH)\n    begin\n    assign fifo_full=  wr_addr[ADDR_WIDTH]!=rd_addr[ADDR_WIDTH] &\n                       wr_addr[ADDR_WIDTH-1:WDATA_WIDTH]==\n                       rd_addr[ADDR_WIDTH-1:WDATA_WIDTH] ? 1'b1 : 1'b0;\n    assign fifo_empty= wr_addr_no2bytes[ADDR_WIDTH:WDATA_WIDTH]==\n                       rd_addr[ADDR_WIDTH:WDATA_WIDTH] ? 1'b1 : 1'b0;\n    end\n  else\n    begin\n    assign fifo_full=  wr_addr[ADDR_WIDTH]!=rd_addr[ADDR_WIDTH] &\n                       wr_addr[ADDR_WIDTH-1:RDATA_WIDTH]==\n                       rd_addr[ADDR_WIDTH-1:RDATA_WIDTH] ? 1'b1 : 1'b0;\n    assign fifo_empty= wr_addr_no2bytes[ADDR_WIDTH:RDATA_WIDTH]==\n                       rd_addr[ADDR_WIDTH:RDATA_WIDTH] ? 1'b1 : 1'b0;\n    end\n  endgenerate\n\n  always @(posedge clk, negedge rst0_async)\n    begin\n    if(!rst0_async)\n      begin\n      wr_shift<=1'b0;\n      wr_addr_no2bytes<={(ADDR_WIDTH-WDATA_WIDTH+1){1'b0}};\n      wr_addr<={(ADDR_WIDTH-WDATA_WIDTH+1){1'b0}};\n      rd_addr<={(ADDR_WIDTH-RDATA_WIDTH+1){1'b0}};\n      end\n    else\n      begin\n      if(!rst0_sync)\n        begin\n        wr_shift<=1'b0;\n        wr_addr_no2bytes<={(ADDR_WIDTH-WDATA_WIDTH+1){1'b0}};\n        wr_addr<={(ADDR_WIDTH-WDATA_WIDTH+1){1'b0}};\n        rd_addr<={(ADDR_WIDTH-RDATA_WIDTH+1){1'b0}};\n        end\n      else\n        begin\n        wr_shift<= wr_en & !fifo_full & wr_addr[3:0]==4'd15 ? 1'b1 :\n                   wr_shift;\n        wr_addr_no2bytes<= wr_shift & wr_en &\n                           !fifo_full ? wr_addr_no2bytes+1'b1:\n                           wr_addr_no2bytes;\n        wr_addr<= wr_en & !fifo_full ? wr_addr+1'b1 : wr_addr;\n        rd_addr<= rd_en & !fifo_empty ? rd_addr+1'b1 : rd_addr;\n        end\n      end\n    end\n\n  generate\n  genvar i,j;\n  for(i=0; i<(FIFO_LENGTH>>WDATA_WIDTH); i=i+1)\n    begin:loopi\n    for(j=i*(1<<WDATA_WIDTH) ; j<(i+1)*(1<<WDATA_WIDTH) ; j=j+1)\n      begin:loopj\n      always @(posedge clk, negedge rst0_async)\n        if(!rst0_async)\n          mem[j]<=1'b0;\n        else\n          mem[j]<=  wr_addr[ADDR_WIDTH-1:WDATA_WIDTH]==i &\n                    !fifo_full & wr_en ? wr_data[j%(1<<WDATA_WIDTH)] :\n                    mem[j];\n      end\n    end\n  endgenerate\nendmodule"}
{"task_id": 433, "completion": "wire [7:0] data;\n    wire pclk;\n    wire [15:0] rgb;\n\n    system_ov7670_vga_0_1_ov7670_vga U0\n         (.data(data),\n          .pclk(pclk),\n          .rgb(rgb));\nendmodule\n\n(* ORIG_REF_NAME = \"ov7670_vga\" *) \nmodule system_ov7670_vga_0_1_ov7670_vga\n   (output [15:0] rgb, input pclk, input [7:0] data);\n  wire cycle;\n  wire [7:0] data;\n  wire p_0_in0;\n  wire pclk;\n  wire [15:0] rgb;\n\n  FDRE #(\n    .INIT(1'b0)) \n    cycle_reg\n       (.C(pclk),\n        .CE(1'b1),\n        .D(p_0_in0),\n        .Q(cycle),\n        .R(1'b0));\n  LUT1 #(\n    .INIT(2'h1)) \n    \\rgb[15]_i_1 \n       (.I0(cycle),\n        .O(p_0_in0));\n  FDRE \\rgb_reg[0] \n       (.C(pclk),\n        .CE(cycle),\n        .D(data[0]),\n        .Q(rgb[0]),\n        .R(1'b0));\n  FDRE \\rgb_reg[10] \n       (.C(pclk),\n        .CE(p_0_in0),\n        .D(data[2]),\n        .Q(rgb[10]),\n        .R(1'b0));\n  FDRE \\rgb_reg[11] \n       (.C(pclk),\n        .CE(p_0_in0),\n        .D(data[3]),\n        .Q(rgb[11]),\n        .R(1'b0));\n  FDRE \\rgb_reg[12] \n       (.C(pclk),\n        .CE(p_0_in0),\n        .D(data[4]),\n        .Q(rgb[12]),\n        .R(1'b0));\n  FDRE \\rgb_reg[13] \n       (.C(pclk),\n        .CE(p_0_in0),\n        .D(data[5]),\n        .Q(rgb[13]),\n        .R(1'b0));\n  FDRE \\rgb_reg[14] \n       (.C(pclk),\n        .CE(p_0_in0),\n        .D(data[6]),\n        .Q(rgb[14]),\n        .R(1'b0));\n  FDRE \\rgb_reg[15] \n       (.C(pclk),\n        .CE(p_0_in0),\n        .D(data[7]),\n        .Q(rgb[15]),\n        .R(1'b0));\n  FDRE \\rgb_reg[1] \n       (.C(pclk),\n        .CE(cycle),\n        .D(data[1]),\n        .Q(rgb[1]),\n        .R(1'b0));\n  FDRE \\rgb_reg[2] \n       (.C(pclk),\n        .CE(cycle),\n        .D(data[2]),\n        .Q(rgb[2]),\n        .R(1'b0));\n  FDRE \\rgb_reg[3] \n       (.C(pclk),\n        .CE(cycle),\n        .D(data[3]),\n        .Q(rgb[3]),\n        .R(1'b0));\n  FDRE \\rgb_reg[4] \n       (.C(pclk),\n        .CE(cycle),\n        .D(data[4]),\n        .Q(rgb[4]),\n        .R(1'b0));\n  FDRE \\rgb_reg[5] \n       (.C(pclk),\n        .CE(cycle),\n        .D(data[5]),\n        .Q(rgb[5]),\n        .R(1'b0));\n  FDRE \\rgb_reg[6] \n       (.C(pclk),\n        .CE(cycle),\n        .D(data[6]),\n        .Q(rgb[6]),\n        .R(1'b0));\n  FDRE \\rgb_reg[7] \n       (.C(pclk),\n        .CE(cycle),\n        .D(data[7]),\n        .Q(rgb[7]),\n        .R(1'b0));\n  FDRE \\rgb_reg[8] \n       (.C(pclk),\n        .CE(p_0_in0),\n        .D(data[0]),\n        .Q(rgb[8]),\n        .R(1'b0));\n  FDRE \\rgb_reg[9] \n       (.C(pclk),\n        .CE(p_0_in0),\n        .D(data[1]),\n        .Q(rgb[9]),\n        .R(1'b0));\nendmodule"}
{"task_id": 658, "completion": "wire\t\tsignal_aa_ba;\n\twire\t[7:0]\tsignal_bb_ab;\n\n\tassign\tsignal_aa_ba\t= p_mix_signal_aa_ba_gi;\n\tassign\tp_mix_signal_bb_ab_go\t= signal_bb_ab;\n\n\tinst_xa_e inst_ba_i (\n\t\t.port_xa_i(signal_aa_ba),\n\t\t.port_xa_o()\n\t);\n\n\tinst_bb_e inst_bb_i (\n\t\t.port_bb_o(signal_bb_ab)\n\t);\n\n\tinst_vb_e inst_bc1_i ();\n\n\tinst_vb_e inst_bc2_i ();\n\n\tinst_be_i inst_be_i ();\n\n\tinst_be_i inst_bf_i ();\n\nendmodule"}
{"task_id": 578, "completion": "localparam N = 2;\n    reg [N-1:0] q_act, q_next;\n    wire [N-1:0] count_horizontal;\n    reg enLEFT_reg, enRIGHT_reg, enUP_reg, enDOWN_reg;\n    reg [1:0] reg_config_mode, next_config_mode;\n    reg [3:0] enable_counters;\n\n    always@(posedge clk)\n    begin\n        if(reset) reg_config_mode <= 2'b0;\n        else reg_config_mode <= next_config_mode;\n    end\n    always@*\n    begin\n        if((write_strobe == 1'b1 || k_write_strobe == 1'b1)&&(port_id == 8'h11)) next_config_mode = in_dato[4:3];\n        else next_config_mode = reg_config_mode;\n    end\n    assign config_mode = reg_config_mode;\n    always@(posedge clk)\n    begin\n        if(write_strobe == 1'b1 || k_write_strobe == 1'b1)\n        begin\n            case(port_id)\n            8'h11:\n                begin\n                    if(in_dato[2] == 1'b1)\n                    begin\n                        case(in_dato[1:0])\n                        2'b00: enRIGHT_reg <= 1'b1;\n                        2'b01: enUP_reg <= 1'b1;\n                        2'b10: enDOWN_reg <= 1'b1;\n                        2'b11: enLEFT_reg <= 1'b1;\n                        endcase\n                    end\n                    else\n                    begin\n                        enRIGHT_reg <= 1'b0;\n                        enUP_reg <= 1'b0;\n                        enDOWN_reg <= 1'b0;\n                        enLEFT_reg <= 1'b0;\n                    end\n                end\n            default:\n            begin\n                    enRIGHT_reg <= 1'b0;\n                    enUP_reg <= 1'b0;\n                    enDOWN_reg <= 1'b0;\n                    enLEFT_reg <= 1'b0;\n            end\n            endcase\n        end\n        else\n        begin\n            enRIGHT_reg <= 1'b0;\n            enUP_reg <= 1'b0;\n            enDOWN_reg <= 1'b0;\n            enLEFT_reg <= 1'b0;\n        end\n    end\n    always@(posedge clk)\n    begin\n        if(reset)\n        begin\n            q_act <= 2'b0;\n        end\n        else\n        begin\n            q_act <= q_next;\n        end\n    end\n    always@*\n    begin\n        if(enLEFT_reg)\n        begin\n            q_next = q_act + 1'b1;\n        end\n        else if(enRIGHT_reg)\n        begin\n            q_next = q_act - 1'b1;\n        end\n        else if(enLEFT_reg && q_act == 2 && config_mode == 1)\n        begin\n            q_next = 5'd0;\n        end\n        else if(enRIGHT_reg && q_act == 0 && config_mode == 1)\n        begin\n            q_next = 5'd2;\n        end\n        else if(enLEFT_reg && q_act == 2 && config_mode == 4)\n        begin\n            q_next = 5'd0;\n        end\n        else if(enRIGHT_reg && q_act == 0 && config_mode == 4)\n        begin\n            q_next = 5'd2;\n        end\n        else\n        begin\n            q_next = q_act;\n        end\n    end\n    assign count_horizontal = q_act;\n    contador_AD_SS_2dig Instancia_contador_SS(\n    .clk(clk),\n    .reset(reset),\n    .en_count(enable_counters),\n    .enUP(enUP_reg),\n    .enDOWN(enDOWN_reg),\n    .data_SS(btn_data_SS)\n    );\n    contador_AD_MM_2dig Instancia_contador_MM(\n    .clk(clk),\n    .reset(reset),\n    .enUP(enUP_reg),\n    .enDOWN(enDOWN_reg),\n    .en_count(enable_counters),\n    .data_MM(btn_data_MM)\n    );\n    contador_AD_HH_2dig Instancia_contador_HH(\n    .clk(clk), \n    .reset(reset),\n    .en_count(enable_counters),\n    .enUP(enUP_reg),\n    .enDOWN(enDOWN_reg),\n    .data_HH(btn_data_HH)\n    );   \n    contador_AD_YEAR_2dig Instancia_contador_YEAR(\n    .clk(clk),\n    .reset(reset),\n    .enUP(enUP_reg),\n    .en_count(enable_counters),\n    .enDOWN(enDOWN_reg),\n    .data_YEAR(btn_data_YEAR)\n    );\n    contador_AD_MES_2dig Instancia_contador_MES(\n    .clk(clk),\n    .reset(reset),\n    .en_count(enable_counters),\n    .enUP(enUP_reg),\n    .enDOWN(enDOWN_reg),\n    .data_MES(btn_data_MES)\n    );\n    contador_AD_DAY_2dig Instancia_contador_DAY(\n    .clk(clk),\n    .reset(reset),\n    .en_count(enable_counters),\n    .enUP(enUP_reg),\n    .enDOWN(enDOWN_reg),\n    .data_DAY(btn_data_DAY)\n    );\n    contador_AD_SS_T_2dig Instancia_contador_SS_T(\n    .clk(clk),\n    .reset(reset),\n    .en_count(enable_counters),\n    .enUP(enUP_reg),\n    .enDOWN(enDOWN_reg),\n    .data_SS_T(btn_data_SS_T)\n    );\n    contador_AD_MM_T_2dig Instancia_contador_MM_T(\n    .clk(clk),\n    .reset(reset),\n    .en_count(enable_counters),\n    .enUP(enUP_reg),\n    .enDOWN(enDOWN_reg),\n    .data_MM_T(btn_data_MM_T)\n    );\n    contador_AD_HH_T_2dig Instancia_contador_HH_T (\n    .clk(clk),\n    .reset(reset),\n    .en_count(enable_counters),\n    .enUP(enUP_reg),\n    .enDOWN(enDOWN_reg),\n    .data_HH_T(btn_data_HH_T)\n    );\n    always@*\n    case(config_mode)\n    3'd0:\n    begin\n    enable_counters = 4'b0;\n    end\n    3'd1:\n    begin\n        case(count_horizontal)\n        2'd0: enable_counters = 4'd1;\n        2'd1: enable_counters = 4'd2;\n        2'd2: enable_counters = 4'd3;\n        default: enable_counters = 4'd0;\n        endcase\n    end\n    3'd2:\n    begin\n        case(count_horizontal)\n        2'd0: enable_counters = 4'd4;\n        2'd1: enable_counters = 4'd5;\n        2'd2: enable_counters = 4'd6;\n        default: enable_counters = 4'd0;\n        endcase\n    end\n    3'd3:\n    begin\n        case(count_horizontal)\n        2'd0: enable_counters = 4'd8;\n        2'd1: enable_counters = 4'd9;\n        2'd2: enable_counters = 4'd10;\n        default: enable_counters = 4'd0;\n        endcase\n    end\n    default: enable_counters = 4'b0;\n    endcase\n    assign cursor_location = count_horizontal;\nendmodule"}
{"task_id": 563, "completion": "reg ack;\n   reg [(7*11)-1:0] counters;\n   parameter S_IDLE = 0;\n   parameter S_ISSUE = 1;\n   parameter S_REISSUE = 2;\n   reg [2:0] state;\n   reg [31:0] cx;\n   reg [31:0] i_vx;\n   reg [31:0] i_vy;\n   reg [31:0] i_dvx;\n   reg [31:0] i_dvy;\n   reg [6:0] i_counter;\n   reg [3:0] i_thrid;\n   wire [31:0] vx;\n   wire [31:0] vy;\n   wire [31:0] dvx;\n   wire [31:0] dvy;\n   wire [31:0] counter;\n   wire [31:0] thrid;\n   reg [31:0] s00vx1;\n   reg [31:0] s00tmp1;\n   reg [31:0] s01tmp1A;\n   reg [31:0] s01tmp2;\n   reg [31:0] s01vx;\n   reg [31:0] s02vx;\n   reg [31:0] s02tmp1B;\n   reg [31:0] s02tmp2A;\n   reg [31:0] s03tmp1C;\n   reg [31:0] s03tmp2B;\n   reg [31:0] s03vx;\n   reg [31:0] s04tmp1D;\n   reg [31:0] s04tmp2C;\n   reg [31:0] s04vx;\n   reg [31:0] s05tmp2D;\n   reg [31:0] s05vy1;\n   reg [31:0] s05tmp3;\n   reg [31:0] s05vx;\n   reg [31:0] s06tmp3A;\n   reg [31:0] s06vx;\n   reg [31:0] s06vy;\n   reg [31:0] s06tmp2;\n   reg [31:0] s07tmp3B;\n   reg [31:0] s07vx;\n   reg [31:0] s07vy;\n   reg [31:0] s07tmp2;\n   reg [31:0] s08tmp3C;\n   reg [31:0] s08vx;\n   reg [31:0] s08vy;\n   reg [31:0] s08tmp2;\n   reg [31:0] s09tmp3D;\n   reg [31:0] s09vx;\n   reg [31:0] s09vy;\n   reg [31:0] s09tmp2;\n   reg [31:0] s10dvx;\n   reg [31:0] s10dvy;\n   reg [31:0] s10r;\n   reg [31:0] s10vx;\n   reg [31:0] s10vy;\n   reg [3:0] s00thrid;\n   reg [3:0] s01thrid;\n   reg [3:0] s02thrid;\n   reg [3:0] s03thrid;\n   reg [3:0] s04thrid;\n   reg [3:0] s05thrid;\n   reg [3:0] s06thrid;\n   reg [3:0] s07thrid;\n   reg [3:0] s08thrid;\n   reg [3:0] s09thrid;\n   reg [3:0] s10thrid;\n   reg [6:0] s00counter;\n   reg [6:0] s01counter;\n   reg [6:0] s02counter;\n   reg [6:0] s03counter;\n   reg [6:0] s04counter;\n   reg [6:0] s05counter;\n   reg [6:0] s06counter;\n   reg [6:0] s07counter;\n   reg [6:0] s08counter;\n   reg [6:0] s09counter;\n   reg [6:0] s10counter;\n   wire [31:0] s05vy1_comb;\n   wire s1;\n   assign s1 = s04tmp1D[31];\n   assign s05vy1_comb = {s1,s1,s1,s1,s1,s1,s1,s1,s1,s1,s1,s04tmp1D[31:11]} + cy;\n   wire [31:0] s10dvx_comb;\n   wire [31:0] s10dvy_comb;\n   wire [31:0] s10r_comb;\n   wire s2;\n   assign s2 = s09tmp2[31];\n   assign s10dvx_comb = {s2,s2,s2,s2,s2,s2,s2,s2,s2,s2,s2,s2,s09tmp2[31:12]};\n   wire s3;\n   assign s3 = s09tmp3D[31];\n   assign s10dvy_comb = {s3,s3,s3,s3,s3,s3,s3,s3,s3,s3,s3,s3,s09tmp3D[31:12]};\n   assign s10r_comb = s10dvx_comb + s10dvy_comb;\n   wire reissue;\n   assign reissue = (state == S_REISSUE) && (s10r < 16384) && (s10thrid !=0);\n   assign vx = reissue?s10vx:i_vx;\n   assign vy = reissue?s10vy:i_vy;\n   assign dvx = reissue?s10dvx:i_dvx;\n   assign dvy = reissue?s10dvy:i_dvy;\n   assign counter = reissue?s10counter+1:i_counter;\n   assign thrid = reissue?s10thrid:i_thrid;\n   always @(posedge clk)\n     if (!reset) begin\n        s00vx1 <= 0;\n        s00tmp1 <= 0;\n        s01tmp1A <= 0;\n        s01tmp2 <= 0;\n        s01vx <= 0;\n        s02vx <= 0;\n        s02tmp1B <= 0;\n        s02tmp2A <= 0;\n        s03tmp1C <= 0;\n        s03tmp2B <= 0;\n        s03vx <= 0;\n        s04tmp1D <= 0;\n        s04tmp2C <= 0;\n        s04vx <= 0;\n        s05tmp2D <= 0;\n        s05vy1 <= 0;\n        s05tmp3 <= 0;\n        s05vx <= 0;\n        s06tmp3A <= 0;\n        s06vx <= 0;\n        s06vy <= 0;\n        s06tmp2 <= 0;\n        s07tmp3B <= 0;\n        s07vx <= 0;\n        s07vy <= 0;\n        s07tmp2 <= 0;\n        s08tmp3C <= 0;\n        s08vx <= 0;\n        s08vy <= 0;\n        s08tmp2 <= 0;\n        s09tmp3D <= 0;\n        s09vx <= 0;\n        s09vy <= 0;\n        s09tmp2 <= 0;\n        s10dvx <= 0;\n        s10dvy <= 0;\n        s10r <= 0;\n        s10vx <= 0;\n        s10vy <= 0;\n        s00thrid <= 0;\n        s01thrid <= 0;\n        s02thrid <= 0;\n        s03thrid <= 0;\n        s04thrid <= 0;\n        s05thrid <= 0;\n        s06thrid <= 0;\n        s07thrid <= 0;\n        s08thrid <= 0;\n        s09thrid <= 0;\n        s10thrid <= 0;\n        s00counter <= 0;\n        s01counter <= 0;\n        s02counter <= 0;\n        s03counter <= 0;\n        s04counter <= 0;\n        s05counter <= 0;\n        s06counter <= 0;\n        s07counter <= 0;\n        s08counter <= 0;\n        s09counter <= 0;\n        s10counter <= 0;\n     end else begin\n        s00thrid <= thrid;\n        s01thrid <= s00thrid;\n        s02thrid <= s01thrid;\n        s03thrid <= s02thrid;\n        s04thrid <= s03thrid;\n        s05thrid <= s04thrid;\n        s06thrid <= s05thrid;\n        s07thrid <= s06thrid;\n        s08thrid <= s07thrid;\n        s09thrid <= s08thrid;\n        s10thrid <= s09thrid;\n        s00counter <= counter;\n        s01counter <= s00counter;\n        s02counter <= s01counter;\n        s03counter <= s02counter;\n        s04counter <= s03counter;\n        s05counter <= s04counter;\n        s06counter <= s05counter;\n        s07counter <= s06counter;\n        s08counter <= s07counter;\n        s09counter <= s08counter;\n        s10counter <= s09counter;\n        s00vx1 <= dvx - dvy + cx;\n        s00tmp1 <= vx * vy;\n        s01tmp1A <= s00tmp1;\n        s01tmp2 <= s00vx1 * s00vx1;\n        s01vx <= s00vx1;\n        s02tmp1B <= s01tmp1A;\n        s02tmp2A <= s01tmp2;\n        s02vx <= s01vx;\n        s03tmp1C <= s02tmp1B;\n        s03tmp2B <= s02tmp2A;\n        s03vx <= s02vx;\n        s04tmp1D <= s03tmp1C;\n        s04tmp2C <= s03tmp2B;\n        s04vx <= s03vx;\n        s05tmp2D <= s04tmp2C;\n        s05vy1 <= s05vy1_comb;\n        s05tmp3 <= s05vy1_comb * s05vy1_comb;\n        s05vx <= s04vx;\n        s06tmp3A <= s05tmp3;\n        s06vx <= s05vx;\n        s06vy <= s05vy1;\n        s06tmp2 <= s05tmp2D;\n        s07tmp3B <= s06tmp3A;\n        s07vx <= s06vx;\n        s07vy <= s06vy;\n        s07tmp2 <= s06tmp2;\n        s08tmp3C <= s07tmp3B;\n        s08vx <= s07vx;\n        s08vy <= s07vy;\n        s08tmp2 <= s07tmp2;\n        s09tmp3D <= s08tmp3C;\n        s09vx <= s08vx;\n        s09vy <= s08vy;\n        s09tmp2 <= s08tmp2;\n        s10dvx <= s10dvx_comb;\n        s10dvy <= s10dvy_comb;\n        s10r <= s10r_comb;\n        s10vx <= s09vx;\n        s10vy <= s09vy;\n     end\n   reg [3:0] thrid1;\n   reg [6:0] iterations;\n   wire [(11*7)-1:0] counters_comb;\n   assign counters_comb = \n     {\n      (s10thrid==11)?s10counter:counters[(11*7)-1:10*7],\n      (s10thrid==10)?s10counter:counters[(10*7)-1:9*7],\n      (s10thrid==9)?s10counter:counters[( 9*7)-1:8*7],\n      (s10thrid==8)?s10counter:counters[( 8*7)-1:7*7],\n      (s10thrid==7)?s10counter:counters[( 7*7)-1:6*7],\n      (s10thrid==6)?s10counter:counters[( 6*7)-1:5*7],\n      (s10thrid==5)?s10counter:counters[( 5*7)-1:4*7],\n      (s10thrid==4)?s10counter:counters[( 4*7)-1:3*7],\n      (s10thrid==3)?s10counter:counters[( 3*7)-1:2*7],\n      (s10thrid==2)?s10counter:counters[(2*7)-1:1*7],\n      (s10thrid==1)?s10counter:counters[(1*7)-1:0]};\n   reg [4:0] reissues;\n   always @(posedge clk)\n     if (!reset) begin\n        state <= S_IDLE;\n        i_thrid <= 0;\n        i_dvx <= 0;\n        i_dvy <= 0;\n        i_vx <= 0;\n        i_vy <= 0;\n        counters <= 0;\n        iterations <= 0;\n        thrid1 <= 0;\n        ack <= 0;\n        cx <= 0;\n        reissues <= 0;\n     end else begin\n        counters <= counters_comb;\n        case(state)\n          S_IDLE: if (rq) begin\n             state <= S_ISSUE;\n             i_thrid <= 1;\n             cx <= cx0;\n             i_dvx <= 0;\n             i_dvy <= 0;\n             i_vx <= 0;\n             i_vy <= 0;\n             counters <= 0;\n             iterations <= 0;\n             ack <= 0;\n             reissues <= 0;\n          end else ack <= 0;\n          S_ISSUE: begin\n             i_thrid <= i_thrid + 1;\n             cx <= cx + cxstep;\n             if (i_thrid == 11) begin\n                cx <= cx0;\n                state <= S_REISSUE;\n                i_thrid <= 0;\n                i_counter <= 0;\n                thrid1 <= 1;\n             end\n          end\n          S_REISSUE: begin\n             if (thrid1 == 11) begin\n                cx <= cx0;\n                thrid1 <= 1;\n                reissues <= 0;\n                if (iterations == 100 || reissues == 0) begin\n                   state <= S_IDLE;\n                   ack <= 1;\n                end else begin\n                   iterations <= iterations + 1;\n                end\n             end else begin\n                cx <= cx + cxstep;\n                thrid1 <= thrid1 + 1;\n                reissues <= reissues + reissue?1:0;\n             end\n          end\n        endcase\n     end\nendmodule"}
{"task_id": 501, "completion": "IBUFG clkin1_buf\n   (.O (clkin1),\n    .I (CLK_IN1));\n\n  wire [15:0] do_unused;\n  wire        drdy_unused;\n  wire        psdone_unused;\n  wire        clkfbout;\n  wire        clkfboutb_unused;\n  wire        clkout0b_unused;\n  wire        clkout1b_unused;\n  wire        clkout2b_unused;\n  wire        clkout3b_unused;\n  wire        clkout5_unused;\n  wire        clkout6_unused;\n  wire        clkfbstopped_unused;\n  wire        clkinstopped_unused;\n\n  MMCM_ADV\n  #(.BANDWIDTH            (\"OPTIMIZED\"),\n    .CLKOUT4_CASCADE      (\"FALSE\"),\n    .CLOCK_HOLD           (\"FALSE\"),\n    .COMPENSATION         (\"ZHOLD\"),\n    .STARTUP_WAIT         (\"FALSE\"),\n    .DIVCLK_DIVIDE        (1),\n    .CLKFBOUT_MULT_F      (8.000),\n    .CLKFBOUT_PHASE       (0.000),\n    .CLKFBOUT_USE_FINE_PS (\"FALSE\"),\n    .CLKOUT0_DIVIDE_F     (8.000),\n    .CLKOUT0_PHASE        (0.000),\n    .CLKOUT0_DUTY_CYCLE   (0.500),\n    .CLKOUT0_USE_FINE_PS  (\"FALSE\"),\n    .CLKOUT1_DIVIDE       (8),\n    .CLKOUT1_PHASE        (90.000),\n    .CLKOUT1_DUTY_CYCLE   (0.500),\n    .CLKOUT1_USE_FINE_PS  (\"FALSE\"),\n    .CLKOUT2_DIVIDE       (8),\n    .CLKOUT2_PHASE        (180.000),\n    .CLKOUT2_DUTY_CYCLE   (0.500),\n    .CLKOUT2_USE_FINE_PS  (\"FALSE\"),\n    .CLKOUT3_DIVIDE       (8),\n    .CLKOUT3_PHASE        (270.000),\n    .CLKOUT3_DUTY_CYCLE   (0.500),\n    .CLKOUT3_USE_FINE_PS  (\"FALSE\"),\n    .CLKOUT4_DIVIDE       (4),\n    .CLKOUT4_PHASE        (0.000),\n    .CLKOUT4_DUTY_CYCLE   (0.500),\n    .CLKOUT4_USE_FINE_PS  (\"FALSE\"),\n    .CLKIN1_PERIOD        (7.812),\n    .REF_JITTER1          (0.010))\n  mmcm_adv_inst\n    (.CLKFBOUT            (clkfbout),\n    .CLKFBOUTB           (clkfboutb_unused),\n    .CLKOUT0             (clkout0),\n    .CLKOUT0B            (clkout0b_unused),\n    .CLKOUT1             (clkout1),\n    .CLKOUT1B            (clkout1b_unused),\n    .CLKOUT2             (clkout2),\n    .CLKOUT2B            (clkout2b_unused),\n    .CLKOUT3             (clkout3),\n    .CLKOUT3B            (clkout3b_unused),\n    .CLKOUT4             (clkout4),\n    .CLKOUT5             (clkout5_unused),\n    .CLKOUT6             (clkout6_unused),\n    .CLKFBIN             (clkfbout),\n    .CLKIN1              (clkin1),\n    .CLKIN2              (1'b0),\n    .CLKINSEL            (1'b1),\n    .DADDR               (7'h0),\n    .DCLK                (1'b0),\n    .DEN                 (1'b0),\n    .DI                  (16'h0),\n    .DO                  (do_unused),\n    .DRDY                (drdy_unused),\n    .DWE                 (1'b0),\n    .PSCLK               (1'b0),\n    .PSEN                (1'b0),\n    .PSINCDEC            (1'b0),\n    .PSDONE              (psdone_unused),\n    .LOCKED              (LOCKED),\n    .CLKINSTOPPED        (clkinstopped_unused),\n    .CLKFBSTOPPED        (clkfbstopped_unused),\n    .PWRDWN              (1'b0),\n    .RST                 (1'b0));\n\n  assign CLK_OUT1 = clkout0;\n  assign CLK_OUT2 = clkout1;\n  assign CLK_OUT3 = clkout2;\n  assign CLK_OUT4 = clkout3;\n  assign CLK_OUT5 = clkout4;\n\nendmodule"}
{"task_id": 623, "completion": "wire wbs0_match = ~|((wbm_adr_i ^ wbs0_addr) & wbs0_addr_msk);\n    wire wbs1_match = ~|((wbm_adr_i ^ wbs1_addr) & wbs1_addr_msk);\n\n    wire wbs0_sel = wbs0_match;\n    wire wbs1_sel = wbs1_match & ~(wbs0_match);\n\n    wire master_cycle = wbm_cyc_i & wbm_stb_i;\n\n    wire select_error = ~(wbs0_sel | wbs1_sel) & master_cycle;\n\n    assign wbm_dat_o = wbs0_sel ? wbs0_dat_i :\n                       wbs1_sel ? wbs1_dat_i :\n                       {DATA_WIDTH{1'b0}};\n\n    assign wbm_ack_o = wbs0_ack_i |\n                       wbs1_ack_i;\n\n    assign wbm_err_o = wbs0_err_i |\n                       wbs1_err_i |\n                       select_error;\n\n    assign wbm_rty_o = wbs0_rty_i |\n                       wbs1_rty_i;\n\n    assign wbs0_adr_o = wbm_adr_i;\n    assign wbs0_dat_o = wbm_dat_i;\n    assign wbs0_we_o = wbm_we_i & wbs0_sel;\n    assign wbs0_sel_o = wbm_sel_i;\n    assign wbs0_stb_o = wbm_stb_i & wbs0_sel;\n    assign wbs0_cyc_o = wbm_cyc_i & wbs0_sel;\n\n    assign wbs1_adr_o = wbm_adr_i;\n    assign wbs1_dat_o = wbm_dat_i;\n    assign wbs1_we_o = wbm_we_i & wbs1_sel;\n    assign wbs1_sel_o = wbm_sel_i;\n    assign wbs1_stb_o = wbm_stb_i & wbs1_sel;\n    assign wbs1_cyc_o = wbm_cyc_i & wbs1_sel;\n\nendmodule"}
{"task_id": 673, "completion": "wire [7:0] AB      = SAB_i ? B_i : A_i;    wire [7:0] ABC     = SC_i  ? C_i : AB;    wire [7:0] ABCD    = SD_i  ? D_i : ABC;    wire [7:0] ABCDE   = SE_i  ? E_i : ABCD;    wire [7:0] ABCDEF  = SF_i  ? F_i : ABCDE;    wire [7:0] ABCDEFG = SG_i  ? G_i : ABCDEF;    assign     Y_o     = SH_i  ? H_i : ABCDEFG;endmodule"}
{"task_id": 275, "completion": "`include \"functions.vh\"\n    localparam C_PIPELINE_HDR_FIFO_INPUT = C_PIPELINE_INPUT;\n    localparam C_PIPELINE_HDR_FIFO_OUTPUT = C_PIPELINE_OUTPUT;\n    localparam C_PIPELINE_HDR_INPUT = C_PIPELINE_INPUT;\n    localparam C_ACTUAL_HDR_FIFO_DEPTH = clog2s(C_DEPTH_PACKETS);\n    localparam C_USE_COMPUTE_REG = 1;\n    localparam C_USE_READY_REG = 1;\n    localparam C_USE_FWFT_HDR_FIFO = 1;\n    localparam C_DATA_FIFO_DEPTH = C_ACTUAL_HDR_FIFO_DEPTH + C_FORMATTER_DELAY + \n                                   C_PIPELINE_HDR_FIFO_INPUT + C_PIPELINE_HDR_FIFO_OUTPUT + C_USE_FWFT_HDR_FIFO + \n                                   C_PIPELINE_HDR_INPUT + C_USE_COMPUTE_REG + C_USE_READY_REG + C_PIPELINE_OUTPUT;\n\n    wire                                  wTxHdrReady;\n    wire                                  wTxHdrValid;\n    wire [C_MAX_HDR_WIDTH-1:0]            wTxHdr;\n    wire [`SIG_NONPAY_W-1:0]              wTxHdrNonpayLen;\n    wire [`SIG_PACKETLEN_W-1:0]           wTxHdrPacketLen;\n    wire [`SIG_LEN_W-1:0]                 wTxHdrPayloadLen; \n    wire                                  wTxHdrNoPayload;\n\n    wire                                  wTxDataReady;\n    wire [C_DATA_WIDTH-1:0]               wTxData;\n    wire [clog2s(C_DATA_WIDTH/32)-1:0]    wTxDataEndOffset;\n    wire                                  wTxDataStartFlag;\n    wire [(C_DATA_WIDTH/32)-1:0]          wTxDataEndFlags;\n    wire [(C_DATA_WIDTH/32)-1:0]          wTxDataWordValid;\n    wire [(C_DATA_WIDTH/32)-1:0]          wTxDataWordReady;\n\n    tx_data_pipeline\n        #(\n          .C_MAX_PAYLOAD                (C_MAX_PAYLOAD_DWORDS*32),\n          .C_DEPTH_PACKETS              (C_DATA_FIFO_DEPTH),\n          .C_DATA_WIDTH                 (C_DATA_WIDTH),\n          .C_PIPELINE_INPUT             (C_PIPELINE_INPUT),\n          .C_PIPELINE_OUTPUT            (C_PIPELINE_OUTPUT),\n          .C_VENDOR                     (C_VENDOR))\n    tx_data_pipeline_inst\n        (\n         .RD_TX_DATA                  (wTxData[C_DATA_WIDTH-1:0]),\n         .RD_TX_DATA_WORD_VALID       (wTxDataWordValid[(C_DATA_WIDTH/32)-1:0]),\n         .RD_TX_DATA_START_FLAG       (wTxDataStartFlag),\n         .RD_TX_DATA_END_FLAGS        (wTxDataEndFlags[(C_DATA_WIDTH/32)-1:0]),\n         .WR_TX_DATA_READY            (TX_DATA_READY),\n         .RD_TX_DATA_WORD_READY       (wTxDataWordReady[(C_DATA_WIDTH/32)-1:0]),\n         .WR_TX_DATA                  (TX_DATA),\n         .WR_TX_DATA_VALID            (TX_DATA_VALID),\n         .WR_TX_DATA_START_FLAG       (TX_DATA_START_FLAG),\n         .WR_TX_DATA_START_OFFSET     (TX_DATA_START_OFFSET[clog2s(C_DATA_WIDTH/32)-1:0]),\n         .WR_TX_DATA_END_FLAG         (TX_DATA_END_FLAG),\n         .WR_TX_DATA_END_OFFSET       (TX_DATA_END_OFFSET[clog2s(C_DATA_WIDTH/32)-1:0]),\n         .CLK                           (CLK),\n         .RST_IN                        (RST_IN));\n\n    tx_hdr_fifo\n        #(\n          .C_PIPELINE_OUTPUT            (C_PIPELINE_HDR_FIFO_OUTPUT),\n          .C_PIPELINE_INPUT             (C_PIPELINE_HDR_FIFO_INPUT),\n          .C_DEPTH_PACKETS              (C_ACTUAL_HDR_FIFO_DEPTH),\n          .C_MAX_HDR_WIDTH              (C_MAX_HDR_WIDTH),\n          .C_VENDOR                     (C_VENDOR))\n    txhf_inst\n        (\n         .WR_TX_HDR_READY               (TX_HDR_READY),\n         .RD_TX_HDR                     (wTxHdr[C_MAX_HDR_WIDTH-1:0]),\n         .RD_TX_HDR_VALID               (wTxHdrValid),\n         .RD_TX_HDR_NOPAYLOAD           (wTxHdrNoPayload),\n         .RD_TX_HDR_PAYLOAD_LEN         (wTxHdrPayloadLen[`SIG_LEN_W-1:0]),\n         .RD_TX_HDR_NONPAY_LEN          (wTxHdrNonpayLen[`SIG_NONPAY_W-1:0]),\n         .RD_TX_HDR_PACKET_LEN          (wTxHdrPacketLen[`SIG_PACKETLEN_W-1:0]),\n         .WR_TX_HDR                     (TX_HDR[C_MAX_HDR_WIDTH-1:0]),\n         .WR_TX_HDR_VALID               (TX_HDR_VALID),\n         .WR_TX_HDR_NOPAYLOAD           (TX_HDR_NOPAYLOAD),\n         .WR_TX_HDR_PAYLOAD_LEN         (TX_HDR_PAYLOAD_LEN[`SIG_LEN_W-1:0]),\n         .WR_TX_HDR_NONPAY_LEN          (TX_HDR_NONPAY_LEN[`SIG_NONPAY_W-1:0]),\n         .WR_TX_HDR_PACKET_LEN          (TX_HDR_PACKET_LEN[`SIG_PACKETLEN_W-1:0]),\n         .RD_TX_HDR_READY               (wTxHdrReady),\n         .CLK                           (CLK),\n         .RST_IN                        (RST_IN));\n\n    tx_alignment_pipeline\n        #(\n          .C_PIPELINE_OUTPUT            (1),\n          .C_PIPELINE_DATA_INPUT        (1),\n          .C_PIPELINE_HDR_INPUT         (C_PIPELINE_HDR_INPUT),\n          .C_DATA_WIDTH                 (C_DATA_WIDTH),\n          .C_USE_COMPUTE_REG            (C_USE_COMPUTE_REG),\n          .C_USE_READY_REG              (C_USE_READY_REG),\n          .C_VENDOR                     (C_VENDOR))\n    tx_alignment_inst\n        (\n         .TX_DATA_WORD_READY            (wTxDataWordReady[(C_DATA_WIDTH/32)-1:0]),\n         .TX_HDR_READY                  (wTxHdrReady),\n         .TX_PKT                        (TX_PKT[C_DATA_WIDTH-1:0]),\n         .TX_PKT_VALID                  (TX_PKT_VALID),\n         .TX_PKT_START_FLAG             (TX_PKT_START_FLAG),\n         .TX_PKT_START_OFFSET           (TX_PKT_START_OFFSET[clog2s(C_DATA_WIDTH/32)-1:0]),\n         .TX_PKT_END_FLAG               (TX_PKT_END_FLAG),\n         .TX_PKT_END_OFFSET             (TX_PKT_END_OFFSET[clog2s(C_DATA_WIDTH/32)-1:0]),\n         .TX_DATA_START_FLAG            (wTxDataStartFlag),\n         .TX_DATA_END_FLAGS             (wTxDataEndFlags),\n         .TX_DATA_WORD_VALID            (wTxDataWordValid[(C_DATA_WIDTH/32)-1:0]),\n         .TX_DATA                       (wTxData[C_DATA_WIDTH-1:0]),\n         .TX_HDR                        (wTxHdr[C_MAX_HDR_WIDTH-1:0]),\n         .TX_HDR_VALID                  (wTxHdrValid),\n         .TX_HDR_NOPAYLOAD              (wTxHdrNoPayload),\n         .TX_HDR_PAYLOAD_LEN            (wTxHdrPayloadLen[`SIG_LEN_W-1:0]),\n         .TX_HDR_NONPAY_LEN             (wTxHdrNonpayLen[`SIG_NONPAY_W-1:0]),\n         .TX_HDR_PACKET_LEN             (wTxHdrPacketLen[`SIG_PACKETLEN_W-1:0]),\n         .TX_PKT_READY                  (TX_PKT_READY),\n         .CLK                           (CLK),\n         .RST_IN                        (RST_IN));\nendmodule"}
{"task_id": 694, "completion": "endmodule"}
{"task_id": 666, "completion": "assign divide_by_0 = b == 0 ? 1'b1:1'b0;\n\n  integer i;\n  reg frac;\n  reg   [aw-1:0] quo_temp;\n  reg   [bw:0] am [0:aw-1];\n  reg   [bw:0] at [0:aw-1];\n  reg   [bw:0] a_end;\n  \n  wire signed [bw:0] sb;\n \n  assign sb = {1'b0,b};\n\nalways  \nbegin\n  quo_temp[aw-1] = 0;\n  at[aw-2] = {{(bw-1){1'b0}},a[aw-1:aw-2]};\n  for(i=aw-3;i>=0;i=i-1)\n    begin\n      am[i+1] = at[i+1] - sb;\n      quo_temp[i+1] = ~am[i+1][bw];\n      \n      if(quo_temp[i+1])\n        at[i] = {am[i+1][bw-1:0],a[i]};\n      else\n        at[i] = {at[i+1][bw-1:0],a[i]};\n    end\n//lsb  \n  am[0] = at[0] - sb;\n  quo_temp[0] = ~am[0][bw];\n\n  if (quo_temp[0])\n    a_end = am[0];\n  else\n    a_end = at[0];\nend\n\nassign quo = b == 0? {aw{1'b1}}: \n             b == 1? a:quo_temp;\nassign res = b == 0? 0:\n            (b == 1? 0:a_end[bw-1:0]);\nendmodule"}
{"task_id": 569, "completion": "BLK_MEM_GEN_V6_2 #(\n    .C_ADDRA_WIDTH(13),\n    .C_ADDRB_WIDTH(13),\n    .C_ALGORITHM(1),\n    .C_AXI_ID_WIDTH(4),\n    .C_AXI_SLAVE_TYPE(0),\n    .C_AXI_TYPE(1),\n    .C_BYTE_SIZE(9),\n    .C_COMMON_CLK(0),\n    .C_DEFAULT_DATA(\"0\"),\n    .C_DISABLE_WARN_BHV_COLL(1),\n    .C_DISABLE_WARN_BHV_RANGE(1),\n    .C_FAMILY(\"virtex5\"),\n    .C_HAS_AXI_ID(0),\n    .C_HAS_ENA(0),\n    .C_HAS_ENB(0),\n    .C_HAS_INJECTERR(0),\n    .C_HAS_MEM_OUTPUT_REGS_A(0),\n    .C_HAS_MEM_OUTPUT_REGS_B(0),\n    .C_HAS_MUX_OUTPUT_REGS_A(0),\n    .C_HAS_MUX_OUTPUT_REGS_B(0),\n    .C_HAS_REGCEA(0),\n    .C_HAS_REGCEB(0),\n    .C_HAS_RSTA(0),\n    .C_HAS_RSTB(0),\n    .C_HAS_SOFTECC_INPUT_REGS_A(0),\n    .C_HAS_SOFTECC_OUTPUT_REGS_B(0),\n    .C_INIT_FILE_NAME(\"no_coe_file_loaded\"),\n    .C_INITA_VAL(\"0\"),\n    .C_INITB_VAL(\"0\"),\n    .C_INTERFACE_TYPE(0),\n    .C_LOAD_INIT_FILE(0),\n    .C_MEM_TYPE(1),\n    .C_MUX_PIPELINE_STAGES(0),\n    .C_PRIM_TYPE(1),\n    .C_READ_DEPTH_A(8192),\n    .C_READ_DEPTH_B(8192),\n    .C_READ_WIDTH_A(8),\n    .C_READ_WIDTH_B(8),\n    .C_RST_PRIORITY_A(\"CE\"),\n    .C_RST_PRIORITY_B(\"CE\"),\n    .C_RST_TYPE(\"SYNC\"),\n    .C_RSTRAM_A(0),\n    .C_RSTRAM_B(0),\n    .C_SIM_COLLISION_CHECK(\"ALL\"),\n    .C_USE_BYTE_WEA(0),\n    .C_USE_BYTE_WEB(0),\n    .C_USE_DEFAULT_DATA(0),\n    .C_USE_ECC(0),\n    .C_USE_SOFTECC(0),\n    .C_WEA_WIDTH(1),\n    .C_WEB_WIDTH(1),\n    .C_WRITE_DEPTH_A(8192),\n    .C_WRITE_DEPTH_B(8192),\n    .C_WRITE_MODE_A(\"WRITE_FIRST\"),\n    .C_WRITE_MODE_B(\"WRITE_FIRST\"),\n    .C_WRITE_WIDTH_A(8),\n    .C_WRITE_WIDTH_B(8),\n    .C_XDEVICEFAMILY(\"virtex5\")\n  )\n  inst (\n    .CLKA(clka),\n    .WEA(wea),\n    .ADDRA(addra),\n    .DINA(dina),\n    .CLKB(clkb),\n    .ADDRB(addrb),\n    .DOUTB(doutb),\n    .RSTA(),\n    .ENA(),\n    .REGCEA(),\n    .DOUTA(),\n    .RSTB(),\n    .ENB(),\n    .REGCEB(),\n    .WEB(),\n    .DINB(),\n    .INJECTSBITERR(),\n    .INJECTDBITERR(),\n    .SBITERR(),\n    .DBITERR(),\n    .RDADDRECC(),\n    .S_ACLK(),\n    .S_ARESETN(),\n    .S_AXI_AWID(),\n    .S_AXI_AWADDR(),\n    .S_AXI_AWLEN(),\n    .S_AXI_AWSIZE(),\n    .S_AXI_AWBURST(),\n    .S_AXI_AWVALID(),\n    .S_AXI_AWREADY(),\n    .S_AXI_WDATA(),\n    .S_AXI_WSTRB(),\n    .S_AXI_WLAST(),\n    .S_AXI_WVALID(),\n    .S_AXI_WREADY(),\n    .S_AXI_BID(),\n    .S_AXI_BRESP(),\n    .S_AXI_BVALID(),\n    .S_AXI_BREADY(),\n    .S_AXI_ARID(),\n    .S_AXI_ARADDR(),\n    .S_AXI_ARLEN(),\n    .S_AXI_ARSIZE(),\n    .S_AXI_ARBURST(),\n    .S_AXI_ARVALID(),\n    .S_AXI_ARREADY(),\n    .S_AXI_RID(),\n    .S_AXI_RDATA(),\n    .S_AXI_RRESP(),\n    .S_AXI_RLAST(),\n    .S_AXI_RVALID(),\n    .S_AXI_RREADY(),\n    .S_AXI_INJECTSBITERR(),\n    .S_AXI_INJECTDBITERR(),\n    .S_AXI_SBITERR(),\n    .S_AXI_DBITERR(),\n    .S_AXI_RDADDRECC()\n  );\n\nendmodule"}
{"task_id": 695, "completion": "output X;\n    input  A;\n    input  VPWR;\n    input  VGND;\n    input  VPB;\n    input  VNB;\n    sky130_fd_sc_lp__clkbuf base (\n        .X(X),\n        .A(A),\n        .VPWR(VPWR),\n        .VGND(VGND),\n        .VPB(VPB),\n        .VNB(VNB)\n    );\n\nendmodule"}
{"task_id": 676, "completion": "`include \"log2.inc\"\n\n    parameter WIDTH_N = 32;\n    parameter WIDTH_D = 32;\n    localparam LOG2_WIDTH_N = log2(WIDTH_N);\n    localparam MIN_ND = (WIDTH_N <WIDTH_D ? WIDTH_N : WIDTH_D);\n\n    input clk,rst;\n\n    input load;                   \n    input [WIDTH_N-1:0] n;       \n    input [WIDTH_D-1:0] d;       \n    output [WIDTH_N-1:0] q;      \n    output [WIDTH_D-1:0] r;      \n    output ready;                \n\n    reg [WIDTH_N + MIN_ND : 0] working;\n    reg [WIDTH_D-1 : 0] denom;\n\n    wire [WIDTH_N-1:0] lower_working = working [WIDTH_N-1:0];\n    wire [MIN_ND:0] upper_working = working [WIDTH_N + MIN_ND : WIDTH_N];\n\n    wire [WIDTH_D:0] sub_result = upper_working - denom;\n    wire sub_result_neg = sub_result[WIDTH_D];\n\n    reg [LOG2_WIDTH_N:0] cntr;\n    wire cntr_zero = ~|cntr;\n    assign ready = cntr_zero;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            working <= 0;\n            denom <= 0;\n            cntr <= 0;\n        end\n        else begin\n            if (load) begin\n                working <= {{WIDTH_D{1'b0}},n,1'b0};\n                cntr <= WIDTH_N;\n                denom <= d;\n            end\n            else begin\n                if (!cntr_zero) begin\n                    cntr <= cntr - 1;\n                    working <= sub_result_neg ? {working[WIDTH_N+MIN_ND-1:0],1'b0} :\n                            {sub_result[WIDTH_D-1:0],lower_working,1'b1};\n                end\n            end\n        end\n    end\n\n    assign q = lower_working;\n    assign r = upper_working >> 1;\n\nendmodule"}
{"task_id": 601, "completion": "localparam PACKET_WIDTH = (USE_PACKETS) ? 2 + EMPTY_WIDTH : 0;\n    localparam PCHANNEL_W   = (USE_CHANNEL) ? CHANNEL_WIDTH : 0;\n    localparam PERROR_W     = (USE_ERROR) ? ERROR_WIDTH : 0;\n\n    localparam PAYLOAD_WIDTH = DATA_WIDTH + \n        PACKET_WIDTH +\n        PCHANNEL_W +\n        EMPTY_WIDTH +\n        PERROR_W;\n   \n    wire [PAYLOAD_WIDTH - 1: 0] in_payload;\n    wire [PAYLOAD_WIDTH - 1: 0] out_payload;\n   \n    assign in_payload[DATA_WIDTH - 1 : 0] = in_data;\n    generate\n        if (PACKET_WIDTH) begin\n            assign in_payload[\n                DATA_WIDTH + PACKET_WIDTH - 1 : \n                DATA_WIDTH\n            ] = {in_startofpacket, in_endofpacket};\n        end\n        if (USE_CHANNEL) begin\n            assign in_payload[\n              DATA_WIDTH + PACKET_WIDTH + PCHANNEL_W - 1 : \n              DATA_WIDTH + PACKET_WIDTH\n            ] = in_channel;\n        end\n        if (EMPTY_WIDTH) begin\n            assign in_payload[\n                DATA_WIDTH + PACKET_WIDTH + PCHANNEL_W + EMPTY_WIDTH - 1 : \n                DATA_WIDTH + PACKET_WIDTH + PCHANNEL_W\n            ] = in_empty;\n        end\n        if (USE_ERROR) begin\n            assign in_payload[\n                DATA_WIDTH + PACKET_WIDTH + PCHANNEL_W + EMPTY_WIDTH + PERROR_W - 1 : \n                DATA_WIDTH + PACKET_WIDTH + PCHANNEL_W + EMPTY_WIDTH\n            ] = in_error;\n        end\n    endgenerate\n\n    altera_avalon_st_clock_crosser\n    #(\n        .SYMBOLS_PER_BEAT    (1),\n        .BITS_PER_SYMBOL     (PAYLOAD_WIDTH),\n        .FORWARD_SYNC_DEPTH  (VALID_SYNC_DEPTH),\n        .BACKWARD_SYNC_DEPTH (READY_SYNC_DEPTH),\n        .USE_OUTPUT_PIPELINE (USE_OUTPUT_PIPELINE)\n    ) clock_xer (\n        .in_clk    (in_clk      ),\n        .in_reset  (in_reset    ),\n        .in_ready  (in_ready    ),\n        .in_valid  (in_valid    ),\n        .in_data   (in_payload  ),\n        .out_clk   (out_clk     ),\n        .out_reset (out_reset   ),\n        .out_ready (out_ready   ),\n        .out_valid (out_valid   ),\n        .out_data  (out_payload )\n    );\n\n    assign out_data = out_payload[DATA_WIDTH - 1 : 0];\n\n    generate\n        if (USE_PACKETS) begin\n            assign {out_startofpacket, out_endofpacket} = \n                out_payload[DATA_WIDTH + PACKET_WIDTH - 1 : DATA_WIDTH];\n        end else begin\n            assign {out_startofpacket, out_endofpacket} = 2'b0;\n        end\n   \n        if (USE_CHANNEL) begin\n            assign out_channel = out_payload[\n              DATA_WIDTH + PACKET_WIDTH + PCHANNEL_W - 1 : \n              DATA_WIDTH + PACKET_WIDTH\n            ];\n        end else begin\n            assign out_channel = 1'b0;\n        end\n\n        if (EMPTY_WIDTH) begin\n            assign out_empty = out_payload[\n              DATA_WIDTH + PACKET_WIDTH + PCHANNEL_W + EMPTY_WIDTH - 1 : \n              DATA_WIDTH + PACKET_WIDTH + PCHANNEL_W\n            ];\n        end else begin\n            assign out_empty = 1'b0;\n        end\n\n        if (USE_ERROR) begin\n            assign out_error = out_payload[\n              DATA_WIDTH + PACKET_WIDTH + PCHANNEL_W + EMPTY_WIDTH + PERROR_W - 1 : \n              DATA_WIDTH + PACKET_WIDTH + PCHANNEL_W + EMPTY_WIDTH\n            ];\n        end else begin\n            assign out_error = 1'b0;\n        end\n    endgenerate\n\n    function integer log2ceil;\n        input integer val;\n        integer i;\n\n        begin\n            i = 1;\n            log2ceil = 0;\n\n            while (i < val) begin\n                log2ceil = log2ceil + 1;\n                i = i << 1;\n            end\n        end\n    endfunction\n\nendmodule"}
{"task_id": 616, "completion": "wire      io_we = ~nIORQ & ~nWR & nM1;\n    wire      io_rd = ~nIORQ & ~nRD & nM1;\n    wire      m1    = ~nMREQ & ~nM1;\n\n    reg       old_we, old_rd, old_m1;\n\n    always @(posedge clk_sys) begin\n        old_we <= io_we;\n        old_rd <= io_rd;\n        old_m1 <= m1;\n    end\n\n    assign    active_io   = port_io;\n\n    wire      port_cs = ((mode[0]      ) && (addr[7:0] == 8'hE7)) ||\n                        ((mode == 2'b10) && (addr[7:0] == 8'h1F));\n    wire      port_io = ((mode[0]      ) && (addr[7:0] == 8'hEB)) ||\n                        ((mode == 2'b10) && (addr[7:0] == 8'h3F));\n\n    reg       tx_strobe;\n    reg       rx_strobe;\n\n    always @(posedge clk_sys) begin\n\n        reg m1_trigger;\n\n        rx_strobe <= 0;\n        tx_strobe <= 0;\n\n        if(enable) begin\n\n            if(io_we & ~old_we) begin\n                if (port_cs) spi_ss <= din[0];                          \n                if (port_io) tx_strobe <= 1'b1;                         \n            end\n\n            if(io_rd & ~old_rd & port_io) rx_strobe <= 1;\n\n        end else begin\n            spi_ss     <= 1;\n        end\n    end\n\n    wire      page0 = addr[15:13] == 3'b000;\n    wire      page1 = addr[15:13] == 3'b001;\n\n    assign    rom_active = (nRFSH & page0 & (conmem | (!mapram & automap)));\n    assign    ram_active = (nRFSH & page0 & !conmem & mapram & automap) | (page1 & (conmem | automap));\n    assign    ram_bank   = page0 ? 4'h3 : sram_page;\n\n    reg [3:0] sram_page;\n    reg       conmem;\n    reg       mapram;\n    reg       automap;\n\n    always @(posedge clk_sys) begin\n        reg m1_trigger;\n\n        if(enable && mode == 2'b11) begin\n\n            if(io_we & ~old_we) begin\n                case(addr[7:0])\n                    'hE3: {conmem, mapram, sram_page} <= {din[7:6], din[3:0]};\n                    default:;\n                endcase\n            end\n\n            if(m1 & ~old_m1) begin\n                casex(addr)\n                    16'h0000, 16'h0008, 16'h0038, 16'h0066:\n                        m1_trigger <= 1;\n                    16'h04C6, 16'h0562:\n                        m1_trigger <= !disable_pagein;\n                    16'h3DXX:\n                        {automap, m1_trigger} <= 2'b11;\n                    16'b0001111111111XXX:\n                        m1_trigger <= 0;\n                    default: ;\n                endcase\n            end\n            if(~nRFSH) automap <= m1_trigger;\n\n        end else begin\n            m1_trigger <= 0;\n            automap    <= 0;\n            conmem     <= 0;\n            sram_page  <= 0;\n            mapram     <= 0;\n        end\n    end\n\n    spi spi(\n       .clk_sys(clk_sys),\n       .tx(tx_strobe),\n       .rx(rx_strobe),\n       .din(din),\n       .dout(dout),\n       .spi_clk(spi_clk),\n       .spi_di(spi_di),\n       .spi_do(spi_do)\n    );\n\nendmodule\n\nmodule spi(\n    input        clk_sys,\n    input        tx,\n    input        rx,\n    input  [7:0] din,\n    output [7:0] dout,\n    output       spi_clk,\n    input        spi_di,\n    output       spi_do\n);\n\n    assign    spi_clk = counter[0];\n    assign    spi_do  = io_byte[7];\n    assign    dout    = data;\n\n    reg [4:0] counter = 5'b10000;\n    reg [7:0] io_byte, data;\n\n    always @(negedge clk_sys) begin\n        if(counter[4]) begin\n            if(rx | tx) begin\n                counter <= 0;\n                data <= io_byte;\n                io_byte <= tx ? din : 8'hff;\n            end\n        end else begin\n            if(spi_clk) io_byte <= { io_byte[6:0], spi_di };\n            counter <= counter + 2'd1;\n        end\n    end\n\nendmodule"}
{"task_id": 595, "completion": "localparam RDF_FIFO_NUM = ((APPDATA_WIDTH/2)+63)/64;\n    reg [DQS_WIDTH-1:0] ctrl_rden_r;\n    wire [(DQS_WIDTH*DQ_PER_DQS)-1:0] fall_data;\n    reg [(DQS_WIDTH*DQ_PER_DQS)-1:0] rd_data_in_fall_r;\n    reg [(DQS_WIDTH*DQ_PER_DQS)-1:0] rd_data_in_rise_r;\n    wire rden;\n    reg [DQS_WIDTH-1:0] rden_sel_r /* synthesis syn_preserve=1 */;\n    wire [DQS_WIDTH-1:0] rden_sel_mux;\n    wire [(DQS_WIDTH*DQ_PER_DQS)-1:0] rise_data;\n\n    wire [((RDF_FIFO_NUM -1) *2)+1:0] db_ecc_error;\n    reg [(DQS_WIDTH*DQ_PER_DQS)-1:0] fall_data_r;\n    reg fifo_rden_r0;\n    reg fifo_rden_r1;\n    reg fifo_rden_r2;\n    reg fifo_rden_r3;\n    reg fifo_rden_r4;\n    reg fifo_rden_r5;\n    reg fifo_rden_r6;\n    wire [(APPDATA_WIDTH/2)-1:0] rd_data_out_fall_temp;\n    wire [(APPDATA_WIDTH/2)-1:0] rd_data_out_rise_temp;\n    reg rst_r;\n    reg [(DQS_WIDTH*DQ_PER_DQS)-1:0] rise_data_r;\n    wire [((RDF_FIFO_NUM -1) *2)+1:0] sb_ecc_error;\n\n    always @(posedge clk0) begin\n      rden_sel_r <= ctrl_rden_sel;\n      ctrl_rden_r <= ctrl_rden;\n      rd_data_in_rise_r <= rd_data_in_rise;\n      rd_data_in_fall_r <= rd_data_in_fall;\n    end\n\n    genvar rd_i;\n    generate\n      for (rd_i = 0; rd_i < DQS_WIDTH; rd_i = rd_i+1) begin: gen_rden_sel_mux\n        FDRSE u_ff_rden_sel_mux\n          (\n           .Q   (rden_sel_mux[rd_i]),\n           .C   (clk0),\n           .CE  (1'b1),\n           .D   (ctrl_rden_sel[rd_i]),\n           .R   (1'b0),\n           .S   (1'b0)\n           );\n      end\n    endgenerate\n\n    assign rden = (rden_sel_r[0]) ? ctrl_rden[0] : ctrl_rden_r[0];\n\n    genvar data_i;\n    generate\n      for(data_i = 0; data_i < DQS_WIDTH; data_i = data_i+1) begin: gen_data\n        assign rise_data[(data_i*DQ_PER_DQS)+(DQ_PER_DQS-1):(data_i*DQ_PER_DQS)]\n               = (rden_sel_mux[data_i]) ?\n                 rd_data_in_rise[(data_i*DQ_PER_DQS)+(DQ_PER_DQS-1):(data_i*DQ_PER_DQS)] :\n                 rd_data_in_rise_r[(data_i*DQ_PER_DQS)+(DQ_PER_DQS-1):(data_i*DQ_PER_DQS)];\n        assign fall_data[(data_i*DQ_PER_DQS)+(DQ_PER_DQS-1):(data_i*DQ_PER_DQS)]\n                = (rden_sel_mux[data_i]) ?\n                  rd_data_in_fall[(data_i*DQ_PER_DQS)+(DQ_PER_DQS-1):(data_i*DQ_PER_DQS)] :\n                  rd_data_in_fall_r[(data_i*DQ_PER_DQS)+(DQ_PER_DQS-1):(data_i*DQ_PER_DQS)];\n      end\n    endgenerate\n\n    always @(posedge clk0) rst_r <= rst0;\n\n    genvar rdf_i;\n    generate\n      if (ECC_ENABLE) begin\n        always @(posedge clk0) begin\n          rd_ecc_error[0] <= (|sb_ecc_error) & fifo_rden_r5;\n          rd_ecc_error[1] <= (|db_ecc_error) & fifo_rden_r5;\n          rd_data_out_rise <= rd_data_out_rise_temp;\n          rd_data_out_fall <= rd_data_out_fall_temp;\n          rise_data_r <= rise_data;\n          fall_data_r <= fall_data;\n        end\n\n        assign rd_data_valid = fifo_rden_r6;\n\n        always @(posedge clk0) begin\n          if (rst0) begin\n            fifo_rden_r0 <= 1'b0;\n            fifo_rden_r1 <= 1'b0;\n            fifo_rden_r2 <= 1'b0;\n            fifo_rden_r3 <= 1'b0;\n            fifo_rden_r4 <= 1'b0;\n            fifo_rden_r5 <= 1'b0;\n            fifo_rden_r6 <= 1'b0;\n          end else {\n            fifo_rden_r0 <= rden;\n            fifo_rden_r1 <= fifo_rden_r0;\n            fifo_rden_r2 <= fifo_rden_r1;\n            fifo_rden_r3 <= fifo_rden_r2;\n            fifo_rden_r4 <= fifo_rden_r3;\n            fifo_rden_r5 <= fifo_rden_r4;\n            fifo_rden_r6 <= fifo_rden_r5;\n          end\n        end\n\n        for (rdf_i = 0; rdf_i < RDF_FIFO_NUM; rdf_i = rdf_i + 1) begin: gen_rdf\n          FIFO36_72  # // rise fifo\n            (\n             .ALMOST_EMPTY_OFFSET     (9'h007),\n             .ALMOST_FULL_OFFSET      (9'h00F),\n             .DO_REG                  (1),          // extra CC output delay\n             .EN_ECC_WRITE            (\"FALSE\"),\n             .EN_ECC_READ             (\"TRUE\"),\n             .EN_SYN                  (\"FALSE\"),\n             .FIRST_WORD_FALL_THROUGH (\"FALSE\")\n             )\n            u_rdf\n              (\n               .ALMOSTEMPTY (),\n               .ALMOSTFULL  (),\n               .DBITERR     (db_ecc_error[rdf_i + rdf_i]),\n               .DO          (rd_data_out_rise_temp[(64*(rdf_i+1))-1:(64 *rdf_i)]),\n               .DOP         (),\n               .ECCPARITY   (),\n               .EMPTY       (),\n               .FULL        (),\n               .RDCOUNT     (),\n               .RDERR       (),\n               .SBITERR     (sb_ecc_error[rdf_i + rdf_i]),\n               .WRCOUNT     (),\n               .WRERR       (),\n               .DI          (rise_data_r[((64*(rdf_i+1)) + (rdf_i*8))-1:(64 *rdf_i)+(rdf_i*8)]),\n               .DIP         (rise_data_r[(72*(rdf_i+1))-1:(64*(rdf_i+1))+ (8*rdf_i)]),\n               .RDCLK       (clk0),\n               .RDEN        (~rst_r),\n               .RST         (rst_r),\n               .WRCLK       (clk0),\n               .WREN        (~rst_r)\n               );\n\n          FIFO36_72  # // fall_fifo\n            (\n             .ALMOST_EMPTY_OFFSET     (9'h007),\n             .ALMOST_FULL_OFFSET      (9'h00F),\n             .DO_REG                  (1),          // extra CC output delay\n             .EN_ECC_WRITE            (\"FALSE\"),\n             .EN_ECC_READ             (\"TRUE\"),\n             .EN_SYN                  (\"FALSE\"),\n             .FIRST_WORD_FALL_THROUGH (\"FALSE\")\n             )\n            u_rdf1\n              (\n               .ALMOSTEMPTY (),\n               .ALMOSTFULL  (),\n               .DBITERR     (db_ecc_error[(rdf_i+1) + rdf_i]),\n               .DO          (rd_data_out_fall_temp[(64*(rdf_i+1))-1:(64 *rdf_i)]),\n               .DOP         (),\n               .ECCPARITY   (),\n               .EMPTY       (),\n               .FULL        (),\n               .RDCOUNT     (),\n               .RDERR       (),\n               .SBITERR     (sb_ecc_error[(rdf_i+1) + rdf_i]),\n               .WRCOUNT     (),\n               .WRERR       (),\n               .DI          (fall_data_r[((64*(rdf_i+1)) + (rdf_i*8))-1:(64*rdf_i)+(rdf_i*8)]),\n               .DIP         (fall_data_r[(72*(rdf_i+1))-1:(64*(rdf_i+1))+ (8*rdf_i)]),\n               .RDCLK       (clk0),\n               .RDEN        (~rst_r),\n               .RST         (rst_r),          // or can use rst0\n               .WRCLK       (clk0),\n               .WREN        (~rst_r)\n               );\n        end\n      end else begin\n        assign rd_data_valid = fifo_rden_r0;\n        always @(posedge clk0) begin\n          rd_data_out_rise <= rise_data;\n          rd_data_out_fall <= fall_data;\n          fifo_rden_r0 <= rden;\n        end\n      end\n    endgenerate\nendmodule"}
{"task_id": 453, "completion": "input   [7:0] RXStatus;\ninput   clk;\ninput   getPacketRdy;\ninput   isoEn;\ninput   rst;\ninput   sendPacketArbiterGnt;\ninput   sendPacketRdy;\ninput   transReq;\ninput   [1:0] transType;\noutput  clearTXReq;\noutput  getPacketREn;\noutput  sendPacketArbiterReq;\noutput  [3:0] sendPacketPID;\noutput  sendPacketWEn;\noutput  transDone;\n\nwire    [7:0] RXStatus;\nreg     clearTXReq, next_clearTXReq;\nwire    clk;\nreg     getPacketREn, next_getPacketREn;\nwire    getPacketRdy;\nwire    isoEn;\nwire    rst;\nwire    sendPacketArbiterGnt;\nreg     sendPacketArbiterReq, next_sendPacketArbiterReq;\nreg     [3:0] sendPacketPID, next_sendPacketPID;\nwire    sendPacketRdy;\nreg     sendPacketWEn, next_sendPacketWEn;\nreg     transDone, next_transDone;\nwire    transReq;\nwire    [1:0] transType;\n\nreg  [3:0]delCnt, next_delCnt;\nreg [5:0] CurrState_hstCntrl;\nreg [5:0] NextState_hstCntrl;\n\nalways @ (delCnt or transReq or transType or sendPacketArbiterGnt or getPacketRdy or sendPacketRdy or isoEn or RXStatus or sendPacketArbiterReq or transDone or clearTXReq or sendPacketWEn or getPacketREn or sendPacketPID or CurrState_hstCntrl)\nbegin : hstCntrl_NextState\n  NextState_hstCntrl <= CurrState_hstCntrl;\n  next_sendPacketArbiterReq <= sendPacketArbiterReq;\n  next_transDone <= transDone;\n  next_clearTXReq <= clearTXReq;\n  next_delCnt <= delCnt;\n  next_sendPacketWEn <= sendPacketWEn;\n  next_getPacketREn <= getPacketREn;\n  next_sendPacketPID <= sendPacketPID;\n  case (CurrState_hstCntrl)\n    `START_HC:\n      NextState_hstCntrl <= `TX_REQ;\n    `TX_REQ:\n      if (transReq == 1'b1)  \n      begin\n        NextState_hstCntrl <= `WAIT_GNT;\n        next_sendPacketArbiterReq <= 1'b1;\n      end\n    `CHK_TYPE:\n      if (transType == `IN_TRANS)  \n        NextState_hstCntrl <= `IN_WAIT_SP_RDY1;\n      else if (transType == `OUTDATA0_TRANS)  \n        NextState_hstCntrl <= `OUT0_WAIT_SP_RDY1;\n      else if (transType == `OUTDATA1_TRANS)  \n        NextState_hstCntrl <= `OUT1_WAIT_SP_RDY1;\n      else if (transType == `SETUP_TRANS)  \n        NextState_hstCntrl <= `SETUP_HC_WAIT_RDY;\n    `FLAG:\n    begin\n      next_transDone <= 1'b1;\n      next_clearTXReq <= 1'b1;\n      next_sendPacketArbiterReq <= 1'b0;\n      next_delCnt <= 4'h0;\n      NextState_hstCntrl <= `FIN;\n    end\n    `FIN:\n    begin\n      next_clearTXReq <= 1'b0;\n      next_transDone <= 1'b0;\n      next_delCnt <= delCnt + 1'b1;\n      if (delCnt == 4'hf)  \n        NextState_hstCntrl <= `TX_REQ;\n    end\n    `WAIT_GNT:\n      if (sendPacketArbiterGnt == 1'b1)  \n        NextState_hstCntrl <= `CHK_TYPE;\n    `SETUP_CLR_SP_WEN1:\n    begin\n      next_sendPacketWEn <= 1'b0;\n      NextState_hstCntrl <= `SETUP_WAIT_SETUP_SENT;\n    end\n    `SETUP_CLR_SP_WEN2:\n    begin\n      next_sendPacketWEn <= 1'b0;\n      NextState_hstCntrl <= `SETUP_WAIT_DATA_SENT;\n    end\n    `SETUP_WAIT_PKT_RXED:\n    begin\n      next_getPacketREn <= 1'b0;\n      if (getPacketRdy == 1'b1)  \n        NextState_hstCntrl <= `FLAG;\n    end\n    `SETUP_HC_WAIT_RDY:\n      if (sendPacketRdy == 1'b1)  \n      begin\n        NextState_hstCntrl <= `SETUP_CLR_SP_WEN1;\n        next_sendPacketWEn <= 1'b1;\n        next_sendPacketPID <= `SETUP;\n      end\n    `SETUP_WAIT_SETUP_SENT:\n      if (sendPacketRdy == 1'b1)  \n      begin\n        NextState_hstCntrl <= `SETUP_CLR_SP_WEN2;\n        next_sendPacketWEn <= 1'b1;\n        next_sendPacketPID <= `DATA0;\n      end\n    `SETUP_WAIT_DATA_SENT:\n      if (sendPacketRdy == 1'b1)  \n      begin\n        NextState_hstCntrl <= `SETUP_WAIT_PKT_RXED;\n        next_getPacketREn <= 1'b1;\n      end\n    `IN_WAIT_DATA_RXED:\n    begin\n      next_getPacketREn <= 1'b0;\n      if (getPacketRdy == 1'b1)  \n        NextState_hstCntrl <= `IN_CHK_FOR_ERROR;\n    end\n    `IN_CHK_FOR_ERROR:\n      if (isoEn == 1'b1)  \n        NextState_hstCntrl <= `FLAG;\n      else if (RXStatus [`HC_CRC_ERROR_BIT] == 1'b0 &&\n        RXStatus [`HC_BIT_STUFF_ERROR_BIT] == 1'b0 &&\n        RXStatus [`HC_RX_OVERFLOW_BIT] == 1'b0 &&\n        RXStatus [`HC_NAK_RXED_BIT] == 1'b0 &&\n        RXStatus [`HC_STALL_RXED_BIT] == 1'b0 &&\n        RXStatus [`HC_RX_TIME_OUT_BIT] == 1'b0)\n        NextState_hstCntrl <= `IN_WAIT_SP_RDY2;\n      else\n        NextState_hstCntrl <= `FLAG;\n    `IN_CLR_SP_WEN2:\n    begin\n      next_sendPacketWEn <= 1'b0;\n      NextState_hstCntrl <= `IN_WAIT_ACK_SENT;\n    end\n    `IN_WAIT_IN_SENT:\n      if (sendPacketRdy == 1'b1)  \n      begin\n        NextState_hstCntrl <= `IN_WAIT_DATA_RXED;\n        next_getPacketREn <= 1'b1;\n      end\n    `IN_WAIT_SP_RDY1:\n      if (sendPacketRdy == 1'b1)  \n      begin\n        NextState_hstCntrl <= `IN_CLR_SP_WEN1;\n        next_sendPacketWEn <= 1'b1;\n        next_sendPacketPID <= `IN;\n      end\n    `IN_WAIT_SP_RDY2:\n      if (sendPacketRdy == 1'b1)  \n      begin\n        NextState_hstCntrl <= `IN_CLR_SP_WEN2;\n        next_sendPacketWEn <= 1'b1;\n        next_sendPacketPID <= `ACK;\n      end\n    `IN_CLR_SP_WEN1:\n    begin\n      next_sendPacketWEn <= 1'b0;\n      NextState_hstCntrl <= `IN_WAIT_IN_SENT;\n    end\n    `IN_WAIT_ACK_SENT:\n      if (sendPacketRdy == 1'b1)  \n        NextState_hstCntrl <= `FLAG;\n    `OUT0_WAIT_RX_DATA:\n    begin\n      next_getPacketREn <= 1'b0;\n      if (getPacketRdy == 1'b1)  \n        NextState_hstCntrl <= `FLAG;\n    end\n    `OUT0_WAIT_DATA0_SENT:\n      if (sendPacketRdy == 1'b1)  \n        NextState_hstCntrl <= `OUT0_CHK_ISO;\n    `OUT0_WAIT_OUT_SENT:\n      if (sendPacketRdy == 1'b1)  \n      begin\n        NextState_hstCntrl <= `OUT0_CLR_WEN2;\n        next_sendPacketWEn <= 1'b1;\n        next_sendPacketPID <= `DATA0;\n      end\n    `OUT0_WAIT_SP_RDY1:\n      if (sendPacketRdy == 1'b1)  \n      begin\n        NextState_hstCntrl <= `OUT0_CLR_WEN1;\n        next_sendPacketWEn <= 1'b1;\n        next_sendPacketPID <= `OUT;\n      end\n    `OUT0_CLR_WEN1:\n    begin\n      next_sendPacketWEn <= 1'b0;\n      NextState_hstCntrl <= `OUT0_WAIT_OUT_SENT;\n    end\n    `OUT0_CLR_WEN2:\n    begin\n      next_sendPacketWEn <= 1'b0;\n      NextState_hstCntrl <= `OUT0_WAIT_DATA0_SENT;\n    end\n    `OUT0_CHK_ISO:\n      if (isoEn == 1'b0)  \n      begin\n        NextState_hstCntrl <= `OUT0_WAIT_RX_DATA;\n        next_getPacketREn <= 1'b1;\n      end\n      else\n        NextState_hstCntrl <= `FLAG;\n    `OUT1_WAIT_RX_DATA:\n    begin\n      next_getPacketREn <= 1'b0;\n      if (getPacketRdy == 1'b1)  \n        NextState_hstCntrl <= `FLAG;\n    end\n    `OUT1_WAIT_OUT_SENT:\n      if (sendPacketRdy == 1'b1)  \n      begin\n        NextState_hstCntrl <= `OUT1_CLR_WEN2;\n        next_sendPacketWEn <= 1'b1;\n        next_sendPacketPID <= `DATA1;\n      end\n    `OUT1_WAIT_DATA1_SENT:\n      if (sendPacketRdy == 1'b1)  \n      begin\n        NextState_hstCntrl <= `OUT1_WAIT_RX_DATA;\n        next_getPacketREn <= 1'b1;\n      end\n    `OUT1_WAIT_SP_RDY1:\n      if (sendPacketRdy == 1'b1)  \n      begin\n        NextState_hstCntrl <= `OUT1_CLR_WEN1;\n        next_sendPacketWEn <= 1'b1;\n        next_sendPacketPID <= `OUT;\n      end\n    `OUT1_CLR_WEN1:\n    begin\n      next_sendPacketWEn <= 1'b0;\n      NextState_hstCntrl <= `OUT1_WAIT_OUT_SENT;\n    end\n    `OUT1_CLR_WEN2:\n    begin\n      next_sendPacketWEn <= 1'b0;\n      NextState_hstCntrl <= `OUT1_WAIT_DATA1_SENT;\n    end\n  endcase\nend\n\nalways @ (posedge clk)\nbegin : hstCntrl_CurrentState\n  if (rst)  \n    CurrState_hstCntrl <= `START_HC;\n  else\n    CurrState_hstCntrl <= NextState_hstCntrl;\nend\n\nalways @ (posedge clk)\nbegin : hstCntrl_RegOutput\n  if (rst)  \n  begin\n    delCnt <= 4'h0;\n    transDone <= 1'b0;\n    clearTXReq <= 1'b0;\n    getPacketREn <= 1'b0;\n    sendPacketArbiterReq <= 1'b0;\n    sendPacketWEn <= 1'b0;\n    sendPacketPID <= 4'b0;\n  end\n  else \n  begin\n    delCnt <= next_delCnt;\n    transDone <= next_transDone;\n    clearTXReq <= next_clearTXReq;\n    getPacketREn <= next_getPacketREn;\n    sendPacketArbiterReq <= next_sendPacketArbiterReq;\n    sendPacketWEn <= next_sendPacketWEn;\n    sendPacketPID <= next_sendPacketPID;\n  end\nend\n\nendmodule"}
{"task_id": 682, "completion": "wire [2:0] size;  generate if(C_M_AXI_DATA_WIDTH == 32) begin : M_SISE32   assign size = 3'b010;  end endgenerate  generate if(C_M_AXI_DATA_WIDTH == 64) begin : M_SISE64   assign size = 3'b011;  end endgenerate  generate if(C_M_AXI_DATA_WIDTH == 128) begin : M_SISE128   assign size = 3'b100;  end endgenerate  generate if(C_M_AXI_DATA_WIDTH == 256) begin : M_SISE256   assign size = 3'b101;  end endgenerate  generate if(C_M_AXI_DATA_WIDTH == 512) begin : M_SISE512   assign size = 3'b110;  end endgenerate  wire [5:0] id = 6'h0;  wire [1:0] burst = 2'b01;  reg [7:0] len = 8'h0;  always @(posedge Clk) begin   len[7:0] <= (rst_l) ? static_len[7:0] : C_ATG_STATIC_LENGTH;  end  generate if(C_ATG_SYSTEM_INIT == 0 && C_ATG_SYSTEM_TEST == 0) begin : STATIC_MODE_ON assign cmd_out_mw = {                     32'h0,                     32'h0,                     static_ctl_en,7'h0,3'b010,id,size,burst,2'b00,len,                     C_ATG_STATIC_ADDRESS                    }; assign cmd_out_mr = {                     32'h0,                     32'h0,                     static_ctl_en,7'h0,3'b010,id,size,burst,2'b00,len,                     C_ATG_STATIC_ADDRESS                    }; assign cmd_data[C_M_AXI_DATA_WIDTH-1:0] = {                                           64'hCAFE5AFE_C001CAFE,                                           64'hCAFE1AFE_C001DAFE,                                           64'hCAFE2AFE_C001EAFE,                                           64'hCAFE3AFE_C001FAFE                                          }; end endgenerate  wire system_init_en;  wire system_init_cnt_en;  wire system_init_cmd_en;  assign system_init_cnt_en = (rom_addr_ptr_ff[C_ATG_MIF_ADDR_BITS] != 1'b1);  assign system_init_cmd_en = ~(&rom_addr);  assign system_init_en = system_init_cnt_en && system_init_cmd_en;  generate if(C_ATG_SYSTEM_INIT == 1 || C_ATG_SYSTEM_TEST == 1) begin : SYSTEM_INIT_TEST_MODE_ON assign cmd_out_mw = {                     32'h0,                     32'h0,                     system_init_en,7'h0,3'b010,id,size,burst,2'b00,8'h0,                     rom_addr[31:0]                    }; assign cmd_data[C_M_AXI_DATA_WIDTH-1:0] = rom_data[31:0]; end endgenerateendmodule"}
{"task_id": 574, "completion": "wire FSM_op_start_in_load_a,FSM_op_start_in_load_b;\n    wire [W-2:0] DMP, DmP;\n    wire real_op;\n    wire sign_final_result;\n    wire FSM_selector_A;\n    wire [EW-1:0] S_Oper_A_exp;\n    wire [1:0] FSM_selector_B;\n    wire [EW-1:0] S_Oper_B_exp;\n    wire FSM_exp_operation_load_diff, FSM_exp_operation_load_OU ,FSM_exp_operation_A_S;\n    wire [EW-1:0] exp_oper_result;\n    wire [EWR-1:0] S_Shift_Value;\n    wire FSM_selector_C;\n    wire [SWR-1:0] S_Data_Shift;\n    wire FSM_barrel_shifter_load, FSM_barrel_shifter_L_R, FSM_barrel_shifter_B_S;\n    wire [SWR-1:0] Sgf_normalized_result;\n    wire FSM_selector_D;\n    wire S_A_S_op;\n    wire [SWR-1:0] S_A_S_Oper_A;\n    wire [SWR-1:0] S_A_S_Oper_B;\n    wire FSM_Add_Subt_Sgf_load, add_overflow_flag;\n    wire [SWR-1:0] Add_Subt_result;\n    wire [SWR-1:0] A_S_P;\n    wire [SWR-1:1] A_S_C;\n    wire FSM_LZA_load;\n    wire [EWR-1:0] LZA_output;\n    wire round_flag;\n    wire FSM_Final_Result_load;\n    wire rst_int;\n    wire selector_A;\n    wire [1:0] selector_B;\n    wire load_b;\n    wire selector_C;\n    wire selector_D;\n    FSM_Add_Subtract FS_Module(\n        .clk(clk),                                                       \n        .rst(rst),                                                       \n        .rst_FSM(ack_FSM),                                               \n        .beg_FSM(beg_FSM),                                               \n        .zero_flag_i(zero_flag),                                         \n        .norm_iteration_i(FSM_selector_C),                               \n        .add_overflow_i(add_overflow_flag),                              \n        .round_i(round_flag),                                            \n        .load_1_o(FSM_op_start_in_load_a),                               \n        .load_2_o(FSM_op_start_in_load_b),                               \n        .load_3_o(FSM_exp_operation_load_diff),                          \n        .load_8_o(FSM_exp_operation_load_OU),                            \n        .A_S_op_o(FSM_exp_operation_A_S),                                \n        .load_4_o(FSM_barrel_shifter_load),                              \n        .left_right_o(FSM_barrel_shifter_L_R),                           \n        .bit_shift_o(FSM_barrel_shifter_B_S),                            \n        .load_5_o(FSM_Add_Subt_Sgf_load),                               \n        .load_6_o(FSM_LZA_load),                                        \n        .load_7_o(FSM_Final_Result_load),                                  \n        .ctrl_a_o(selector_A),                                         \n        .ctrl_b_o(selector_B),                                         \n        .ctrl_b_load_o(load_b),\n        .ctrl_c_o(selector_C),                                         \n        .ctrl_d_o(selector_D),                                         \n        .rst_int(rst_int),                                               \n        .ready(ready)                                                    \n    );\n    RegisterAdd #(.W(1)) Sel_A (\n        .clk(clk), \n        .rst(rst_int), \n        .load(selector_A), \n        .D(1'b1), \n        .Q(FSM_selector_A)\n    );\n    RegisterAdd #(.W(1)) Sel_C (\n        .clk(clk), \n        .rst(rst_int), \n        .load(selector_C), \n        .D(1'b1), \n        .Q(FSM_selector_C)\n    );\n    RegisterAdd #(.W(1)) Sel_D (\n        .clk(clk), \n        .rst(rst_int), \n        .load(selector_D), \n        .D(1'b1), \n        .Q(FSM_selector_D)\n    );\n    RegisterAdd #(.W(2)) Sel_B (\n        .clk(clk), \n        .rst(rst_int), \n        .load(load_b), \n        .D(selector_B), \n        .Q(FSM_selector_B)\n    );\n    Oper_Start_In #(.W(W)) Oper_Start_in_module (\n        .clk(clk), \n        .rst(rst_int),\n        .load_a_i(FSM_op_start_in_load_a),\n        .load_b_i(FSM_op_start_in_load_b),\n        .add_subt_i(add_subt),\n        .Data_X_i(Data_X),\n        .Data_Y_i(Data_Y),\n        .DMP_o(DMP),\n        .DmP_o(DmP),\n        .zero_flag_o(zero_flag),\n        .real_op_o(real_op),\n        .sign_final_result_o(sign_final_result)\n    );\n    Multiplexer_AC #(.W(EW)) Exp_Oper_A_mux(\n        .ctrl(FSM_selector_A),\n        .D0 (DMP[W-2:W-EW-1]),\n        .D1 (exp_oper_result),\n        .S (S_Oper_A_exp)\n    );\n    wire [EW-EWR-1:0] Exp_oper_B_D1;\n    wire [EW-1:0] Exp_oper_B_D2;\n    Mux_3x1 #(.W(EW)) Exp_Oper_B_mux(\n        .ctrl(FSM_selector_B),\n        .D0 (DmP[W-2:W-EW-1]),\n        .D1 ({Exp_oper_B_D1,LZA_output}),\n        .D2 (Exp_oper_B_D2),\n        .S(S_Oper_B_exp)\n    );\n    generate\n        case(EW)\n            8:begin\n                assign Exp_oper_B_D1 =3'd0;\n                assign Exp_oper_B_D2 = 8'd1;\n            end\n            default:begin\n                assign Exp_oper_B_D1 =5'd0;\n                assign Exp_oper_B_D2 = 11'd1;\n            end\n        endcase\n    endgenerate\n    Exp_Operation #(.EW(EW)) Exp_Operation_Module(\n        .clk(clk), \n        .rst(rst_int),\n        .load_a_i(FSM_exp_operation_load_diff),\n        .load_b_i(FSM_exp_operation_load_OU),\n        .Data_A_i(S_Oper_A_exp),\n        .Data_B_i(S_Oper_B_exp),\n        .Add_Subt_i(FSM_exp_operation_A_S),\n        .Data_Result_o(exp_oper_result),\n        .Overflow_flag_o(overflow_flag),\n        .Underflow_flag_o(underflow_flag)\n    );\n    wire [EWR-1:0] Barrel_Shifter_S_V_D2;\n    Mux_3x1 #(.W(EWR)) Barrel_Shifter_S_V_mux(\n        .ctrl(FSM_selector_B),\n        .D0 (exp_oper_result[EWR-1:0]),\n        .D1 (LZA_output),\n        .D2 (Barrel_Shifter_S_V_D2),\n        .S  (S_Shift_Value)\n    );\n    generate\n        case(EW)\n            8:begin\n                assign Barrel_Shifter_S_V_D2 = 5'd1;\n            end\n            default:begin\n                assign Barrel_Shifter_S_V_D2 = 6'd1;\n            end \n        endcase\n    endgenerate\n    Multiplexer_AC #(.W(SWR)) Barrel_Shifter_D_I_mux(\n        .ctrl(FSM_selector_C),\n        .D0 ({1'b1,DmP[SW-1:0],2'b00}),\n        .D1 (Add_Subt_result),\n        .S (S_Data_Shift)\n    );\n    Barrel_Shifter #(.SWR(SWR),.EWR(EWR)) Barrel_Shifter_module (\n        .clk(clk), \n        .rst(rst_int),\n        .load_i(FSM_barrel_shifter_load),\n        .Shift_Value_i(S_Shift_Value),\n        .Shift_Data_i(S_Data_Shift),\n        .Left_Right_i(FSM_barrel_shifter_L_R),\n        .Bit_Shift_i(FSM_barrel_shifter_B_S),\n        .N_mant_o(Sgf_normalized_result)\n    );\n    Multiplexer_AC #(.W(1)) Add_Sub_Sgf_op_mux(\n        .ctrl(FSM_selector_D),\n        .D0 (real_op),\n        .D1 (1'b0),\n        .S (S_A_S_op)\n    );\n    Multiplexer_AC #(.W(SWR)) Add_Sub_Sgf_Oper_A_mux(\n        .ctrl(FSM_selector_D),\n        .D0 ({1'b1,DMP[SW-1:0],2'b00}),\n        .D1 (Sgf_normalized_result),\n        .S (S_A_S_Oper_A)\n    );\n    Multiplexer_AC #(.W(SWR)) Add_Sub_Sgf_Oper_B_mux(\n        .ctrl(FSM_selector_D),\n        .D0 (Sgf_normalized_result),\n        .D1 (Add_Sub_Sgf_Oper_A_D1),\n        .S (S_A_S_Oper_B)\n    );\n    generate\n        case (W)\n            32:begin\n                assign Add_Sub_Sgf_Oper_A_D1 = 26'd4;\n                end\n            default:begin\n                assign Add_Sub_Sgf_Oper_A_D1 =55'd4;\n                end\n       endcase\n    endgenerate\n    Add_Subt #(.SWR(SWR)) Add_Subt_Sgf_module(\n        .clk(clk), \n        .rst(rst_int),\n        .load_i(FSM_Add_Subt_Sgf_load),\n        .Add_Sub_op_i(S_A_S_op),\n        .Data_A_i(S_A_S_Oper_A),\n        .PreData_B_i(S_A_S_Oper_B),\n        .Data_Result_o(Add_Subt_result),\n        .FSM_C_o(add_overflow_flag)\n    );\n    wire [SWR-1:0] Add_Subt_LZD;\n    assign Add_Subt_LZD = ~Add_Subt_result;\n    LZD #(.SWR(SWR),.EWR(EWR)) Leading_Zero_Detector_Module (\n        .clk(clk), \n        .rst(rst_int),\n        .load_i(FSM_LZA_load),\n        .Add_subt_result_i(Add_Subt_LZD),\n        .Shift_Value_o(LZA_output)\n    );\n    Round_Sgf_Dec Rounding_Decoder(\n        .Data_i(Sgf_normalized_result[1:0]),\n        .Round_Type_i(r_mode),\n        .Sign_Result_i(sign_final_result),\n        .Round_Flag_o(round_flag)\n    );\n    Tenth_Phase #(.W(W),.EW(EW),.SW(SW)) final_result_ieee_Module(\n        .clk(clk), \n        .rst(rst_int),\n        .load_i(FSM_Final_Result_load),\n        .sel_a_i(overflow_flag),\n        .sel_b_i(underflow_flag),\n        .sign_i(sign_final_result),\n        .exp_ieee_i(exp_oper_result),\n        .sgf_ieee_i(Sgf_normalized_result[SWR-2:2]),\n        .final_result_ieee_o(final_result_ieee)\n    );\nendmodule"}
{"task_id": 607, "completion": "localparam CMD_WIDTH = BURSTCOUNT_WIDTH + DATA_WIDTH + HDL_ADDR_WIDTH \n                    + BYTEEN_WIDTH \n                    + 3;        \n\n    localparam NUMSYMBOLS    = DATA_WIDTH / SYMBOL_WIDTH;\n    localparam RSP_WIDTH     = DATA_WIDTH;\n    localparam MAX_BURST     = (1 << (BURSTCOUNT_WIDTH-1));\n    localparam COUNTER_WIDTH = log2ceil(RESPONSE_FIFO_DEPTH) + 1;\n    localparam NON_BURSTING  = (MAX_BURST == 1);\n    localparam BURST_WORDS_W = BURSTCOUNT_WIDTH;\n\n    wire [CMD_WIDTH-1:0]     s0_cmd_payload;\n    wire [CMD_WIDTH-1:0]     m0_cmd_payload;\n    wire                     s0_cmd_valid;\n    wire                     m0_cmd_valid;\n    wire                     m0_internal_write;\n    wire                     m0_internal_read;\n    wire                     s0_cmd_ready;\n    wire                     m0_cmd_ready;\n    reg  [COUNTER_WIDTH-1:0] pending_read_count;\n    wire [COUNTER_WIDTH-1:0] space_avail;\n    wire                     stop_cmd;\n    reg                      stop_cmd_r;\n    wire                     m0_read_accepted;\n    wire                     m0_rsp_ready;\n    reg                      old_read;\n    wire [BURST_WORDS_W-1:0] m0_burstcount_words;\n\n    (* altera_attribute = \"-name ALLOW_ANY_RAM_SIZE_FOR_RECOGNITION ON\" *) altera_avalon_dc_fifo\n    #(\n        .SYMBOLS_PER_BEAT (1),\n        .BITS_PER_SYMBOL  (CMD_WIDTH),\n        .FIFO_DEPTH       (COMMAND_FIFO_DEPTH),\n        .WR_SYNC_DEPTH    (MASTER_SYNC_DEPTH),\n        .RD_SYNC_DEPTH    (SLAVE_SYNC_DEPTH),\n        .BACKPRESSURE_DURING_RESET (1)\n    ) \n    cmd_fifo\n    (\n        .in_clk          (s0_clk),\n        .in_reset_n      (~s0_reset),\n        .out_clk         (m0_clk),\n        .out_reset_n     (~m0_reset),\n\n        .in_data         (s0_cmd_payload),\n        .in_valid        (s0_cmd_valid),\n        .in_ready        (s0_cmd_ready),\n\n        .out_data        (m0_cmd_payload),\n        .out_valid       (m0_cmd_valid),\n        .out_ready       (m0_cmd_ready),\n\n        .in_startofpacket   (1'b0),\n        .in_endofpacket     (1'b0),\n        .in_empty           (1'b0),\n        .in_error           (1'b0),\n        .in_channel         (1'b0),\n        .in_csr_address     (1'b0),\n        .in_csr_read        (1'b0),\n        .in_csr_write       (1'b0),\n        .in_csr_writedata   (32'b0),\n        .out_csr_address    (1'b0),\n        .out_csr_read       (1'b0),\n        .out_csr_write      (1'b0),\n        .out_csr_writedata  (32'b0)\n    );\n\n    assign s0_waitrequest = ~s0_cmd_ready;\n    assign s0_cmd_valid   = s0_write | s0_read;\n\n    assign s0_cmd_payload = {s0_address, \n                             s0_burstcount, \n                             s0_read, \n                             s0_write, \n                             s0_writedata, \n                             s0_byteenable,\n                             s0_debugaccess};\n    assign {m0_address, \n            m0_burstcount, \n            m0_internal_read, \n            m0_internal_write,\n            m0_writedata, \n            m0_byteenable,\n            m0_debugaccess} = m0_cmd_payload;\n\n    assign m0_cmd_ready = ~m0_waitrequest & \n                            ~(m0_internal_read & stop_cmd_r & ~old_read);\n    assign m0_write =  m0_internal_write & m0_cmd_valid;\n    assign m0_read  =  m0_internal_read & m0_cmd_valid & (~stop_cmd_r | old_read);\n    assign m0_read_accepted = m0_read & ~m0_waitrequest;\n\n    generate if (NON_BURSTING)\n    begin\n        always @(posedge m0_clk, posedge m0_reset) begin\n            if (m0_reset) begin\n                pending_read_count <= 0;\n            end\n            else begin\n                if (m0_read_accepted & m0_readdatavalid)\n                    pending_read_count <= pending_read_count;\n                else if (m0_readdatavalid)\n                    pending_read_count <= pending_read_count - 1;\n                else if (m0_read_accepted)\n                    pending_read_count <= pending_read_count + 1; \n            end\n        end\n    end\n    else begin\n        assign m0_burstcount_words = m0_burstcount;\n\n        always @(posedge m0_clk, posedge m0_reset) begin\n            if (m0_reset) begin\n                pending_read_count <= 0;\n            end\n            else begin\n                if (m0_read_accepted & m0_readdatavalid)\n                    pending_read_count <= pending_read_count +\n                                            m0_burstcount_words - 1;\n                else if (m0_readdatavalid)\n                    pending_read_count <= pending_read_count - 1;  \n                else if (m0_read_accepted)\n                    pending_read_count <= pending_read_count +\n                                            m0_burstcount_words;  \n            end\n        end\n    end\n    endgenerate\n\n    assign stop_cmd = (pending_read_count + 2*MAX_BURST) > space_avail;\n\n    always @(posedge m0_clk, posedge m0_reset) begin\n        if (m0_reset) begin\n            stop_cmd_r <= 1'b0;\n            old_read   <= 1'b0;\n        end\n        else begin\n            stop_cmd_r <= stop_cmd;\n            old_read   <= m0_read & m0_waitrequest;\n        end\n    end\n\n    (* altera_attribute = \"-name ALLOW_ANY_RAM_SIZE_FOR_RECOGNITION ON\" *) altera_avalon_dc_fifo\n    #(\n        .SYMBOLS_PER_BEAT   (1),\n        .BITS_PER_SYMBOL    (RSP_WIDTH),\n        .FIFO_DEPTH         (RESPONSE_FIFO_DEPTH),\n        .WR_SYNC_DEPTH      (SLAVE_SYNC_DEPTH),\n        .RD_SYNC_DEPTH      (MASTER_SYNC_DEPTH),\n        .USE_SPACE_AVAIL_IF (1)\n    ) \n    rsp_fifo\n    (\n        .in_clk           (m0_clk),\n        .in_reset_n       (~m0_reset),\n        .out_clk          (s0_clk),\n        .out_reset_n      (~s0_reset),\n\n        .in_data          (m0_readdata),\n        .in_valid         (m0_readdatavalid),\n\n        .in_ready         (m0_rsp_ready),\n\n        .out_data         (s0_readdata),\n        .out_valid        (s0_readdatavalid),\n        .out_ready        (1'b1),\n\n        .space_avail_data (space_avail),\n\n        .in_startofpacket   (1'b0),\n        .in_endofpacket     (1'b0),\n        .in_empty           (1'b0),\n        .in_error           (1'b0),\n        .in_channel         (1'b0),\n        .in_csr_address     (1'b0),\n        .in_csr_read        (1'b0),\n        .in_csr_write       (1'b0),\n        .in_csr_writedata   (32'b0),\n        .out_csr_address    (1'b0),\n        .out_csr_read       (1'b0),\n        .out_csr_write      (1'b0),\n        .out_csr_writedata  (32'b0)  \n    );\n// synthesis translate_off\n    always @(posedge m0_clk) begin\n        if (~m0_rsp_ready & m0_readdatavalid) begin\n            $display(\"%t %m: internal error, response fifo overflow\", $time);\n        end\n\n        if (pending_read_count > space_avail) begin\n            $display(\"%t %m: internal error, too many pending reads\", $time);\n        end\n    end\n// synthesis translate_on\n    function integer log2ceil;\n        input integer val;\n        integer i;\n\n        begin\n            i = 1;\n            log2ceil = 0;\n\n            while (i < val) begin\n                log2ceil = log2ceil + 1;\n                i = i << 1; \n            end\n        end\n    endfunction\nendmodule"}
{"task_id": 703, "completion": "wire and0_out ;\n    wire or0_out_X;\n\n    and and0 (and0_out , A1, A2              );\n    or  or0  (or0_out_X, C1, B1, and0_out, D1);\n    buf buf0 (X        , or0_out_X           );\n\nendmodule"}
{"task_id": 718, "completion": "output Y   ;\n    input  A1_N;\n    input  A2_N;\n    input  B1  ;\n    input  B2  ;\n\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\nendmodule"}
{"task_id": 641, "completion": "reg [DSIZE-1:0] mem [0:FIFO_DEPTH-1];\nreg [ASIZE:0] rd_capture_ptr;\nreg [ASIZE:0] pre_rd_capture_gray_ptr;\nreg [ASIZE:0] rd_capture_gray_ptr;\nreg [ASIZE:0] wr_capture_ptr;\nreg [ASIZE:0] pre_wr_capture_gray_ptr;\nreg [ASIZE:0] wr_capture_gray_ptr;\nwire [ASIZE:0] buf_avail;\nwire [ASIZE:0] buf_filled;\nwire [ASIZE-1:0] wr_addr, rd_addr;\nreg [ASIZE:0] wr_ptr, rd_ptr,rd_ptr_cp;\ninteger i,j,k;\ngenerate\nif (SYNC == 1) begin: RDSYNC\n always @ (rd_ptr)\n rd_capture_ptr = rd_ptr;\nend\nendgenerate\n\ngenerate\nif (SYNC == 1) begin: WRSYNC\nalways @ (wr_ptr)\n wr_capture_ptr = wr_ptr;\nend\nendgenerate\nassign wr_addr = wr_ptr[ASIZE-1:0];\nassign rd_data = mem[rd_addr];\nalways @(posedge wr_clk)\nbegin\nif (wr_en && !full)\n mem[wr_addr] <= #TCQ wr_data;\nend\nassign rd_addr = rd_ptr_cp[ASIZE-1:0];\nassign rd_strobe = rd_en && !empty;\n\ninteger n;\nalways @(posedge rd_clk)\nbegin\nif (rst)\n begin\n rd_ptr <= #TCQ 'b0;\n rd_ptr_cp <= #TCQ 'b0;\n end\nelse begin\n if (rd_strobe) begin\n rd_ptr <= #TCQ rd_ptr + 1'b1;\n rd_ptr_cp <= #TCQ rd_ptr_cp + 1'b1;\n end\n end\nend\nassign buf_filled = wr_capture_ptr - rd_ptr;\n               \nalways @ (posedge rd_clk )\nbegin\n if (rst)\n empty <= #TCQ 1'b1;\n else if ((buf_filled == 0) || (buf_filled == 1 && rd_strobe))\n empty <= #TCQ 1'b1;\n else\n empty <= #TCQ 1'b0;\nend\nreg [ASIZE:0] wbin;\nwire [ASIZE:0] wgraynext, wbinnext;\n\nalways @(posedge rd_clk)\nbegin\nif (rst)\n begin\n wr_ptr <= #TCQ 'b0;\n end\nelse begin\n if (wr_en)\n wr_ptr <= #TCQ wr_ptr + 1'b1;\n end\nend\nassign buf_avail = (rd_capture_ptr + 5'd16) - wr_ptr;\nalways @ (posedge wr_clk )\nbegin\n if (rst)\n full <= #TCQ 1'b0;\n else if ((buf_avail == 0) || (buf_avail == 1 && wr_en))\n full <= #TCQ 1'b1;\n else\n full <= #TCQ 1'b0;\nend\n\nalways @ (posedge wr_clk )\nbegin\n if (rst)\n almost_full <= #TCQ 1'b0;\n else if ((buf_avail == FIFO_DEPTH - 2 ) || ((buf_avail == FIFO_DEPTH -3) && wr_en))\n almost_full <= #TCQ 1'b1;\n else\n almost_full <= #TCQ 1'b0;\nend\n\nendmodule"}
{"task_id": 705, "completion": "input  VPWR;\n    input  VGND;\n    output Y   ;\n    input  A   ;\n    input  B   ;\n    input  C   ;\n\n    wire   nor0_out_Y        ;\n    wire   u_vpwr_vgnd0_out_Y;\n\n    nor                          nor0         (nor0_out_Y        , C, A, B               );\n    sky130_fd_sc_hs__u_vpwr_vgnd u_vpwr_vgnd0 (u_vpwr_vgnd0_out_Y, nor0_out_Y, VPWR, VGND);\n    buf                          buf0         (Y                 , u_vpwr_vgnd0_out_Y    );\n\nendmodule"}
{"task_id": 710, "completion": "reg[8 - 1:0] lfsr_data;   assign data = lfsr_data ;   always @(posedge clk or negedge reset_n)   begin      if (!reset_n)      begin         lfsr_data <= seed[7:0] ;      end      else      begin         if (!enable)         begin            lfsr_data <= seed[7:0];         end         else         begin            if (load)            begin               lfsr_data <= ldata ;            end            else            begin               if (!pause)               begin                  lfsr_data[0] <= lfsr_data[7] ;                  lfsr_data[1] <= lfsr_data[0] ;                  lfsr_data[2] <= lfsr_data[1] ^ lfsr_data[7] ;                  lfsr_data[3] <= lfsr_data[2] ^ lfsr_data[7] ;                  lfsr_data[4] <= lfsr_data[3] ^ lfsr_data[7] ;                  lfsr_data[5] <= lfsr_data[4] ;                  lfsr_data[6] <= lfsr_data[5] ;                  lfsr_data[7] <= lfsr_data[6] ;               end            end         end      end   endendmodule"}
{"task_id": 655, "completion": "localparam UP = 2'b00;\n    localparam DOWN = 2'b01;\n    localparam LEFT = 2'b10;\n    localparam RIGHT = 2'b11;\n    localparam NONE = 2'b00;\n    localparam HEAD = 2'b01;\n    localparam BODY = 2'b10;\n    localparam WALL = 2'b11;\n    localparam RESTART = 2'b00;\n    localparam PLAY = 2'b10;\n    reg[31:0]cnt;\n    reg[31:0] cnt_lv1 = 32'd12_500_000;\n    reg[31:0] cnt_lv2 = 32'd62_500_00;\n    wire[1:0]direct;\n    reg [1:0]direct_r;\n    assign direct = direct_r;\n    reg[1:0]direct_next;\n    reg change_to_left;\n    reg change_to_right;\n    reg change_to_up;\n    reg change_to_down;\n    reg [5:0]cube_x[15:0];\n    reg [5:0]cube_y[15:0];\n    reg [15:0]is_exist;\n    reg addcube_state;\n    assign head_x = cube_x[0];\n    assign head_y = cube_y[0];\n    always @(posedge clk or negedge rst) begin\n        if(!rst)\n            direct_r <= RIGHT;\n        else if(game_status == RESTART) \n            direct_r <= RIGHT;\n        else\n            direct_r <= direct_next;\n    end\n    always @(posedge clk or negedge rst) begin\n        if(!rst) begin\n            is_exist <= 16'd7;\n            cube_num <= 3;\n            addcube_state <= 0;\n        end  \n        else if (game_status == RESTART) begin\n            is_exist <= 16'd7;\n            cube_num <= 3;\n            addcube_state <= 0;\n        end\n        else begin\n            case(addcube_state)\n                0:begin\n                    if(add_cube) begin\n                        cube_num <= cube_num + 1;\n                        is_exist[cube_num] <= 1;\n                        addcube_state <= 1;\n                    end\n                end\n                1:begin\n                    if(!add_cube)\n                        addcube_state <= 0;\n                end\n            endcase\n        end\n    end\n    reg[3:0]lox;\n    reg[3:0]loy;\n    always @(x_pos or y_pos ) begin\n        if(x_pos >= 0 && x_pos < 640 && y_pos >= 0 && y_pos < 480) begin\n            if(x_pos[9:4] == 0 | y_pos[9:4] == 0 | x_pos[9:4] == 39 | y_pos[9:4] == 29)\n                snake = WALL;\n            else if(x_pos[9:4] == cube_x[0] && y_pos[9:4] == cube_y[0] && is_exist[0] == 1) \n                snake = (die_flash == 1) ? HEAD : NONE;\n            else if\n                ((x_pos[9:4] == cube_x[1] && y_pos[9:4] == cube_y[1] && is_exist[1] == 1)|\n                 (x_pos[9:4] == cube_x[2] && y_pos[9:4] == cube_y[2] && is_exist[2] == 1)|\n                 (x_pos[9:4] == cube_x[3] && y_pos[9:4] == cube_y[3] && is_exist[3] == 1)|\n                 (x_pos[9:4] == cube_x[4] && y_pos[9:4] == cube_y[4] && is_exist[4] == 1)|\n                 (x_pos[9:4] == cube_x[5] && y_pos[9:4] == cube_y[5] && is_exist[5] == 1)|\n                 (x_pos[9:4] == cube_x[6] && y_pos[9:4] == cube_y[6] && is_exist[6] == 1)|\n                 (x_pos[9:4] == cube_x[7] && y_pos[9:4] == cube_y[7] && is_exist[7] == 1)|\n                 (x_pos[9:4] == cube_x[8] && y_pos[9:4] == cube_y[8] && is_exist[8] == 1)|\n                 (x_pos[9:4] == cube_x[9] && y_pos[9:4] == cube_y[9] && is_exist[9] == 1)|\n                 (x_pos[9:4] == cube_x[10] && y_pos[9:4] == cube_y[10] && is_exist[10] == 1)|\n                 (x_pos[9:4] == cube_x[11] && y_pos[9:4] == cube_y[11] && is_exist[11] == 1)|\n                 (x_pos[9:4] == cube_x[12] && y_pos[9:4] == cube_y[12] && is_exist[12] == 1)|\n                 (x_pos[9:4] == cube_x[13] && y_pos[9:4] == cube_y[13] && is_exist[13] == 1)|\n                 (x_pos[9:4] == cube_x[14] && y_pos[9:4] == cube_y[14] && is_exist[14] == 1)|\n                 (x_pos[9:4] == cube_x[15] && y_pos[9:4] == cube_y[15] && is_exist[15] == 1))\n                snake = (die_flash == 1) ? BODY : NONE;\n            else snake = NONE;\n        end\n    end\nendmodule"}
{"task_id": 712, "completion": "wire or0_out          ;\n    wire or1_out          ;\n    wire nand0_out_Y      ;\n    wire pwrgood_pp0_out_Y;\n\n    or                                 or0         (or0_out          , B2, B1                 );\n    or                                 or1         (or1_out          , A2, A1                 );\n    nand                               nand0       (nand0_out_Y      , or1_out, or0_out, C1   );\n    sky130_fd_sc_hd__udp_pwrgood_pp$PG pwrgood_pp0 (pwrgood_pp0_out_Y, nand0_out_Y, VPWR, VGND);\n    buf                                buf0        (Y                , pwrgood_pp0_out_Y      );\n\nendmodule"}
{"task_id": 156, "completion": "assign result = (n == m);\nendmodule"}
{"task_id": 683, "completion": "wire xnor0_out_Y      ;\n    wire pwrgood_pp0_out_Y;\n\n    xnor                               xnor0       (xnor0_out_Y      , A, B                   );\n    sky130_fd_sc_ms__udp_pwrgood_pp$PG pwrgood_pp0 (pwrgood_pp0_out_Y, xnor0_out_Y, VPWR, VGND);\n    buf                                buf0        (Y                , pwrgood_pp0_out_Y      );\n\nendmodule"}
{"task_id": 720, "completion": "// Voltage supply signals\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\nendmodule"}
{"task_id": 257, "completion": "localparam [1:0]\n    STATE_IDLE = 2'd0,\n    STATE_PAYLOAD = 2'd1;\n\nreg [1:0] state_reg = STATE_IDLE, state_next;\n\nreg reset_crc;\nreg update_crc;\nreg shift_in;\nreg shift_reset;\n\nreg [7:0] s_axis_tdata_d0 = 8'd0;\nreg [7:0] s_axis_tdata_d1 = 8'd0;\nreg [7:0] s_axis_tdata_d2 = 8'd0;\nreg [7:0] s_axis_tdata_d3 = 8'd0;\n\nreg s_axis_tvalid_d0 = 1'b0;\nreg s_axis_tvalid_d1 = 1'b0;\nreg s_axis_tvalid_d2 = 1'b0;\nreg s_axis_tvalid_d3 = 1'b0;\n\nreg busy_reg = 1'b0;\nreg error_bad_fcs_reg = 1'b0, error_bad_fcs_next;\n\nreg s_axis_tready_reg = 1'b0, s_axis_tready_next;\n\nreg [31:0] crc_state = 32'hFFFFFFFF;\nwire [31:0] crc_next;\n\nreg [7:0] m_axis_tdata_int;\nreg       m_axis_tvalid_int;\nreg       m_axis_tready_int_reg = 1'b0;\nreg       m_axis_tlast_int;\nreg       m_axis_tuser_int;\nwire      m_axis_tready_int_early;\n\nassign s_axis_tready = s_axis_tready_reg;\n\nassign busy = busy_reg;\nassign error_bad_fcs = error_bad_fcs_reg;\n\nlfsr #(\n    .LFSR_WIDTH(32),\n    .LFSR_POLY(32'h4c11db7),\n    .LFSR_CONFIG(\"GALOIS\"),\n    .LFSR_FEED_FORWARD(0),\n    .REVERSE(1),\n    .DATA_WIDTH(8),\n    .STYLE(\"AUTO\")\n)\neth_crc_8 (\n    .data_in(s_axis_tdata_d3),\n    .state_in(crc_state),\n    .data_out(),\n    .state_out(crc_next)\n);\n\nalways @* begin\n    state_next = STATE_IDLE;\n\n    reset_crc = 1'b0;\n    update_crc = 1'b0;\n    shift_in = 1'b0;\n    shift_reset = 1'b0;\n\n    s_axis_tready_next = 1'b0;\n\n    m_axis_tdata_int = 8'd0;\n    m_axis_tvalid_int = 1'b0;\n    m_axis_tlast_int = 1'b0;\n    m_axis_tuser_int = 1'b0;\n\n    error_bad_fcs_next = 1'b0;\n\n    case (state_reg)\n        STATE_IDLE: begin\n            s_axis_tready_next = m_axis_tready_int_early;\n            reset_crc = 1'b1;\n\n            m_axis_tdata_int = s_axis_tdata_d3;\n            m_axis_tvalid_int = s_axis_tvalid_d3 && s_axis_tvalid;\n            m_axis_tlast_int = 1'b0;\n            m_axis_tuser_int = 1'b0;\n\n            if (s_axis_tready && s_axis_tvalid) begin\n                shift_in = 1'b1;\n\n                if (s_axis_tvalid_d3) begin\n                    reset_crc = 1'b0;\n                    update_crc = 1'b1;\n                    if (s_axis_tlast) begin\n                        shift_reset = 1'b1;\n                        reset_crc = 1'b1;\n                        m_axis_tlast_int = 1'b1;\n                        m_axis_tuser_int = s_axis_tuser;\n                        if ({s_axis_tdata, s_axis_tdata_d0, s_axis_tdata_d1, s_axis_tdata_d2} != ~crc_next) begin\n                            m_axis_tuser_int = 1'b1;\n                            error_bad_fcs_next = 1'b1;\n                        end\n                        s_axis_tready_next = m_axis_tready_int_early;\n                        state_next = STATE_IDLE;\n                    end else begin\n                        state_next = STATE_PAYLOAD;\n                    end\n                end else begin\n                    state_next = STATE_IDLE;\n                end\n            end else begin\n                state_next = STATE_IDLE;\n            end\n        end\n        STATE_PAYLOAD: begin\n            s_axis_tready_next = m_axis_tready_int_early;\n\n            m_axis_tdata_int = s_axis_tdata_d3;\n            m_axis_tvalid_int = s_axis_tvalid_d3 && s_axis_tvalid;\n            m_axis_tlast_int = 1'b0;\n            m_axis_tuser_int = 1'b0;\n\n            if (s_axis_tready && s_axis_tvalid) begin\n                shift_in = 1'b1;\n                update_crc = 1'b1;\n                if (s_axis_tlast) begin\n                    shift_reset = 1'b1;\n                    reset_crc = 1'b1;\n                    m_axis_tlast_int = 1'b1;\n                    m_axis_tuser_int = s_axis_tuser;\n                    if ({s_axis_tdata, s_axis_tdata_d0, s_axis_tdata_d1, s_axis_tdata_d2} != ~crc_next) begin\n                        m_axis_tuser_int = 1'b1;\n                        error_bad_fcs_next = 1'b1;\n                    end\n                    s_axis_tready_next = m_axis_tready_int_early;\n                    state_next = STATE_IDLE;\n                end else begin\n                    state_next = STATE_PAYLOAD;\n                end\n            end else begin\n                state_next = STATE_PAYLOAD;\n            end\n        end\n    endcase\nend\n\nalways @(posedge clk) begin\n    if (rst) begin\n        state_reg <= STATE_IDLE;\n\n        s_axis_tready_reg <= 1'b0;\n\n        busy_reg <= 1'b0;\n        error_bad_fcs_reg <= 1'b0;\n\n        s_axis_tvalid_d0 <= 1'b0;\n        s_axis_tvalid_d1 <= 1'b0;\n        s_axis_tvalid_d2 <= 1'b0;\n        s_axis_tvalid_d3 <= 1'b0;\n\n        crc_state <= 32'hFFFFFFFF;\n    end else begin\n        state_reg <= state_next;\n\n        s_axis_tready_reg <= s_axis_tready_next;\n\n        busy_reg <= state_next != STATE_IDLE;\n        error_bad_fcs_reg <= error_bad_fcs_next;\n\n        if (reset_crc) begin\n            crc_state <= 32'hFFFFFFFF;\n        end else if (update_crc) begin\n            crc_state <= crc_next;\n        end\n\n        if (shift_reset) begin\n            s_axis_tvalid_d0 <= 1'b0;\n            s_axis_tvalid_d1 <= 1'b0;\n            s_axis_tvalid_d2 <= 1'b0;\n            s_axis_tvalid_d3 <= 1'b0;\n        end else if (shift_in) begin\n            s_axis_tvalid_d0 <= s_axis_tvalid;\n            s_axis_tvalid_d1 <= s_axis_tvalid_d0;\n            s_axis_tvalid_d2 <= s_axis_tvalid_d1;\n            s_axis_tvalid_d3 <= s_axis_tvalid_d2;\n        end\n    end\n\n    if (shift_in) begin\n        s_axis_tdata_d0 <= s_axis_tdata;\n        s_axis_tdata_d1 <= s_axis_tdata_d0;\n        s_axis_tdata_d2 <= s_axis_tdata_d1;\n        s_axis_tdata_d3 <= s_axis_tdata_d2;\n    end\nend\n\nreg [7:0] m_axis_tdata_reg = 8'd0;\nreg       m_axis_tvalid_reg = 1'b0, m_axis_tvalid_next;\nreg       m_axis_tlast_reg = 1'b0;\nreg       m_axis_tuser_reg = 1'b0;\n\nreg [7:0] temp_m_axis_tdata_reg = 8'd0;\nreg       temp_m_axis_tvalid_reg = 1'b0, temp_m_axis_tvalid_next;\nreg       temp_m_axis_tlast_reg = 1'b0;\nreg       temp_m_axis_tuser_reg = 1'b0;\n\nreg store_axis_int_to_output;\nreg store_axis_int_to_temp;\nreg store_axis_temp_to_output;\n\nassign m_axis_tdata = m_axis_tdata_reg;\nassign m_axis_tvalid = m_axis_tvalid_reg;\nassign m_axis_tlast = m_axis_tlast_reg;\nassign m_axis_tuser = m_axis_tuser_reg;\n\nassign m_axis_tready_int_early = m_axis_tready || (!temp_m_axis_tvalid_reg && (!m_axis_tvalid_reg || !m_axis_tvalid_int));\n\nalways @* begin\n    m_axis_tvalid_next = m_axis_tvalid_reg;\n    temp_m_axis_tvalid_next = temp_m_axis_tvalid_reg;\n\n    store_axis_int_to_output = 1'b0;\n    store_axis_int_to_temp = 1'b0;\n    store_axis_temp_to_output = 1'b0;\n    \n    if (m_axis_tready_int_reg) begin\n        if (m_axis_tready || !m_axis_tvalid_reg) begin\n            m_axis_tvalid_next = m_axis_tvalid_int;\n            store_axis_int_to_output = 1'b1;\n        end else begin\n            temp_m_axis_tvalid_next = m_axis_tvalid_int;\n            store_axis_int_to_temp = 1'b1;\n        end\n    end else if (m_axis_tready) begin\n        m_axis_tvalid_next = temp_m_axis_tvalid_reg;\n        temp_m_axis_tvalid_next = 1'b0;\n        store_axis_temp_to_output = 1'b1;\n    end\nend\n\nalways @(posedge clk) begin\n    if (rst) begin\n        m_axis_tvalid_reg <= 1'b0;\n        m_axis_tready_int_reg <= 1'b0;\n        temp_m_axis_tvalid_reg <= 1'b0;\n    end else begin\n        m_axis_tvalid_reg <= m_axis_tvalid_next;\n        m_axis_tready_int_reg <= m_axis_tready_int_early;\n        temp_m_axis_tvalid_reg <= temp_m_axis_tvalid_next;\n    end\n\n    if (store_axis_int_to_output) begin\n        m_axis_tdata_reg <= m_axis_tdata_int;\n        m_axis_tlast_reg <= m_axis_tlast_int;\n        m_axis_tuser_reg <= m_axis_tuser_int;\n    end else if (store_axis_temp_to_output) begin\n        m_axis_tdata_reg <= temp_m_axis_tdata_reg;\n        m_axis_tlast_reg <= temp_m_axis_tlast_reg;\n        m_axis_tuser_reg <= temp_m_axis_tuser_reg;\n    end\n\n    if (store_axis_int_to_temp) begin\n        temp_m_axis_tdata_reg <= m_axis_tdata_int;\n        temp_m_axis_tlast_reg <= m_axis_tlast_int;\n        temp_m_axis_tuser_reg <= m_axis_tuser_int;\n    end\nend\n\nendmodule"}
{"task_id": 684, "completion": "// \u53cd\u76f8\u5668\u5b9e\u73b0\n    assign Y = ~A;\nendmodule"}
{"task_id": 729, "completion": "wire                  aclk;\n    wire                  aclken;\n    wire                  a_tvalid;\n    wire [63:0]           a_tdata;\n    wire                  b_tvalid;\n    wire [63:0]           b_tdata;\n    wire                  r_tvalid;\n    wire [63:0]           r_tdata;\n    reg  [din0_WIDTH-1:0] din0_buf1;\n    reg  [din1_WIDTH-1:0] din1_buf1;\n\n    ANN_ap_ddiv_29_no_dsp_64 ANN_ap_ddiv_29_no_dsp_64_u (\n        .aclk                 ( aclk ),\n        .aclken               ( aclken ),\n        .s_axis_a_tvalid      ( a_tvalid ),\n        .s_axis_a_tdata       ( a_tdata ),\n        .s_axis_b_tvalid      ( b_tvalid ),\n        .s_axis_b_tdata       ( b_tdata ),\n        .m_axis_result_tvalid ( r_tvalid ),\n        .m_axis_result_tdata  ( r_tdata )\n    );\n\n    assign aclk     = clk;\n    assign aclken   = ce;\n    assign a_tvalid = 1'b1;\n    assign a_tdata  = din0_buf1==='bx ? 'b0 : din0_buf1;\n    assign b_tvalid = 1'b1;\n    assign b_tdata  = din1_buf1==='bx ? 'b0 : din1_buf1;\n    assign dout     = r_tdata;\n\n    always @(posedge clk) begin\n        if (ce) begin\n            din0_buf1 <= din0;\n            din1_buf1 <= din1;\n        end\n    end\nendmodule"}
{"task_id": 150, "completion": "parameter IDLE = 4'h0;parameter PIO_WAIT_FOR_DATA = 4'h1;parameter PIO_WRITE_DATA = 4'h2;parameter WAIT_FOR_DMA_ACT = 4'h1;parameter WAIT_FOR_WRITE_DATA = 4'h2;parameter SEND_DATA = 4'h3;reg [3:0] cntrl_state;reg srst;reg [7:0] status;wire idle;reg cntrl_send_data_stb;reg send_command_stb;wire dev_busy;wire dev_data_req;reg [3:0] write_state;reg dma_send_data_stb;reg dma_act_detected_en;reg enable_tl_data_ready;wire [1:0] if_write_ready;wire [1:0] if_write_activate;wire [23:0] if_write_size;wire if_write_strobe;wire [31:0] if_write_data;wire if_read_strobe;wire if_read_ready;wire if_read_activate;wire [23:0] if_read_size;wire [31:0] if_read_data;wire if_reset;wire [31:0] of_write_data;wire [1:0] of_write_ready;wire [1:0] of_write_activate;wire [23:0] of_read_size;wire of_write_strobe;wire out_fifo_starved;wire of_read_ready;wire [31:0] of_read_data;wire of_read_activate;wire [23:0] of_write_size;wire of_read_strobe;wire of_reset;ppfifo # (.DATA_WIDTH (`DATA_SIZE), .ADDRESS_WIDTH (`FIFO_ADDRESS_WIDTH)) fifo_in (.reset (if_reset), .write_clock (data_in_clk), .write_data (if_write_data), .write_ready (if_write_ready), .write_activate (if_write_activate), .write_fifo_size (if_write_size), .write_strobe (if_write_strobe), .starved (user_din_empty), .read_clock (clk), .read_strobe (if_read_strobe), .read_ready (if_read_ready), .read_activate (if_read_activate), .read_count (if_read_size), .read_data (if_read_data), .inactive ( ));ppfifo # (.DATA_WIDTH (`DATA_SIZE), .ADDRESS_WIDTH (`FIFO_ADDRESS_WIDTH)) fifo_out (.reset (of_reset), .write_clock (clk), .write_data (of_write_data), .write_ready (of_write_ready), .write_activate (of_write_activate), .write_fifo_size (of_write_size), .write_strobe (of_write_strobe), .starved ( ), .read_clock (data_out_clk), .read_strobe (of_read_strobe), .read_ready (of_read_ready), .read_activate (of_read_activate), .read_count (of_read_size), .read_data (of_read_data), .inactive ( ));assign t_if_ready = if_read_ready && enable_tl_data_ready;assign t_if_size = if_read_size;assign t_if_data = if_read_data;assign if_read_activate = t_if_activate;assign if_read_strobe = t_if_strobe;assign t_of_ready = of_write_ready;assign t_of_size = 24'h00800;assign of_write_data = t_of_data;assign of_write_activate = t_of_activate;assign of_write_strobe = t_of_strobe;assign of_reset = (rst && data_out_clk_valid);assign if_reset = (rst && data_in_clk_valid);assign if_write_data = user_din;assign if_write_strobe = user_din_stb;assign user_din_ready = if_write_ready;assign if_write_activate = user_din_activate;assign user_din_size = if_write_size;assign user_dout = of_read_data;assign user_dout_ready = of_read_ready;assign of_read_activate = user_dout_activate;assign user_dout_size = of_read_size;assign user_dout_strobe = user_dout_stb;assign d2h_status_bsy = d2h_status[7];assign d2h_status_drdy = d2h_status[6];assign d2h_status_dwf = d2h_status[5];assign d2h_status_dsc = d2h_status[4];assign d2h_status_drq = d2h_status[3];assign d2h_status_corr = d2h_status[2];assign d2h_status_idx = d2h_status[1];assign d2h_status_err = d2h_status[0];assign d2h_error_bbk = d2h_error[7];assign d2h_error_unc = d2h_error[6];assign d2h_error_mc = d2h_error[5];assign d2h_error_idnf = d2h_error[4];assign d2h_error_mcr = d2h_error[3];assign d2h_error_abrt = d2h_error[2];assign d2h_error_tk0nf = d2h_error[1];assign d2h_error_amnf = d2h_error[0];assign t_send_command_stb = execute_command_stb;assign t_send_data_stb = dma_send_data_stb || cntrl_send_data_stb;assign idle = (cntrl_state == IDLE) && (write_state == IDLE) && transport_layer_ready;assign command_layer_ready = idle;assign h2d_command = hard_drive_command;assign h2d_sector_count = sector_count;assign h2d_lba = sector_address;assign h2d_control = {5'h00, srst, 2'b00};assign h2d_port_mult = 4'h0;assign h2d_device = `D2H_REG_DEVICE;assign dev_busy = status[`STATUS_BUSY_BIT];assign dev_data_req = status[`STATUS_DRQ_BIT];assign hard_drive_error = status[`STATUS_ERR_BIT];assign cl_c_state = cntrl_state;assign cl_w_state = write_state;always @ (posedge clk) begin if (rst || (!linkup)) begin cntrl_state <= IDLE; h2d_features <= `D2H_REG_FEATURES; srst <= 0; t_send_control_stb <= 0; cntrl_send_data_stb <= 0; pio_data_ready <= 0; status <= 0; sata_busy <= 0; sync_escape <= 0; end else begin t_send_control_stb <= 0; cntrl_send_data_stb <= 0; pio_data_ready <= 0; if (t_d2h_reg_stb) begin sata_busy <= 0; h2d_features <= `D2H_REG_FEATURES; end if (execute_command_stb) begin h2d_features <= user_features; sata_busy <= 1; end case (cntrl_state) IDLE: begin if (command_layer_reset && !srst) begin srst <= 1; t_send_control_stb <= 1; end if (idle) begin if (!command_layer_reset && srst) begin srst <= 0; t_send_control_stb <= 1; end end if(t_pio_setup_stb) begin if (t_pio_direction) begin cntrl_state <= PIO_WAIT_FOR_DATA; end else begin cntrl_state <= PIO_WRITE_DATA; end end if (t_set_device_bits_stb) begin status <= d2h_status; end if (t_d2h_reg_stb) begin status <= d2h_status; end end PIO_WAIT_FOR_DATA: begin if (t_d2h_data_stb) begin pio_data_ready <= 1; cntrl_state <= IDLE; status <= t_pio_e_status; end end PIO_WRITE_DATA: begin if (if_read_activate) begin cntrl_send_data_stb <= 0; cntrl_state <= IDLE; status <= t_pio_e_status; end end default: begin cntrl_state <= IDLE; end endcase if (send_sync_escape) begin cntrl_state <= IDLE; sync_escape <= 1; sata_busy <= 0; end end end end //Write State Machine always @ (posedge clk) begin if (rst || !linkup) begin write_state <= IDLE; dma_send_data_stb <= 0; enable_tl_data_ready <= 0; dma_act_detected_en <= 0; end else begin dma_send_data_stb <= 0; if (t_dma_activate_stb) begin dma_act_detected_en <= 1; end case (write_state) IDLE: begin enable_tl_data_ready <= 0; if (idle) begin if (dma_act_detected_en) begin write_state <= WAIT_FOR_DMA_ACT; end end end WAIT_FOR_DMA_ACT: begin if (dma_act_detected_en) begin dma_act_detected_en <= 0; enable_tl_data_ready <= 1; write_state <= WAIT_FOR_WRITE_DATA; end end WAIT_FOR_WRITE_DATA: begin if (if_read_activate) begin enable_tl_data_ready <= 0; write_state <= SEND_DATA; end end SEND_DATA: begin if (transport_layer_ready) begin dma_send_data_stb <= 1; dma_act_detected_en <= 0; write_state <= IDLE; end end default: begin write_state <= IDLE; end endcase if (command_layer_reset) begin write_state <= IDLE; end if (t_d2h_reg_stb) begin write_state <= IDLE; end if (send_sync_escape) begin write_state <= IDLE; end end end endmodule"}
{"task_id": 653, "completion": "output           almost_empty;\n  output           almost_full;\n  output           empty;\n  output           full;\n  output  [ 42: 0] rd_data;\n  input            clk;\n  input            rd;\n  input            reset_n;\n  input            wr;\n  input   [ 42: 0] wr_data;\n  wire             almost_empty;\n  wire             almost_full;\n  wire             empty;\n  reg     [  1: 0] entries;\n  reg     [ 42: 0] entry_0;\n  reg     [ 42: 0] entry_1;\n  wire             full;\n  reg              rd_address;\n  reg     [ 42: 0] rd_data;\n  wire    [  1: 0] rdwr;\n  reg              wr_address;\n  assign rdwr = {rd, wr};\n  assign full = entries == 2;\n  assign almost_full = entries >= 1;\n  assign empty = entries == 0;\n  assign almost_empty = entries <= 1;\n  always @(entry_0 or entry_1 or rd_address)\n    begin\n      case (rd_address) // synthesis parallel_case full_case\n          1'd0: begin\n              rd_data = entry_0;\n          end // 1'd0 \n          1'd1: begin\n              rd_data = entry_1;\n          end // 1'd1 \n          default: begin\n          end // default\n      endcase // rd_address\n    end\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n        begin\n          wr_address <= 0;\n          rd_address <= 0;\n          entries <= 0;\n        end\n      else \n        case (rdwr) // synthesis parallel_case full_case\n            2'd1: begin\n                // Write data\n                if (!full)\n                  begin\n                    entries <= entries + 1;\n                    wr_address <= (wr_address == 1) ? 0 : (wr_address + 1);\n                  end\n            end // 2'd1 \n            2'd2: begin\n                // Read data\n                if (!empty)\n                  begin\n                    entries <= entries - 1;\n                    rd_address <= (rd_address == 1) ? 0 : (rd_address + 1);\n                  end\n            end // 2'd2 \n            2'd3: begin\n                wr_address <= (wr_address == 1) ? 0 : (wr_address + 1);\n                rd_address <= (rd_address == 1) ? 0 : (rd_address + 1);\n            end // 2'd3 \n            default: begin\n            end // default\n        endcase // rdwr\n    end\n  always @(posedge clk)\n    begin\n      //Write data\n      if (wr & !full)\n          case (wr_address) // synthesis parallel_case full_case\n              1'd0: begin\n                  entry_0 <= wr_data;\n              end // 1'd0 \n              1'd1: begin\n                  entry_1 <= wr_data;\n              end // 1'd1 \n              default: begin\n              end // default\n          endcase // wr_address\n    end\nendmodule"}
{"task_id": 732, "completion": "supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\nendmodule"}
{"task_id": 721, "completion": "reg [3:0] multiplexState = 4'b0111;    assign anodes = multiplexState;    wire [3:0] display[0:3];    assign display[3] = data[15:12];    assign display[2] = data[11:8];    assign display[1] = data[7:4];    assign display[0] = data[3:0];    reg [1:0] counter = 0;    reg [CLK_BITS-1:0] clockDivisor = 0;    always @(posedge clk)    begin        if(clockDivisor >= CLOCK_DIVISOR)        begin            counter = counter + 1;            clockDivisor = 0;        end        else            clockDivisor = clockDivisor + 1;        case(counter)            0: multiplexState <= 'b1110;            1: multiplexState <= 'b1101;            2: multiplexState <= 'b1011;            3: multiplexState <= 'b0111;        endcase        case(display[counter])            0: segments <= ~'b0111111;            1: segments <= ~'b0000110;            2: segments <= ~'b1011011;            3: segments <= ~'b1001111;            4: segments <= ~'b1100110;            5: segments <= ~'b1101101;            6: segments <= ~'b1111101;            7: segments <= ~'b0000111;            8: segments <= ~'b1111111;            9: segments <= ~'b1101111;            10: segments <= ~'b1110111;            11: segments <= ~'b1111100;            12: segments <= ~'b0111001;            13: segments <= ~'b1011110;            14: segments <= ~'b1111001;            15: segments <= ~'b1110001;        endcase    endendmodule"}
{"task_id": 606, "completion": "wire [11:0] NLW_U0_dpo_UNCONNECTED;\n    wire [11:0] NLW_U0_qdpo_UNCONNECTED;\n    wire [11:0] NLW_U0_qspo_UNCONNECTED;\n\n    MemScore_dist_mem_gen_v8_0__parameterized0 U0\n       (.a(a),\n        .clk(clk),\n        .d({1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0}),\n        .dpo(NLW_U0_dpo_UNCONNECTED[11:0]),\n        .dpra({1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0}),\n        .i_ce(1'b1),\n        .qdpo(NLW_U0_qdpo_UNCONNECTED[11:0]),\n        .qdpo_ce(1'b1),\n        .qdpo_clk(1'b0),\n        .qdpo_rst(1'b0),\n        .qdpo_srst(1'b0),\n        .qspo(NLW_U0_qspo_UNCONNECTED[11:0]),\n        .qspo_ce(1'b1),\n        .qspo_rst(1'b0),\n        .qspo_srst(1'b0),\n        .spo(spo),\n        .we(1'b0));\nendmodule"}
{"task_id": 696, "completion": "wire and0_out_X;\n\n    and and0 (and0_out_X, A, SLEEP_B);\n    sky130_fd_sc_lp__udp_pwrgood_pp$PG pwrgood_pp0 (X, and0_out_X, VPWR, VGND);\n\nendmodule"}
{"task_id": 43, "completion": "DCM_ADV #(\n    .CLKDV_DIVIDE(2.0),\n    .CLKFX_DIVIDE(4),\n    .CLKFX_MULTIPLY(2),\n    .CLKIN_DIVIDE_BY_2(\"FALSE\"),\n    .CLKIN_PERIOD(16.0),\n    .CLKOUT_PHASE_SHIFT(\"FIXED\"),\n    .CLK_FEEDBACK(\"1X\"),\n    .DCM_PERFORMANCE_MODE(\"MAX_SPEED\"),\n    .DESKEW_ADJUST(\"SYSTEM_SYNCHRONOUS\"),\n    .DFS_FREQUENCY_MODE(\"LOW\"),\n    .DLL_FREQUENCY_MODE(\"LOW\"),\n    .DUTY_CYCLE_CORRECTION(\"TRUE\"),\n    .FACTORY_JF(16'hf0f0),\n    .PHASE_SHIFT(-32),\n    .SIM_DEVICE(\"VIRTEX5\"),\n    .STARTUP_WAIT(\"FALSE\")\n  ) DCM_ADV_inst (\n    .CLK0(dcm_out),\n    .LOCKED(dcmLocked),\n    .CLKFB(outClk),\n    .CLKIN(ddrClk),\n    .RST(!dcmResetN)\n  );\n  BUFG bufg_i_ddrClk(.O(outClk),.I(dcm_out));\n  BUFG bufg_i_sdrClk(.O(sdrClk),.I(dcm_div));\n  wire rstSerdes;\n  FDRSE#(.INIT(1'b0)) FRDSE_inst (.Q(rstSerdes), .C(sdrClk), .CE(1'b1), .D(!dcmLocked), .R(1'b0), .S(1'b0));\n  wire da[nbo-1:0], db[nbo-1:0], dc[nbo-1:0], dd[nbo-1:0]; \n  genvar i; generate\n  for (i=0;i<nbo;i=i+1) begin : DDR_g\n    OSERDES #(\n      .DATA_RATE_OQ(\"DDR\"),\n      .DATA_RATE_TQ(\"DDR\"),\n      .DATA_WIDTH(4),\n      .INIT_OQ(1'b0),\n      .INIT_TQ(1'b0),\n      .SERDES_MODE(\"MASTER\"),\n      .SRVAL_OQ(1'b0),\n      .SRVAL_TQ(1'b0),\n      .TRISTATE_WIDTH(4)\n    ) OSERDES_inst_a (\n      .OQ(da[i]),\n      .CLK(outClk),\n      .CLKDIV(sdrClk),\n      .D1(sdrData0[i]),\n      .D2(sdrData4[i]),\n      .D3(sdrData8[i]),\n      .D4(sdrDataC[i]),\n      .SR(rstSerdes)\n    );\n    OBUFDS#(.IOSTANDARD(\"LVDS_25\")) obufds_i_a(.O(dap[i]),.OB(dan[i]),.I(da[i]));\n    OSERDES #(\n      .DATA_RATE_OQ(\"DDR\"),\n      .DATA_RATE_TQ(\"DDR\"),\n      .DATA_WIDTH(4),\n      .INIT_OQ(1'b0),\n      .INIT_TQ(1'b0),\n      .SERDES_MODE(\"MASTER\"),\n      .SRVAL_OQ(1'b0),\n      .SRVAL_TQ(1'b0),\n      .TRISTATE_WIDTH(4)\n    ) OSERDES_inst_b (\n      .OQ(db[i]),\n      .CLK(outClk),\n      .CLKDIV(sdrClk),\n      .D1(sdrData1[i]),\n      .D2(sdrData5[i]),\n      .D3(sdrData9[i]),\n      .D4(sdrDataD[i]),\n      .SR(rstSerdes)\n    );\n    OBUFDS#(.IOSTANDARD(\"LVDS_25\")) obufds_i_b(.O(dbp[i]),.OB(dbn[i]),.I(db[i]));\n    OSERDES #(\n      .DATA_RATE_OQ(\"DDR\"),\n      .DATA_RATE_TQ(\"DDR\"),\n      .DATA_WIDTH(4),\n      .INIT_OQ(1'b0),\n      .INIT_TQ(1'b0),\n      .SERDES_MODE(\"MASTER\"),\n      .SRVAL_OQ(1'b0),\n      .SRVAL_TQ(1'b0),\n      .TRISTATE_WIDTH(4)\n    ) OSERDES_inst_c (\n      .OQ(dc[i]),\n      .CLK(outClk),\n      .CLKDIV(sdrClk),\n      .D1(sdrData2[i]),\n      .D2(sdrData6[i]),\n      .D3(sdrDataA[i]),\n      .D4(sdrDataE[i]),\n      .SR(rstSerdes)\n    );\n    OBUFDS#(.IOSTANDARD(\"LVDS_25\")) obufds_i_c(.O(dcp[i]),.OB(dcn[i]),.I(dc[i]));\n    OSERDES #(\n      .DATA_RATE_OQ(\"DDR\"),\n      .DATA_RATE_TQ(\"DDR\"),\n      .DATA_WIDTH(4),\n      .INIT_OQ(1'b0),\n      .INIT_TQ(1'b0),\n      .SERDES_MODE(\"MASTER\"),\n      .SRVAL_OQ(1'b0),\n      .SRVAL_TQ(1'b0),\n      .TRISTATE_WIDTH(4)\n    ) OSERDES_inst_d (\n      .OQ(dd[i]),\n      .CLK(outClk),\n      .CLKDIV(sdrClk),\n      .D1(sdrData3[i]),\n      .D2(sdrData7[i]),\n      .D3(sdrDataB[i]),\n      .D4(sdrDataF[i]),\n      .SR(rstSerdes)\n    );\n    OBUFDS#(.IOSTANDARD(\"LVDS_25\")) obufds_i_d(.O(ddp[i]),.OB(ddn[i]),.I(dd[i]));\n  end\n  endgenerate\nendmodule"}
{"task_id": 742, "completion": "always @(posedge CLK or posedge RESET) begin\n        if (RESET) begin\n            Q <= 1'b0;\n        end else begin\n            Q <= D;\n        end\n    end\nendmodule"}
{"task_id": 750, "completion": "wire bus20040728_oc;\n\nendmodule"}
{"task_id": 700, "completion": "parameter data_seg_begin = 32'h2000,\n              data_seg_size  = 32'h100000;\n    reg [31:0] dmem [0:(data_seg_size>>2)];\n\n    wire[31:0] read_data;\n    wire[31:0] wr_strb = {wr_strb_dmem_ram_i[3],wr_strb_dmem_ram_i[3],wr_strb_dmem_ram_i[3],wr_strb_dmem_ram_i[3],\n                          wr_strb_dmem_ram_i[3],wr_strb_dmem_ram_i[3],wr_strb_dmem_ram_i[3],wr_strb_dmem_ram_i[3],  \n                          wr_strb_dmem_ram_i[2],wr_strb_dmem_ram_i[2],wr_strb_dmem_ram_i[2],wr_strb_dmem_ram_i[2], \n                          wr_strb_dmem_ram_i[2],wr_strb_dmem_ram_i[2],wr_strb_dmem_ram_i[2],wr_strb_dmem_ram_i[2], \n                          wr_strb_dmem_ram_i[1],wr_strb_dmem_ram_i[1],wr_strb_dmem_ram_i[1],wr_strb_dmem_ram_i[1], \n                          wr_strb_dmem_ram_i[1],wr_strb_dmem_ram_i[1],wr_strb_dmem_ram_i[1],wr_strb_dmem_ram_i[1], \n                          wr_strb_dmem_ram_i[0],wr_strb_dmem_ram_i[0],wr_strb_dmem_ram_i[0],wr_strb_dmem_ram_i[0], \n                          wr_strb_dmem_ram_i[0],wr_strb_dmem_ram_i[0],wr_strb_dmem_ram_i[0],wr_strb_dmem_ram_i[0]}; \n\n    assign read_data_dmem_ram_o = read_data;\n\n    always @(posedge clk)\n    if (wr_en_dmem_ram_i)\n        dmem[((addr_dmem_ram_i - data_seg_begin)&(~32'h3))>>2] <= ((wr_data_dmem_ram_i & wr_strb) | (~wr_strb & read_data));\n\n    assign read_data = dmem[((addr_dmem_ram_i - data_seg_begin)&(~32'h3))>>2];\n\nendmodule"}
{"task_id": 200, "completion": "localparam SPEED_GRADE = \"C8\";localparam MEM_IF_DQS_WIDTH = 1;localparam MEM_IF_DWIDTH = 8;localparam MEM_IF_DM_WIDTH = 1;localparam MEM_IF_DQ_PER_DQS = 8;localparam DWIDTH_RATIO = 4;localparam CLOCK_INDEX_WIDTH = 3;localparam MEM_IF_CLK_PAIR_COUNT = 1;localparam MEM_IF_ADDR_WIDTH = 14;localparam MEM_IF_BANKADDR_WIDTH = 2;localparam MEM_IF_CS_WIDTH = 1;localparam RESYNCHRONISE_AVALON_DBG = 0;localparam DBG_A_WIDTH = 13;localparam DQS_PHASE_SETTING = 2;localparam SCAN_CLK_DIVIDE_BY = 2;localparam PLL_STEPS_PER_CYCLE = 80;localparam MEM_IF_CLK_PS = 8000;localparam DQS_DELAY_CTL_WIDTH = 6;localparam MEM_IF_MEMTYPE = \"DDR2\";localparam RANK_HAS_ADDR_SWAP = 0;localparam MEM_IF_MR_0 = 579;localparam MEM_IF_MR_1 = 1024;localparam MEM_IF_MR_2 = 0;localparam MEM_IF_MR_3 = 0;localparam MEM_IF_OCT_EN = 0;localparam IP_BUILDNUM = 0;localparam FAMILY = \"Cyclone IV E\";localparam FAMILYGROUP_ID = 2;localparam MEM_IF_ADDR_CMD_PHASE = 90;localparam CAPABILITIES = 2048;localparam WRITE_DESKEW_T10 = 0;localparam WRITE_DESKEW_HC_T10 = 0;localparam WRITE_DESKEW_T9NI = 0;localparam WRITE_DESKEW_HC_T9NI = 0;localparam WRITE_DESKEW_T9I = 0;localparam WRITE_DESKEW_HC_T9I = 0;localparam WRITE_DESKEW_RANGE = 0;localparam IOE_PHASES_PER_TCK = 12;localparam ADV_LAT_WIDTH = 5;localparam RDP_ADDR_WIDTH = 4;localparam IOE_DELAYS_PER_PHS = 5;localparam SINGLE_DQS_DELAY_CONTROL_CODE = 0;localparam PRESET_RLAT = 0;localparam FORCE_HC = 0;localparam MEM_IF_DQS_CAPTURE_EN = 0;localparam REDUCE_SIM_TIME = 0;localparam TINIT_TCK = 12500;localparam TINIT_RST = 0;localparam GENERATE_ADDITIONAL_DBG_RTL = 0;localparam MEM_IF_CS_PER_RANK = 1;localparam MEM_IF_RANKS_PER_SLOT = 1;localparam CHIP_OR_DIMM = \"Discrete Device\";localparam RDIMM_CONFIG_BITS = \"0000000000000000000000000000000000000000000000000000000000000000\";localparam OCT_LAT_WIDTH = ADV_LAT_WIDTH;localparam GENERATE_TRACKING_PHASE_STORE = 0;localparam MEM_IF_NUM_RANKS = MEM_IF_CS_WIDTH/MEM_IF_CS_PER_RANK;input wire phy_clk_1x;input wire reset_phy_clk_1x_n;output wire ctl_cal_success;output wire ctl_cal_fail;output wire ctl_cal_warning;input wire ctl_cal_req;input wire [MEM_IF_NUM_RANKS - 1 : 0] int_RANK_HAS_ADDR_SWAP;input wire [MEM_IF_NUM_RANKS * MEM_IF_DQS_WIDTH - 1 : 0] ctl_cal_byte_lane_sel_n;output wire seq_pll_inc_dec_n;output wire seq_pll_start_reconfig;output wire [CLOCK_INDEX_WIDTH - 1 : 0] seq_pll_select;input wire phs_shft_busy;input wire [CLOCK_INDEX_WIDTH - 1 : 0] pll_resync_clk_index;input wire [CLOCK_INDEX_WIDTH - 1 : 0] pll_measure_clk_index;output [MEM_IF_DQS_WIDTH - 1 : 0] sc_clk_dp;output wire [MEM_IF_DQS_WIDTH - 1 : 0] scan_enable_dqs_config;output wire [MEM_IF_DQS_WIDTH - 1 : 0] scan_update;output wire [MEM_IF_DQS_WIDTH - 1 : 0] scan_din;output wire [MEM_IF_CLK_PAIR_COUNT - 1 : 0] scan_enable_ck;output wire [MEM_IF_DQS_WIDTH - 1 : 0] scan_enable_dqs;output wire [MEM_IF_DQS_WIDTH - 1 : 0] scan_enable_dqsn;output wire [MEM_IF_DWIDTH - 1 : 0] scan_enable_dq;output wire [MEM_IF_DM_WIDTH - 1 : 0] scan_enable_dm;input wire hr_rsc_clk;output wire [(DWIDTH_RATIO/2) * MEM_IF_ADDR_WIDTH - 1 : 0] seq_ac_addr;output wire [(DWIDTH_RATIO/2) * MEM_IF_BANKADDR_WIDTH - 1 : 0] seq_ac_ba;output wire [(DWIDTH_RATIO/2) - 1 : 0] seq_ac_cas_n;output wire [(DWIDTH_RATIO/2) - 1 : 0] seq_ac_ras_n;output wire [(DWIDTH_RATIO/2) - 1 : 0] seq_ac_we_n;output wire [(DWIDTH_RATIO/2) * MEM_IF_NUM_RANKS - 1 : 0] seq_ac_cke;output wire [(DWIDTH_RATIO/2) * MEM_IF_CS_WIDTH - 1 : 0] seq_ac_cs_n;output wire [(DWIDTH_RATIO/2) * MEM_IF_NUM_RANKS - 1 : 0] seq_ac_odt;output wire [(DWIDTH_RATIO/2) - 1 : 0] seq_ac_rst_n;output wire seq_ac_sel;output wire seq_mem_clk_disable;output wire ctl_add_1t_ac_lat_internal;output wire ctl_add_1t_odt_lat_internal;output wire ctl_add_intermediate_regs_internal;output wire [MEM_IF_DQS_WIDTH * DWIDTH_RATIO/2 - 1 : 0] seq_rdv_doing_rd;output wire seq_rdp_reset_req_n;output wire [MEM_IF_DQS_WIDTH - 1 : 0] seq_rdp_inc_read_lat_1x;output wire [MEM_IF_DQS_WIDTH - 1 : 0] seq_rdp_dec_read_lat_1x;input wire [DWIDTH_RATIO * MEM_IF_DWIDTH - 1 : 0] ctl_rdata;input wire [DWIDTH_RATIO/2 - 1 : 0] int_rdata_valid_1t;output wire seq_rdata_valid_lat_inc;output wire seq_rdata_valid_lat_dec;output wire [ADV_LAT_WIDTH - 1 : 0] ctl_rlat;output wire [MEM_IF_DQS_WIDTH - 1 : 0] seq_poa_lat_dec_1x;output wire [MEM_IF_DQS_WIDTH - 1 : 0] seq_poa_lat_inc_1x;output wire seq_poa_protection_override_1x;output wire [OCT_LAT_WIDTH - 1 : 0] seq_oct_oct_delay;output wire [OCT_LAT_WIDTH - 1 : 0] seq_oct_oct_extend;output wire seq_oct_val;output wire [(DWIDTH_RATIO/2) * MEM_IF_DQS_WIDTH - 1 : 0] seq_wdp_dqs_burst;output wire [(DWIDTH_RATIO/2) * MEM_IF_DQS_WIDTH - 1 : 0] seq_wdp_wdata_valid;output wire [DWIDTH_RATIO * MEM_IF_DWIDTH - 1 : 0] seq_wdp_wdata;output wire [DWIDTH_RATIO * MEM_IF_DM_WIDTH - 1 : 0] seq_wdp_dm;output wire [DWIDTH_RATIO - 1 : 0] seq_wdp_dqs;output wire seq_wdp_ovride;output wire [MEM_IF_DQS_WIDTH - 1 : 0] seq_dqs_add_2t_delay;output wire [ADV_LAT_WIDTH - 1 : 0] ctl_wlat;output wire seq_mmc_start;input wire mmc_seq_done;input wire mmc_seq_value;input wire dbg_clk;input wire dbg_reset_n;input wire [DBG_A_WIDTH - 1 : 0] dbg_addr;input wire dbg_wr;input wire dbg_rd;input wire dbg_cs;input wire [31 : 0] dbg_wr_data;output wire [31 : 0] dbg_rd_data;output wire dbg_waitrequest;input wire mem_err_out_n;output wire parity_error_n;(* altera_attribute = \"-name global_signal off\" *) wire [MEM_IF_DQS_WIDTH - 1 : 0] sc_clk_dp;nios_altmemddr_0_phy_alt_mem_phy_seq #( .MEM_IF_DQS_WIDTH (MEM_IF_DQS_WIDTH), .MEM_IF_DWIDTH (MEM_IF_DWIDTH), .MEM_IF_DM_WIDTH (MEM_IF_DM_WIDTH), .MEM_IF_DQ_PER_DQS (MEM_IF_DQ_PER_DQS), .DWIDTH_RATIO (DWIDTH_RATIO), .CLOCK_INDEX_WIDTH (CLOCK_INDEX_WIDTH), .MEM_IF_CLK_PAIR_COUNT (MEM_IF_CLK_PAIR_COUNT), .MEM_IF_ADDR_WIDTH (MEM_IF_ADDR_WIDTH), .MEM_IF_BANKADDR_WIDTH (MEM_IF_BANKADDR_WIDTH), .MEM_IF_CS_WIDTH (MEM_IF_CS_WIDTH), .MEM_IF_NUM_RANKS (MEM_IF_NUM_RANKS), .MEM_IF_RANKS_PER_SLOT (MEM_IF_RANKS_PER_SLOT), .ADV_LAT_WIDTH (ADV_LAT_WIDTH), .RESYNCHRONISE_AVALON_DBG (RESYNCHRONISE_AVALON_DBG), .AV_IF_ADDR_WIDTH (DBG_A_WIDTH), .NOM_DQS_PHASE_SETTING (DQS_PHASE_SETTING), .SCAN_CLK_DIVIDE_BY (SCAN_CLK_DIVIDE_BY), .RDP_ADDR_WIDTH (RDP_ADDR_WIDTH), .PLL_STEPS_PER_CYCLE (PLL_STEPS_PER_CYCLE), .IOE_PHASES_PER_TCK (IOE_PHASES_PER_TCK), .IOE_DELAYS_PER_PHS (IOE_DELAYS_PER_PHS), .MEM_IF_CLK_PS (MEM_IF_CLK_PS), .PHY_DEF_MR_1ST (MEM_IF_MR_0), .PHY_DEF_MR_2ND (MEM_IF_MR_1), .PHY_DEF_MR_3RD (MEM_IF_MR_2), .PHY_DEF_MR_4TH (MEM_IF_MR_3), .MEM_IF_DQSN_EN (0), .MEM_IF_DQS_CAPTURE_EN (MEM_IF_DQS_CAPTURE_EN), .FAMILY (FAMILY), .FAMILYGROUP_ID (FAMILYGROUP_ID), .SPEED_GRADE (SPEED_GRADE), .MEM_IF_MEMTYPE (MEM_IF_MEMTYPE), .WRITE_DESKEW_T10 (WRITE_DESKEW_T10), .WRITE_DESKEW_HC_T10 (WRITE_DESKEW_HC_T10), .WRITE_DESKEW_T9NI (WRITE_DESKEW_T9NI), .WRITE_DESKEW_HC_T9NI (WRITE_DESKEW_HC_T9NI), .WRITE_DESKEW_T9I (WRITE_DESKEW_T9I), .WRITE_DESKEW_HC_T9I (WRITE_DESKEW_HC_T9I), .WRITE_DESKEW_RANGE (WRITE_DESKEW_RANGE), .SINGLE_DQS_DELAY_CONTROL_CODE (SINGLE_DQS_DELAY_CONTROL_CODE), .PRESET_RLAT (PRESET_RLAT), .EN_OCT (MEM_IF_OCT_EN), .SIM_TIME_REDUCTIONS (REDUCE_SIM_TIME), .FORCE_HC (FORCE_HC), .CAPABILITIES (CAPABILITIES), .GENERATE_ADDITIONAL_DBG_RTL (GENERATE_ADDITIONAL_DBG_RTL), .TINIT_TCK (TINIT_TCK), .TINIT_RST (TINIT_RST), .GENERATE_TRACKING_PHASE_STORE (0), .OCT_LAT_WIDTH (OCT_LAT_WIDTH), .IP_BUILDNUM (IP_BUILDNUM), .CHIP_OR_DIMM (CHIP_OR_DIMM), .RDIMM_CONFIG_BITS (RDIMM_CONFIG_BITS) ) seq_inst ( .clk (phy_clk_1x), .rst_n (reset_phy_clk_1x_n), .ctl_init_success (ctl_cal_success), .ctl_init_fail (ctl_cal_fail), .ctl_init_warning (ctl_cal_warning), .ctl_recalibrate_req (ctl_cal_req), .MEM_AC_SWAPPED_RANKS (int_RANK_HAS_ADDR_SWAP), .ctl_cal_byte_lanes (ctl_cal_byte_lane_sel_n), .seq_pll_inc_dec_n (seq_pll_inc_dec_n), .seq_pll_start_reconfig (seq_pll_start_reconfig), .seq_pll_select (seq_pll_select), .seq_pll_phs_shift_busy (phs_shft_busy), .pll_resync_clk_index (pll_resync_clk_index), .pll_measure_clk_index (pll_measure_clk_index), .seq_scan_clk (sc_clk_dp), .seq_scan_enable_dqs_config (scan_enable_dqs_config), .seq_scan_update (scan_update), .seq_scan_din (scan_din), .seq_scan_enable_ck (scan_enable_ck), .seq_scan_enable_dqs (scan_enable_dqs), .seq_scan_enable_dqsn (scan_enable_dqsn), .seq_scan_enable_dq (scan_enable_dq), .seq_scan_enable_dm (scan_enable_dm), .hr_rsc_clk (hr_rsc_clk), .seq_ac_addr (seq_ac_addr), .seq_ac_ba (seq_ac_ba), .seq_ac_cas_n (seq_ac_cas_n), .seq_ac_ras_n (seq_ac_ras_n), .seq_ac_we_n (seq_ac_we_n), .seq_ac_cke (seq_ac_cke), .seq_ac_cs_n (seq_ac_cs_n), .seq_ac_odt (seq_ac_odt), .seq_ac_rst_n (seq_ac_rst_n), .seq_ac_sel (seq_ac_sel), .seq_mem_clk_disable (seq_mem_clk_disable), .seq_ac_add_1t_ac_lat_internal (ctl_add_1t_ac_lat_internal), .seq_ac_add_1t_odt_lat_internal (ctl_add_1t_odt_lat_internal), .seq_ac_add_2t (ctl_add_intermediate_regs_internal), .seq_rdv_doing_rd (seq_rdv_doing_rd), .seq_rdp_reset_req_n (seq_rdp_reset_req_n), .seq_rdp_inc_read_lat_1x (seq_rdp_inc_read_lat_1x), .seq_rdp_dec_read_lat_1x (seq_rdp_dec_read_lat_1x), .rdata (ctl_rdata), .rdata_valid (int_rdata_valid_1t), .seq_rdata_valid_lat_inc (seq_rdata_valid_lat_inc), .seq_rdata_valid_lat_dec (seq_rdata_valid_lat_dec), .seq_ctl_rlat (ctl_rlat), .seq_poa_lat_dec_1x (seq_poa_lat_dec_1x), .seq_poa_lat_inc_1x (seq_poa_lat_inc_1x), .seq_poa_protection_override_1x (seq_poa_protection_override_1x), .seq_oct_oct_delay (seq_oct_oct_delay), .seq_oct_oct_extend (seq_oct_oct_extend), .seq_oct_value (seq_oct_val), .seq_wdp_dqs_burst (seq_wdp_dqs_burst), .seq_wdp_wdata_valid (seq_wdp_wdata_valid), .seq_wdp_wdata (seq_wdp_wdata), .seq_wdp_dm (seq_wdp_dm), .seq_wdp_dqs (seq_wdp_dqs), .seq_wdp_ovride (seq_wdp_ovride), .seq_dqs_add_2t_delay (seq_dqs_add_2t_delay), .seq_ctl_wlat (ctl_wlat), .seq_mmc_start (seq_mmc_start), .mmc_seq_done (mmc_seq_done), .mmc_seq_value (mmc_seq_value), .mem_err_out_n (mem_err_out_n), .parity_error_n (parity_error_n), .dbg_seq_clk (dbg_clk), .dbg_seq_rst_n (dbg_reset_n), .dbg_seq_addr (dbg_addr), .dbg_seq_wr (dbg_wr), .dbg_seq_rd (dbg_rd), .dbg_seq_cs (dbg_cs), .dbg_seq_wr_data (dbg_wr_data), .seq_dbg_rd_data (dbg_rd_data), .seq_dbg_waitrequest (dbg_waitrequest));endmodule"}
{"task_id": 697, "completion": "wire SYNTHESIZED_WIRE_9;    wire SYNTHESIZED_WIRE_3;    wire SYNTHESIZED_WIRE_5;    wire SYNTHESIZED_WIRE_6;    wire SYNTHESIZED_WIRE_7;    wire SYNTHESIZED_WIRE_8;    assign div5 = SYNTHESIZED_WIRE_5;    assign div13 = SYNTHESIZED_WIRE_6;    assign SYNTHESIZED_WIRE_9 = 0;    \\7490  b2v_inst(        .SET9A(SYNTHESIZED_WIRE_9),        .CLRA(SYNTHESIZED_WIRE_9),        .SET9B(SYNTHESIZED_WIRE_9),        .CLKB(clk),        .CLKA(SYNTHESIZED_WIRE_3),        .CLRB(SYNTHESIZED_WIRE_9),        .QD(SYNTHESIZED_WIRE_5),        .QA(SYNTHESIZED_WIRE_7)    );    \\7492  b2v_inst2(        .CLKB(SYNTHESIZED_WIRE_5),        .CLRA(SYNTHESIZED_WIRE_6),        .CLKA(SYNTHESIZED_WIRE_7),        .CLRB(SYNTHESIZED_WIRE_8),        .QB(SYNTHESIZED_WIRE_8),        .QD(SYNTHESIZED_WIRE_3),        .QA(SYNTHESIZED_WIRE_6));endmodule"}
{"task_id": 758, "completion": "supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\nendmodule"}
{"task_id": 570, "completion": "localparam [1:0]\n        STATE_IDLE = 2'd0,\n        STATE_SEED = 2'd1;\n\n    reg [1:0] state_reg = STATE_IDLE, state_next;\n\n    reg [63:0] mt [311:0];\n    reg [63:0] mt_save_reg = 0, mt_save_next;\n    reg [9:0] mti_reg = 313, mti_next;\n\n    reg [63:0] y1, y2, y3, y4, y5;\n\n    reg [9:0] mt_wr_ptr;\n    reg [63:0] mt_wr_data;\n    reg mt_wr_en;\n\n    reg [9:0] mt_rd_a_ptr_reg = 0, mt_rd_a_ptr_next;\n    reg [63:0] mt_rd_a_data = 0;\n\n    reg [9:0] mt_rd_b_ptr_reg = 0, mt_rd_b_ptr_next;\n    reg [63:0] mt_rd_b_data = 0;\n\n    reg [63:0] product_reg = 0, product_next;\n    reg [63:0] factor1_reg = 0, factor1_next;\n    reg [63:0] factor2_reg = 0, factor2_next;\n    reg [5:0] mul_cnt_reg = 0, mul_cnt_next;\n\n    reg [63:0] output_axis_tdata_reg = 0, output_axis_tdata_next;\n    reg output_axis_tvalid_reg = 0, output_axis_tvalid_next;\n\n    reg busy_reg = 0;\n\n    assign output_axis_tdata = output_axis_tdata_reg;\n    assign output_axis_tvalid = output_axis_tvalid_reg;\n    assign busy = busy_reg;\n\n    always @* begin\n        state_next = 2'bz;\n\n        mt_save_next = mt_save_reg;\n        mti_next = mti_reg;\n\n        mt_wr_data = 0;\n        mt_wr_ptr = 0;\n        mt_wr_en = 0;\n\n        y1 = 64'bz;\n        y2 = 64'bz;\n        y3 = 64'bz;\n        y4 = 64'bz;\n        y5 = 64'bz;\n\n        mt_rd_a_ptr_next = mt_rd_a_ptr_reg;\n        mt_rd_b_ptr_next = mt_rd_b_ptr_reg;\n\n        product_next = product_reg;\n        factor1_next = factor1_reg;\n        factor2_next = factor2_reg;\n        mul_cnt_next = mul_cnt_reg;\n\n        output_axis_tdata_next = output_axis_tdata_reg;\n        output_axis_tvalid_next = output_axis_tvalid_reg & ~output_axis_tready;\n\n        case (state_reg)\n            STATE_IDLE: begin\n                if (seed_start) begin\n                    mt_save_next = seed_val;\n                    product_next = 0;\n                    factor1_next = mt_save_next ^ (mt_save_next >> 62);\n                    factor2_next = 64'd6364136223846793005;\n                    mul_cnt_next = 63;\n                    mt_wr_data = mt_save_next;\n                    mt_wr_ptr = 0;\n                    mt_wr_en = 1;\n                    mti_next = 1;\n                    state_next = STATE_SEED;\n                end else if (output_axis_tready) begin\n                    if (mti_reg == 313) begin\n                        mt_save_next = 64'd5489;\n                        product_next = 0;\n                        factor1_next = mt_save_next ^ (mt_save_next >> 62);\n                        factor2_next = 64'd6364136223846793005;\n                        mul_cnt_next = 63;\n                        mt_wr_data = mt_save_next;\n                        mt_wr_ptr = 0;\n                        mt_wr_en = 1;\n                        mti_next = 1;\n                        state_next = STATE_SEED;\n                    end else begin\n                        if (mti_reg < 311)\n                            mti_next = mti_reg + 1;\n                        else\n                            mti_next = 0;\n\n                        if (mt_rd_a_ptr_reg < 311)\n                            mt_rd_a_ptr_next = mt_rd_a_ptr_reg + 1;\n                        else\n                            mt_rd_a_ptr_next = 0;\n\n                        if (mt_rd_b_ptr_reg < 311)\n                            mt_rd_b_ptr_next = mt_rd_b_ptr_reg + 1;\n                        else\n                            mt_rd_b_ptr_next = 0;\n\n                        mt_save_next = mt_rd_a_data;\n                        y1 = {mt_save_reg[63:31], mt_rd_a_data[30:0]};\n                        y2 = mt_rd_b_data ^ (y1 >> 1) ^ (y1[0] ? 64'hB5026F5AA96619E9 : 64'h0);\n                        y3 = y2 ^ ((y2 >> 29) & 64'h5555555555555555);\n                        y4 = y3 ^ ((y3 << 17) & 64'h71D67FFFEDA60000);\n                        y5 = y4 ^ ((y4 << 37) & 64'hFFF7EEE000000000);\n                        output_axis_tdata_next = y5 ^ (y5 >> 43);\n                        output_axis_tvalid_next = 1;\n                        mt_wr_data = y2;\n                        mt_wr_ptr = mti_reg;\n                        mt_wr_en = 1;\n                        state_next = STATE_IDLE;\n                    end\n                end else begin\n                    state_next = STATE_IDLE;\n                end\n            end\n            STATE_SEED: begin\n                if (mul_cnt_reg == 0) begin\n                    if (mti_reg < 312) begin\n                        mt_save_next = product_reg + mti_reg;\n                        product_next = 0;\n                        factor1_next = mt_save_next ^ (mt_save_next >> 62);\n                        factor2_next = 64'd6364136223846793005;\n                        mul_cnt_next = 63;\n                        mt_wr_data = mt_save_next;\n                        mt_wr_ptr = mti_reg;\n                        mt_wr_en = 1;\n                        mti_next = mti_reg + 1;\n                        mt_rd_a_ptr_next = 0;\n                        state_next = STATE_SEED;\n                    end else begin\n                        mti_next = 0;\n                        mt_save_next = mt_rd_a_data;\n                        mt_rd_a_ptr_next = 1;\n                        mt_rd_b_ptr_next = 156;\n                        state_next = STATE_IDLE;\n                    end\n                end else begin\n                    mul_cnt_next = mul_cnt_reg - 1;\n                    factor1_next = factor1_reg << 1;\n                    factor2_next = factor2_reg >> 1;\n                    if (factor2_reg[0]) product_next = product_reg + factor1_reg;\n                    state_next = STATE_SEED;\n                end\n            end\n        endcase\n    end\n\n    always @(posedge clk) begin\n        if (rst) begin\n            state_reg <= STATE_IDLE;\n            mti_reg <= 313;\n            mt_rd_a_ptr_reg <= 0;\n            mt_rd_b_ptr_reg <= 0;\n            product_reg <= 0;\n            factor1_reg <= 0;\n            factor2_reg <= 0;\n            mul_cnt_reg <= 0;\n            output_axis_tdata_reg <= 0;\n            output_axis_tvalid_reg <= 0;\n            busy_reg <= 0;\n        end else begin\n            state_reg <= state_next;\n\n            mt_save_reg = mt_save_next;\n            mti_reg <= mti_next;\n\n            mt_rd_a_ptr_reg <= mt_rd_a_ptr_next;\n            mt_rd_b_ptr_reg <= mt_rd_b_ptr_next;\n\n            product_reg <= product_next;\n            factor1_reg <= factor1_next;\n            factor2_reg <= factor2_next;\n            mul_cnt_reg <= mul_cnt_next;\n\n            output_axis_tdata_reg <= output_axis_tdata_next;\n            output_axis_tvalid_reg <= output_axis_tvalid_next;\n\n            busy_reg <= state_next != STATE_IDLE;\n\n            if (mt_wr_en) begin\n                mt[mt_wr_ptr] <= mt_wr_data;\n            end\n\n            mt_rd_a_data <= mt[mt_rd_a_ptr_next];\n            mt_rd_b_data <= mt[mt_rd_b_ptr_next];\n        end\n    end\n\nendmodule"}
{"task_id": 719, "completion": "wire [3:0] mac_mii_rxd; wire mac_mii_rx_dv; wire mac_mii_rx_er; wire [3:0] mac_mii_txd; wire mac_mii_tx_en; wire mac_mii_tx_er; mii_phy_if #(.TARGET(TARGET), .CLOCK_INPUT_STYLE(CLOCK_INPUT_STYLE)) mii_phy_if_inst (.rst(rst), .mac_mii_rx_clk(rx_clk), .mac_mii_rx_rst(rx_rst), .mac_mii_rxd(mac_mii_rxd), .mac_mii_rx_dv(mac_mii_rx_dv), .mac_mii_rx_er(mac_mii_rx_er), .mac_mii_tx_clk(tx_clk), .mac_mii_tx_rst(tx_rst), .mac_mii_txd(mac_mii_txd), .mac_mii_tx_en(mac_mii_tx_en), .mac_mii_tx_er(mac_mii_tx_er), .phy_mii_rx_clk(mii_rx_clk), .phy_mii_rxd(mii_rxd), .phy_mii_rx_dv(mii_rx_dv), .phy_mii_rx_er(mii_rx_er), .phy_mii_tx_clk(mii_tx_clk), .phy_mii_txd(mii_txd), .phy_mii_tx_en(mii_tx_en), .phy_mii_tx_er(mii_tx_er)); eth_mac_1g #(.ENABLE_PADDING(ENABLE_PADDING), .MIN_FRAME_LENGTH(MIN_FRAME_LENGTH)) eth_mac_1g_inst (.tx_clk(tx_clk), .tx_rst(tx_rst), .rx_clk(rx_clk), .rx_rst(rx_rst), .tx_axis_tdata(tx_axis_tdata), .tx_axis_tvalid(tx_axis_tvalid), .tx_axis_tready(tx_axis_tready), .tx_axis_tlast(tx_axis_tlast), .tx_axis_tuser(tx_axis_tuser), .rx_axis_tdata(rx_axis_tdata), .rx_axis_tvalid(rx_axis_tvalid), .rx_axis_tlast(rx_axis_tlast), .rx_axis_tuser(rx_axis_tuser), .gmii_rxd(mac_mii_rxd), .gmii_rx_dv(mac_mii_rx_dv), .gmii_rx_er(mac_mii_rx_er), .gmii_txd(mac_mii_txd), .gmii_tx_en(mac_mii_tx_en), .gmii_tx_er(mac_mii_tx_er), .rx_clk_enable(1'b1), .tx_clk_enable(1'b1), .rx_mii_select(1'b1), .tx_mii_select(1'b1), .tx_start_packet(tx_start_packet), .tx_error_underflow(tx_error_underflow), .rx_start_packet(rx_start_packet), .rx_error_bad_frame(rx_error_bad_frame), .rx_error_bad_fcs(rx_error_bad_fcs), .ifg_delay(ifg_delay));endmodule"}
{"task_id": 765, "completion": "output X    ;    input  A    ;    input  VPWR ;    input  VGND ;    input  KAPWR;    input  VPB  ;    input  VNB  ;    sky130_fd_sc_lp__bufkapwr base (        .X(X),        .A(A),        .VPWR(VPWR),        .VGND(VGND),        .KAPWR(KAPWR),        .VPB(VPB),        .VNB(VNB)    );    endmodule"}
{"task_id": 714, "completion": "reg     [27:0]  tx_data_n = 'd0;\n  reg     [27:0]  tx_data_p = 'd0;\n\n  wire            core_clk;\n  wire    [27:0]  tx_data_s;\n \n  assign tx_clk_out_n = 1'd0;\n  assign tx_frame_out_n = 1'd0;\n  assign tx_data_out_n = 6'd0;\n\n  assign tx_data_s[24] = tx_frame[3];\n  assign tx_data_s[25] = tx_frame[2];\n  assign tx_data_s[26] = tx_frame[1];\n  assign tx_data_s[27] = tx_frame[0];\n  assign tx_data_s[20] = tx_data_3[5];\n  assign tx_data_s[16] = tx_data_3[4];\n  assign tx_data_s[12] = tx_data_3[3];\n  assign tx_data_s[ 8] = tx_data_3[2];\n  assign tx_data_s[ 4] = tx_data_3[1];\n  assign tx_data_s[ 0] = tx_data_3[0];\n  assign tx_data_s[21] = tx_data_2[5];\n  assign tx_data_s[17] = tx_data_2[4];\n  assign tx_data_s[13] = tx_data_2[3];\n  assign tx_data_s[ 9] = tx_data_2[2];\n  assign tx_data_s[ 5] = tx_data_2[1];\n  assign tx_data_s[ 1] = tx_data_2[0];\n  assign tx_data_s[22] = tx_data_1[5];\n  assign tx_data_s[18] = tx_data_1[4];\n  assign tx_data_s[14] = tx_data_1[3];\n  assign tx_data_s[10] = tx_data_1[2];\n  assign tx_data_s[ 6] = tx_data_1[1];\n  assign tx_data_s[ 2] = tx_data_1[0];\n  assign tx_data_s[23] = tx_data_0[5];\n  assign tx_data_s[19] = tx_data_0[4];\n  assign tx_data_s[15] = tx_data_0[3];\n  assign tx_data_s[11] = tx_data_0[2];\n  assign tx_data_s[ 7] = tx_data_0[1];\n  assign tx_data_s[ 3] = tx_data_0[0];\n\n  always @(negedge clk) begin\n    tx_data_n <= tx_data_s;\n  end\n\n  always @(posedge core_clk) begin\n    tx_data_p <= tx_data_n;\n  end\n\n  altlvds_tx #(\n    .center_align_msb (\"UNUSED\"),\n    .common_rx_tx_pll (\"ON\"),\n    .coreclock_divide_by (1),\n    .data_rate (\"500.0 Mbps\"),\n    .deserialization_factor (4),\n    .differential_drive (0),\n    .enable_clock_pin_mode (\"UNUSED\"),\n    .implement_in_les (\"OFF\"),\n    .inclock_boost (0),\n    .inclock_data_alignment (\"EDGE_ALIGNED\"),\n    .inclock_period (4000),\n    .inclock_phase_shift (0),\n    .intended_device_family (\"Cyclone V\"),\n    .lpm_hint (\"CBX_MODULE_PREFIX=axi_ad9361_alt_lvds_tx\"),\n    .lpm_type (\"altlvds_tx\"),\n    .multi_clock (\"OFF\"),\n    .number_of_channels (7),\n    .outclock_alignment (\"EDGE_ALIGNED\"),\n    .outclock_divide_by (2),\n    .outclock_duty_cycle (50),\n    .outclock_multiply_by (1),\n    .outclock_phase_shift (0),\n    .outclock_resource (\"Regional clock\"),\n    .output_data_rate (500),\n    .pll_compensation_mode (\"AUTO\"),\n    .pll_self_reset_on_loss_lock (\"OFF\"),\n    .preemphasis_setting (0),\n    .refclk_frequency (\"250.000000 MHz\"),\n    .registered_input (\"TX_CORECLK\"),\n    .use_external_pll (\"OFF\"),\n    .use_no_phase_shift (\"ON\"),\n    .vod_setting (0),\n    .clk_src_is_pll (\"off\"))\n  i_altlvds_tx (\n    .tx_inclock (tx_clk),\n    .tx_coreclock (core_clk),\n    .tx_in (tx_data_p),\n    .tx_outclock (tx_clk_out_p),\n    .tx_out ({tx_frame_out_p, tx_data_out_p}),\n    .tx_locked (tx_locked),\n    .pll_areset (1'b0),\n    .sync_inclock (1'b0),\n    .tx_data_reset (1'b0),\n    .tx_enable (1'b1),\n    .tx_pll_enable (1'b1),\n    .tx_syncclock (1'b0));\n\nendmodule"}
{"task_id": 734, "completion": "reg [3:0] key_value;\n    wire [3:0] key0_value;\n    wire [3:0] key1_value;\n    wire [3:0] key2_value;\n    wire [3:0] key3_value;\n\n    assign key0_value = KEY[0] ? 4'h1 : 4'h0;\n    assign key1_value = KEY[1] ? 4'h2 : 4'h0;\n    assign key2_value = KEY[2] ? 4'h3 : 4'h0;\n    assign key3_value = KEY[3] ? 4'h4 : 4'h0;\n\n    always @(posedge CLOCK_50)\n        key_value = key3_value + key2_value + key1_value + key0_value;\n\n    always @(posedge CLOCK_50)\n        begin\n            case (key_value)\n                4'h0 : LEDR <= 10'b0000000000;\n                4'h1 : LEDR <= 10'b0000000001;\n                4'h2 : LEDR <= 10'b0000000011;\n                4'h3 : LEDR <= 10'b0000000111;\n                4'h4 : LEDR <= 10'b0000001111;\n                4'h5 : LEDR <= 10'b0000011111;\n                4'h6 : LEDR <= 10'b0000111111;\n                4'h7 : LEDR <= 10'b0001111111;\n                4'h8 : LEDR <= 10'b0011111111;\n                4'h9 : LEDR <= 10'b0111111111;\n                4'hA : LEDR <= 10'b1111111111;\n                default : LEDR <= 10'b0000000000;\n            endcase\n        end\n\n    reg [6:0] hex0_reg;\n    reg [6:0] hex1_reg;\n    reg [6:0] hex2_reg;\n    reg [6:0] hex3_reg;\n    reg [6:0] hex4_reg;\n    reg [6:0] hex5_reg;\n\n    assign HEX0 = ~hex0_reg;\n    assign HEX1 = ~hex1_reg;\n    assign HEX2 = ~hex2_reg;\n    assign HEX3 = ~hex3_reg;\n    assign HEX4 = ~hex4_reg;\n    assign HEX5 = ~hex5_reg;\n\n    always @(posedge CLOCK_50)\n        begin\n            case (key_value)\n                4'h0 : hex0_reg <= 7'h3F;\n                4'h1 : hex0_reg <= 7'h06;\n                4'h2 : hex0_reg <= 7'h5B;\n                4'h3 : hex0_reg <= 7'h4F;\n                4'h4 : hex0_reg <= 7'h66;\n                4'h5 : hex0_reg <= 7'h6D;\n                4'h6 : hex0_reg <= 7'h7D;\n                4'h7 : hex0_reg <= 7'h27;\n                4'h8 : hex0_reg <= 7'h7F;\n                4'h9 : hex0_reg <= 7'h6F;\n                4'hA : hex0_reg <= 7'h3F;\n                default : hex0_reg <= 7'h00;\n            endcase\n        end\n\n    always @(posedge CLOCK_50)\n        begin\n            case (key_value)\n                4'hA : hex1_reg <= 7'h06;\n                default : hex1_reg <= 7'h00;\n            endcase\n        end\n\n    always @(posedge CLOCK_50)\n        begin\n            case (key_value)\n                4'hA : hex2_reg <= 7'h79;\n                default : hex2_reg <= 7'h00;\n            endcase\n        end\n\n    always @(posedge CLOCK_50)\n        begin\n            case (key_value)\n                4'h9,\n                4'hA : hex3_reg <= 7'h6D;\n                default : hex3_reg <= 7'h00;\n            endcase\n        end\n\n    always @(posedge CLOCK_50)\n        begin\n            case (key_value)\n                4'h7,\n                4'h8,\n                4'h9,\n                4'hA : hex4_reg <= 7'h77;\n                default : hex4_reg <= 7'h00;\n            endcase\n        end\n\n    always @(posedge CLOCK_50)\n        begin\n            case (key_value)\n                4'h4,\n                4'h5,\n                4'h6,\n                4'h7,\n                4'h8,\n                4'h9,\n                4'hA : hex5_reg <= 7'h39;\n                default : hex5_reg <= 7'h00;\n            endcase\n        end\n\nendmodule"}
{"task_id": 754, "completion": "wire not0_out;    wire or0_out_X;    wire pwrgood_pp0_out_X;    not not0 (not0_out, D_N);    or or0 (or0_out_X, not0_out, C, B, A);    sky130_fd_sc_lp__udp_pwrgood_pp$PG pwrgood_pp0 (pwrgood_pp0_out_X, or0_out_X, VPWR, VGND);    buf buf0 (X, pwrgood_pp0_out_X);    endmodule"}
{"task_id": 733, "completion": "input  VPWR;\n    input  VGND;\n    output X   ;\n    input  A1_N;\n    input  A2_N;\n    input  B1  ;\n    input  B2  ;\n\n    // Local signals\n    wire    B2 nand0_out         ;\n    wire    B2 or0_out           ;\n    wire    and0_out_X        ;\n    wire    u_vpwr_vgnd0_out_X;\n\n    //                           Name          Output              Other arguments\n    nand                         nand0        (nand0_out         , A2_N, A1_N            );\n    or                           or0          (or0_out           , B2, B1                );\n    and                          and0         (and0_out_X        , nand0_out, or0_out    );\n    sky130_fd_sc_hs__u_vpwr_vgnd u_vpwr_vgnd0 (u_vpwr_vgnd0_out_X, and0_out_X, VPWR, VGND);\n    buf                          buf0         (X                 , u_vpwr_vgnd0_out_X    );\n\nendmodule"}
{"task_id": 741, "completion": "reg [P_DEPTH_N:0] b_write_pointer;\n    reg [P_DEPTH_N:0] b_read_pointer;\n    reg [P_N-1:0] b_memory [0:P_DEPTH-1];\n    wire [P_DEPTH_N:0] count = b_write_pointer - b_read_pointer;\n    wire full = count[P_DEPTH_N];\n    wire empty = (count == {P_DEPTH_N+1{1'b0}})? 1'b1 : 1'b0;\n    wire almost_full = full || (count[P_DEPTH_N-1:0] == {P_DEPTH_N{1'b1}});\n    wire almost_empty = empty || (count[P_DEPTH_N:0] == {{P_DEPTH_N{1'b0}}, 1'b1});\n    wire read_condition = iRD_EN && !empty;\n    wire write_condition = iWR_EN && !full;\n    always@(posedge iCLOCK)begin\n        if(write_condition)begin\n            b_memory [b_write_pointer[P_DEPTH_N-1:0]] <= iWR_DATA;\n        end\n    end \n    always@(posedge iCLOCK or negedge inRESET)begin\n        if(!inRESET)begin\n            b_write_pointer <= {P_DEPTH_N+1{1'b0}};\n        end\n        else if(iREMOVE)begin\n            b_write_pointer <= {P_DEPTH_N+1{1'b0}};\n        end\n        else begin\n            if(write_condition)begin\n                b_write_pointer <= b_write_pointer + {{P_DEPTH_N-1{1'b0}}, 1'b1};\n            end\n        end\n    end \n    always@(posedge iCLOCK or negedge inRESET)begin\n        if(!inRESET)begin\n            b_read_pointer <= {P_DEPTH_N+1{1'b0}};\n        end\n        else if(iREMOVE)begin\n            b_read_pointer <= {P_DEPTH_N+1{1'b0}};\n        end\n        else begin\n            if(read_condition)begin\n                b_read_pointer <= b_read_pointer + {{P_DEPTH_N-1{1'b0}}, 1'b1};\n            end\n        end\n    end \n    assign oRD_DATA = b_memory[b_read_pointer[P_DEPTH_N-1:0]];\n    assign oRD_EMPTY = empty;\n    assign oRD_ALMOST_EMPTY = almost_empty;\n    assign oWR_FULL = full;\n    assign oWR_ALMOST_FULL = almost_full;\n    assign oCOUNT = count[P_DEPTH_N:0];\nendmodule"}
{"task_id": 756, "completion": "X   ,\n    A1_N,\n    A2_N,\n    B1  ,\n    B2  ,\n    VPWR,\n    VGND,\n    VPB ,\n    VNB\n);\n\n    output X   ;\n    input  A1_N;\n    input  A2_N;\n    input  B1  ;\n    input  B2  ;\n    input  VPWR;\n    input  VGND;\n    input  VPB ;\n    input  VNB ;\n\n    wire and0_out         ;\n    wire nor0_out         ;\n    wire or0_out_X        ;\n    wire pwrgood_pp0_out_X;\n\n    and                                  and0        (and0_out         , B1, B2               );\n    nor                                  nor0        (nor0_out         , A1_N, A2_N           );\n    or                                   or0         (or0_out_X        , nor0_out, and0_out   );\n    sky130_fd_sc_hdll__udp_pwrgood_pp$PG pwrgood_pp0 (pwrgood_pp0_out_X, or0_out_X, VPWR, VGND);\n    buf                                  buf0        (X                , pwrgood_pp0_out_X    );\n\nendmodule"}
{"task_id": 557, "completion": "wire      [31:0]          execute_address;\nwire                      execute_address_valid;\nwire      [31:0]          execute_address_nxt;\nwire      [31:0]          write_data;\nwire                      write_enable;\nwire      [31:0]          read_data;\nwire                      priviledged;\nwire                      exclusive_exec;\nwire                      data_access_exec;\nwire      [3:0]           byte_enable;\nwire                      data_access;\nwire                      exclusive;\nwire                      cache_enable;\nwire                      cache_flush;\nwire      [31:0]          cacheable_area;\n\nwire                      fetch_stall;\nwire     [1:0]            status_bits_mode;\nwire                      status_bits_irq_mask;\nwire                      status_bits_firq_mask;\nwire                      status_bits_flags_wen;\nwire                      status_bits_mode_wen;\nwire                      status_bits_irq_mask_wen;\nwire                      status_bits_firq_mask_wen;\nwire     [31:0]           execute_status_bits;\n                \nwire     [31:0]           imm32;\nwire     [4:0]            imm_shift_amount;\nwire                      shift_imm_zero;\nwire     [3:0]            condition;\nwire     [31:0]           read_data_s2;\nwire     [4:0]            read_data_alignment;\n     \nwire     [3:0]            rm_sel;\nwire     [3:0]            rds_sel;\nwire     [3:0]            rn_sel;\nwire     [3:0]            rm_sel_nxt;\nwire     [3:0]            rds_sel_nxt;\nwire     [3:0]            rn_sel_nxt;\nwire     [1:0]            barrel_shift_amount_sel;\nwire     [1:0]            barrel_shift_data_sel;\nwire     [1:0]            barrel_shift_function;\nwire                      use_carry_in;\nwire     [8:0]            alu_function;\nwire     [1:0]            multiply_function;\nwire     [2:0]            interrupt_vector_sel;\nwire     [3:0]            address_sel;\nwire     [1:0]            pc_sel;\nwire     [1:0]            byte_enable_sel;\nwire     [2:0]            status_bits_sel;\nwire     [2:0]            reg_write_sel;\nwire                      user_mode_regs_load;\nwire                      user_mode_regs_store_nxt;\nwire                      firq_not_user_mode;\n\nwire                      write_data_wen;\nwire                      copro_write_data_wen;\nwire                      base_address_wen;\nwire                      pc_wen;\nwire     [14:0]           reg_bank_wen;\nwire     [3:0]            reg_bank_wsel;\n            \nwire     [2:0]            copro_opcode1;\nwire     [2:0]            copro_opcode2;\nwire     [3:0]            copro_crn;\nwire     [3:0]            copro_crm;\nwire     [3:0]            copro_num;\nwire     [1:0]            copro_operation;\nwire     [31:0]           copro_read_data;\nwire     [31:0]           copro_write_data;\nwire                      multiply_done;\n\nwire                      decode_fault;\nwire                      iabt_trigger;\nwire                      dabt_trigger;\n\nwire     [7:0]            decode_fault_status;\nwire     [7:0]            iabt_fault_status;\nwire     [7:0]            dabt_fault_status;\n\nwire     [31:0]           decode_fault_address;\nwire     [31:0]           iabt_fault_address;\nwire     [31:0]           dabt_fault_address;\n\nwire                      adex;\n\nassign decode_fault_status  = dabt_trigger ? dabt_fault_status  : iabt_fault_status;\nassign decode_fault_address = dabt_trigger ? dabt_fault_address : iabt_fault_address;\nassign decode_fault         = dabt_trigger | iabt_trigger;\n\na23_fetch u_fetch (\n    .i_clk                              ( i_clk                             ),\n    .i_address                          ( {execute_address[31:2], 2'd0}     ),\n    .i_address_valid                    ( execute_address_valid             ), \n    .i_address_nxt                      ( execute_address_nxt               ),\n    .i_write_data                       ( write_data                        ),\n    .i_write_enable                     ( write_enable                      ),\n    .o_read_data                        ( read_data                         ),\n    .i_priviledged                      ( priviledged                       ),\n    .i_byte_enable                      ( byte_enable                       ),\n    .i_data_access                      ( data_access                       ),      \n    .i_exclusive                        ( exclusive                         ),\n    .i_cache_enable                     ( cache_enable                      ),     \n    .i_cache_flush                      ( cache_flush                       ), \n    .i_cacheable_area                   ( cacheable_area                    ),\n    .i_system_rdy                       ( i_system_rdy                      ),\n    .o_fetch_stall                      ( fetch_stall                       ),\n    .o_wb_adr                           ( o_wb_adr                          ),\n    .o_wb_sel                           ( o_wb_sel                          ),\n    .o_wb_we                            ( o_wb_we                           ),\n    .i_wb_dat                           ( i_wb_dat                          ),\n    .o_wb_dat                           ( o_wb_dat                          ),\n    .o_wb_cyc                           ( o_wb_cyc                          ),\n    .o_wb_stb                           ( o_wb_stb                          ),\n    .i_wb_ack                           ( i_wb_ack                          ),\n    .i_wb_err                           ( i_wb_err                          )\n);\n\na23_decode u_decode (\n    .i_clk                              ( i_clk                             ),\n    .i_read_data                        ( read_data                         ),                                           \n    .i_execute_address                  ( execute_address                   ),\n    .i_adex                             ( adex                              ),\n    .i_iabt                             ( 1'd0                              ),\n    .i_dabt                             ( 1'd0                              ),\n    .i_abt_status                       ( 8'd0                              ),                                           \n    .o_read_data                        ( read_data_s2                      ),                                           \n    .o_read_data_alignment              ( read_data_alignment               ),                                           \n    .i_irq                              ( i_irq                             ),                                           \n    .i_firq                             ( i_firq                            ),                                           \n    .i_fetch_stall                      ( fetch_stall                       ),                                           \n    .i_execute_status_bits              ( execute_status_bits               ),                                           \n    .i_multiply_done                    ( multiply_done                     ),                                           \n    .o_status_bits_mode                 ( status_bits_mode                  ),\n    .o_status_bits_irq_mask             ( status_bits_irq_mask              ),  \n    .o_status_bits_firq_mask            ( status_bits_firq_mask             ),  \n    .o_imm32                            ( imm32                             ),\n    .o_imm_shift_amount                 ( imm_shift_amount                  ),\n    .o_shift_imm_zero                   ( shift_imm_zero                    ),\n    .o_condition                        ( condition                         ),\n    .o_exclusive_exec                   ( exclusive_exec                    ), \n    .o_data_access_exec                 ( data_access_exec                  ),\n    .o_rm_sel                           ( rm_sel                            ),\n    .o_rds_sel                          ( rds_sel                           ),\n    .o_rn_sel                           ( rn_sel                            ),\n    .o_rm_sel_nxt                       ( rm_sel_nxt                        ),\n    .o_rds_sel_nxt                      ( rds_sel_nxt                       ),\n    .o_rn_sel_nxt                       ( rn_sel_nxt                        ),\n    .o_barrel_shift_amount_sel          ( barrel_shift_amount_sel           ),\n    .o_barrel_shift_data_sel            ( barrel_shift_data_sel             ),\n    .o_barrel_shift_function            ( barrel_shift_function             ),\n    .o_use_carry_in                     ( use_carry_in                      ),\n    .o_alu_function                     ( alu_function                      ),\n    .o_multiply_function                ( multiply_function                 ),\n    .o_interrupt_vector_sel             ( interrupt_vector_sel              ),\n    .o_address_sel                      ( address_sel                       ),\n    .o_pc_sel                           ( pc_sel                            ),\n    .o_byte_enable_sel                  ( byte_enable_sel                   ),\n    .o_status_bits_sel                  ( status_bits_sel                   ),\n    .o_reg_write_sel                    ( reg_write_sel                     ),\n    .o_user_mode_regs_load              ( user_mode_regs_load               ),\n    .o_user_mode_regs_store_nxt         ( user_mode_regs_store_nxt          ),\n    .o_firq_not_user_mode               ( firq_not_user_mode                ),\n    .o_write_data_wen                   ( write_data_wen                    ),\n    .o_base_address_wen                 ( base_address_wen                  ),\n    .o_pc_wen                           ( pc_wen                            ),\n    .o_reg_bank_wen                     ( reg_bank_wen                      ),\n    .o_reg_bank_wsel                    ( reg_bank_wsel                     ),\n    .o_status_bits_flags_wen            ( status_bits_flags_wen             ),\n    .o_status_bits_mode_wen             ( status_bits_mode_wen              ),\n    .o_status_bits_irq_mask_wen         ( status_bits_irq_mask_wen          ),\n    .o_status_bits_firq_mask_wen        ( status_bits_firq_mask_wen         ),\n    .o_copro_opcode1                    ( copro_opcode1                     ),                                        \n    .o_copro_opcode2                    ( copro_opcode2                     ),                                        \n    .o_copro_crn                        ( copro_crn                         ),                                        \n    .o_copro_crm                        ( copro_crm                         ),                                        \n    .o_copro_num                        ( copro_num                         ),                                        \n    .o_copro_operation                  ( copro_operation                   ), \n    .o_copro_write_data_wen             ( copro_write_data_wen              ),                                        \n    .o_iabt_trigger                     ( iabt_trigger                      ),\n    .o_iabt_address                     ( iabt_fault_address                ),\n    .o_iabt_status                      ( iabt_fault_status                 ),\n    .o_dabt_trigger                     ( dabt_trigger                      ),\n    .o_dabt_address                     ( dabt_fault_address                ),\n    .o_dabt_status                      ( dabt_fault_status                 ) \n);\n\n\na23_execute u_execute (\n    .i_clk                              ( i_clk                             ),\n    .i_read_data                        ( read_data_s2                      ),\n    .i_read_data_alignment              ( read_data_alignment               ), \n    .i_copro_read_data                  ( copro_read_data                   ),\n    .o_write_data                       ( write_data                        ),\n    .o_copro_write_data                 ( copro_write_data                  ),\n    .o_address                          ( execute_address                   ),\n    .o_address_valid                    ( execute_address_valid             ),\n    .o_address_nxt                      ( execute_address_nxt               ),\n    .o_adex                             ( adex                              ),\n    .o_byte_enable                      ( byte_enable                       ),\n    .o_data_access                      ( data_access                       ),\n    .o_write_enable                     ( write_enable                      ),\n    .o_exclusive                        ( exclusive                         ),\n    .o_priviledged                      ( priviledged                       ),\n    .o_status_bits                      ( execute_status_bits               ),\n    .o_multiply_done                    ( multiply_done                     ),\n    .i_fetch_stall                      ( fetch_stall                       ),   \n    .i_status_bits_mode                 ( status_bits_mode                  ),   \n    .i_status_bits_irq_mask             ( status_bits_irq_mask              ),   \n    .i_status_bits_firq_mask            ( status_bits_firq_mask             ),   \n    .i_imm32                            ( imm32                             ),   \n    .i_imm_shift_amount                 ( imm_shift_amount                  ),   \n    .i_shift_imm_zero                   ( shift_imm_zero                    ),   \n    .i_condition                        ( condition                         ),   \n    .i_exclusive_exec                   ( exclusive_exec                    ),   \n    .i_data_access_exec                 ( data_access_exec                  ),   \n    .i_rm_sel                           ( rm_sel                            ),   \n    .i_rds_sel                          ( rds_sel                           ),   \n    .i_rn_sel                           ( rn_sel                            ),   \n    .i_rm_sel_nxt                       ( rm_sel_nxt                        ),\n    .i_rds_sel_nxt                      ( rds_sel_nxt                       ),\n    .i_rn_sel_nxt                       ( rn_sel_nxt                        ),\n    .i_barrel_shift_amount_sel          ( barrel_shift_amount_sel           ),   \n    .i_barrel_shift_data_sel            ( barrel_shift_data_sel             ),   \n    .i_barrel_shift_function            ( barrel_shift_function             ),   \n    .i_use_carry_in                     ( use_carry_in                      ),\n    .i_alu_function                     ( alu_function                      ),   \n    .i_multiply_function                ( multiply_function                 ),   \n    .i_interrupt_vector_sel             ( interrupt_vector_sel              ),   \n    .i_address_sel                      ( address_sel                       ),   \n    .i_pc_sel                           ( pc_sel                            ),   \n    .i_byte_enable_sel                  ( byte_enable_sel                   ),   \n    .i_status_bits_sel                  ( status_bits_sel                   ),   \n    .i_reg_write_sel                    ( reg_write_sel                     ),   \n    .i_user_mode_regs_load              ( user_mode_regs_load               ),   \n    .i_user_mode_regs_store_nxt         ( user_mode_regs_store_nxt          ),   \n    .i_firq_not_user_mode               ( firq_not_user_mode                ),   \n    .i_write_data_wen                   ( write_data_wen                    ),   \n    .i_base_address_wen                 ( base_address_wen                  ),   \n    .i_pc_wen                           ( pc_wen                            ),   \n    .i_reg_bank_wen                     ( reg_bank_wen                      ),   \n    .i_reg_bank_wsel                    ( reg_bank_wsel                     ),\n    .i_status_bits_flags_wen            ( status_bits_flags_wen             ),   \n    .i_status_bits_mode_wen             ( status_bits_mode_wen              ),   \n    .i_status_bits_irq_mask_wen         ( status_bits_irq_mask_wen          ),   \n    .i_status_bits_firq_mask_wen        ( status_bits_firq_mask_wen         ),   \n    .i_copro_write_data_wen             ( copro_write_data_wen              )\n);\n\n\na23_coprocessor u_coprocessor (\n    .i_clk                              ( i_clk                             ),\n    .i_fetch_stall                      ( fetch_stall                       ),\n    .i_copro_opcode1                    ( copro_opcode1                     ),\n    .i_copro_opcode2                    ( copro_opcode2                     ),\n    .i_copro_crn                        ( copro_crn                         ),    \n    .i_copro_crm                        ( copro_crm                         ),\n    .i_copro_num                        ( copro_num                         ),\n    .i_copro_operation                  ( copro_operation                   ),\n    .i_copro_write_data                 ( copro_write_data                  ),\n    .i_fault                            ( decode_fault                      ),\n    .i_fault_status                     ( decode_fault_status               ),\n    .i_fault_address                    ( decode_fault_address              ), \n    .o_copro_read_data                  ( copro_read_data                   ),\n    .o_cache_enable                     ( cache_enable                      ),\n    .o_cache_flush                      ( cache_flush                       ),\n    .o_cacheable_area                   ( cacheable_area                    )\n);\n\nendmodule"}
{"task_id": 731, "completion": "wire and0_out;\n    wire or0_out_X;\n    wire pwrgood_pp0_out_X;\n\n    and and0 (and0_out, A1, A2);\n    or  or0  (or0_out_X, and0_out, B1);\n    sky130_fd_sc_ls__udp_pwrgood_pp$PG pwrgood_pp0 (pwrgood_pp0_out_X, or0_out_X, VPWR, VGND);\n    buf buf0 (X, pwrgood_pp0_out_X);\n\nendmodule"}
{"task_id": 766, "completion": "output Y   ;\n    input  A_N ;\n    input  B   ;\n    input  VPWR;\n    input  VGND;\n    input  VPB ;\n    input  VNB ;\n    sky130_fd_sc_ls__nand2b base (\n        .Y(Y),\n        .A_N(A_N),\n        .B(B),\n        .VPWR(VPWR),\n        .VGND(VGND),\n        .VPB(VPB),\n        .VNB(VNB)\n    );\n\nendmodule"}
{"task_id": 154, "completion": "parameter CL_M_COUNT = $clog2(M_COUNT);reg [CL_M_COUNT-1:0] select_reg = {CL_M_COUNT{1'b0}}, select_ctl, select_next;reg drop_reg = 1'b0, drop_ctl, drop_next;reg frame_reg = 1'b0, frame_ctl, frame_next;reg s_ip_hdr_ready_reg = 1'b0, s_ip_hdr_ready_next;reg s_ip_payload_axis_tready_reg = 1'b0, s_ip_payload_axis_tready_next;reg [M_COUNT-1:0] m_ip_hdr_valid_reg = 0, m_ip_hdr_valid_next;reg [47:0] m_eth_dest_mac_reg = 48'd0, m_eth_dest_mac_next;reg [47:0] m_eth_src_mac_reg = 48'd0, m_eth_src_mac_next;reg [15:0] m_eth_type_reg = 16'd0, m_eth_type_next;reg [3:0]  m_ip_version_reg = 4'd0, m_ip_version_next;reg [3:0]  m_ip_ihl_reg = 4'd0, m_ip_ihl_next;reg [5:0]  m_ip_dscp_reg = 6'd0, m_ip_dscp_next;reg [1:0]  m_ip_ecn_reg = 2'd0, m_ip_ecn_next;reg [15:0] m_ip_length_reg = 16'd0, m_ip_length_next;reg [15:0] m_ip_identification_reg = 16'd0, m_ip_identification_next;reg [2:0]  m_ip_flags_reg = 3'd0, m_ip_flags_next;reg [12:0] m_ip_fragment_offset_reg = 13'd0, m_ip_fragment_offset_next;reg [7:0]  m_ip_ttl_reg = 8'd0, m_ip_ttl_next;reg [7:0]  m_ip_protocol_reg = 8'd0, m_ip_protocol_next;reg [15:0] m_ip_header_checksum_reg = 16'd0, m_ip_header_checksum_next;reg [31:0] m_ip_source_ip_reg = 32'd0, m_ip_source_ip_next;reg [31:0] m_ip_dest_ip_reg = 32'd0, m_ip_dest_ip_next;reg  [DATA_WIDTH-1:0] m_ip_payload_axis_tdata_int;reg  [KEEP_WIDTH-1:0] m_ip_payload_axis_tkeep_int;reg  [M_COUNT-1:0]    m_ip_payload_axis_tvalid_int;reg                   m_ip_payload_axis_tready_int_reg = 1'b0;reg                   m_ip_payload_axis_tlast_int;reg  [ID_WIDTH-1:0]   m_ip_payload_axis_tid_int;reg  [DEST_WIDTH-1:0] m_ip_payload_axis_tdest_int;reg  [USER_WIDTH-1:0] m_ip_payload_axis_tuser_int;wire                  m_ip_payload_axis_tready_int_early;assign s_ip_hdr_ready = s_ip_hdr_ready_reg && enable;assign s_ip_payload_axis_tready = s_ip_payload_axis_tready_reg && enable;assign m_ip_hdr_valid = m_ip_hdr_valid_reg;assign m_eth_dest_mac = {M_COUNT{m_eth_dest_mac_reg}};assign m_eth_src_mac = {M_COUNT{m_eth_src_mac_reg}};assign m_eth_type = {M_COUNT{m_eth_type_reg}};assign m_ip_version = {M_COUNT{m_ip_version_reg}};assign m_ip_ihl = {M_COUNT{m_ip_ihl_reg}};assign m_ip_dscp = {M_COUNT{m_ip_dscp_reg}};assign m_ip_ecn = {M_COUNT{m_ip_ecn_reg}};assign m_ip_length = {M_COUNT{m_ip_length_reg}};assign m_ip_identification = {M_COUNT{m_ip_identification_reg}};assign m_ip_flags = {M_COUNT{m_ip_flags_reg}};assign m_ip_fragment_offset = {M_COUNT{m_ip_fragment_offset_reg}};assign m_ip_ttl = {M_COUNT{m_ip_ttl_reg}};assign m_ip_protocol = {M_COUNT{m_ip_protocol_reg}};assign m_ip_header_checksum = {M_COUNT{m_ip_header_checksum_reg}};assign m_ip_source_ip = {M_COUNT{m_ip_source_ip_reg}};assign m_ip_dest_ip = {M_COUNT{m_ip_dest_ip_reg}};integer i;always @* begin; select_next = select_reg; select_ctl = select_reg; drop_next = drop_reg; drop_ctl = drop_reg; frame_next = frame_reg; frame_ctl = frame_reg; s_ip_hdr_ready_next = 1'b0; s_ip_payload_axis_tready_next = 1'b0; m_ip_hdr_valid_next = m_ip_hdr_valid_reg & ~m_ip_hdr_ready; m_eth_dest_mac_next = m_eth_dest_mac_reg; m_eth_src_mac_next = m_eth_src_mac_reg; m_eth_type_next = m_eth_type_reg; m_ip_version_next = m_ip_version_reg; m_ip_ihl_next = m_ip_ihl_reg; m_ip_dscp_next = m_ip_dscp_reg; m_ip_ecn_next = m_ip_ecn_reg; m_ip_length_next = m_ip_length_reg; m_ip_identification_next = m_ip_identification_reg; m_ip_flags_next = m_ip_flags_reg; m_ip_fragment_offset_next = m_ip_fragment_offset_reg; m_ip_ttl_next = m_ip_ttl_reg; m_ip_protocol_next = m_ip_protocol_reg; m_ip_header_checksum_next = m_ip_header_checksum_reg; m_ip_source_ip_next = m_ip_source_ip_reg; m_ip_dest_ip_next = m_ip_dest_ip_reg; if (s_ip_payload_axis_tvalid && s_ip_payload_axis_tready) begin; if (s_ip_payload_axis_tlast) begin; frame_next = 1'b0; drop_next = 1'b0; end; end; if (!frame_reg && s_ip_hdr_valid && s_ip_hdr_ready) begin; select_ctl = select; drop_ctl = drop; frame_ctl = 1'b1; select_next = select_ctl; drop_next = drop_ctl; frame_next = frame_ctl; s_ip_hdr_ready_next = 1'b0; m_ip_hdr_valid_next = (!drop_ctl) << select_ctl; m_eth_dest_mac_next = s_eth_dest_mac; m_eth_src_mac_next = s_eth_src_mac; m_eth_type_next = s_eth_type; m_ip_version_next = s_ip_version; m_ip_ihl_next = s_ip_ihl; m_ip_dscp_next = s_ip_dscp; m_ip_ecn_next = s_ip_ecn; m_ip_length_next = s_ip_length; m_ip_identification_next = s_ip_identification; m_ip_flags_next = s_ip_flags; m_ip_fragment_offset_next = s_ip_fragment_offset; m_ip_ttl_next = s_ip_ttl; m_ip_protocol_next = s_ip_protocol; m_ip_header_checksum_next = s_ip_header_checksum; m_ip_source_ip_next = s_ip_source_ip; m_ip_dest_ip_next = s_ip_dest_ip; end; s_ip_hdr_ready_next = !frame_next && !m_ip_hdr_valid_next; s_ip_payload_axis_tready_next = (m_ip_payload_axis_tready_int_early || drop_ctl) && frame_ctl; m_ip_payload_axis_tdata_int  = s_ip_payload_axis_tdata; m_ip_payload_axis_tkeep_int  = s_ip_payload_axis_tkeep; m_ip_payload_axis_tvalid_int = (s_ip_payload_axis_tvalid && s_ip_payload_axis_tready && !drop_ctl) << select_ctl; m_ip_payload_axis_tlast_int  = s_ip_payload_axis_tlast; m_ip_payload_axis_tid_int    = s_ip_payload_axis_tid; m_ip_payload_axis_tdest_int  = s_ip_payload_axis_tdest; m_ip_payload_axis_tuser_int  = s_ip_payload_axis_tuser; end; always @(posedge clk) begin; if (rst) begin; select_reg <= 2'd0; drop_reg <= 1'b0; frame_reg <= 1'b0; s_ip_hdr_ready_reg <= 1'b0; s_ip_payload_axis_tready_reg <= 1'b0; m_ip_hdr_valid_reg <= 0; end else begin; select_reg <= select_next; drop_reg <= drop_next; frame_reg <= frame_next; s_ip_hdr_ready_reg <= s_ip_hdr_ready_next; s_ip_payload_axis_tready_reg <= s_ip_payload_axis_tready_next; m_ip_hdr_valid_reg <= m_ip_hdr_valid_next; end; m_eth_dest_mac_reg <= m_eth_dest_mac_next; m_eth_src_mac_reg <= m_eth_src_mac_next; m_eth_type_reg <= m_eth_type_next; m_ip_version_reg <= m_ip_version_next; m_ip_ihl_reg <= m_ip_ihl_next; m_ip_dscp_reg <= m_ip_dscp_next; m_ip_ecn_reg <= m_ip_ecn_next; m_ip_length_reg <= m_ip_length_next; m_ip_identification_reg <= m_ip_identification_next; m_ip_flags_reg <= m_ip_flags_next; m_ip_fragment_offset_reg <= m_ip_fragment_offset_next; m_ip_ttl_reg <= m_ip_ttl_next; m_ip_protocol_reg <= m_ip_protocol_next; m_ip_header_checksum_reg <= m_ip_header_checksum_next; m_ip_source_ip_reg <= m_ip_source_ip_next; m_ip_dest_ip_reg <= m_ip_dest_ip_next; end; reg [DATA_WIDTH-1:0] m_ip_payload_axis_tdata_reg  = {DATA_WIDTH{1'b0}};reg [KEEP_WIDTH-1:0] m_ip_payload_axis_tkeep_reg  = {KEEP_WIDTH{1'b0}};reg [M_COUNT-1:0]    m_ip_payload_axis_tvalid_reg = {M_COUNT{1'b0}}, m_ip_payload_axis_tvalid_next;reg                  m_ip_payload_axis_tlast_reg  = 1'b0;reg [ID_WIDTH-1:0]   m_ip_payload_axis_tid_reg    = {ID_WIDTH{1'b0}};reg [DEST_WIDTH-1:0] m_ip_payload_axis_tdest_reg  = {DEST_WIDTH{1'b0}};reg [USER_WIDTH-1:0] m_ip_payload_axis_tuser_reg  = {USER_WIDTH{1'b0}};reg [DATA_WIDTH-1:0] temp_m_ip_payload_axis_tdata_reg  = {DATA_WIDTH{1'b0}};reg [KEEP_WIDTH-1:0] temp_m_ip_payload_axis_tkeep_reg  = {KEEP_WIDTH{1'b0}};reg [M_COUNT-1:0]    temp_m_ip_payload_axis_tvalid_reg = {M_COUNT{1'b0}}, temp_m_ip_payload_axis_tvalid_next;reg                  temp_m_ip_payload_axis_tlast_reg  = 1'b0;reg [ID_WIDTH-1:0]   temp_m_ip_payload_axis_tid_reg    = {ID_WIDTH{1'b0}};reg [DEST_WIDTH-1:0] temp_m_ip_payload_axis_tdest_reg  = {DEST_WIDTH{1'b0}};reg [USER_WIDTH-1:0] temp_m_ip_payload_axis_tuser_reg  = {USER_WIDTH{1'b0}};reg store_axis_int_to_output;reg store_axis_int_to_temp;reg store_ip_payload_axis_temp_to_output;assign m_ip_payload_axis_tdata  = {M_COUNT{m_ip_payload_axis_tdata_reg}};assign m_ip_payload_axis_tkeep  = KEEP_ENABLE ? {M_COUNT{m_ip_payload_axis_tkeep_reg}} : {M_COUNT*KEEP_WIDTH{1'b1}};assign m_ip_payload_axis_tvalid = m_ip_payload_axis_tvalid_reg;assign m_ip_payload_axis_tlast  = {M_COUNT{m_ip_payload_axis_tlast_reg}};assign m_ip_payload_axis_tid    = ID_ENABLE   ? {M_COUNT{m_ip_payload_axis_tid_reg}}   : {M_COUNT*ID_WIDTH{1'b0}};assign m_ip_payload_axis_tdest  = DEST_ENABLE ? {M_COUNT{m_ip_payload_axis_tdest_reg}} : {M_COUNT*DEST_WIDTH{1'b0}};assign m_ip_payload_axis_tuser  = USER_ENABLE ? {M_COUNT{m_ip_payload_axis_tuser_reg}} : {M_COUNT*USER_WIDTH{1'b0}};assign m_ip_payload_axis_tready_int_early = (m_ip_payload_axis_tready & m_ip_payload_axis_tvalid) || (!temp_m_ip_payload_axis_tvalid_reg && (!m_ip_payload_axis_tvalid || !m_ip_payload_axis_tvalid_int));always @* begin; m_ip_payload_axis_tvalid_next = m_ip_payload_axis_tvalid_reg; temp_m_ip_payload_axis_tvalid_next = temp_m_ip_payload_axis_tvalid_reg; store_axis_int_to_output = 1'b0; store_axis_int_to_temp = 1'b0; store_ip_payload_axis_temp_to_output = 1'b0; if (m_ip_payload_axis_tready_int_reg) begin; if ((m_ip_payload_axis_tready & m_ip_payload_axis_tvalid) || !m_ip_payload_axis_tvalid) begin; m_ip_payload_axis_tvalid_next = m_ip_payload_axis_tvalid_int; store_axis_int_to_output = 1'b1; end else begin; temp_m_ip_payload_axis_tvalid_next = m_ip_payload_axis_tvalid_int; store_axis_int_to_temp = 1'b1; end; end else if (m_ip_payload_axis_tready & m_ip_payload_axis_tvalid) begin; m_ip_payload_axis_tvalid_next = temp_m_ip_payload_axis_tvalid_reg; temp_m_ip_payload_axis_tvalid_next = 1'b0; store_ip_payload_axis_temp_to_output = 1'b1; end; endalways @(posedge clk) begin; if (rst) begin; m_ip_payload_axis_tvalid_reg <= {M_COUNT{1'b0}}; m_ip_payload_axis_tready_int_reg <= 1'b0; temp_m_ip_payload_axis_tvalid_reg <= 1'b0; end else begin; m_ip_payload_axis_tvalid_reg <= m_ip_payload_axis_tvalid_next; m_ip_payload_axis_tready_int_reg <= m_ip_payload_axis_tready_int_early; temp_m_ip_payload_axis_tvalid_reg <= temp_m_ip_payload_axis_tvalid_next; end; if (store_axis_int_to_output) begin; m_ip_payload_axis_tdata_reg <= m_ip_payload_axis_tdata_int; m_ip_payload_axis_tkeep_reg <= m_ip_payload_axis_tkeep_int; m_ip_payload_axis_tlast_reg <= m_ip_payload_axis_tlast_int; m_ip_payload_axis_tid_reg   <= m_ip_payload_axis_tid_int; m_ip_payload_axis_tdest_reg <= m_ip_payload_axis_tdest_int; m_ip_payload_axis_tuser_reg <= m_ip_payload_axis_tuser_int; end else if (store_ip_payload_axis_temp_to_output) begin; m_ip_payload_axis_tdata_reg <= temp_m_ip_payload_axis_tdata_reg; m_ip_payload_axis_tkeep_reg <= temp_m_ip_payload_axis_tkeep_reg; m_ip_payload_axis_tlast_reg <= temp_m_ip_payload_axis_tlast_reg; m_ip_payload_axis_tid_reg   <= temp_m_ip_payload_axis_tid_reg; m_ip_payload_axis_tdest_reg <= temp_m_ip_payload_axis_tdest_reg; m_ip_payload_axis_tuser_reg <= temp_m_ip_payload_axis_tuser_reg; end if (store_axis_int_to_temp) begin; temp_m_ip_payload_axis_tdata_reg <= m_ip_payload_axis_tdata_int; temp_m_ip_payload_axis_tkeep_reg <= m_ip_payload_axis_tkeep_int; temp_m_ip_payload_axis_tlast_reg <= m_ip_payload_axis_tlast_int; temp_m_ip_payload_axis_tid_reg   <= m_ip_payload_axis_tid_int; temp_m_ip_payload_axis_tdest_reg <= m_ip_payload_axis_tdest_int; temp_m_ip_payload_axis_tuser_reg <= m_ip_payload_axis_tuser_int; end; endendmodule"}
{"task_id": 757, "completion": "reg [23:0] cnt_reg = 24'd0;\n\n    reg [N-1:0] debounce_reg[WIDTH-1:0];\n\n    reg [WIDTH-1:0] state;\n\n    assign out = state;\n\n    integer k;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            cnt_reg <= 0;\n            state <= 0;\n\n            for (k = 0; k < WIDTH; k = k + 1) begin\n                debounce_reg[k] <= 0;\n            end\n        end else begin\n            if (cnt_reg < RATE) begin\n                cnt_reg <= cnt_reg + 24'd1;\n            end else begin\n                cnt_reg <= 24'd0;\n            end\n\n            if (cnt_reg == 24'd0) begin\n                for (k = 0; k < WIDTH; k = k + 1) begin\n                    debounce_reg[k] <= {debounce_reg[k][N-2:0], in[k]};\n                end\n            end\n\n            for (k = 0; k < WIDTH; k = k + 1) begin\n                if (|debounce_reg[k] == 0) begin\n                    state[k] <= 0;\n                end else if (&debounce_reg[k] == 1) begin\n                    state[k] <= 1;\n                end else begin\n                    state[k] <= state[k];\n                end\n            end\n        end\n    end\n\nendmodule"}
{"task_id": 722, "completion": "endmodule"}
{"task_id": 240, "completion": "`include\"ftl_define.v\"    input reset;    input clk;    input ssd_command_fifo_empty_or_not;    input [COMMAND_WIDTH-1:0] ssd_command_fifo_out;    input dram_permit;    input [DRAM_IO_WIDTH-1:0] data_from_dram;    input dram_ready;    input rd_data_valid;    input [GC_COMMAND_WIDTH-1:0] gc_command_fifo_out;    input gc_command_fifo_empty_or_not;    input [7:0] command_available;    input register_ready;    output ssd_command_fifo_out_en;    output [COMMAND_WIDTH-1:0] controller_command_fifo_in;    output [7:0] controller_command_fifo_in_en;    output [DRAM_IO_WIDTH-1:0] write_data_fifo_in;    output [7:0] write_data_fifo_in_en;    output dram_request;    output release_dram;    output [DRAM_ADDR_WIDTH-1:0] addr_to_dram;    output [DRAM_IO_WIDTH-1:0]data_to_dram;    output [DRAM_MASK_WIDTH-1:0]dram_data_mask;    output dram_en;    output dram_read_or_write;    output data_to_dram_en;    output data_to_dram_end;    input  data_to_dram_ready;    output gc_command_fifo_out_en;    inout [18:0]flash_left_capacity;    inout [127:0] free_block_fifo_tails;    inout [127:0] free_block_fifo_heads;    output [4:0] state;    reg ssd_command_fifo_out_en;    reg request_for_addr_management_en;    reg [1:0] request_for_addr_management_op;    reg [27:0] laddr_to_addr_management;    reg [COMMAND_WIDTH-1:0] controller_command_fifo_in;    reg [7:0] controller_command_fifo_in_en;    reg [DRAM_IO_WIDTH-1:0] write_data_fifo_in;    reg [7:0] write_data_fifo_in_en;    reg dram_request;    reg release_dram;    reg gc_command_fifo_out_en;    wire [18:0]flash_left_capacity;    wire [127:0] free_block_fifo_tails;    wire [127:0] free_block_fifo_heads;    wire register_ready;    wire [DRAM_ADDR_WIDTH-1:0] addr_to_dram;    wire [DRAM_IO_WIDTH-1:0]data_to_dram;    wire [DRAM_MASK_WIDTH-1:0]dram_data_mask;    wire dram_en;    wire dram_read_or_write;    wire [DRAM_ADDR_WIDTH-1:0] addr_to_dram_addr;    wire [DRAM_IO_WIDTH-1:0]data_to_dram_addr;    wire dram_en_addr;    wire dram_read_or_write_addr;    wire [DRAM_MASK_WIDTH-1:0]dram_data_mask_addr;    wire data_to_dram_en_addr;    wire data_to_dram_end_addr;    reg [DRAM_ADDR_WIDTH-1:0] addr_to_dram_io;    reg [DRAM_IO_WIDTH-1:0]data_to_dram_io;    reg dram_en_io;    reg dram_read_or_write_io;    reg [DRAM_MASK_WIDTH-1:0]dram_data_mask_io;    reg data_to_dram_en_io;    reg data_to_dram_end_io;    wire addr_manage_dram_busy;    assign dram_en=(addr_manage_dram_busy)?dram_en_addr:dram_en_io;    assign dram_read_or_write=(addr_manage_dram_busy)?dram_read_or_write_addr:dram_read_or_write_io;    assign addr_to_dram=(addr_manage_dram_busy)?addr_to_dram_addr:addr_to_dram_io;    assign data_to_dram=(addr_manage_dram_busy)?data_to_dram_addr:data_to_dram_io;    assign dram_data_mask=(addr_manage_dram_busy)?dram_data_mask_addr:dram_data_mask_io;    assign data_to_dram_en=(addr_manage_dram_busy)?data_to_dram_en_addr:data_to_dram_en_io;    assign data_to_dram_end=(addr_manage_dram_busy)?data_to_dram_end_addr:data_to_dram_end_io;    wire [PHYSICAL_ADDR_WIDTH-1:0] paddr0_from_addr_management;    wire [PHYSICAL_ADDR_WIDTH-1:0] paddr1_from_addr_management;    wire addr_management_ready;    parameter IDLE =5'b00000;    parameter WAIT_DRAM_FOR_IO =5'b00001;    parameter IO_COMMAND_INTERPRET =5'b00010;    parameter GET_PHYSICAL_ADDRESS_FOR_READ =5'b00011;    parameter WAIT_PADDR_FOR_READ =5'b00100;    parameter GENERATE_READ_COMMAND =5'b00101;    parameter GET_PHYSICAL_ADDRESS_FOR_WRITE =5'b00110;    parameter WAIT_PADDR_FOR_WRITE =5'b00111;    parameter GENERATE_WRITE_COMMAND =5'b01000;    parameter WAIT_DRAM_FOR_GC =5'b01001;    parameter GC_COMMAND_INTERPRET =5'b01010;    parameter MOVE_COMMAND =5'b01011;    parameter WAIT_PADDRS_FOR_MOVE =5'b01100;    parameter GENERATE_MOVE_COMMAND =5'b01101;    parameter ERASE_COMMAND =5'b01110;    parameter WAIT_FOR_ERASE =5'b01111;    parameter CHIP_SELECT =5'b10000;    parameter CHECK_FULL_SIGNAL =5'b10001;    parameter TRANSMIT_WRITE_DATA =5'b10010;    parameter GET_DATA_FROM_DRAM0 =5'b10011;    parameter GET_DATA_FROM_DRAM1 =5'b10100;    parameter GET_DATA_FROM_DRAM2 =5'b10101;    parameter SEND_CONTROLLER_COMMAND =5'b10110;    parameter UNLOCK_DRAM_FOR_A_WHILE =5'b10111;    parameter WAIT_DRAM_FOR_A_WHILE =5'b11000;    parameter CHANCG_TO_STATE_BUF =5'b11001;    parameter UNLOCK_DRAM =5'b11010;    parameter FINISH =5'b11111;    reg [COMMAND_WIDTH-1:0] ssd_command;    reg [PHYSICAL_ADDR_WIDTH-1:0] paddr;    reg [4:0] state;    reg [4:0] state_buf;    reg [PHYSICAL_ADDR_WIDTH-1:0] target_paddr;    reg [COMMAND_WIDTH-1:0] controller_command;    reg command_fifo_available;    reg [7:0] enable;    reg [31:0] count;    reg [10:0] count_read;    reg io_or_gc;    reg [DRAM_ADDR_WIDTH-1:0] dram_addr;    reg [GC_COMMAND_WIDTH-1:0] gc_command;    always@ (negedge reset or posedge clk)    begin        if(!reset)        begin            ssd_command_fifo_out_en <=0;            request_for_addr_management_en<=0;            request_for_addr_management_op<=0;            laddr_to_addr_management <=0;            controller_command_fifo_in <=0;            controller_command_fifo_in_en <=0;            write_data_fifo_in <=0;            write_data_fifo_in_en <=0;            dram_request <=0;            release_dram <=0;            gc_command_fifo_out_en <=0;            addr_to_dram_io <=0;            data_to_dram_io <=0;            dram_en_io <=0;            dram_read_or_write_io <=0;            dram_data_mask_io <=0;            ssd_command <=0;            paddr <=0;            state <=0;            state_buf <=0;            target_paddr <=0;            controller_command <=0;            command_fifo_available <=0;            enable <=0;            count <=0;            count_read <=0;            io_or_gc <=0;            dram_addr <=0;            gc_command <=0;            data_to_dram_en_io <=0;            data_to_dram_end_io <=0;        end        else        begin            case (state)                IDLE:                begin                    if(ssd_command_fifo_empty_or_not==0 && (&(command_available)))                    begin                        ssd_command_fifo_out_en <= 1;                        ssd_command <= ssd_command_fifo_out;                        io_or_gc <= 1;                        dram_request <= 1;                        state <= WAIT_DRAM_FOR_IO;                    end                    else if(gc_command_fifo_empty_or_not==0)                    begin                        gc_command_fifo_out_en <= 1;                        gc_command <= gc_command_fifo_out;                        io_or_gc <= 0;                        dram_request <= 1;                        state <= WAIT_DRAM_FOR_GC;                    end                    else                        state <= IDLE;                end                WAIT_DRAM_FOR_IO:                begin                    ssd_command_fifo_out_en <= 0;                    if(dram_permit==1)            {            dram_request <= 0;            state <= IO_COMMAND_INTERPRET;        end                    else state <= WAIT_DRAM_FOR_IO;                end                IO_COMMAND_INTERPRET:                begin                    case(ssd_command[127:126])                    1'b00:                        state <= GET_PHYSICAL_ADDRESS_FOR_READ;                    1'b01:                        state <= GET_PHYSICAL_ADDRESS_FOR_WRITE;                    default: state <= IDLE;                    endcase                end                GET_PHYSICAL_ADDRESS_FOR_READ:                begin                    request_for_addr_management_en <= 1;                    request_for_addr_management_op <= READ;                    laddr_to_addr_management <= ssd_command[27:0];                    state <= WAIT_PADDR_FOR_READ;                end                WAIT_PADDR_FOR_READ:                begin                    request_for_addr_management_en <= 0;                    if(addr_management_ready==1)                    begin                        paddr <= paddr0_from_addr_management;                        state <= GENERATE_READ_COMMAND;                    end                    else state <= WAIT_PADDR_FOR_READ;                end                GENERATE_READ_COMMAND:                begin                    controller_command <= {ssd_command[127:89],1'b0,paddr[23:0],ssd_command[63:32],ssd_command[31:0]};                    state <= CHIP_SELECT;                end                GET_PHYSICAL_ADDRESS_FOR_WRITE:                begin                    request_for_addr_management_en <= 1;                    request_for_addr_management_op <= WRITE;                    laddr_to_addr_management <= ssd_command[27:0];                    state <= WAIT_PADDR_FOR_WRITE;                end                WAIT_PADDR_FOR_WRITE:                begin                    request_for_addr_management_en <= 0;                    if(addr_management_ready==1)                    begin                        paddr <= paddr1_from_addr_management;                        state <= GENERATE_WRITE_COMMAND;                    end                    else state <= WAIT_PADDR_FOR_WRITE;                end                GENERATE_WRITE_COMMAND:                begin                    controller_command <= {WRITE,ssd_command[125], 36'b0,1'b0, paddr[23:0],ssd_command[63:32],ssd_command[31:0]};                    state <= CHIP_SELECT;                end                WAIT_DRAM_FOR_GC:                begin                    gc_command_fifo_out_en <= 0;                    if(dram_permit==1)                    begin                        dram_request <= 0;                        state <= GC_COMMAND_INTERPRET;                    end                    else state <= WAIT_DRAM_FOR_GC ;                end                GC_COMMAND_INTERPRET:                begin                    if(gc_command[28]==0)                        state <= MOVE_COMMAND;                    else                        state <= ERASE_COMMAND;                end                MOVE_COMMAND:                begin                    request_for_addr_management_en <= 1;                    request_for_addr_management_op <= MOVE;                    laddr_to_addr_management <= gc_command[27:0];                    state <= WAIT_PADDRS_FOR_MOVE;                end                WAIT_PADDRS_FOR_MOVE:                begin                    request_for_addr_management_en <= 0;                    if(addr_management_ready==1)                    begin                        paddr <= paddr0_from_addr_management;                        target_paddr <= paddr1_from_addr_management;                        state <= GENERATE_MOVE_COMMAND;                    end                    else state <= WAIT_PADDRS_FOR_MOVE;                end                GENERATE_MOVE_COMMAND:                begin                    controller_command <= {MOVE, 62'b0,5'b0, target_paddr, 5'b0,paddr};                    state <= CHIP_SELECT;                end                ERASE_COMMAND:                begin                    request_for_addr_management_en <= 1;                    request_for_addr_management_op <= ERASE;                    laddr_to_addr_management <= gc_command[27:0];                    state <= WAIT_FOR_ERASE;                end                WAIT_FOR_ERASE:                begin                    request_for_addr_management_en <= 0;                    paddr <= gc_command[23:0];                    controller_command <= {ERASE,101'b0 , gc_command[24:0]};                    state <= CHIP_SELECT;                end                CHIP_SELECT:                begin                    case (paddr[26:24])                        3'b000:                        begin                            command_fifo_available <= command_available[0];                            enable <= 8'b00000001;                        end                        3'b001:                        begin                            command_fifo_available <= command_available[1];                            enable <= 8'b00000010;                        end                        3'b010:                        begin                            command_fifo_available <= command_available[2];                            enable <= 8'b00000100;                        end                        3'b011:                        begin                            command_fifo_available <= command_available[3];                            enable <= 8'b00001000;                        end                        3'b100:                        begin                            command_fifo_available <= command_available[4];                            enable <= 8'b00010000;                        end                        3'b101:                        begin                            command_fifo_available <= command_available[5];                            enable <= 8'b00100000;                        end                        3'b110:                        begin                            command_fifo_available <= command_available[6];                            enable <= 8'b01000000;                        end                        3'b111:                        begin                            command_fifo_available <= command_available[7];                            enable <= 8'b10000000;                        end                    endcase        state <= CHECK_FULL_SIGNAL;                end                CHECK_FULL_SIGNAL:                begin                    if(io_or_gc==1 && controller_command[127:126] !=WRITE && command_fifo_available)                        state <= SEND_CONTROLLER_COMMAND;                    else if(io_or_gc==1 && controller_command[127:126]==WRITE  && command_fifo_available)                    begin                        if(ssd_command[125])  //dram_addr <= CACHE_BASE + {ssd_command[48:32],11'b000_00000000};                            dram_addr <= CACHE_BASE + {ssd_command[50:32],9'b0_00000000};                        else //in additional cache                            dram_addr <= ADDITIONAL_CACHE_FIFO_BASE + {ssd_command[50:32],9'b0_00000000};                            state <= SEND_CONTROLLER_COMMAND;                    end                    else                    begin                state <= UNLOCK_DRAM_FOR_A_WHILE;                state_buf <= CHIP_SELECT;            end                end                TRANSMIT_WRITE_DATA:                begin                    controller_command_fifo_in_en <= 0;                    state <= GET_DATA_FROM_DRAM0;                    dram_en_io <= 1;                    dram_read_or_write_io <= 1; //read                    addr_to_dram_io <= dram_addr;                    count<=0;                    count_read<=0;                end                GET_DATA_FROM_DRAM0:                begin                    write_data_fifo_in_en<=0;                    if(rd_data_valid)                    begin                        write_data_fifo_in_en <= enable;                        write_data_fifo_in <= data_from_dram;                        count_read<=count_read+1;                    end                    if(dram_ready)                    begin                        dram_en_io <= 0;                        dram_addr <= dram_addr+8;                        count <= count+1;                        state<=GET_DATA_FROM_DRAM1;                    end                end                GET_DATA_FROM_DRAM1:                begin                    write_data_fifo_in_en<=0;                    if(rd_data_valid)                    begin                        write_data_fifo_in_en <= enable;                        write_data_fifo_in <= data_from_dram;                        count_read<=count_read+1;                    end                    if(count>=DRAM_COUNT)                    begin                        state <= GET_DATA_FROM_DRAM2;                    end                    else                    begin                        state <= GET_DATA_FROM_DRAM0;                        dram_en_io <= 1;                        dram_read_or_write_io <= 1; //read                        addr_to_dram_io <= dram_addr;                    end                end                GET_DATA_FROM_DRAM2:                begin                    write_data_fifo_in_en<=0;                    if(rd_data_valid)                    begin                        write_data_fifo_in_en <= enable;                        write_data_fifo_in <= data_from_dram;                        count_read<=count_read+1;                    end                    else begin end                    if(count_read>=DRAM_COUNT*2)                    begin                        state <= UNLOCK_DRAM;                        count<=0;                        count_read<=0;                    end                end                SEND_CONTROLLER_COMMAND:                begin                    controller_command_fifo_in <= controller_command;                    controller_command_fifo_in_en <= enable;                    if(controller_command[127:126]==WRITE)                        state <= TRANSMIT_WRITE_DATA;                    else                        state <= UNLOCK_DRAM;                end                UNLOCK_DRAM_FOR_A_WHILE:                begin                    release_dram <= 1;                    count <= 0;                    controller_command_fifo_in_en <= 0;                    state <= WAIT_DRAM_FOR_A_WHILE;                end                WAIT_DRAM_FOR_A_WHILE:                begin                    release_dram <= 0;                    if(count>=63)                    begin                        dram_request <= 1;                        count<=0;                        state <= CHANCG_TO_STATE_BUF;                    end                    else                    begin                        count <= count+1;                        state<=WAIT_DRAM_FOR_A_WHILE;                    end                end                CHANCG_TO_STATE_BUF:                begin                    if(dram_permit)                    begin                        dram_request <= 0;                        state <= state_buf;                    end                    else                        state<=CHANCG_TO_STATE_BUF;                end                UNLOCK_DRAM:                begin                    release_dram <= 1;                    controller_command_fifo_in_en <= 0;                    state <= FINISH;                end                FINISH:                begin                    release_dram <= 0;                    state <= IDLE;                end            default: state <= IDLE;        endcase    end    address_management addr_management_instance(        .reset(reset),        .clk(clk),        .request_coming(request_for_addr_management_en),        .request_op(request_for_addr_management_op),        .addr_to_addr_management(laddr_to_addr_management),        .data_from_dram(data_from_dram),        .dram_ready(dram_ready),        .rd_data_valid(rd_data_valid),        .paddr0_from_addr_management(paddr0_from_addr_management),        .paddr1_from_addr_management(paddr1_from_addr_management),        .addr_management_ready(addr_management_ready),        .dram_en_o(dram_en_addr),        .dram_read_or_write(dram_read_or_write_addr),        .addr_to_dram_o(addr_to_dram_addr),        .data_to_dram(data_to_dram_addr),        .dram_data_mask(dram_data_mask_addr),        .data_to_dram_en(data_to_dram_en_addr),        .data_to_dram_end(data_to_dram_end_addr),        .data_to_dram_ready(data_to_dram_ready),        .addr_manage_dram_busy(addr_manage_dram_busy),        .flash_left_capacity_io(flash_left_capacity),        .free_block_fifo_heads_io(free_block_fifo_heads),        .free_block_fifo_tails_io(free_block_fifo_tails),        .register_ready(register_ready)    );    endmodule"}
{"task_id": 664, "completion": "reg [1:0] b_state;\n\n\tlocalparam PL_STT_IDLE = 2'h0;\n\tlocalparam PL_STT_REQ = 2'h1;\n\tlocalparam PL_STT_WAIT = 2'h2;\n\t\n\twire condition_start_load_store = iPREV_VALID && iPREV_EX_LDST && iSTATE_NORMAL && !iNEXT_BUSY;\n\twire condition_req_load_store = ((b_state == PL_STT_IDLE) && condition_start_load_store) || (b_state == PL_STT_REQ);\n\t\n\talways@(posedge iCLOCK or negedge inRESET)begin\n\t\tif(!inRESET)begin\n\t\t\tb_state <= PL_STT_IDLE;\n\t\tend\n\t\telse if(iRESET_SYNC || iEVENT_HOLD || iEVENT_END)begin\n\t\t\tb_state <= PL_STT_IDLE;\n\t\tend\n\t\telse begin\n\t\t\tcase(b_state)\n\t\t\t\tPL_STT_IDLE:\n\t\t\t\t\tbegin\n\t\t\t\t\t\tif(condition_start_load_store)begin\n\t\t\t\t\t\t\tb_state <= PL_STT_REQ;\n\t\t\t\t\t\tend\n\t\t\t\t\tend\n\t\t\t\tPL_STT_REQ:\n\t\t\t\t\tbegin\n\t\t\t\t\t\tif(!iLDST_BUSY)begin\n\t\t\t\t\t\t\tb_state <= PL_STT_WAIT;\n\t\t\t\t\t\tend\n\t\t\t\t\tend\n\t\t\t\tPL_STT_WAIT:\n\t\t\t\t\tbegin\n\t\t\t\t\t\tif(iLDST_VALID)begin\n\t\t\t\t\t\t\tb_state <= PL_STT_IDLE;\n\t\t\t\t\t\tend\n\t\t\t\t\tend\n\t\t\t\tdefault:\n\t\t\t\t\tbegin\n\t\t\t\t\t\tb_state <= PL_STT_IDLE;\n\t\t\t\t\tend\n\t\t\tendcase\n\t\tend\n\tend\n\t\n\treg b_spr_valid;\n\treg [31:0] b_spr;\n\treg [1:0] b_shift;\n\treg [3:0] b_mask;\n\n\talways@(posedge iCLOCK or negedge inRESET)begin\n\t\tif(!inRESET)begin\n\t\t\tb_spr_valid <= 1'b0;\n\t\t\tb_spr <= 32'h0;\n\t\t\tb_shift <= 2'h0;\n\t\t\tb_mask <= 4'h0;\n\t\tend\n\t\telse if(iRESET_SYNC || iEVENT_HOLD || iEVENT_END)begin\n\t\t\tb_spr_valid <= 1'b0;\n\t\t\tb_spr <= 32'h0;\n\t\t\tb_shift <= 2'h0;\n\t\t\tb_mask <= 4'h0;\n\t\tend\n\t\telse begin\n\t\t\tif(condition_start_load_store)begin\t\n\t\t\t\tb_spr_valid <= iPREV_SPR_VALID;\n\t\t\t\tb_spr <= iPREV_SPR;\n\t\t\t\tb_shift <= iPREV_LOAD_SHIFT;\n\t\t\t\tb_mask <= iPREV_LDST_MASK;\n\t\t\tend\n\t\tend\n\tend\n\n\tassign oNEXT_VALID = (b_state == PL_STT_WAIT) && iLDST_VALID;\n\n\tassign oNEXT_SPR_VALID = b_spr_valid;\n\tassign oNEXT_SPR = b_spr;\n\tassign oNEXT_SHIFT = b_shift;\n\tassign oNEXT_MASK = b_mask;\n\n\treg b_ldst_rw;\n\treg [31:0] b_ldst_pdt;\n\treg [31:0] b_ldst_addr;\n\treg [31:0] b_ldst_data;\n\treg [1:0] b_ldst_order;\n\treg [3:0] b_ldst_mask;\n\treg [13:0] b_ldst_asid;\n\treg [1:0] b_ldst_mmumod;\n\treg [2:0] b_ldst_mmups;\n\n\talways@(posedge iCLOCK or negedge inRESET)begin\n\t\tif(!inRESET)begin\n\t\t\tb_ldst_rw <= 1'b0;\n\t\t\tb_ldst_pdt <= 32'h0;\n\t\t\tb_ldst_addr <= 32'h0;\n\t\t\tb_ldst_data <= 32'h0;\n\t\t\tb_ldst_order <= 2'h0;\n\t\t\tb_ldst_mask <= 4'h0;\n\t\t\tb_ldst_asid <= 14'h0;\n\t\t\tb_ldst_mmumod <= 2'h0;\n\t\t\tb_ldst_mmups <= 3'h0;\n\t\tend\n\t\telse if(iRESET_SYNC || iEVENT_HOLD || iEVENT_END)begin\n\t\t\tb_ldst_rw <= 1'b0;\n\t\t\tb_ldst_pdt <= 32'h0;\n\t\t\tb_ldst_addr <= 32'h0;\n\t\t\tb_ldst_data <= 32'h0;\n\t\t\tb_ldst_order <= 2'h0;\n\t\t\tb_ldst_mask <= 4'h0;\n\t\t\tb_ldst_asid <= 14'h0;\n\t\t\tb_ldst_mmumod <= 2'h0;\n\t\t\tb_ldst_mmups <= 3'h0;\n\t\tend\n\t\telse begin\n\t\t\tif(iSTATE_NORMAL)begin\t\n\t\t\t\tif(!iNEXT_BUSY)begin\n\t\t\t\t\tif(iPREV_VALID && iPREV_EX_LDST)begin\n\t\t\t\t\t\tb_ldst_rw <= iPREV_LDST_RW;\n\t\t\t\t\t\tb_ldst_pdt <= iPREV_LDST_PDT;\n\t\t\t\t\t\tb_ldst_addr <= iPREV_LDST_ADDR;\n\t\t\t\t\t\tb_ldst_data <= iPREV_LDST_DATA;\n\t\t\t\t\t\tb_ldst_order <= iPREV_LDST_ORDER;\n\t\t\t\t\t\tb_ldst_mask <= iPREV_LDST_MASK;\n\t\t\t\t\t\tb_ldst_asid <= iPREV_TIDR[31:18];\n\t\t\t\t\t\tb_ldst_mmumod <= iPREV_PSR[1:0];\n\t\t\t\t\t\tb_ldst_mmups <= iPREV_PSR[9:7];\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\n\tassign oLDST_REQ = (b_state == PL_STT_REQ) && !iLDST_BUSY;\n\tassign oLDST_RW = b_ldst_rw;\n\tassign oLDST_PDT = b_ldst_pdt;\n\tassign oLDST_ADDR = b_ldst_addr;\n\tassign oLDST_DATA = b_ldst_data;\n\tassign oLDST_ORDER = b_ldst_order;\n\tassign oLDST_MASK = b_ldst_mask;\n\tassign oLDST_ASID = b_ldst_asid;\n\tassign oLDST_MMUMOD = b_ldst_mmumod;\n\tassign oLDST_MMUPS = b_ldst_mmups;\n\nendmodule"}
{"task_id": 764, "completion": "endmodule"}
{"task_id": 167, "completion": "wire [1:0] fpga_debounced_buttons;  wire [7:0] fpga_led_internal;  wire hps_fpga_reset_n;  wire [2:0] hps_reset_req;  wire hps_cold_reset;  wire hps_warm_reset;  wire hps_debug_reset;  wire [27:0] stm_hw_events;  assign stm_hw_events = {{13{1'b0}},SW, fpga_led_internal, fpga_debounced_buttons};  soc_system u0 ( .clk_clk (FPGA_CLK1_50 ), .reset_reset_n (1'b1 ), .memory_mem_a ( HPS_DDR3_ADDR), .memory_mem_ba ( HPS_DDR3_BA), .memory_mem_ck ( HPS_DDR3_CK_P), .memory_mem_ck_n ( HPS_DDR3_CK_N), .memory_mem_cke ( HPS_DDR3_CKE), .memory_mem_cs_n ( HPS_DDR3_CS_N), .memory_mem_ras_n ( HPS_DDR3_RAS_N), .memory_mem_cas_n ( HPS_DDR3_CAS_N), .memory_mem_we_n ( HPS_DDR3_WE_N), .memory_mem_reset_n ( HPS_DDR3_RESET_N), .memory_mem_dq ( HPS_DDR3_DQ), .memory_mem_dqs ( HPS_DDR3_DQS_P), .memory_mem_dqs_n ( HPS_DDR3_DQS_N), .memory_mem_odt ( HPS_DDR3_ODT), .memory_mem_dm ( HPS_DDR3_DM), .memory_oct_rzqin ( HPS_DDR3_RZQ), .hps_0_hps_io_hps_io_emac1_inst_TX_CLK ( HPS_ENET_GTX_CLK), .hps_0_hps_io_hps_io_emac1_inst_TXD0 ( HPS_ENET_TX_DATA[0] ), .hps_0_hps_io_hps_io_emac1_inst_TXD1 ( HPS_ENET_TX_DATA[1] ), .hps_0_hps_io_hps_io_emac1_inst_TXD2 ( HPS_ENET_TX_DATA[2] ), .hps_0_hps_io_hps_io_emac1_inst_TXD3 ( HPS_ENET_TX_DATA[3] ), .hps_0_hps_io_hps_io_emac1_inst_RXD0 ( HPS_ENET_RX_DATA[0] ), .hps_0_hps_io_hps_io_emac1_inst_MDIO ( HPS_ENET_MDIO ), .hps_0_hps_io_hps_io_emac1_inst_MDC ( HPS_ENET_MDC ), .hps_0_hps_io_hps_io_emac1_inst_RX_CTL ( HPS_ENET_RX_DV), .hps_0_hps_io_hps_io_emac1_inst_TX_CTL ( HPS_ENET_TX_EN), .hps_0_hps_io_hps_io_emac1_inst_RX_CLK ( HPS_ENET_RX_CLK), .hps_0_hps_io_hps_io_emac1_inst_RXD1 ( HPS_ENET_RX_DATA[1] ), .hps_0_hps_io_hps_io_emac1_inst_RXD2 ( HPS_ENET_RX_DATA[2] ), .hps_0_hps_io_hps_io_emac1_inst_RXD3 ( HPS_ENET_RX_DATA[3] ), .hps_0_hps_io_hps_io_sdio_inst_CMD ( HPS_SD_CMD ), .hps_0_hps_io_hps_io_sdio_inst_D0 ( HPS_SD_DATA[0] ), .hps_0_hps_io_hps_io_sdio_inst_D1 ( HPS_SD_DATA[1] ), .hps_0_hps_io_hps_io_sdio_inst_CLK ( HPS_SD_CLK ), .hps_0_hps_io_hps_io_sdio_inst_D2 ( HPS_SD_DATA[2] ), .hps_0_hps_io_hps_io_sdio_inst_D3 ( HPS_SD_DATA[3] ), .hps_0_hps_io_hps_io_usb1_inst_D0 ( HPS_USB_DATA[0] ), .hps_0_hps_io_hps_io_usb1_inst_D1 ( HPS_USB_DATA[1] ), .hps_0_hps_io_hps_io_usb1_inst_D2 ( HPS_USB_DATA[2] ), .hps_0_hps_io_hps_io_usb1_inst_D3 ( HPS_USB_DATA[3] ), .hps_0_hps_io_hps_io_usb1_inst_D4 ( HPS_USB_DATA[4] ), .hps_0_hps_io_hps_io_usb1_inst_D5 ( HPS_USB_DATA[5] ), .hps_0_hps_io_hps_io_usb1_inst_D6 ( HPS_USB_DATA[6] ), .hps_0_hps_io_hps_io_usb1_inst_D7 ( HPS_USB_DATA[7] ), .hps_0_hps_io_hps_io_usb1_inst_CLK ( HPS_USB_CLKOUT ), .hps_0_hps_io_hps_io_usb1_inst_STP ( HPS_USB_STP ), .hps_0_hps_io_hps_io_usb1_inst_DIR ( HPS_USB_DIR ), .hps_0_hps_io_hps_io_usb1_inst_NXT ( HPS_USB_NXT ), .hps_0_hps_io_hps_io_spim1_inst_CLK ( HPS_SPIM_CLK ), .hps_0_hps_io_hps_io_spim1_inst_MOSI ( HPS_SPIM_MOSI ), .hps_0_hps_io_hps_io_spim1_inst_MISO ( HPS_SPIM_MISO ), .hps_0_hps_io_hps_io_spim1_inst_SS0 ( HPS_SPIM_SS ), .hps_0_hps_io_hps_io_uart0_inst_RX ( HPS_UART_RX ), .hps_0_hps_io_hps_io_uart0_inst_TX ( HPS_UART_TX ), .hps_0_hps_io_hps_io_i2c0_inst_SDA ( HPS_I2C0_SDAT ), .hps_0_hps_io_hps_io_i2c0_inst_SCL ( HPS_I2C0_SCLK ), .hps_0_hps_io_hps_io_i2c1_inst_SDA ( HPS_I2C1_SDAT ), .hps_0_hps_io_hps_io_i2c1_inst_SCL ( HPS_I2C1_SCLK ), .hps_0_hps_io_hps_io_gpio_inst_GPIO09 ( HPS_CONV_USB_N ), .hps_0_hps_io_hps_io_gpio_inst_GPIO35 ( HPS_ENET_INT_N ), .hps_0_hps_io_hps_io_gpio_inst_GPIO40 ( HPS_LTC_GPIO ), .hps_0_hps_io_hps_io_gpio_inst_GPIO53 ( HPS_LED ), .hps_0_hps_io_hps_io_gpio_inst_GPIO54 ( HPS_KEY ), .hps_0_hps_io_hps_io_gpio_inst_GPIO61 ( HPS_GSENSOR_INT ), .hps_0_f2h_stm_hw_events_stm_hwevents (stm_hw_events), .hps_0_h2f_reset_reset_n (hps_fpga_reset_n), .hps_0_f2h_warm_reset_req_reset_n (~hps_warm_reset), .hps_0_f2h_debug_reset_req_reset_n (~hps_debug_reset), .hps_0_f2h_cold_reset_req_reset_n (~hps_cold_reset) );  hps_reset hps_reset_inst ( .source_clk (FPGA_CLK1_50), .source (hps_reset_req) );  altera_edge_detector pulse_cold_reset ( .clk (FPGA_CLK1_50), .rst_n (hps_fpga_reset_n), .signal_in (hps_reset_req[0]), .pulse_out (hps_cold_reset) );  defparam pulse_cold_reset.PULSE_EXT = 6;  defparam pulse_cold_reset.EDGE_TYPE = 1;  defparam pulse_cold_reset.IGNORE_RST_WHILE_BUSY = 1;  altera_edge_detector pulse_warm_reset ( .clk (FPGA_CLK1_50), .rst_n (hps_fpga_reset_n), .signal_in (hps_reset_req[1]), .pulse_out (hps_warm_reset) );  defparam pulse_warm_reset.PULSE_EXT = 2;  defparam pulse_warm_reset.EDGE_TYPE = 1;  defparam pulse_warm_reset.IGNORE_RST_WHILE_BUSY = 1;  altera_edge_detector pulse_debug_reset ( .clk (FPGA_CLK1_50), .rst_n (hps_fpga_reset_n), .signal_in (hps_reset_req[2]), .pulse_out (hps_debug_reset) );  defparam pulse_debug_reset.PULSE_EXT = 32;  defparam pulse_debug_reset.EDGE_TYPE = 1;  defparam pulse_debug_reset.IGNORE_RST_WHILE_BUSY = 1;endmodule"}
{"task_id": 659, "completion": "always @(posedge clk)\n  begin\n\n    case(state)\n\n      get_a:\n      begin\n        s_input_a_ack <= 1;\n        if (s_input_a_ack && input_a_stb) begin\n          a <= input_a;\n          s_input_a_ack <= 0;\n          state <= unpack;\n        end\n      end\n\n      unpack:\n      begin\n        z[31] <= a[63];\n        state <= put_z;\n        if (a[62:52] == 0) begin\n            z[30:23] <= 0;\n            z[22:0] <= 0;\n        end else if (a[62:52] < 897) begin\n            z[30:23] <= 0;\n            z_m <= {1'd1, a[51:29]};\n            z_e <= a[62:52];\n            guard <= a[28];\n            round <= a[27];\n            sticky <= a[26:0] != 0;\n            state <= denormalise;\n        end else if (a[62:52] == 2047) begin\n            z[30:23] <= 255;\n            z[22:0] <= 0;\n            if (a[51:0]) begin\n                z[22] <= 1;\n            end\n        end else if (a[62:52] > 1150) begin\n            z[30:23] <= 255;\n            z[22:0] <= 0;\n        end else begin\n            z[30:23] <= (a[62:52] - 1023) + 127;\n            if (a[28] && (a[27] || a[26:0])) begin\n                z[22:0] <= a[51:29] + 1;\n            end else begin\n                z[22:0] <= a[51:29];\n            end\n        end\n      end\n\n      denormalise:\n      begin\n        if (z_e == 897 || (z_m == 0 && guard == 0)) begin\n            state <= put_z;\n            z[22:0] <= z_m;\n            if (guard && (round || sticky)) begin\n                z[22:0] <= z_m + 1;\n            end\n        end else begin\n            z_e <= z_e + 1;\n            z_m <= {1'd0, z_m[23:1]};\n            guard <= z_m[0];\n            round <= guard;\n            sticky <= sticky | round;\n        end\n      end\n\n      put_z:\n      begin\n        s_output_z_stb <= 1;\n        s_output_z <= z;\n        if (s_output_z_stb && output_z_ack) begin\n          s_output_z_stb <= 0;\n          state <= get_a;\n        end\n      end\n\n    endcase\n\n    if (rst == 1) begin\n      state <= get_a;\n      s_input_a_ack <= 0;\n      s_output_z_stb <= 0;\n    end\n\n  end\n  assign input_a_ack = s_input_a_ack;\n  assign output_z_stb = s_output_z_stb;\n  assign output_z = s_output_z;\n\nendmodule"}
{"task_id": 775, "completion": "output Y ;\n    input  A1;\n    input  A2;\n    input  B1;\n    input  C1;\n\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    wire or0_out    ;\n    wire nand0_out_Y;\n\n    or   or0   (or0_out    , A2, A1         );\n    nand nand0 (nand0_out_Y, C1, or0_out, B1);\n    buf  buf0  (Y          , nand0_out_Y    );\n\nendmodule"}
{"task_id": 686, "completion": "axi_protocol_converter_v2_1_9_axi_protocol_converter #(    .C_FAMILY(\"zynq\"),    .C_M_AXI_PROTOCOL(0),    .C_S_AXI_PROTOCOL(1),    .C_IGNORE_ID(0),    .C_AXI_ID_WIDTH(12),    .C_AXI_ADDR_WIDTH(32),    .C_AXI_DATA_WIDTH(32),    .C_AXI_SUPPORTS_WRITE(1),    .C_AXI_SUPPORTS_READ(1),    .C_AXI_SUPPORTS_USER_SIGNALS(0),    .C_AXI_AWUSER_WIDTH(1),    .C_AXI_ARUSER_WIDTH(1),    .C_AXI_WUSER_WIDTH(1),    .C_AXI_RUSER_WIDTH(1),    .C_AXI_BUSER_WIDTH(1),    .C_TRANSLATION_MODE(2)  ) inst (    .aclk(aclk),    .aresetn(aresetn),    .s_axi_awid(s_axi_awid),    .s_axi_awaddr(s_axi_awaddr),    .s_axi_awlen(s_axi_awlen),    .s_axi_awsize(s_axi_awsize),    .s_axi_awburst(s_axi_awburst),    .s_axi_awlock(s_axi_awlock),    .s_axi_awcache(s_axi_awcache),    .s_axi_awprot(s_axi_awprot),    .s_axi_awregion(4'H0),    .s_axi_awqos(s_axi_awqos),    .s_axi_awuser(1'H0),    .s_axi_awvalid(s_axi_awvalid),    .s_axi_awready(s_axi_awready),    .s_axi_wid(s_axi_wid),    .s_axi_wdata(s_axi_wdata),    .s_axi_wstrb(s_axi_wstrb),    .s_axi_wlast(s_axi_wlast),    .s_axi_wuser(1'H0),    .s_axi_wvalid(s_axi_wvalid),    .s_axi_wready(s_axi_wready),    .s_axi_bid(s_axi_bid),    .s_axi_bresp(s_axi_bresp),    .s_axi_buser(),    .s_axi_bvalid(s_axi_bvalid),    .s_axi_bready(s_axi_bready),    .s_axi_arid(s_axi_arid),    .s_axi_araddr(s_axi_araddr),    .s_axi_arlen(s_axi_arlen),    .s_axi_arsize(s_axi_arsize),    .s_axi_arburst(s_axi_arburst),    .s_axi_arlock(s_axi_arlock),    .s_axi_arcache(s_axi_arcache),    .s_axi_arprot(s_axi_arprot),    .s_axi_arregion(4'H0),    .s_axi_arqos(s_axi_arqos),    .s_axi_aruser(1'H0),    .s_axi_arvalid(s_axi_arvalid),    .s_axi_arready(s_axi_arready),    .s_axi_rid(s_axi_rid),    .s_axi_rdata(s_axi_rdata),    .s_axi_rresp(s_axi_rresp),    .s_axi_rlast(s_axi_rlast),    .s_axi_ruser(),    .s_axi_rvalid(s_axi_rvalid),    .s_axi_rready(s_axi_rready),    .m_axi_awid(m_axi_awid),    .m_axi_awaddr(m_axi_awaddr),    .m_axi_awlen(m_axi_awlen),    .m_axi_awsize(m_axi_awsize),    .m_axi_awburst(m_axi_awburst),    .m_axi_awlock(m_axi_awlock),    .m_axi_awcache(m_axi_awcache),    .m_axi_awprot(m_axi_awprot),    .m_axi_awregion(m_axi_awregion),    .m_axi_awqos(m_axi_awqos),    .m_axi_awuser(),    .m_axi_awvalid(m_axi_awvalid),    .m_axi_awready(m_axi_awready),    .m_axi_wid(),    .m_axi_wdata(m_axi_wdata),    .m_axi_wstrb(m_axi_wstrb),    .m_axi_wlast(m_axi_wlast),    .m_axi_wuser(),    .m_axi_wvalid(m_axi_wvalid),    .m_axi_wready(m_axi_wready),    .m_axi_bid(m_axi_bid),    .m_axi_bresp(m_axi_bresp),    .m_axi_buser(1'H0),    .m_axi_bvalid(m_axi_bvalid),    .m_axi_bready(m_axi_bready),    .m_axi_arid(m_axi_arid),    .m_axi_araddr(m_axi_araddr),    .m_axi_arlen(m_axi_arlen),    .m_axi_arsize(m_axi_arsize),    .m_axi_arburst(m_axi_arburst),    .m_axi_arlock(m_axi_arlock),    .m_axi_arcache(m_axi_arcache),    .m_axi_arprot(m_axi_arprot),    .m_axi_arregion(m_axi_arregion),    .m_axi_arqos(m_axi_arqos),    .m_axi_aruser(),    .m_axi_arvalid(m_axi_arvalid),    .m_axi_arready(m_axi_arready),    .m_axi_rid(m_axi_rid),    .m_axi_rdata(m_axi_rdata),    .m_axi_rresp(m_axi_rresp),    .m_axi_rlast(m_axi_rlast),    .m_axi_ruser(1'H0),    .m_axi_rvalid(m_axi_rvalid),    .m_axi_rready(m_axi_rready)  );endmodule"}
{"task_id": 728, "completion": "parameter MASTER_ID = 0;\n    parameter DEPTH = 8;\n    reg [60:0] req_buf[(DEPTH - 1):0];\n    reg [5:0] write_ptr;\n    reg [5:0] read_ptr;\n    reg [6:0] req_cnt;\n    assign busy = (req_cnt == DEPTH);\n    wire req_push = cs && (req_cnt != DEPTH);\n    wire req_pop;\n\n    always @ (posedge clk or posedge rst)\n        if (rst)\n            req_cnt <= 7'd0;\n        else\n            case ({req_push, req_pop})\n            2'b10: req_cnt <= req_cnt + 7'd1;\n            2'd01: req_cnt <= req_cnt - 7'd1;\n            default: ;\n            endcase\n\n    always @ (posedge clk or posedge rst)\n        if (rst)\n            write_ptr <= 6'd0;\n        else if (req_push)\n            write_ptr <= (write_ptr == (DEPTH - 1)) ? 6'd0 : write_ptr + 6'd1;\n\n    always @ (posedge clk or posedge rst)\n        if (rst)\n            read_ptr <= 6'd0;\n        else if (req_pop)\n            read_ptr <= (read_ptr == (DEPTH - 1)) ? 6'd0 : read_ptr + 6'd1;\n\n    always @ (posedge clk)\n        if (req_push)\n            req_buf[write_ptr] <= {seq, wr, mask[3:0], addr[23:2], wdata[31:0]};\n\n    wire req_vld = (req_cnt != 0);\n    wire [60:0] req = req_buf[read_ptr][60:0];\n    wire req_busy;\n\n    assign req_pop = req_vld && !req_busy;\n\n    assign issue = req_pop;\n    assign iss_seq = req[60:59];\n\n    rcn_master #(.MASTER_ID(MASTER_ID)) rcn_master\n    (\n        .rst(rst),\n        .clk(clk),\n        .rcn_in(rcn_in),\n        .rcn_out(rcn_out),\n        .cs(req_vld),\n        .seq(req[60:59]),\n        .busy(req_busy),\n        .wr(req[58]),\n        .mask(req[57:54]),\n        .addr({req[53:32], 2'd0}),\n        .wdata(req[31:0]),\n        .rdone(rdone),\n        .wdone(wdone),\n        .rsp_seq(rsp_seq),\n        .rsp_mask(rsp_mask),\n        .rsp_addr(rsp_addr),\n        .rsp_data(rsp_data)\n    );\n\nendmodule"}
{"task_id": 767, "completion": "wire [31:0] cpu_data_i;\n    wire [31:0] cpu_data_o;\n    wire [31:0] cpu_addr_o;\n    wire cpu_we_o;\n\n    wire [31:0] cpu_c_data_i;\n    assign cpu_c_data_i = 32'hbaadf00d;\n\n    wire [31:0] cpu_prog_data_i;\n    wire [31:0] cpu_prog_addr_o;\n    nkmd_cpu cpu(\n        .clk(clk), .rst(rst),\n        .r_data_i(cpu_data_i),\n        .r_data_o(cpu_data_o),\n        .r_addr_o(cpu_addr_o),\n        .r_we_o(cpu_we_o),\n        .c_data_i(cpu_c_data_i),\n        .p_data_i(cpu_prog_data_i),\n        .p_addr_o(cpu_prog_addr_o));\n\n    wire [31:0] ram_data_o;\n    nkmd_ram ram(\n        .clk(clk),\n        .data_i(cpu_data_o),\n        .data_o(ram_data_o),\n        .addr_i(cpu_addr_o),\n        .we_i(cpu_we_o));\n\n    wire [31:0] uart_data_o;\n    nkmd_uart uart(\n        .clk(clk), .rst(rst),\n        .rx(uart_rx), .tx(uart_tx),\n        .data_i(cpu_data_o),\n        .data_o(uart_data_o),\n        .addr_i(cpu_addr_o),\n        .we_i(cpu_we_o));\n\n    wire [31:0] dai_rx_data_o;\n    nkmd_dai_rx dai_rx(\n        .clk(clk), .rst(rst),\n        .rx_data_i(dai_data_i),\n        .rx_ack_i(dai_ack_i),\n        .data_i(cpu_data_o),\n        .data_o(dai_rx_data_o),\n        .addr_i(cpu_addr_o),\n        .we_i(cpu_we_o));\n\n    wire [31:0] dai_tx_data_o;\n    nkmd_dai_tx dai_tx(\n        .clk(clk), .rst(rst),\n        .tx_data_o(dai_data_o),\n        .tx_pop_i(dai_pop_i),\n        .tx_ack_o(dai_ack_o),\n        .data_i(cpu_data_o),\n        .data_o(dai_tx_data_o),\n        .addr_i(cpu_addr_o),\n        .we_i(cpu_we_o));\n\n    wire [31:0] debug_data_o;\n    nkmd_debug debug(\n        .clk(clk), .rst(rst),\n        .dbgout_o(dbgout_o), .dbgin_i(dbgin_i),\n        .data_i(cpu_data_o),\n        .data_o(debug_data_o),\n        .addr_i(cpu_addr_o),\n        .we_i(cpu_we_o));\n\n    assign cpu_data_i =\n        ram_data_o |\n        uart_data_o |\n        dai_rx_data_o | dai_tx_data_o |\n        debug_data_o;\n\n    `ifdef PROMW\n    nkmd_progrom_w\n    `else\n    nkmd_progrom\n    `endif\n        rom(\n        .clk(clk),\n        .addr_i(cpu_prog_addr_o),\n        .data_o(cpu_prog_data_i)\n    `ifdef PROMW\n        ,\n        .prog_addr_i(prog_addr_i),\n        .prog_data_i(prog_data_i),\n        .prog_ack_i(prog_ack_i)\n    `endif\n    );\n\nendmodule"}
{"task_id": 743, "completion": "output Q;\n    output Q_N;\n    input  CLK;\n    input  D;\n    input  SET_B;\n    input  VPWR;\n    input  VGND;\n    input  VPB;\n    input  VNB;\n    sky130_fd_sc_lp__dfsbp base (\n        .Q(Q),\n        .Q_N(Q_N),\n        .CLK(CLK),\n        .D(D),\n        .SET_B(SET_B),\n        .VPWR(VPWR),\n        .VGND(VGND),\n        .VPB(VPB),\n        .VNB(VNB)\n    );\n\nendmodule"}
{"task_id": 708, "completion": "wire [2:0] n_bits_parallel = quad_mode ? 4 : 1;\n    reg [11:0] bit_cntr;\n    reg [3:0] DQ = 4'b1111;\n    reg oe;\n    reg [1:0] state;\n\n    assign DQio[0] = oe ? DQ[0] : 1'bZ;\n    assign DQio[1] = oe ? DQ[1] : 1'bZ;\n    assign DQio[2] = oe ? DQ[2] : 1'bZ;\n    assign DQio[3] = quad_mode ? (oe ? DQ[3] : 1'bZ) : 1'b1;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= `STATE_IDLE;\n            oe <= 0;\n            S <= 1;\n            busy <= 1;\n        end else begin\n            case (state)\n                `STATE_IDLE: begin\n                    if (trigger && !busy) begin\n                        state <= `STATE_TX;\n                        busy <= 1;\n                        bit_cntr <= data_in_count * 8 - 1;\n                     end else begin\n                        S <= 1;\n                        busy <= 0;\n                     end\n                 end\n\n                `STATE_TX: begin\n                    S <= 0;\n                    oe <= 1;\n                    if(quad_mode) begin\n                        DQ[0] <= data_in[bit_cntr - 3];\n                        DQ[1] <= data_in[bit_cntr - 2];\n                        DQ[2] <= data_in[bit_cntr - 1];\n                        DQ[3] <= data_in[bit_cntr];\n                    end else\n                         DQ[0] <= data_in[bit_cntr];\n                    if (bit_cntr > n_bits_parallel - 1) begin\n                        bit_cntr <= bit_cntr - n_bits_parallel;\n                    end else begin\n                        if (data_out_count > 0) begin\n                            state <= `STATE_RX;\n                            bit_cntr <= 7 + 1;\n                        end\n                        else begin\n                            state <= `STATE_IDLE;\n                        end\n                    end\n                end\n\n                `STATE_RX: begin\n                    oe <= 0;\n                    if (bit_cntr > n_bits_parallel - 1) begin\n                        bit_cntr <= bit_cntr - n_bits_parallel;\n                    end else begin\n                        S <= 1;\n                        state <= `STATE_IDLE;\n                    end\n                end\n\n                default: begin\n                    state <= `STATE_IDLE;\n                end\n            endcase\n        end\n    end \n   \n    always @(negedge clk) begin\n        if (reset) begin\n            data_out <= 0;\n        end else begin\n            if (state == `STATE_RX) begin\n                if (quad_mode)\n                    data_out <= {data_out[3:0], DQio[3], DQio[2], DQio[1], DQio[0]};\n                else\n                    data_out <= {data_out[6:0], DQio[1]};\n            end\n        end\n    end\n\nendmodule"}
{"task_id": 784, "completion": "endmodule"}
{"task_id": 776, "completion": "supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    wire RESET;\n    wire intgate;\n    reg notifier;\n    wire D_delayed;\n    wire GATE_N_delayed;\n    wire RESET_delayed;\n    wire RESET_B_delayed;\n    wire buf_Q;\n    wire awake;\n    wire cond0;\n    wire cond1;\n\n    not not0 (RESET, RESET_B_delayed);\n    not not1 (intgate, GATE_N_delayed);\n    sky130_fd_sc_ls__udp_dlatch$PR_pp$PG$N dlatch0 (buf_Q, D_delayed, intgate, RESET, notifier, VPWR, VGND);\n    assign awake = (VPWR === 1'b1);\n    assign cond0 = (awake && (RESET_B_delayed === 1'b1));\n    assign cond1 = (awake && (RESET_B === 1'b1));\n    buf buf0 (Q, buf_Q);\n    not not2 (Q_N, buf_Q);\n\nendmodule"}
{"task_id": 781, "completion": "supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\nendmodule"}
{"task_id": 649, "completion": "reg [DATA_TYPE-1:0] list_mem [0:255];\n    reg [7:0] length;\n\n    // \u8ba1\u7b97\u5217\u8868\u957f\u5ea6\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            length <= 0;\n        end else begin\n            length <= length + 1;\n        end\n    end\n\n    // \u5b58\u50a8\u6570\u636e\n    always @(posedge clk) begin\n        list_mem[length] <= data_in;\n    end\n\n    // \u8f93\u51fa\u6570\u636e\n    assign data_out = list_mem[length];\n    assign valid = (length > 0);\nendmodule"}
{"task_id": 772, "completion": "wire stp_out,rst_out,zf;\n\twire [31:0] i_pc;\n\twire [31:0] dpdata;\n\twire [31:0] o_pc;\n\twire [31:0] o_ins;\n\twire [31:0] o_sign,aluinputb;\n\twire [4:0] w1;\n\twire [31:0] pc_add4,add_branch,not_jump;\n\twire [31:0]Wdata,Adat,Bdat,mem_data,alu_res;\n\twire  RegDst,ALUsrcB,MemToReg,WriteReg,MemWrite,Branch,ALUop1,ALUop0,JMP;\n\twire [2:0] aluoper;\n\treg [15:0] digit,count=0;\n\tpbdebounce p0(clk,stp,stp_out);\n\talways @(posedge stp_out) count=count+1;\n\tpbdebounce p1(clk,rst,rst_out);\n\tsingle_pc PC0(stp_out,rst_out,i_pc,o_pc);\n\tIns_Mem ins (o_pc[11:2],o_ins);\n\tRegFile regfile(stp_out,o_ins[25:21], o_ins[20:16],regselect, w1, Wdata, WriteReg,  Adat, Bdat, dpdata);\n\tData_Mem data_mem (alu_res[7:2], Bdat,stp_out,MemWrite,mem_data);\n\tcpu_ctr cpuctr(o_ins[31:26],RegDst,ALUsrcB,MemToReg,WriteReg,MemWrite,Branch,ALUop1,ALUop0,JMP );\n\taluc   alucontrol ({ALUop1,ALUop0}, o_ins[3:0], aluoper);\n\talu   alut(Adat, aluinputb, aluoper, zf, alu_res);\n\tsign_extend sign(o_ins[15:0],o_sign);\n\tdisplay dp(clk,digit,node,segment);\n\tadd a1(o_pc,32'h4,pc_add4);\n\tadd a2(pc_add4,{o_sign[29:0],2'b00},add_branch);\n\tassign w1=(RegDst==1)?o_ins[15:11]:o_ins[20:16];\n\tassign not_jump=(Branch & zf)?add_branch:pc_add4;\n\tassign i_pc=(JMP==1)?{pc_add4[31:29],o_ins[25:0],2'b00}:not_jump;\n\tassign aluinputb=(ALUsrcB==1)?o_sign:Bdat;\n\tassign Wdata=(MemToReg==1)?mem_data:alu_res;\n\talways @* begin\n\t case (dptype) \n\t 2'b00:digit<=dpdata[15:0];\n\t 2'b01:digit<=dpdata[31:16];\n\t 2'b10:digit<=o_pc[15:0];\n\t 2'b11:digit<=count;\n\t endcase\n\tend\n\tassign exec=stp_out; \n\tassign initype=o_ins[31:26];\nendmodule"}
{"task_id": 786, "completion": "sky130_fd_sc_lp__lsbufiso0p base (\n        .X(X),\n        .SLEEP(SLEEP),\n        .A(A),\n        .DESTPWR(DESTPWR),\n        .VPWR(VPWR),\n        .VGND(VGND),\n        .DESTVPB(DESTVPB),\n        .VPB(VPB),\n        .VNB(VNB)\n    );\n\nendmodule"}
{"task_id": 782, "completion": "reg [5:0] s;    reg [15:0] datain=0;    reg enable=0;    wire [15:0] dataout;    wire done;    spi driver ( .clk(clk), .reset(reset), .datain(datain), .enable(enable), .dataout(dataout), .done(done) );    always @(*) begin    case (addr) 4'h0: begin s = (cs && wr) ? 4'b0001 : 6'b0000; end //datain 4'h2: begin s = (cs && wr) ? 4'b0010 : 6'b0000; end //en 4'h4: begin s = (cs && rd) ? 4'b0100 : 6'b0000; end //done 4'h6: begin s = (cs && rd) ? 4'b1000 : 6'b0000; end //dataout default: begin s = 6'b000000; end endcase end    always @(negedge clk) begin    datain = (s[0]) ? d_in : datain;    enable = (s[1]) ? d_in[0] : enable; end    always @(negedge clk) begin    case (s) 4'b0100: d_out[0] = done; 3'b1000: d_out = dataout[15:0]; default: d_out = 0; endcase endendmodule"}
{"task_id": 774, "completion": "assign abus = Aselect[0] ? 32'b0 : 32'bz;\n    assign bbus = Bselect[0] ? 32'b0 : 32'bz;\n    DNegflipFlop myFlips[30:0](\n        .dbus(dbus),\n        .abus(abus),\n        .Dselect(Dselect[31:1]),\n        .Bselect(Bselect[31:1]),\n        .Aselect(Aselect[31:1]),\n        .bbus(bbus),\n        .clk(clk)\n    );\nendmodule\nmodule DNegflipFlop(dbus, abus, Dselect, Bselect, Aselect, bbus, clk);\n    input [31:0] dbus;\n    input Dselect;\n    input Bselect;\n    input Aselect;\n    input clk;\n    output [31:0] abus;\n    output [31:0] bbus;\n    reg [31:0] data;\n    always @(negedge clk) begin\n      if(Dselect) begin\n      data = dbus;\n      end\n    end\n    assign abus = Aselect ? data : 32'bz;\n    assign bbus = Bselect ? data : 32'bz;\nendmodule"}
{"task_id": 770, "completion": "output X   ;    input  A   ;    input  B   ;    input  C_N ;    input  D_N ;    input  VPWR;    input  VGND;    input  VPB ;    input  VNB ;    sky130_fd_sc_ms__or4bb base (        .X(X),        .A(A),        .B(B),        .C_N(C_N),        .D_N(D_N),        .VPWR(VPWR),        .VGND(VGND),        .VPB(VPB),        .VNB(VNB)    );\nendmodule"}
{"task_id": 338, "completion": "// Type definitions\n  typedef enum { T_TOP, T_BASE, T_ARROW, T_RNIL, T_RCONS } type;\n  typedef struct { int id; type ty; } term;\n  \n  // Well-formedness proofs\n  function bool well_formed_type(type t);\n    // ... Implementation of well-formedness vetting\n  endfunction\n  \n  // Substitution function\n  function term substitute(id x, term s, term t);\n    // ... Implementation of substitution logic\n  endfunction\n  \n  // Reduction and value rules\n  function bool value(term t);\n    // ... Implementation to check if 't' is a value\n  endfunction\n  \n  // Subtyping relation\n  inductive subtype(type S, type T);\n    // ... Rules of subtyping\n  endfunction\n  \n  // Typing judgments\n  inductive has_type(context Gamma, term t, type T);\n    // ... Rules for typing terms\n  endfunction\nendmodule"}
{"task_id": 615, "completion": "localparam [1:0]\n        STATE_IDLE = 2'd0,\n        STATE_SEGMENT = 2'd1,\n        STATE_NEXT_SEGMENT = 2'd2;\n\n    reg [1:0] state_reg = STATE_IDLE, state_next;\n\n    reg [7:0] count_reg = 8'd0, count_next;\n    reg suppress_zero_reg = 1'b0, suppress_zero_next;\n\n    reg [7:0] temp_tdata_reg = 8'd0, temp_tdata_next;\n    reg temp_tvalid_reg = 1'b0, temp_tvalid_next;\n\n    reg [7:0] m_axis_tdata_int;\n    reg       m_axis_tvalid_int;\n    reg       m_axis_tready_int_reg = 1'b0;\n    reg       m_axis_tlast_int;\n    reg       m_axis_tuser_int;\n    wire      m_axis_tready_int_early;\n\n    reg s_axis_tready_reg = 1'b0, s_axis_tready_next;\n\n    assign s_axis_tready = s_axis_tready_reg;\n\n    always @* begin\n        state_next = STATE_IDLE;\n\n        count_next = count_reg;\n        suppress_zero_next = suppress_zero_reg;\n\n        temp_tdata_next = temp_tdata_reg;\n        temp_tvalid_next = temp_tvalid_reg;\n\n        m_axis_tdata_int = 8'd0;\n        m_axis_tvalid_int = 1'b0;\n        m_axis_tlast_int = 1'b0;\n        m_axis_tuser_int = 1'b0;\n\n        s_axis_tready_next = 1'b0;\n\n        case (state_reg)\n            STATE_IDLE: begin\n                s_axis_tready_next = m_axis_tready_int_early || !temp_tvalid_reg;\n                m_axis_tdata_int = temp_tdata_reg;\n                m_axis_tvalid_int = temp_tvalid_reg;\n                m_axis_tlast_int = temp_tvalid_reg;\n                temp_tvalid_next = temp_tvalid_reg && !m_axis_tready_int_reg;\n                if (s_axis_tready && s_axis_tvalid) begin\n                    if (s_axis_tdata != 8'd0) begin\n                        count_next = s_axis_tdata-1;\n                        suppress_zero_next = (s_axis_tdata == 8'd255);\n                        s_axis_tready_next = m_axis_tready_int_early;\n                        if (s_axis_tdata == 8'd1) begin\n                            state_next = STATE_NEXT_SEGMENT;\n                        end else begin\n                            state_next = STATE_SEGMENT;\n                        end\n                    end else begin\n                        state_next = STATE_IDLE;\n                    end\n                end else begin\n                    state_next = STATE_IDLE;\n                end\n            end\n            STATE_SEGMENT: begin\n                s_axis_tready_next = m_axis_tready_int_early;\n                if (s_axis_tready && s_axis_tvalid) begin\n                    temp_tdata_next = s_axis_tdata;\n                    temp_tvalid_next = 1'b1;\n                    m_axis_tdata_int = temp_tdata_reg;\n                    m_axis_tvalid_int = temp_tvalid_reg;\n                    count_next = count_reg - 1;\n                    if (s_axis_tdata == 8'd0) begin\n                        temp_tvalid_next = 1'b0;\n                        m_axis_tvalid_int = 1'b1;\n                        m_axis_tuser_int = 1'b1;\n                        m_axis_tlast_int = 1'b1;\n                        s_axis_tready_next = 1'b1;\n                        state_next = STATE_IDLE;\n                    end else if (s_axis_tlast) begin\n                        if (count_reg == 8'd1 && !s_axis_tuser) begin\n                            state_next = STATE_IDLE;\n                        end else begin\n                            temp_tvalid_next = 1'b0;\n                            m_axis_tvalid_int = 1'b1;\n                            m_axis_tuser_int = 1'b1;\n                            m_axis_tlast_int = 1'b1;\n                            s_axis_tready_next = 1'b1;\n                            state_next = STATE_IDLE;\n                        end\n                    end else if (count_reg == 8'd1) begin\n                        state_next = STATE_NEXT_SEGMENT;\n                    end else begin\n                        state_next = STATE_SEGMENT;\n                    end\n                end else begin\n                    state_next = STATE_SEGMENT;\n                end\n            end\n            STATE_NEXT_SEGMENT: begin\n                s_axis_tready_next = m_axis_tready_int_early;\n                if (s_axis_tready && s_axis_tvalid) begin\n                    temp_tdata_next = 8'd0;\n                    temp_tvalid_next = !suppress_zero_reg;\n                    m_axis_tdata_int = temp_tdata_reg;\n                    m_axis_tvalid_int = temp_tvalid_reg;\n                    if (s_axis_tdata == 8'd0) begin\n                        temp_tvalid_next = 1'b0;\n                        m_axis_tuser_int = s_axis_tuser;\n                        m_axis_tlast_int = 1'b1;\n                        s_axis_tready_next = 1'b1;\n                        state_next = STATE_IDLE;\n                    end else if (s_axis_tlast) begin\n                        if (s_axis_tdata == 8'd1 && !s_axis_tuser) begin\n                            state_next = STATE_IDLE;\n                        end else begin\n                            temp_tvalid_next = 1'b0;\n                            m_axis_tvalid_int = 1'b1;\n                            m_axis_tuser_int = 1'b1;\n                            m_axis_tlast_int = 1'b1;\n                            s_axis_tready_next = 1'b1;\n                            state_next = STATE_IDLE;\n                        end\n                    end else begin\n                        count_next = s_axis_tdata-1;\n                        suppress_zero_next = (s_axis_tdata == 8'd255);\n                        s_axis_tready_next = m_axis_tready_int_early;\n                        if (s_axis_tdata == 8'd1) begin\n                            state_next = STATE_NEXT_SEGMENT;\n                        end else begin\n                            state_next = STATE_SEGMENT;\n                        end\n                    end\n                end else begin\n                    state_next = STATE_NEXT_SEGMENT;\n                end\n            end\n        endcase\n    end\n\n    always @(posedge clk) begin\n        if (rst) begin\n            state_reg <= STATE_IDLE;\n            temp_tvalid_reg <= 1'b0;\n            s_axis_tready_reg <= 1'b0;\n        end else begin\n            state_reg <= state_next;\n            temp_tvalid_reg <= temp_tvalid_next;\n            s_axis_tready_reg <= s_axis_tready_next;\n        end\n\n        temp_tdata_reg <= temp_tdata_next;\n\n        count_reg <= count_next;\n        suppress_zero_reg <= suppress_zero_next;\n    end\n\n    reg [7:0] m_axis_tdata_reg = 8'd0;\n    reg       m_axis_tvalid_reg = 1'b0, m_axis_tvalid_next;\n    reg       m_axis_tlast_reg = 1'b0;\n    reg       m_axis_tuser_reg = 1'b0;\n\n    reg [7:0] temp_m_axis_tdata_reg = 8'd0;\n    reg       temp_m_axis_tvalid_reg = 1'b0, temp_m_axis_tvalid_next;\n    reg       temp_m_axis_tlast_reg = 1'b0;\n    reg       temp_m_axis_tuser_reg = 1'b0;\n\n    reg store_axis_int_to_output;\n    reg store_axis_int_to_temp;\n    reg store_axis_temp_to_output;\n\n    assign m_axis_tdata = m_axis_tdata_reg;\n    assign m_axis_tvalid = m_axis_tvalid_reg;\n    assign m_axis_tlast = m_axis_tlast_reg;\n    assign m_axis_tuser = m_axis_tuser_reg;\n\n    assign m_axis_tready_int_early = m_axis_tready || (!temp_m_axis_tvalid_reg && (!m_axis_tvalid_reg || !m_axis_tvalid_int));\n\n    always @* begin\n        m_axis_tvalid_next = m_axis_tvalid_reg;\n        temp_m_axis_tvalid_next = temp_m_axis_tvalid_reg;\n\n        store_axis_int_to_output = 1'b0;\n        store_axis_int_to_temp = 1'b0;\n        store_axis_temp_to_output = 1'b0;\n\n        if (m_axis_tready_int_reg) begin\n            if (m_axis_tready || !m_axis_tvalid_reg) begin\n                m_axis_tvalid_next = m_axis_tvalid_int;\n                store_axis_int_to_output = 1'b1;\n            end else begin\n                temp_m_axis_tvalid_next = m_axis_tvalid_int;\n                store_axis_int_to_temp = 1'b1;\n            end\n        end else if (m_axis_tready) begin\n            m_axis_tvalid_next = temp_m_axis_tvalid_reg;\n            temp_m_axis_tvalid_next = 1'b0;\n            store_axis_temp_to_output = 1'b1;\n        end\n    end\n\n    always @(posedge clk) begin\n        if (rst) begin\n            m_axis_tvalid_reg <= 1'b0;\n            m_axis_tready_int_reg <= 1'b0;\n            temp_m_axis_tvalid_reg <= 1'b0;\n        end else begin\n            m_axis_tvalid_reg <= m_axis_tvalid_next;\n            m_axis_tready_int_reg <= m_axis_tready_int_early;\n            temp_m_axis_tvalid_reg <= temp_m_axis_tvalid_next;\n        end\n\n        if (store_axis_int_to_output) begin\n            m_axis_tdata_reg <= m_axis_tdata_int;\n            m_axis_tlast_reg <= m_axis_tlast_int;\n            m_axis_tuser_reg <= m_axis_tuser_int;\n        end else if (store_axis_temp_to_output) begin\n            m_axis_tdata_reg <= temp_m_axis_tdata_reg;\n            m_axis_tlast_reg <= temp_m_axis_tlast_reg;\n            m_axis_tuser_reg <= temp_m_axis_tuser_reg;\n        end\n\n        if (store_axis_int_to_temp) begin\n            temp_m_axis_tdata_reg <= m_axis_tdata_int;\n            temp_m_axis_tlast_reg <= m_axis_tlast_int;\n            temp_m_axis_tuser_reg <= m_axis_tuser_int;\n        end\n    end\n\nendmodule"}
{"task_id": 798, "completion": "supply1 VPWR;    supply0 VGND;    supply1 VPB ;    supply0 VNB ;endmodule"}
{"task_id": 755, "completion": "wire clk_200;\n    wire locked;\n    wire rst_n = locked & !button[0];\n    wire rst = ~rst_n;\n    assign led[7:0] = {rst,rst,~rst, button, 1'b0};\n\n    DCM_BASE #(\n\t\t.CLKDV_DIVIDE(2.0),\n\t\t.CLKFX_DIVIDE(1),\n\t\t.CLKFX_MULTIPLY(4),\n\t\t.CLKIN_DIVIDE_BY_2(\"FALSE\"),\n\t\t.CLKIN_PERIOD(10.0),\n\t\t.CLKOUT_PHASE_SHIFT(\"NONE\"),\n\t\t.CLK_FEEDBACK(\"NONE\"),\n\t\t.DCM_PERFORMANCE_MODE(\"MAX_SPEED\"),\n\t\t.DESKEW_ADJUST(\"SYSTEM_SYNCHRONOUS\"),\n\t\t.DFS_FREQUENCY_MODE(\"LOW\"),\n\t\t.DLL_FREQUENCY_MODE(\"LOW\"),\n\t\t.DUTY_CYCLE_CORRECTION(\"TRUE\"),\n\t\t.FACTORY_JF(16'hf0f0),\n\t\t.PHASE_SHIFT(0),\n\t\t.STARTUP_WAIT(\"FALSE\")\n    ) DCM_BASE_inst (\n\t\t.CLK0(CLK0),\n\t\t.CLK180(CLK180),\n\t\t.CLK270(CLK270),\n\t\t.CLK2X(clk_200),\n\t\t.CLK2X180(CLK2X180),\n\t\t.CLK90(CLK90),\n\t\t.CLKDV(CLKDV),\n\t\t.CLKFX(CLKFX),\n\t\t.CLKFX180(CLKFX180),\n\t\t.LOCKED(locked),\n\t\t.CLKFB(CLKFB),\n\t\t.CLKIN(clk_100),\n\t\t.RST(1'b0)\n    );\n\n    wire udp_rx_clk;\n    wire udp_tx_clk;\n    wire [7:0] udp_rx;\n    wire udp_rx_dv;\n    reg [15: 0] udp_tx_pending_data=0;\n    wire udp_tx;\n    wire udp_tx_rden;\n\n    eth_if eth_if_inst (\n        .rst(rst), \n        .clk_200(clk_200), \n        .ETH_RESET(ETH_RESET_0), \n        .GTX_CLK(GTX_CLK_0),\n        .GMII_TXD(GMII_TXD_0), \n        .GMII_TX_EN(GMII_TX_EN_0), \n        .GMII_TX_ER(GMII_TX_ER_0), \n        .GMII_TX_CLK(GMII_TX_CLK_0), \n        .GMII_RXD(GMII_RXD_0), \n        .GMII_RX_DV(GMII_RX_DV_0), \n        .GMII_RX_ER(GMII_RX_ER_0), \n        .GMII_RX_CLK(GMII_RX_CLK_0), \n        .MII_TX_CLK(MII_TX_CLK_0), \n        .GMII_COL(GMII_COL_0), \n        .GMII_CRS(GMII_CRS_0),\n        .udp_rx_clk(udp_rx_clk), \n        .udp_rx(udp_rx), \n        .udp_rx_dv(udp_rx_dv), \n        .udp_tx_pending_data(udp_tx_pending_data), \n        .udp_tx_clk(udp_tx_clk), \n        .udp_tx(udp_tx), \n        .udp_tx_rden(udp_tx_rden)\n    );\n\n    wire [15:0] rd_data_count;\n    always @(udp_tx_clk) udp_tx_pending_data <= rd_data_count<1472 ? rd_data_count : 1472;\n\n    eth_fifo fifo (\n       .rst(1'b0), \n       .wr_clk(udp_rx_clk), \n       .din(udp_rx), \n       .wr_en(udp_rx_dv), \n       .full(full), \n       .rd_clk(udp_tx_clk), \n       .rd_en(udp_tx_rden), \n       .dout(udp_tx), \n       .empty(), \n       .rd_data_count(rd_data_count) \n    );\n\nendmodule"}
{"task_id": 806, "completion": "output Q  ;\n    input  CLK;\n    input  D  ;\n    input  DE ;\n\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    wire buf_Q      ;\n    reg  notifier   ;\n    wire D_delayed  ;\n    wire DE_delayed ;\n    wire CLK_delayed;\n    wire mux_out    ;\n    wire awake      ;\n    wire cond0      ;\n\n    sky130_fd_sc_ls__udp_mux_2to1      mux_2to10 (mux_out, buf_Q, D_delayed, DE_delayed              );\n    sky130_fd_sc_ls__udp_dff$P_pp$PG$N dff0      (buf_Q  , mux_out, CLK_delayed, notifier, VPWR, VGND);\n    assign awake = ( VPWR === 1'b1 );\n    assign cond0 = ( awake && ( DE_delayed === 1'b1 ) );\n    buf                                buf0      (Q      , buf_Q                                     );\n\nendmodule"}
{"task_id": 811, "completion": "output X;    input  A;    input  B;    input  C;    input  D;    sky130_fd_sc_hd__or4 base (        .X(X),        .A(A),        .B(B),        .C(C),        .D(D),        .VPWR(VPWR),        .VGND(VGND),        .VPB(VPB),        .VNB(VNB)    );\nendmodule"}
{"task_id": 751, "completion": "reg [31:0]counter;\n    reg [7:0]stage;\n    reg [15:0]stage_iter;\n    assign CS=0;\n    assign SBI=0;\n    assign SEB=1;\n    assign R12=0;\n    assign IS1=1;\n    assign IS2=0;\n    assign SR=1;\n    assign Vthr=16'H0025;\n    assign Aref=16'H0033;\n    assign Vana=16'H0066;\n    assign RG=16'H0033;\n    always @(posedge clk) begin\n      if(reset_gen == 1) begin\n        counter <= 0;\n        stage <= 0;\n        stage_iter <= 0;\n      end\n      else begin\n        if(stage == 0) begin\n          if(counter == 0) begin\n            CAL <= 1;\n            SPHI1 <= 0;\n            SPHI2 <= 0;\n            RESET <= 0;\n            RBI <= 1;\n            RPHI1 <= 1;\n            RPHI2 <= 1;\n            LE <= 1;\n          end\n          if(counter == 2) begin\n            SPHI1 <= 1;\n            SPHI2 <= 1;\n          end\n          if(counter == 5) begin\n            SPHI1 <= 0;\n            SPHI2 <= 0;\n          end\n          if(counter == 9) begin\n            if(stage_iter == 0) begin\n              stage <= (stage + 1) % 5;\n              stage_iter <= 0;\n            end\n            else begin\n              stage_iter <= stage_iter + 1;\n            end\n            counter <= 0;\n          end\n          else begin\n            counter <= counter + 1;\n          end\n        end\n        if(stage == 1) begin\n          if(counter == 0) begin\n            CAL <= 0;\n            SPHI1 <= 0;\n            SPHI2 <= 0;\n            RESET <= 0;\n            RBI <= 1;\n            RPHI1 <= 1;\n            RPHI2 <= 1;\n            LE <= 1;\n          end\n          if(counter == 0) begin\n            if(stage_iter == stage_A2_cntr-1) begin\n              stage <= (stage + 1) % 5;\n              stage_iter <= 0;\n            end\n            else begin\n              stage_iter <= stage_iter + 1;\n            end\n            counter <= 0;\n          end\n          else begin\n            counter <= counter + 1;\n          end\n        end\n        if(stage == 2) begin\n          if(counter == 0) begin\n            CAL <= 0;\n            SPHI1 <= 0;\n            SPHI2 <= 0;\n            RESET <= 0;\n            RBI <= 1;\n            RPHI1 <= 1;\n            RPHI2 <= 1;\n            LE <= 0;\n          end\n          if(counter == 2) begin\n            RESET <= 1;\n          end\n          if(counter == 4) begin\n            RBI <= 0;\n          end\n          if(counter == 8) begin\n            RPHI1 <= 0;\n            RPHI2 <= 0;\n          end\n          if(counter == 11) begin\n            RBI <= 1;\n            RPHI1 <= 1;\n          end\n          if(counter == 12) begin\n            RPHI1 <= 0;\n          end\n          if(counter == 13) begin\n            RBI <= 0;\n          end\n          if(counter == 13) begin\n            if(stage_iter == 0) begin\n              stage <= (stage + 1) % 5;\n              stage_iter <= 0;\n            end\n            else begin\n              stage_iter <= stage_iter + 1;\n            end\n            counter <= 0;\n          end\n          else begin\n            counter <= counter + 1;\n          end\n        end\n        if(stage == 3) begin\n          if(counter == 0) begin\n            CAL <= 0;\n            SPHI1 <= 0;\n            SPHI2 <= 0;\n            RESET <= 1;\n            RBI <= 0;\n            RPHI1 <= 0;\n            RPHI2 <= 1;\n            LE <= 1;\n          end\n          if(counter == 21) begin\n            RPHI2 <= 0;\n          end\n          if(counter == 22) begin\n            RPHI1 <= 1;\n          end\n          if(counter == 23) begin\n            RPHI1 <= 0;\n          end\n          if(counter == 23) begin\n            if(stage_iter == 126) begin\n              stage <= (stage + 1) % 5;\n              stage_iter <= 0;\n            end\n            else begin\n              stage_iter <= stage_iter + 1;\n            end\n            counter <= 0;\n          end\n          else begin\n            counter <= counter + 1;\n          end\n        end\n        if(stage == 4) begin\n          if(counter == 0) begin\n            CAL <= 1;\n            SPHI1 <= 0;\n            SPHI2 <= 0;\n            RESET <= 1;\n            RBI <= 0;\n            RPHI1 <= 0;\n            RPHI2 <= 0;\n            LE <= 1;\n          end\n          if(counter == 0) begin\n            if(stage_iter == 299) begin\n              stage <= (stage + 1) % 5;\n              stage_iter <= 0;\n            end\n            else begin\n              stage_iter <= stage_iter + 1;\n            end\n            counter <= 0;\n          end\n          else begin\n            counter <= counter + 1;\n          end\n        end\n      end\n    end\nendmodule"}
{"task_id": 818, "completion": "output Y   ;\n    input  A1  ;\n    input  A2  ;\n    input  A3  ;\n    input  B1  ;\n    input  B2  ;\n    input  VPWR;\n    input  VGND;\n    input  VPB ;\n    input  VNB ;\nendmodule"}
{"task_id": 812, "completion": "wire nand0_out;\n    wire nand1_out;\n    wire and0_out_Y;\n\n    nand nand0 (nand0_out , A2, A1, A3          );\n    nand nand1 (nand1_out , B2, B1              );\n    and  and0  (and0_out_Y, nand0_out, nand1_out);\n    buf  buf0  (Y         , and0_out_Y          );\n\nendmodule"}
{"task_id": 796, "completion": "output Q  ;\n    output Q_N;\n    input  CLK;\n    input  D  ;\n    input  DE ;\n    input  SCD;\n    input  SCE;\n\n    wire buf_Q  ;\n    wire mux_out;\n    wire de_d   ;\n\n    sky130_fd_sc_hdll__udp_mux_2to1             mux_2to10 (mux_out, de_d, SCD, SCE );\n    sky130_fd_sc_hdll__udp_mux_2to1             mux_2to11 (de_d   , buf_Q, D, DE   );\n    sky130_fd_sc_hdll__udp_dff$P    `UNIT_DELAY dff0      (buf_Q  , mux_out, CLK   );\n    buf                                         buf0      (Q      , buf_Q          );\n    not                                         not0      (Q_N    , buf_Q          );\n\nendmodule"}
{"task_id": 761, "completion": "reg [15:0] clk_divider;\n    reg [3:0] display_num;\n    \n    always @ (posedge clk, posedge rst) begin\n    if (rst) begin\n            clk_divider <= 15'b0;\n     end else begin\n          clk_divider <= clk_divider + 15'b1;\n     end\n    end\n    \n    always @ (posedge clk_divider[15], posedge rst) begin\n     if (rst) begin\n          display_num <= 4'b0000;\n          digit <= 4'b1111;\n      end else begin\n          case (digit)\n             4'b1110 : begin\n                        display_num <= nums[7:4];\n                        digit <= 4'b1101;\n                     end\n             4'b1101 : begin\n                        display_num <= nums[11:8];\n                        digit <= 4'b1011;\n                     end\n             4'b1011 : begin\n                        display_num <= nums[15:12];\n                        digit <= 4'b0111;\n                     end\n             4'b0111 : begin\n                        display_num <= nums[3:0];\n                        digit <= 4'b1110;\n                     end\n             default : begin\n                        display_num <= nums[3:0];\n                        digit <= 4'b1110;\n                     end\n          endcase\n      end\n    end\n    \n    always @ (*) begin\n     case (display_num)\n         0 : display = 7'b1000000; \n         1 : display = 7'b1111001;   \n         2 : display = 7'b0100100;   \n         3 : display = 7'b0110000;   \n         4 : display = 7'b0011001;   \n         5 : display = 7'b0010010;   \n         6 : display = 7'b0000010;   \n         7 : display = 7'b1111000;   \n         8 : display = 7'b0000000;   \n         9 : display = 7'b0010000; \n         default : display = 7'b1111111;\n     endcase\n    end\nendmodule"}
{"task_id": 785, "completion": "wire winningChannel, flit0DesiredPort, flit1DesiredPort; wire [`IN_ROUTER_SIZE-1:0] swapFlit [1:0]; wire [`IN_ROUTER_SIZE-1:0] straightFlit [1:0]; reg swap; wire [`PORT_STAT_SIZE-1:0] wPortStatus [3:0]; genvar i; generate for (i=0; i<4; i= i+1) begin : split_bus assign wPortStatus[i] = portStatus[i*`PORT_STAT_SIZE+:`PORT_STAT_SIZE]; end endgenerate arbiter PNArbiter(.GP0(inFlit0[`GOLDEN]), .GP1(inFlit1[`GOLDEN]), .inPktID0(inFlit0[`FLIT_NUM]), .inPktID1(inFlit1[`FLIT_NUM]), .valid0(inFlit0[`VALID]), .valid1(inFlit1[`VALID]), .winner(winningChannel)); steer steerUp(inFlit0[`PROD_VECTOR_NO_LOCAL],stage,flit0DesiredPort); steer steerDown(inFlit1[`PROD_VECTOR_NO_LOCAL],stage,flit1DesiredPort); always @ * begin if ((((stage==1'b0 && position==1'b0) && (wPortStatus[3]==`INACTIVE | wPortStatus[1]==`INACTIVE)) | ((stage==1'b0 && position==1'b1) && (wPortStatus[2]==`INACTIVE | wPortStatus[0]==`INACTIVE)) | ((stage==1'b1 && position==1'b0) && (wPortStatus[3]==`INACTIVE | wPortStatus[2]==`INACTIVE)) | ((stage==1'b1 && position==1'b1) && (wPortStatus[1]==`INACTIVE | wPortStatus[0]==`INACTIVE)) ) swap <= 0; else if ((winningChannel == 0 && flit0DesiredPort == 1) || (winningChannel == 1 && flit1DesiredPort == 0)) swap <= 1; end demux1to2InRouter demux0(.dataIn(inFlit0), .sel(swap), .aOut(straightFlit[0]), .bOut(swapFlit[0])); demux1to2InRouter demux1(.dataIn(inFlit1), .sel(swap), .aOut(straightFlit[1]), .bOut(swapFlit[1])); mux2to1InRouter mux0(.aIn(straightFlit[0]), .bIn(swapFlit[1]), .sel(swap), .dataOut(outFlit0)); mux2to1InRouter mux1(.aIn(straightFlit[1]), .bIn(swapFlit[0]), .sel(swap), .dataOut(outFlit1)); endmodule"}
{"task_id": 829, "completion": "output COUT;\n    output SUM ;\n    input  A   ;\n    input  B   ;\n    input  CIN ;\n    input  VPWR;\n    input  VGND;\n    sky130_fd_sc_hs__fa base (\n        .COUT(COUT),\n        .SUM(SUM),\n        .A(A),\n        .B(B),\n        .CIN(CIN),\n        .VPWR(VPWR),\n        .VGND(VGND)\n    );\n\nendmodule\n\n/*********************************************************/\n\n    output COUT;\n    output SUM ;\n    input  A   ;\n    input  B   ;\n    input  CIN ;\n\n    supply1 VPWR;\n    supply0 VGND;\n\n    sky130_fd_sc_hs__fa base (\n        .COUT(COUT),\n        .SUM(SUM),\n        .A(A),\n        .B(B),\n        .CIN(CIN)\n    );\n\nendmodule"}
{"task_id": 832, "completion": "input  VPWR;    input  VGND;    output Q   ;    input  CLK ;    input  D   ;    input  SCD ;    input  SCE ;    wire buf_Q  ;    wire mux_out;    sky130_fd_sc_hs__u_mux_2_1             u_mux_20   (mux_out, D, SCD, SCE             );    sky130_fd_sc_hs__u_df_p_pg `UNIT_DELAY u_df_p_pg0 (buf_Q  , mux_out, CLK, VPWR, VGND);    buf                                    buf0       (Q      , buf_Q                   );endmodule"}
{"task_id": 831, "completion": "assign d_out = (d_in << shift_amount) | (d_in >> (8 - shift_amount));\nendmodule"}
{"task_id": 826, "completion": "output Y   ;\n    input  A1  ;\n    input  A2  ;\n    input  B1  ;\n    input  C1  ;\n    input  VPWR;\n    input  VGND;\n    sky130_fd_sc_hs__o211ai base (\n        .Y(Y),\n        .A1(A1),\n        .A2(A2),\n        .B1(B1),\n        .C1(C1),\n        .VPWR(VPWR),\n        .VGND(VGND)\n    );\n\nendmodule"}
{"task_id": 828, "completion": "wire [7:0] iaR, iaRA;\n    assign iaR = ia << 1;\n    assign iaRA = iaR + ia;\n    mux mux0 (.in0(8'b0), .in1({4'b0, ia}), .in2(iaR), .in3(iaRA), .sel({ib[1], ib[0]}), .out(o0));\n    mux mux1 (.in0(8'b0), .in1({4'b0, ia}), .in2(iaR), .in3(iaRA), .sel({ib[3], ib[2]}), .out(o1));\n    wire [7:0] o0, o1;\n    wire [7:0] o1R;\n    assign o1R = o1 << 2;\n    assign o = o0 + o1R;\nendmodule"}
{"task_id": 843, "completion": "wire or0_out_X        ;\n    wire pwrgood_pp0_out_X;\n\n    or                                   or0         (or0_out_X        , B, A, C              );\n    sky130_fd_sc_hdll__udp_pwrgood_pp$PG pwrgood_pp0 (pwrgood_pp0_out_X, or0_out_X, VPWR, VGND);\n    buf                                  buf0        (X                , pwrgood_pp0_out_X    );\n\nendmodule"}
{"task_id": 841, "completion": "output Y   ;\n    input  A1  ;\n    input  A2  ;\n    input  B1  ;\n    input  B2  ;\n    input  VPWR;\n    input  VGND;\n    sky130_fd_sc_hs__o22ai base (\n        .Y(Y),\n        .A1(A1),\n        .A2(A2),\n        .B1(B1),\n        .B2(B2),\n        .VPWR(VPWR),\n        .VGND(VGND)\n    );\n\nendmodule"}
{"task_id": 799, "completion": "wire RESET          ;\n    wire intgate        ;\n    reg  notifier       ;\n    wire D_delayed      ;\n    wire GATE_N_delayed ;\n    wire RESET_delayed  ;\n    wire RESET_B_delayed;\n    wire buf_Q          ;\n    wire awake          ;\n    wire cond0          ;\n    wire cond1          ;\n\n    not                             not0            (RESET  , RESET_B_delayed                                );\n    not                             not1            (intgate, GATE_N_delayed                                 );\n    sky130_fd_sc_hs__u_dl_p_r_no_pg u_dl_p_r_no_pg0 (buf_Q  , D_delayed, intgate, RESET, notifier, VPWR, VGND);\n    assign awake = ( VPWR === 1'b1 );\n    assign cond0 = ( awake && ( RESET_B_delayed === 1'b1 ) );\n    assign cond1 = ( awake && ( RESET_B === 1'b1 ) );\n    buf                             buf0            (Q      , buf_Q                                          );\n\nendmodule"}
{"task_id": 827, "completion": "assign usb_cs_n = 1'b1;\n    assign usb_hpi_reset_n = 1'b1;\n\n    assign aceusb_a = {a, 1'b0};\n\n    reg d_drive;\n    assign aceusb_d = d_drive ? di : 16'hzz;\n\n    reg d_drive_r;\n    reg aceusb_oe_n_r;\n    reg aceusb_we_n_r;\n    reg ace_mpce_n_r;\n    always @(posedge ace_clkin) begin\n        d_drive <= d_drive_r;\n        aceusb_oe_n <= aceusb_oe_n_r;\n        aceusb_we_n <= aceusb_we_n_r;\n        ace_mpce_n <= ace_mpce_n_r;\n    end\n\n    reg d_in_sample;\n    always @(posedge ace_clkin)\n        if(d_in_sample)\n            do <= aceusb_d;\n\n    reg [2:0] state;\n    reg [2:0] next_state;\n\n    localparam\n        IDLE = 3'd0,\n        READ = 3'd1,\n        READ1 = 3'd2,\n        READ2 = 3'd3,\n        WRITE = 3'd4,\n        ACK = 3'd5;\n\n    always @(posedge ace_clkin) begin\n        if(rst)\n            state <= IDLE;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        d_drive_r = 1'b0;\n        aceusb_oe_n_r = 1'b1;\n        aceusb_we_n_r = 1'b1;\n        ace_mpce_n_r = 1'b1;\n        d_in_sample = 1'b0;\n        ack = 1'b0;\n        \n        next_state = state;\n        \n        case(state)\n            IDLE: begin\n                if(read) begin\n                    ace_mpce_n_r = 1'b0;\n                    next_state = READ;\n                end\n                if(write) begin\n                    ace_mpce_n_r = 1'b0;\n                    next_state = WRITE;\n                end\n            end\n            \n            READ: begin\n                ace_mpce_n_r = 1'b0;\n                next_state = READ1;\n            end\n            READ1: begin\n                ace_mpce_n_r = 1'b0;\n                aceusb_oe_n_r = 1'b0;\n                next_state = READ2;\n            end\n            READ2: begin\n                d_in_sample = 1'b1;\n                next_state = ACK;\n            end\n            \n            WRITE: begin\n                d_drive_r = 1'b1;\n                ace_mpce_n_r = 1'b0;\n                aceusb_we_n_r = 1'b0;\n                next_state = ACK;\n            end\n            \n            ACK: begin\n                ack = 1'b1;\n                next_state = IDLE;\n            end\n        endcase\n    end\n\nendmodule"}
{"task_id": 794, "completion": "input     CE;                 // Databus selece enable -> Active high\n  input     nRD;                // Databus read enable   -> Active low\n  input     SCK;                // Serial input clock    -> rising edge \n  input     SDA;                // Serial input data \n  input     [17:0]Dout;         // Output data                     \n  input     Start;              // Sync start            -> active high\n  input     Ready;              // Sampling start        -> active high\n  input     Full;               // FIFO RAM is full      -> active high\n  input     Empty;              // FIFO RAM is empty     -> active high\n  input     H_L;                // 0/1 = Status/[15:0]Din -> [15:0]DB\n  input     C_D;                // 1 = [15:0]Data        -> [15:0]DB\n                                \n  input     [15:0]A_Edge;       // CH_A edge counter\n  input     [15:0]A_TL;         // CH_A \n  input     [15:0]A_TH;         // CH_A \n  \n  input     [15:0]B_Edge;       // CH_B edge counter\n  input     [15:0]B_TL;         // CH_B \n  input     [15:0]B_TH;         // CH_B \n  \n  input     [15:0]C_Edge;       // CH_C edge counter\n  input     [15:0]C_TL;         // CH_C \n  input     [15:0]C_TH;         // CH_C \n  \n  input     [15:0]D_Edge;       // CH_D edge counter\n  input     [15:0]D_TL;         // CH_D \n  input     [15:0]D_TH;         // CH_D \n  \n  output    [11:0]Depth;        // Sampling depth\n  output    [11:0]PerCnt;       // Per-sampling counter                        \n  output    [31:0]Delay;        // Sampling delay\n\n  output    nPD;                // ADC power down        -> Active low\n  output    [ 7:0]Trigg_Mode;   // Trigger Mode \n  output    [ 7:0]Vthreshold;   // Trigger voltage threshold \n  output    [15:0]Tthreshold;   // Trigger time threshold \n  output    [ 7:0]CtrlReg;      // bit0=nPD, bit1=Mode, \n\n  inout     [15:0]DB;           // Data bus to MCU\n\n  reg       [ 7:0]Trigg_Mode;   // Trigger Mode \n  reg       [ 7:0]Vthreshold;   // Trigger voltage threshold \n  reg       [15:0]Tthreshold;   // Trigger time threshold \n  reg       [ 7:0]CtrlReg;\n  reg       [ 7:0]RegAddr;\n  reg       [ 7:0]DataBuff;\n  wire      [15:0]DB_Mux ; \n\n  reg       [15:0]Data;\n  reg       [ 7:0]Select;\n  wire      [15:0]CD_Mux ; \n\n  reg       [11:0]Depth;       \n  reg       [11:0]PerCnt;                         \n  reg       [31:0]Delay;      \n   \n  assign nPD = CtrlReg[0];\n        \n  assign CD_Mux = C_D ? Data[15:0] : { 10'h000, Start, Empty, Full, Ready, Dout[17:16] };  \n  assign DB_Mux = H_L ? Dout[15:0] : CD_Mux;  \n   \n  assign DB = ( CE && !nRD ) ? DB_Mux : 16'hzzzz ;\n\n  always @(posedge SCK) begin\n      \n    DataBuff <= { DataBuff[6:0], SDA };\n    \n  end\n  \n  always @( negedge nRD ) begin\n   case( Select )\n     4'b0000: Data <= A_Edge;\n     4'b0001: Data <= A_TL;\n     4'b0010: Data <= A_TH;\n     4'b0100: Data <= B_Edge;\n     4'b0101: Data <= B_TL;\n     4'b0110: Data <= B_TH;\n     4'b1000: Data <= C_Edge;\n     4'b1001: Data <= C_TL;\n     4'b1010: Data <= C_TH;\n     4'b1100: Data <= D_Edge;\n     4'b1101: Data <= D_TL;\n     4'b1110: Data <= D_TH;\n     default: Data <= 0;\n   endcase \n  end\n\n  always @( posedge SDA ) begin\n    if ( !SCK ) begin\n      if ( H_L ) begin\n        RegAddr <= DataBuff;\n      end else begin\n        case( RegAddr )\n          8'h00:  begin \n            Trigg_Mode <= DataBuff;    \n            Depth      <= 4095;\n            PerCnt     <= 150;\n            Delay      <= 1;\n          end\n          8'h01:  Vthreshold       <= DataBuff;    \n          8'h02:  Tthreshold[ 7:0] <= DataBuff;    \n          8'h03:  Tthreshold[15:8] <= DataBuff;    \n          8'h04:  CtrlReg   [ 7:0] <= DataBuff;    \n          8'h05:  Select    [ 7:0] <= DataBuff;    \n          8'h06:  Depth     [ 7:0] <= DataBuff;       \n          8'h07:  Depth     [11:8] <= DataBuff;      \n          8'h08:  PerCnt    [ 7:0] <= DataBuff;                         \n          8'h09:  PerCnt    [11:8] <= DataBuff;                         \n          8'h0A:  Delay     [ 7:0] <= DataBuff;      \n          8'h0B:  Delay     [15:8] <= DataBuff;      \n          8'h0C:  Delay    [23:16] <= DataBuff;      \n          8'h0D:  Delay    [31:24] <= DataBuff;      \n        endcase \n      end\n    end \n  end\n\nendmodule"}
{"task_id": 792, "completion": "parameter RATE_32 = 0;\n    parameter RATE_441 = 1;\n    parameter RATE_48 = 2;\n    parameter RATE_96 = 3;\n    parameter RATE_192 = 4;\n\n    wire [(NUM_CH-1):0] pop_i_32_48;\n    wire [(NUM_CH-1):0] pop_o_32_48;\n    wire [23:0] data_32_48;\n    wire [(NUM_CH-1):0] ack_32_48;\n\n    wire [23:0] bank_data_32_48;\n    wire [5:0] bank_addr_32_48;\n    rom_firbank_32_48 bank_32_48(.clk(clk), .addr(bank_addr_32_48), .data(bank_data_32_48));\n    ringbuffered_resampler #(\n        .NUM_CH(NUM_CH), .NUM_CH_LOG2(NUM_CH_LOG2),\n        .HALFDEPTH(16), .HALFDEPTH_LOG2(4),\n        .NUM_FIR(3), .NUM_FIR_LOG2(2), .DECIM(2),\n        .TIMESLICE(64), .TIMESLICE_LOG2(6)) resampler_32_48(\n        .clk(clk), .rst(rst), .rst_ch(rst_ch),\n        .bank_addr_o(bank_addr_32_48), .bank_data_i(bank_data_32_48),\n        .ack_i(ack_i), .data_i(data_i), .pop_o(pop_o_32_48),\n        .pop_i(pop_i_32_48), .data_o(data_32_48), .ack_o(ack_32_48));\n\n    wire [(NUM_CH-1):0] pop_i_441_480;\n    wire [(NUM_CH-1):0] pop_o_441_480;\n    wire [23:0] data_441_480;\n    wire [(NUM_CH-1):0] ack_441_480;\n\n    wire [23:0] bank_data_441_480;\n    wire [11:0] bank_addr_441_480;\n    rom_firbank_441_480 bank_441_480(.clk(clk), .addr(bank_addr_441_480), .data(bank_data_441_480));\n    ringbuffered_resampler #(\n        .NUM_CH(NUM_CH), .NUM_CH_LOG2(NUM_CH_LOG2),\n        .HALFDEPTH(16), .HALFDEPTH_LOG2(4),\n        .NUM_FIR(160), .NUM_FIR_LOG2(8), .DECIM(147),\n        .TIMESLICE(64), .TIMESLICE_LOG2(6)) resampler_441_480(\n        .clk(clk), .rst(rst), .rst_ch(rst_ch),\n        .bank_addr_o(bank_addr_441_480), .bank_data_i(bank_data_441_480),\n        .ack_i(ack_i), .data_i(data_i), .pop_o(pop_o_441_480),\n        .pop_i(pop_i_441_480), .data_o(data_441_480), .ack_o(ack_441_480));\n\n    wire [(24*NUM_CH-1):0] data_48;\n    wire [(NUM_CH-1):0] ack_48;\n\n    genvar ig48;\n    generate\n    for (ig48 = 0; ig48 < NUM_CH; ig48 = ig48 + 1) begin:g48\n        wire in48 = rate_i[NUM_RATE*ig48+RATE_48];\n        wire in441 = rate_i[NUM_RATE*ig48+RATE_441];\n        assign data_48[(24*ig48) +: 24] =\n            in48 ? data_i[24*ig48 +: 24] :\n            in441 ? data_441_480 : data_32_48;\n        assign ack_48[ig48] =\n            in48 ? ack_i[ig48] :\n            in441 ? ack_441_480[ig48] : ack_32_48[ig48];\n    end\n    endgenerate\n\n    wire [(NUM_CH-1):0] pop_i_48_96;\n    wire [(NUM_CH-1):0] pop_o_48_96;\n    wire [23:0] data_48_96;\n    wire [(NUM_CH-1):0] ack_48_96;\n\n    wire [23:0] bank_data_48_96;\n    wire [4:0] bank_addr_48_96;\n    rom_firbank_48_96 bank_48_96(.clk(clk), .addr(bank_addr_48_96), .data(bank_data_48_96));\n    ringbuffered_resampler #(\n        .NUM_CH(NUM_CH), .NUM_CH_LOG2(NUM_CH_LOG2),\n        .HALFDEPTH(16), .HALFDEPTH_LOG2(4),\n        .NUM_FIR(2), .NUM_FIR_LOG2(1), .DECIM(1),\n        .TIMESLICE(64), .TIMESLICE_LOG2(6)) resampler_48_96(\n        .clk(clk), .rst(rst), .rst_ch(rst_ch),\n        .bank_addr_o(bank_addr_48_96), .bank_data_i(bank_data_48_96),\n        .ack_i(ack_48), .data_i(data_48), .pop_o(pop_o_48_96),\n        .pop_i(pop_i_48_96), .data_o(data_48_96), .ack_o(ack_48_96));\n    assign pop_i_441_480 = pop_o_48_96;\n    assign pop_i_32_48 = pop_o_48_96;\n\n    wire [(24*NUM_CH-1):0] data_96;\n    wire [(NUM_CH-1):0] ack_96;\n\n    genvar ig96;\n    generate\n    for (ig96 = 0; ig96 < NUM_CH; ig96 = ig96 + 1) begin:g96\n        wire in96 = rate_i[NUM_RATE*ig96+RATE_96];\n        assign data_96[(24*ig96) +: 24] = in96 ? data_i[24*ig96 +: 24] : data_48_96;\n        assign ack_96[ig96] = in96 ? ack_i[ig96] : ack_48_96[ig96];\n    end\n    endgenerate\n\n    wire [(NUM_CH-1):0] pop_i_96_192;\n    wire [(NUM_CH-1):0] pop_o_96_192;\n    wire [23:0] data_96_192;\n    wire [(NUM_CH-1):0] ack_96_192;\n\n    wire [23:0] bank_data_96_192;\n    wire [3:0] bank_addr_96_192;\n    rom_firbank_96_192 bank_96_192(.clk(clk), .addr(bank_addr_96_192), .data(bank_data_96_192));\n    ringbuffered_resampler #(\n        .NUM_CH(NUM_CH), .NUM_CH_LOG2(NUM_CH_LOG2),\n        .HALFDEPTH(8), .HALFDEPTH_LOG2(3),\n        .NUM_FIR(2), .NUM_FIR_LOG2(1), .DECIM(1),\n        .TIMESLICE(32), .TIMESLICE_LOG2(5)) resampler_96_192(\n        .clk(clk), .rst(rst), .rst_ch(rst_ch),\n        .bank_addr_o(bank_addr_96_192), .bank_data_i(bank_data_96_192),\n        .ack_i(ack_96), .data_i(data_96), .pop_o(pop_o_96_192),\n        .pop_i(pop_i_96_192), .data_o(data_96_192), .ack_o(ack_96_192));\n    assign pop_i_48_96 = pop_o_96_192;\n\n    genvar ig192;\n    generate\n    for (ig192 = 0; ig192 < NUM_CH; ig192 = ig192 + 1) begin:g192\n        wire in192 = rate_i[NUM_RATE*ig192 + RATE_192];\n\n        wire [23:0] data_192 = in192 ? data_i[24*ig192 +: 24] : data_96_192;\n        wire ack_192 = in192 ? ack_i[ig192] : ack_96_192[ig192];\n        wire pop_192 = pop_i[ig192];\n\n        assign pop_i_96_192[ig192] = pop_192;\n\n        wire [23:0] data_rb;\n        ringbuf rb192(\n            .clk(clk), .rst(rst | rst_ch[ig192]),\n            .data_i(data_192), .we_i(ack_192),\n            .pop_i(pop_192), .offset_i(4'b0), .data_o(data_rb));\n        reg ack_rb_ff;\n        always @(posedge clk) begin\n            if (rst)\n                ack_rb_ff <= 0;\n            else\n                ack_rb_ff <= pop_192;\n        end\n        assign data_o[(24*ig192) +: 24] = data_rb;\n        assign ack_o[ig192] = ack_rb_ff;\n    end\n    endgenerate\n\n    reg [(NUM_CH-1):0] pop_o_reg;\n    genvar igpop;\n    generate\n    for (igpop = 0; igpop < NUM_CH; igpop = igpop + 1) begin:gpop\n        wire [(NUM_RATE-1):0] pop_rate = rate_i[NUM_RATE*igpop +: NUM_RATE];\n        always @(*) begin\n            if (pop_rate[RATE_192])\n                pop_o_reg[igpop] = pop_i[igpop];\n            else if (pop_rate[RATE_96])\n                pop_o_reg[igpop] = pop_o_96_192[igpop];\n            else if (pop_rate[RATE_48])\n                pop_o_reg[igpop] = pop_o_48_96[igpop];\n            else if (pop_rate[RATE_441])\n                pop_o_reg[igpop] = pop_o_441_480[igpop];\n            else\n                pop_o_reg[igpop] = pop_o_32_48[igpop];\n        end\n    end\n    endgenerate\n    assign pop_o = pop_o_reg;\n\nendmodule"}
{"task_id": 834, "completion": "wire nor0_out         ;\n    wire and0_out_X       ;\n    wire pwrgood_pp0_out_X;\n\n    nor                                nor0        (nor0_out         , A_N, B_N              );\n    and                                and0        (and0_out_X       , nor0_out, C, D        );\n    sky130_fd_sc_ls__udp_pwrgood_pp$PG pwrgood_pp0 (pwrgood_pp0_out_X, and0_out_X, VPWR, VGND);\n    buf                                buf0        (X                , pwrgood_pp0_out_X     );\n\nendmodule"}
{"task_id": 788, "completion": "parameter ONE = 3'h0,\n        TWO = 3'h1,\n        FOUR = 3'h2,\n        EIGHT = 3'h3,\n        SIXTEEN = 3'h4,\n        THIRTY_TWO = 3'h5,\n        FMT_1555 = 5'd0,\n        FMT_0565 = 5'd1,\n        FMT_4444 = 5'd2,\n        FMT_8888 = 5'd3,\n        FMT_8332 = 5'd4,\n        FMT_1232 = 5'd5,\n        FMT_0332 = 5'd6,\n        ALPHA4 = 5'd7,\n        ALPHA8 = 5'd8,\n        LUM4 = 5'd9,\n        LUM8 = 5'd10,\n        LUM4_ALPHA4 = 5'd11,\n        LUM6_ALPHA2 = 5'd12,\n        LUM8_ALPHA8 = 5'd13,\n        INT4 = 5'd14,\n        INT8 = 5'd15,\n        RGBA2 = 5'd16;\n\nalways @(posedge de_clk) begin\n  casex (tsize) /* synopsys parallel_case */\n    6'b000000, 6'b000001, 6'b000010, 6'b000011,\n    6'b011000: bpt = ONE;\n    6'b000100, 6'b000101, 6'b000110, 6'b000111,\n    6'b011001: bpt = TWO;\n    6'b100000, 6'b100100, 6'b101100, 6'b001000,\n    6'b001001, 6'b001010, 6'b001011, 6'b011010: bpt = FOUR;\n    6'b100001, 6'b100101, 6'b101000, 6'b101001,\n    6'b101101, 6'b110000, 6'b001100, 6'b001101,\n    6'b001110, 6'b001111, 6'b011100, 6'b011101,\n    6'b111110, 6'b111111, 6'b011110: bpt = EIGHT;\n    6'b101010, 6'b010000, 6'b010001, 6'b010010,\n    6'b010011: bpt = SIXTEEN;\n    default: bpt = THIRTY_TWO;\n  endcase\nend\n\nalways @(posedge de_clk) begin\n  casex (tsize) /* synopsys parallel_case */\n    6'b000000, 6'b000100, 6'b001000, 6'b001110,\n    6'b010001: tfmt = FMT_1555;\n    6'b000001, 6'b000101, 6'b001001, 6'b001111,\n    6'b010010: tfmt = FMT_0565;\n    6'b000010, 6'b000110, 6'b001010, 6'b011100,\n    6'b010000: tfmt = FMT_4444;\n    6'b000011, 6'b000111, 6'b001011, 6'b011101,\n    6'b010100, 6'b111110, 6'b111111: tfmt = FMT_8888;\n    6'b011110, 6'b010011, 6'b011000, 6'b011001,\n    6'b011010: tfmt = FMT_8332;\n    6'b001100: tfmt = FMT_1232;\n    6'b001101: tfmt = FMT_0332;\n    6'b100000: tfmt = ALPHA4;\n    6'b100001: tfmt = ALPHA8;\n    6'b100100: tfmt = LUM4;\n    6'b100101: tfmt = LUM8;\n    6'b101000: tfmt = LUM4_ALPHA4;\n    6'b101001: tfmt = LUM6_ALPHA2;\n    6'b101010: tfmt = LUM8_ALPHA8;\n    6'b101100: tfmt = INT4;\n    6'b101101: tfmt = INT8;\n    default: tfmt = RGBA2;\n  endcase\nend\n\nassign pal_mode = (tsize == 6'h00) | |(tsize == 6'h01) || (tsize == 6'h02) || (tsize == 6'h03) ||\n                  (tsize == 6'h04) | |(tsize == 6'h05) || (tsize == 6'h06) || (tsize == 6'h07) ||\n                  (tsize == 6'h08) | |(tsize == 6'h09) || (tsize == 6'h0A) || (tsize == 6'h0B) ||\n                  (tsize == 6'h18) | |(tsize == 6'h19) || (tsize == 6'h1A) || (tsize == 6'h0E) ||\n                  (tsize == 6'h1A) | |(tsize == 6'h0F) || (tsize == 6'h1C) || (tsize == 6'h1D) ||\n                  (tsize == 6'h3E) | |(tsize == 6'h3F) || (tsize == 6'h1E);\nendmodule"}
{"task_id": 836, "completion": "linescanner_image_capture_unit inst (\n    .enable(enable),\n    .data(data),\n    .rst_cvc(rst_cvc),\n    .rst_cds(rst_cds),\n    .sample(sample),\n    .end_adc(end_adc),\n    .lval(lval),\n    .pixel_clock(pixel_clock),\n    .main_clock_source(main_clock_source),\n    .main_clock(main_clock),\n    .n_reset(n_reset),\n    .load_pulse(load_pulse),\n    .pixel_data(pixel_data),\n    .pixel_captured(pixel_captured)\n  );\nendmodule"}
{"task_id": 837, "completion": "// synthesis translate_off\n\n      BLK_MEM_GEN_V3_3 #(\n\t\t.C_ADDRA_WIDTH(10),\n\t\t.C_ADDRB_WIDTH(10),\n\t\t.C_ALGORITHM(1),\n\t\t.C_BYTE_SIZE(8),\n\t\t.C_COMMON_CLK(0),\n\t\t.C_DEFAULT_DATA(\"0\"),\n\t\t.C_DISABLE_WARN_BHV_COLL(0),\n\t\t.C_DISABLE_WARN_BHV_RANGE(0),\n\t\t.C_FAMILY(\"virtex5\"),\n\t\t.C_HAS_ENA(1),\n\t\t.C_HAS_ENB(0),\n\t\t.C_HAS_INJECTERR(0),\n\t\t.C_HAS_MEM_OUTPUT_REGS_A(0),\n\t\t.C_HAS_MEM_OUTPUT_REGS_B(0),\n\t\t.C_HAS_MUX_OUTPUT_REGS_A(0),\n\t\t.C_HAS_MUX_OUTPUT_REGS_B(0),\n\t\t.C_HAS_REGCEA(0),\n\t\t.C_HAS_REGCEB(0),\n\t\t.C_HAS_RSTA(0),\n\t\t.C_HAS_RSTB(0),\n\t\t.C_INITA_VAL(\"0\"),\n\t\t.C_INITB_VAL(\"0\"),\n\t\t.C_INIT_FILE_NAME(\"no_coe_file_loaded\"),\n\t\t.C_LOAD_INIT_FILE(0),\n\t\t.C_MEM_TYPE(0),\n\t\t.C_MUX_PIPELINE_STAGES(0),\n\t\t.C_PRIM_TYPE(1),\n\t\t.C_READ_DEPTH_A(1024),\n\t\t.C_READ_DEPTH_B(1024),\n\t\t.C_READ_WIDTH_A(16),\n\t\t.C_READ_WIDTH_B(16),\n\t\t.C_RSTRAM_A(0),\n\t\t.C_RSTRAM_B(0),\n\t\t.C_RST_PRIORITY_A(\"CE\"),\n\t\t.C_RST_PRIORITY_B(\"CE\"),\n\t\t.C_RST_TYPE(\"SYNC\"),\n\t\t.C_SIM_COLLISION_CHECK(\"ALL\"),\n\t\t.C_USE_BYTE_WEA(1),\n\t\t.C_USE_BYTE_WEB(1),\n\t\t.C_USE_DEFAULT_DATA(0),\n\t\t.C_USE_ECC(0),\n\t\t.C_WEA_WIDTH(2),\n\t\t.C_WEB_WIDTH(2),\n\t\t.C_WRITE_DEPTH_A(1024),\n\t\t.C_WRITE_DEPTH_B(1024),\n\t\t.C_WRITE_MODE_A(\"WRITE_FIRST\"),\n\t\t.C_WRITE_MODE_B(\"WRITE_FIRST\"),\n\t\t.C_WRITE_WIDTH_A(16),\n\t\t.C_WRITE_WIDTH_B(16),\n\t\t.C_XDEVICEFAMILY(\"virtex5\"))\n\tinst (\n\t\t.CLKA(clka),\n\t\t.ENA(ena),\n\t\t.WEA(wea),\n\t\t.ADDRA(addra),\n\t\t.DINA(dina),\n\t\t.DOUTA(douta),\n\t\t.RSTA(),\n\t\t.REGCEA(),\n\t\t.CLKB(),\n\t\t.RSTB(),\n\t\t.ENB(),\n\t\t.REGCEB(),\n\t\t.WEB(),\n\t\t.ADDRB(),\n\t\t.DINB(),\n\t\t.DOUTB(),\n\t\t.INJECTSBITERR(),\n\t\t.INJECTDBITERR(),\n\t\t.SBITERR(),\n\t\t.DBITERR(),\n\t\t.RDADDRECC());\n\n// synthesis translate_on\n\n// XST black box declaration\n// box_type \"black_box\"\n// synthesis attribute box_type of virtex5_dmem is \"black_box\"\n\nendmodule"}
{"task_id": 356, "completion": "wire active;\n    wire clk;\n    wire hsync;\n    wire rst;\n    wire vsync;\n    wire [9:0] xaddr;\n    wire [9:0] yaddr;\n\n    system_vga_sync_0_0_vga_sync U0\n       (.active(active),\n        .clk(clk),\n        .hsync(hsync),\n        .rst(rst),\n        .vsync(vsync),\n        .xaddr(xaddr),\n        .yaddr(yaddr));\nendmodule\n\n(* ORIG_REF_NAME = \"vga_sync\" *) \nmodule system_vga_sync_0_0_vga_sync\n   (xaddr,\n    active,\n    hsync,\n    vsync,\n    yaddr,\n    clk,\n    rst);\n  output [9:0] xaddr;\n  output active;\n  output hsync;\n  output vsync;\n  output [9:0] yaddr;\n  input clk;\n  input rst;\n\n  wire active;\n  wire active0;\n  wire active_i_2_n_0;\n  wire active_i_3_n_0;\n  wire clk;\n  wire \\h_count_reg[8]_i_1_n_0 ;\n  wire \\h_count_reg[9]_i_2_n_0 ;\n  wire hsync;\n  wire hsync_i_1_n_0;\n  wire hsync_i_2_n_0;\n  wire [9:0] p_0_in;\n  wire [9:0] p_0_in__0;\n  wire rst;\n  wire sel;\n  wire \\v_count_reg[9]_i_3_n_0 ;\n  wire \\v_count_reg[9]_i_4_n_0 ;\n  wire \\v_count_reg[9]_i_5_n_0 ;\n  wire \\v_count_reg[9]_i_6_n_0 ;\n  wire vsync;\n  wire vsync_i_1_n_0;\n  wire [9:0] xaddr;\n  wire [9:0] yaddr;\n\n  LUT5 #(\n    .INIT(32'h00000A2A)) \n    active_i_1\n       (.I0(active_i_3_n_0),\n        .I1(xaddr[8]),\n        .I2(xaddr[9]),\n        .I3(xaddr[7]),\n        .I4(yaddr[9]),\n        .O(active0));\n  LUT1 #(\n    .INIT(2'h1)) \n    active_i_2\n       (.I0(rst),\n        .O(active_i_2_n_0));\n  (* SOFT_HLUTNM = \"soft_lutpair0\" *) \n  LUT4 #(\n    .INIT(16'h7FFF)) \n    active_i_3\n       (.I0(yaddr[7]),\n        .I1(yaddr[5]),\n        .I2(yaddr[6]),\n        .I3(yaddr[8]),\n        .O(active_i_3_n_0));\n  FDCE #(\n    .INIT(1'b0)) \n    active_reg\n       (.C(clk),\n        .CE(1'b1),\n        .CLR(active_i_2_n_0),\n        .D(active0),\n        .Q(active));\n  LUT1 #(\n    .INIT(2'h1)) \n    \\h_count_reg[0]_i_1 \n       (.I0(xaddr[0]),\n        .O(p_0_in[0]));\n  (* SOFT_HLUTNM = \"soft_lutpair7\" *) \n  LUT2 #(\n    .INIT(4'h6)) \n    \\h_count_reg[1]_i_1 \n       (.I0(xaddr[1]),\n        .I1(xaddr[0]),\n        .O(p_0_in[1]));\n  (* SOFT_HLUTNM = \"soft_lutpair7\" *) \n  LUT3 #(\n    .INIT(8'h78)) \n    \\h_count_reg[2]_i_1 \n       (.I0(xaddr[1]),\n        .I1(xaddr[0]),\n        .I2(xaddr[2]),\n        .O(p_0_in[2]));\n  (* SOFT_HLUTNM = \"soft_lutpair3\" *) \n  LUT4 #(\n    .INIT(16'h6AAA)) \n    \\h_count_reg[3]_i_1 \n       (.I0(xaddr[3]),\n        .I1(xaddr[1]),\n        .I2(xaddr[0]),\n        .I3(xaddr[2]),\n        .O(p_0_in[3]));\n  (* SOFT_HLUTNM = \"soft_lutpair3\" *) \n  LUT5 #(\n    .INIT(32'h6AAAAAAA)) \n    \\h_count_reg[4]_i_1 \n       (.I0(xaddr[4]),\n        .I1(xaddr[2]),\n        .I2(xaddr[0]),\n        .I3(xaddr[1]),\n        .I4(xaddr[3]),\n        .O(p_0_in[4]));\n  LUT6 #(\n    .INIT(64'h33332333CCCCCCCC)) \n    \\h_count_reg[5]_i_1 \n       (.I0(xaddr[6]),\n        .I1(xaddr[5]),\n        .I2(xaddr[8]),\n        .I3(xaddr[9]),\n        .I4(xaddr[7]),\n        .I5(\\h_count_reg[9]_i_2_n_0 ),\n        .O(p_0_in[5]));\n  (* SOFT_HLUTNM = \"soft_lutpair5\" *) \n  LUT3 #(\n    .INIT(8'h6A)) \n    \\h_count_reg[6]_i_1 \n       (.I0(xaddr[6]),\n        .I1(xaddr[5]),\n        .I2(\\h_count_reg[9]_i_2_n_0 ),\n        .O(p_0_in[6]));\n  (* SOFT_HLUTNM = \"soft_lutpair5\" *) \n  LUT4 #(\n    .INIT(16'h6AAA)) \n    \\h_count_reg[7]_i_1 \n       (.I0(xaddr[7]),\n        .I1(\\h_count_reg[9]_i_2_n_0 ),\n        .I2(xaddr[5]),\n        .I3(xaddr[6]),\n        .O(p_0_in[7]));\n  LUT6 #(\n    .INIT(64'h3FFFFFF7C0000000)) \n    \\h_count_reg[8]_i_1 \n       (.I0(xaddr[9]),\n        .I1(\\h_count_reg[9]_i_2_n_0 ),\n        .I2(xaddr[5]),\n        .I3(xaddr[7]),\n        .I4(xaddr[6]),\n        .I5(xaddr[8]),\n        .O(\\h_count_reg[8]_i_1_n_0 ));\n  LUT6 #(\n    .INIT(64'h7F80EF00FF00FF00)) \n    \\h_count_reg[9]_i_1 \n       (.I0(xaddr[6]),\n        .I1(xaddr[5]),\n        .I2(xaddr[8]),\n        .I3(xaddr[9]),\n        .I4(xaddr[7]),\n        .I5(\\h_count_reg[9]_i_2_n_0 ),\n        .O(p_0_in[9]));\n  (* SOFT_HLUTNM = \"soft_lutpair2\" *) \n  LUT5 #(\n    .INIT(32'h80000000)) \n    \\h_count_reg[9]_i_2 \n       (.I0(xaddr[1]),\n        .I1(xaddr[0]),\n        .I2(xaddr[2]),\n        .I3(xaddr[4]),\n        .I4(xaddr[3]),\n        .O(\\h_count_reg[9]_i_2_n_0 ));\n  FDCE \\h_count_reg_reg[0] \n       (.C(clk),\n        .CE(1'b1),\n        .CLR(active_i_2_n_0),\n        .D(p_0_in[0]),\n        .Q(xaddr[0]));\n  FDCE \\h_count_reg_reg[1] \n       (.C(clk),\n        .CE(1'b1),\n        .CLR(active_i_2_n_0),\n        .D(p_0_in[1]),\n        .Q(xaddr[1]));\n  FDCE \\h_count_reg_reg[2] \n       (.C(clk),\n        .CE(1'b1),\n        .CLR(active_i_2_n_0),\n        .D(p_0_in[2]),\n        .Q(xaddr[2]));\n  FDCE \\h_count_reg_reg[3] \n       (.C(clk),\n        .CE(1'b1),\n        .CLR(active_i_2_n_0),\n        .D(p_0_in[3]),\n        .Q(xaddr[3]));\n  FDCE \\h_count_reg_reg[4] \n       (.C(clk),\n        .CE(1'b1),\n        .CLR(active_i_2_n_0),\n        .D(p_0_in[4]),\n        .Q(xaddr[4]));\n  FDCE \\h_count_reg_reg[5] \n       (.C(clk),\n        .CE(1'b1),\n        .CLR(active_i_2_n_0),\n        .D(p_0_in[5]),\n        .Q(xaddr[5]));\n  FDCE \\h_count_reg_reg[6] \n       (.C(clk),\n        .CE(1'b1),\n        .CLR(active_i_2_n_0),\n        .D(p_0_in[6]),\n        .Q(xaddr[6]));\n  FDCE \\h_count_reg_reg[7] \n       (.C(clk),\n        .CE(1'b1),\n        .CLR(active_i_2_n_0),\n        .D(p_0_in[7]),\n        .Q(xaddr[7]));\n  FDCE \\h_count_reg_reg[8] \n       (.C(clk),\n        .CE(1'b1),\n        .CLR(active_i_2_n_0),\n        .D(\\h_count_reg[8]_i_1_n_0 ),\n        .Q(xaddr[8]));\n  FDCE \\h_count_reg_reg[9] \n       (.C(clk),\n        .CE(1'b1),\n        .CLR(active_i_2_n_0),\n        .D(p_0_in[9]),\n        .Q(xaddr[9]));\n  LUT6 #(\n    .INIT(64'hFFBFBFBFBFBFBFFF)) \n    hsync_i_1\n       (.I0(xaddr[8]),\n        .I1(xaddr[9]),\n        .I2(xaddr[7]),\n        .I3(hsync_i_2_n_0),\n        .I4(xaddr[5]),\n        .I5(xaddr[6]),\n        .O(hsync_i_1_n_0));\n  (* SOFT_HLUTNM = \"soft_lutpair2\" *) \n  LUT5 #(\n    .INIT(32'hAAAAAAA8)) \n    hsync_i_2\n       (.I0(xaddr[4]),\n        .I1(xaddr[2]),\n        .I2(xaddr[3]),\n        .I3(xaddr[1]),\n        .I4(xaddr[0]),\n        .O(hsync_i_2_n_0));\n  FDCE #(\n    .INIT(1'b0)) \n    hsync_reg\n       (.C(clk),\n        .CE(1'b1),\n        .CLR(active_i_2_n_0),\n        .D(hsync_i_1_n_0),\n        .Q(hsync));\n  LUT6 #(\n    .INIT(64'h5555555555555554)) \n    \\v_count_reg[0]_i_1 \n       (.I0(yaddr[0]),\n        .I1(\\v_count_reg[9]_i_4_n_0 ),\n        .I2(yaddr[7]),\n        .I3(yaddr[4]),\n        .I4(yaddr[8]),\n        .I5(yaddr[6]),\n        .O(p_0_in__0[0]));\n  (* SOFT_HLUTNM = \"soft_lutpair4\" *) \n  LUT2 #(\n    .INIT(4'h6)) \n    \\v_count_reg[1]_i_1 \n       (.I0(yaddr[0]),\n        .I1(yaddr[1]),\n        .O(p_0_in__0[1]));\n  (* SOFT_HLUTNM = \"soft_lutpair4\" *) \n  LUT5 #(\n    .INIT(32'h78007878)) \n    \\v_count_reg[2]_i_1 \n       (.I0(yaddr[0]),\n        .I1(yaddr[1]),\n        .I2(yaddr[2]),\n        .I3(\\v_count_reg[9]_i_4_n_0 ),\n        .I4(\\v_count_reg[9]_i_3_n_0 ),\n        .O(p_0_in__0[2]));\n  LUT6 #(\n    .INIT(64'h7F8000007F807F80)) \n    \\v_count_reg[3]_i_1 \n       (.I0(yaddr[1]),\n        .I1(yaddr[0]),\n        .I2(yaddr[2]),\n        .I3(yaddr[3]),\n        .I4(\\v_count_reg[9]_i_4_n_0 ),\n        .I5(\\v_count_reg[9]_i_3_n_0 ),\n        .O(p_0_in__0[3]));\n  (* SOFT_HLUTNM = \"soft_lutpair1\" *) \n  LUT5 #(\n    .INIT(32'h6AAAAAAA)) \n    \\v_count_reg[4]_i_1 \n       (.I0(yaddr[4]),\n        .I1(yaddr[2]),\n        .I2(yaddr[3]),\n        .I3(yaddr[0]),\n        .I4(yaddr[1]),\n        .O(p_0_in__0[4]));\n  LUT6 #(\n    .INIT(64'h6AAAAAAAAAAAAAAA)) \n    \\v_count_reg[5]_i_1 \n       (.I0(yaddr[5]),\n        .I1(yaddr[1]),\n        .I2(yaddr[0]),\n        .I3(yaddr[3]),\n        .I4(yaddr[2]),\n        .I5(yaddr[4]),\n        .O(p_0_in__0[5]));\n  LUT3 #(\n    .INIT(8'h6A)) \n    \\v_count_reg[6]_i_1 \n       (.I0(yaddr[6]),\n        .I1(\\v_count_reg[9]_i_6_n_0 ),\n        .I2(yaddr[5]),\n        .O(p_0_in__0[6]));\n  (* SOFT_HLUTNM = \"soft_lutpair6\" *) \n  LUT4 #(\n    .INIT(16'h6AAA)) \n    \\v_count_reg[7]_i_1 \n       (.I0(yaddr[7]),\n        .I1(yaddr[5]),\n        .I2(\\v_count_reg[9]_i_6_n_0 ),\n        .I3(yaddr[6]),\n        .O(p_0_in__0[7]));\n  (* SOFT_HLUTNM = \"soft_lutpair0\" *) \n  LUT5 #(\n    .INIT(32'h6AAAAAAA)) \n    \\v_count_reg[8]_i_1 \n       (.I0(yaddr[8]),\n        .I1(yaddr[6]),\n        .I2(yaddr[5]),\n        .I3(yaddr[7]),\n        .I4(\\v_count_reg[9]_i_6_n_0 ),\n        .O(p_0_in__0[8]));\n  LUT6 #(\n    .INIT(64'h0000000000002000)) \n    \\v_count_reg[9]_i_1 \n       (.I0(\\h_count_reg[9]_i_2_n_0 ),\n        .I1(xaddr[7]),\n        .I2(xaddr[9]),\n        .I3(xaddr[8]),\n        .I4(xaddr[5]),\n        .I5(xaddr[6]),\n        .O(sel));\n  LUT6 #(\n    .INIT(64'hD00DD0D0D0D0D0D0)) \n    \\v_count_reg[9]_i_2 \n       (.I0(\\v_count_reg[9]_i_3_n_0 ),\n        .I1(\\v_count_reg[9]_i_4_n_0 ),\n        .I2(yaddr[9]),\n        .I3(\\v_count_reg[9]_i_5_n_0 ),\n        .I4(yaddr[8]),\n        .I5(\\v_count_reg[9]_i_6_n_0 ),\n        .O(p_0_in__0[9]));\n  LUT4 #(\n    .INIT(16'h0001)) \n    \\v_count_reg[9]_i_3 \n       (.I0(yaddr[7]),\n        .I1(yaddr[4]),\n        .I2(yaddr[8]),\n        .I3(yaddr[6]),\n        .O(\\v_count_reg[9]_i_3_n_0 ));\n  LUT6 #(\n    .INIT(64'hFEFFFFFFFFFFFFFF)) \n    \\v_count_reg[9]_i_4 \n       (.I0(yaddr[1]),\n        .I1(yaddr[0]),\n        .I2(yaddr[5]),\n        .I3(yaddr[9]),\n        .I4(yaddr[2]),\n        .I5(yaddr[3]),\n        .O(\\v_count_reg[9]_i_4_n_0 ));\n  (* SOFT_HLUTNM = \"soft_lutpair6\" *) \n  LUT3 #(\n    .INIT(8'h7F)) \n    \\v_count_reg[9]_i_5 \n       (.I0(yaddr[6]),\n        .I1(yaddr[5]),\n        .I2(yaddr[7]),\n        .O(\\v_count_reg[9]_i_5_n_0 ));\n  (* SOFT_HLUTNM = \"soft_lutpair1\" *) \n  LUT5 #(\n    .INIT(32'h80000000)) \n    \\v_count_reg[9]_i_6 \n       (.I0(yaddr[4]),\n        .I1(yaddr[2]),\n        .I2(yaddr[3]),\n        .I3(yaddr[0]),\n        .I4(yaddr[1]),\n        .O(\\v_count_reg[9]_i_6_n_0 ));\n  FDCE \\v_count_reg_reg[0] \n       (.C(clk),\n        .CE(sel),\n        .CLR(active_i_2_n_0),\n        .D(p_0_in__0[0]),\n        .Q(yaddr[0]));\n  FDCE \\v_count_reg_reg[1] \n       (.C(clk),\n        .CE(sel),\n        .CLR(active_i_2_n_0),\n        .D(p_0_in__0[1]),\n        .Q(yaddr[1]));\n  FDCE \\v_count_reg_reg[2] \n       (.C(clk),\n        .CE(sel),\n        .CLR(active_i_2_n_0),\n        .D(p_0_in__0[2]),\n        .Q(yaddr[2]));\n  FDCE \\v_count_reg_reg[3] \n       (.C(clk),\n        .CE(sel),\n        .CLR(active_i_2_n_0),\n        .D(p_0_in__0[3]),\n        .Q(yaddr[3]));\n  FDCE \\v_count_reg_reg[4] \n       (.C(clk),\n        .CE(sel),\n        .CLR(active_i_2_n_0),\n        .D(p_0_in__0[4]),\n        .Q(yaddr[4]));\n  FDCE \\v_count_reg_reg[5] \n       (.C(clk),\n        .CE(sel),\n        .CLR(active_i_2_n_0),\n        .D(p_0_in__0[5]),\n        .Q(yaddr[5]));\n  FDCE \\v_count_reg_reg[6] \n       (.C(clk),\n        .CE(sel),\n        .CLR(active_i_2_n_0),\n        .D(p_0_in__0[6]),\n        .Q(yaddr[6]));\n  FDCE \\v_count_reg_reg[7] \n       (.C(clk),\n        .CE(sel),\n        .CLR(active_i_2_n_0),\n        .D(p_0_in__0[7]),\n        .Q(yaddr[7]));\n  FDCE \\v_count_reg_reg[8] \n       (.C(clk),\n        .CE(sel),\n        .CLR(active_i_2_n_0),\n        .D(p_0_in__0[8]),\n        .Q(yaddr[8]));\n  FDCE \\v_count_reg_reg[9] \n       (.C(clk),\n        .CE(sel),\n        .CLR(active_i_2_n_0),\n        .D(p_0_in__0[9]),\n        .Q(yaddr[9]));\n  LUT6 #(\n    .INIT(64'hFFFFFFEFFFFFFFFF)) \n    vsync_i_1\n       (.I0(active_i_3_n_0),\n        .I1(yaddr[9]),\n        .I2(yaddr[3]),\n        .I3(yaddr[4]),\n        .I4(yaddr[2]),\n        .I5(yaddr[1]),\n        .O(vsync_i_1_n_0));\n  FDCE #(\n    .INIT(1'b0)) \n    vsync_reg\n       (.C(clk),\n        .CE(1'b1),\n        .CLR(active_i_2_n_0),\n        .D(vsync_i_1_n_0),\n        .Q(vsync));\nendmodule"}
{"task_id": 854, "completion": "assign SUM = A ^ B ^ CI;\n    assign COUT = (A & B) | (CI & (A ^ B));\nendmodule"}
{"task_id": 853, "completion": "wire mux_2to1_n0_out_Y;\n\n    sky130_fd_sc_ms__udp_mux_2to1_N mux_2to1_n0 (mux_2to1_n0_out_Y, A0, A1, S);\n    buf buf0 (Y, mux_2to1_n0_out_Y);\n\nendmodule"}
{"task_id": 825, "completion": "wire    B1 or0_out           ;\n    wire    nand0_out_Y       ;\n    wire    u_vpwr_vgnd0_out_Y;\n\n    or                           or0          (or0_out           , A2, A1, A3             );\n    nand                         nand0        (nand0_out_Y       , C1, or0_out, B1        );\n    sky130_fd_sc_hs__u_vpwr_vgnd u_vpwr_vgnd0 (u_vpwr_vgnd0_out_Y, nand0_out_Y, VPWR, VGND);\n    buf                          buf0         (Y                 , u_vpwr_vgnd0_out_Y     );\n\nendmodule"}
{"task_id": 870, "completion": "supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\nendmodule"}
{"task_id": 745, "completion": "parameter AFI_ADDRESS_WIDTH         = \"\";\nparameter AFI_BANK_WIDTH            = \"\";\nparameter AFI_CHIP_SELECT_WIDTH     = \"\";\nparameter AFI_CLK_EN_WIDTH      = \"\";\nparameter AFI_ODT_WIDTH      = \"\";\nparameter MEM_READ_DQS_WIDTH         = \"\";\nparameter AFI_DATA_MASK_WIDTH       = \"\";\nparameter AFI_CONTROL_WIDTH         = \"\";\nparameter AFI_DATA_WIDTH            = \"\";\nparameter AFI_DQS_WIDTH             = \"\";\n\ninput   mux_sel;\n\n// AFI inputs from the controller\ninput   [AFI_ADDRESS_WIDTH-1:0] afi_address;\ninput   [AFI_BANK_WIDTH-1:0]    afi_bank;\ninput   [AFI_CONTROL_WIDTH-1:0] afi_cas_n;\ninput   [AFI_CLK_EN_WIDTH-1:0] afi_cke;\ninput   [AFI_CHIP_SELECT_WIDTH-1:0] afi_cs_n;\ninput   [AFI_ODT_WIDTH-1:0] afi_odt;\ninput   [AFI_CONTROL_WIDTH-1:0] afi_ras_n;\ninput   [AFI_CONTROL_WIDTH-1:0] afi_we_n;\ninput   [AFI_CONTROL_WIDTH-1:0] afi_rst_n;\ninput   [AFI_DQS_WIDTH-1:0]     afi_dqs_burst;\ninput   [AFI_DATA_WIDTH-1:0]    afi_wdata;\ninput   [AFI_DQS_WIDTH-1:0] afi_wdata_valid;\ninput   [AFI_DATA_MASK_WIDTH-1:0]   afi_dm;\ninput   afi_rdata_en;\ninput   afi_rdata_en_full;\noutput  [AFI_DATA_WIDTH-1:0] afi_rdata;\noutput  afi_rdata_valid;\n\n// AFI inputs from the sequencer\ninput  [AFI_ADDRESS_WIDTH-1:0] seq_mux_address;\ninput  [AFI_BANK_WIDTH-1:0]    seq_mux_bank;\ninput  [AFI_CHIP_SELECT_WIDTH-1:0] seq_mux_cs_n;\ninput  [AFI_CLK_EN_WIDTH-1:0] seq_mux_cke;\ninput  [AFI_ODT_WIDTH-1:0] seq_mux_odt;\ninput  [AFI_CONTROL_WIDTH-1:0] seq_mux_ras_n;\ninput  [AFI_CONTROL_WIDTH-1:0] seq_mux_cas_n;\ninput  [AFI_CONTROL_WIDTH-1:0] seq_mux_we_n;\ninput  [AFI_CONTROL_WIDTH-1:0] seq_mux_reset_n;\ninput  [AFI_DQS_WIDTH-1:0]     seq_mux_dqs_en;\ninput  [AFI_DATA_WIDTH-1:0]    seq_mux_wdata;\ninput  [AFI_DQS_WIDTH-1:0]     seq_mux_wdata_valid;\ninput  [AFI_DATA_MASK_WIDTH-1:0]   seq_mux_dm;\ninput  seq_mux_rdata_en;\noutput  [AFI_DATA_WIDTH-1:0]    mux_seq_rdata;\noutput  [AFI_DATA_WIDTH-1:0]    mux_seq_read_fifo_q;\noutput  mux_seq_rdata_valid;\n\n// Mux output to the rest of the PHY logic\noutput  [AFI_ADDRESS_WIDTH-1:0] mux_phy_address;\noutput  [AFI_BANK_WIDTH-1:0]    mux_phy_bank;\noutput  [AFI_CHIP_SELECT_WIDTH-1:0] mux_phy_cs_n;\noutput  [AFI_CLK_EN_WIDTH-1:0] mux_phy_cke;\noutput  [AFI_ODT_WIDTH-1:0] mux_phy_odt;\noutput  [AFI_CONTROL_WIDTH-1:0] mux_phy_ras_n;\noutput  [AFI_CONTROL_WIDTH-1:0] mux_phy_cas_n;\noutput  [AFI_CONTROL_WIDTH-1:0] mux_phy_we_n;\noutput  [AFI_CONTROL_WIDTH-1:0] mux_phy_reset_n;\noutput  [AFI_DQS_WIDTH-1:0]    mux_phy_dqs_en;\noutput  [AFI_DATA_WIDTH-1:0]    mux_phy_wdata;\noutput  [AFI_DQS_WIDTH-1:0]    mux_phy_wdata_valid;\noutput  [AFI_DATA_MASK_WIDTH-1:0]   mux_phy_dm;\noutput  mux_phy_rdata_en;\noutput  mux_phy_rdata_en_full;\ninput   [AFI_DATA_WIDTH-1:0] phy_mux_rdata;\ninput   [AFI_DATA_WIDTH-1:0] phy_mux_read_fifo_q;\ninput   phy_mux_rdata_valid;\n\nassign afi_rdata = phy_mux_rdata;\nassign afi_rdata_valid = mux_sel ? 1'b0 : phy_mux_rdata_valid;\n\nassign mux_seq_rdata = phy_mux_rdata;\nassign mux_seq_read_fifo_q = phy_mux_read_fifo_q;\nassign mux_seq_rdata_valid = phy_mux_rdata_valid;\n\nassign mux_phy_address = mux_sel ? seq_mux_address : afi_address;\nassign mux_phy_bank = mux_sel ? seq_mux_bank : afi_bank;\nassign mux_phy_cs_n = mux_sel ? seq_mux_cs_n : afi_cs_n;\nassign mux_phy_cke = mux_sel ? seq_mux_cke : afi_cke;\nassign mux_phy_odt = mux_sel ? seq_mux_odt : afi_odt;\nassign mux_phy_ras_n = mux_sel ? seq_mux_ras_n : afi_ras_n;\nassign mux_phy_cas_n = mux_sel ? seq_mux_cas_n : afi_cas_n;\nassign mux_phy_we_n = mux_sel ? seq_mux_we_n : afi_we_n;\nassign mux_phy_reset_n = mux_sel ? seq_mux_reset_n : afi_rst_n;\nassign mux_phy_dqs_en = mux_sel ? seq_mux_dqs_en : afi_dqs_burst;\nassign mux_phy_wdata = mux_sel ? seq_mux_wdata : afi_wdata;\nassign mux_phy_wdata_valid = mux_sel ? seq_mux_wdata_valid  : afi_wdata_valid;\nassign mux_phy_dm = mux_sel ? seq_mux_dm : afi_dm;\nassign mux_phy_rdata_en = mux_sel ? seq_mux_rdata_en : afi_rdata_en;\nassign mux_phy_rdata_en_full = mux_sel ? seq_mux_rdata_en : afi_rdata_en_full;\n\n\nendmodule"}
{"task_id": 860, "completion": "output Q      ;\n    input  RESET_B;\n    input  D      ;\n    input  GATE_N ;\n\n    // Voltage supply signals\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    sky130_fd_sc_ls__dlrtn base (\n        .Q(Q),\n        .RESET_B(RESET_B),\n        .D(D),\n        .GATE_N(GATE_N)\n    );\n\nendmodule"}
{"task_id": 869, "completion": "output Y ;\n    input  A1;\n    input  A2;\n    input  A3;\n    input  B1;\n\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\nendmodule"}
{"task_id": 873, "completion": "supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\nendmodule"}
{"task_id": 848, "completion": "reg [31:0] rd0_data;\n   reg [31:0] rd1_data;\n   reg [31:0] rd2_data;\n   wire [31:0] rd0_data_bank0;\n\n   wire [9:0] rd0_addr_last;\n   wire [9:0] rd1_addr_last;\n   wire [9:0] rd2_addr_last;\n\n   dff rd_addr_data_path_delay[10+10+10-1:0]\n     (.q({rd0_addr_last, rd1_addr_last, rd2_addr_last}),\n      .d({rd0_addr, rd1_addr, rd2_addr}),\n      .clk(clk),\n      .rst(1'b0));\n\n   always @(rd0_addr_last or rd0_data_bank0)\n     begin\n        rd0_data <= rd0_data_bank0;\n     end\n\n   wire [31:0] rd1_data_bank0;\n   always @(rd1_addr_last or rd1_data_bank0)\n     begin\n        rd1_data <= rd1_data_bank0;\n     end\n\n   wire [31:0] rd2_data_bank0;\n   always @(rd2_addr_last or rd2_data_bank0)\n     begin\n        rd2_data <= rd2_data_bank0;\n     end\n`ifdef FPGA_BUILD\n  reg_256x32b_3r_1w_fpga\n`else\n  reg_256x32b_3r_1w\n`endif\n   bank0(\n    .rd0_addr(rd0_addr),\n    .rd0_data(rd0_data_bank0),\n    .rd1_addr(rd1_addr),\n    .rd1_data(rd1_data_bank0),\n    .rd2_addr(rd2_addr),\n    .rd2_data(rd2_data_bank0),\n    .wr0_addr(wr0_addr),\n    .wr0_en(wr0_en[0]|wr0_en[1]|wr0_en[2]|wr0_en[3]),\n    .wr0_data(wr0_data[31:0]),\n    .clk(clk)\n  );\n\nendmodule"}
{"task_id": 801, "completion": "reg  [`RV_XLEN-1:0] op_result_mux_out;\n    genvar              genvar_i;\n    reg  [`RV_XLEN-1:0] shift_left_array[0:`RV_XLEN_X];\n    reg  [`RV_XLEN-1:0] shift_right_array[0:`RV_XLEN_X];\n    reg                 cmp_lts;\n    reg                 cmp_ltu;\n\n    always @ `RV_SYNC_LOGIC_CLOCK(clk_i) begin\n        if (stage_en_i) begin\n            op_result_o <= op_result_mux_out;\n        end\n    end\n\n    always @ (*) begin\n        op_result_mux_out = { `RV_XLEN {1'b0} };\n        case (op_opcode_i)\n            `RV_ALUOP_ADD  : op_result_mux_out = op_left_i + op_right_i;\n            `RV_ALUOP_SUB  : op_result_mux_out = op_left_i - op_right_i;\n            `RV_ALUOP_SLL  : op_result_mux_out = shift_left_array[`RV_XLEN_X];\n            `RV_ALUOP_SLT  : op_result_mux_out = { { `RV_XLEN-1 {1'b0} }, cmp_lts };\n            `RV_ALUOP_SLTU : op_result_mux_out = { { `RV_XLEN-1 {1'b0} }, cmp_ltu };\n            `RV_ALUOP_XOR  : op_result_mux_out = op_left_i ^ op_right_i;\n            `RV_ALUOP_SRL  : op_result_mux_out = shift_right_array[`RV_XLEN_X];\n            `RV_ALUOP_SRA  : op_result_mux_out = shift_right_array[`RV_XLEN_X];\n            `RV_ALUOP_OR   : op_result_mux_out = op_left_i | op_right_i;\n            `RV_ALUOP_AND  : op_result_mux_out = op_left_i & op_right_i;\n            `RV_ALUOP_MOV  : op_result_mux_out = op_right_i;\n            default : begin\n            end\n        endcase\n    end\n\n    always @ (*) begin\n        shift_left_array[0]  = op_left_i;\n        shift_right_array[0] = op_left_i;\n    end\n    \n    generate for (genvar_i = 0; genvar_i < `RV_XLEN_X; genvar_i = genvar_i + 1) begin : shifter\n        always @ (*) begin\n            if (op_right_i[genvar_i] == 1'b1) begin\n                shift_left_array[genvar_i + 1][2**genvar_i - 1:   0] = { 2**genvar_i {1'b0} };\n                shift_left_array[genvar_i + 1][`RV_XLEN - 1:2**genvar_i] = shift_left_array[genvar_i][`RV_XLEN - 1 - 2**genvar_i:0];\n                if (op_opcode_i == `RV_ALUOP_SRA && op_left_i[`RV_XLEN-1] == 1'b1) begin\n                    shift_right_array[genvar_i + 1][`RV_XLEN - 1:`RV_XLEN - 2**genvar_i] = { 2**genvar_i {1'b1} };\n                end else begin\n                    shift_right_array[genvar_i + 1][`RV_XLEN - 1:`RV_XLEN - 2**genvar_i] = { 2**genvar_i {1'b0} };\n                end\n                shift_right_array[genvar_i + 1][`RV_XLEN - 1 - 2**genvar_i:0] = shift_right_array[genvar_i][`RV_XLEN - 1:2**genvar_i];\n            end else begin\n                shift_left_array[genvar_i + 1] = shift_left_array[genvar_i];\n                shift_right_array[genvar_i + 1] = shift_right_array[genvar_i];\n            end\n        end\n    end endgenerate\n\n    always @ (*) begin\n        cmp_lts = $signed(cmp_left_i) < $signed(cmp_right_i);\n        cmp_ltu = cmp_left_i < cmp_right_i;\n    end\n    \n    always @ `RV_SYNC_LOGIC_CLOCK(clk_i) begin\n        if (stage_en_i) begin\n            cmp_result_o <= 1'b0;\n            case (cmp_opcode_i)\n                `RV_ALUCOND_EQ  : begin\n                    if (cmp_left_i == cmp_right_i) begin\n                        cmp_result_o <= 1'b1;\n                    end\n                end\n                `RV_ALUCOND_NE  : begin\n                    if (cmp_left_i != cmp_right_i) begin\n                        cmp_result_o <= 1'b1;\n                    end\n                end\n                `RV_ALUCOND_LT  : begin\n                    cmp_result_o <= cmp_lts;\n                end\n                `RV_ALUCOND_GE  : begin\n                    cmp_result_o <= ~cmp_lts;\n                end\n                `RV_ALUCOND_LTU : begin\n                    cmp_result_o <= cmp_ltu;\n                end\n                `RV_ALUCOND_GEU : begin\n                    cmp_result_o <= ~cmp_ltu;\n                end\n                default : begin\n                end\n            endcase\n        end\n    end\nendmodule"}
{"task_id": 876, "completion": "supply1 VPWR;    supply0 VGND;    supply1 VPB;    supply0 VNB;    endmodule"}
{"task_id": 866, "completion": "wire sensor_out, reprogram_out, walk_register, rst_out;\n    wire wr_fsm;\n    wire wr_reset, start_timer;\n    wire [1:0] interval;\n    wire [3:0] tiempo_espera;\n    wire expired;\n\n    synchronizer mod_sync(clk, rst, sensor, reprogram, walk_btn, rst_out, sensor_out, walk_register, reprogram_out);\n    walk_register mod_wk(clk, rst_out, walk_register, wr_reset, wr_fsm);\n    FSM_Semaforo mod_fsm(clk, rst_out, sensor_out, wr_fsm, reprogram_out, expired, wr_reset, interval, start_timer, led_rm, led_ym, leg_gm, led_rs, led_ys, led_gs, led_walk);\n    time_parameters mod_time_p(clk, rst_out, reprogram_out, {bit_a_time_sel, bit_b_time_sel}, {bit_a_new_time, bit_b_new_time, bit_c_new_time, bit_d_new_time }, interval, tiempo_espera);\n    timer mod_timer(clk, rst, start_timer, tiempo_espera, expired);\nendmodule"}
{"task_id": 881, "completion": "endmodule"}
{"task_id": 833, "completion": "`include \"params_proc.v\"\n\n    wire pc_chg_p1;\n    wire [PC_WIDTH-1:0] pc_in_p1, pc_out_p1;\n    wire [INSTR_WIDTH-1:0] instr;\n\n    wire [REG_ADDR_WIDTH-1:0] reg_addr_p2;\n    wire [DATA_WIDTH-1:0] reg_data_p2;\n    wire reg_en_p2;\n    wire [REG_ADDR_WIDTH-1:0] A_addr, B_addr;\n    wire [DATA_WIDTH-1:0] A, B, imm;\n    wire [PC_WIDTH-1:0] pc_out_p2;\n    wire [CTRL_WIDTH-1:0] ctrl_p2;\n\n    wire mem_we_p3;\n    wire [DATA_WIDTH-1:0] data_p3;\n    wire [MEM_WIDTH-1:0] addr_p3;\n    wire [REG_ADDR_WIDTH-1:0] reg_addr_p3;\n    wire [CTRL_WIDTH-1:0] ctrl_out_p3;\n\n    wire [DATA_WIDTH-1:0] reg_data_out_p4;\n    wire [REG_ADDR_WIDTH-1:0] reg_addr_out_p4;\n    wire [CTRL_WIDTH-1:0] ctrl_out_p4;\n\n    pipeline1 pipe1(.clk_in(clk_in), .RST(RST),\n        .pc_chg(pc_chg_p1), .pc_in(pc_in_p1), .pc_out(pc_out_p1),\n        .instr(instr)\n    );\n\n    pipeline2 pipe2(\n        .clk_in(clk_in), .RST(RST),\n        .pc_in(pc_out_p1),\n        .instr(instr),\n        .reg_addr(reg_addr_p2), .reg_data(reg_data_p2), .reg_en(reg_en_p2),\n        .A_addr(A_addr), .B_addr(B_addr),\n        .A(A), .B(B), .imm(imm),\n        .pc_out(pc_out_p2),\n        .ctrl(ctrl_p2)\n    );\n\n    pipeline3 pipe3(\n        .clk_in(clk_in), .RST(RST),\n        .ctrl_in(ctrl_p2), .pc_in(pc_out_p2),\n        .A_addr(A_addr), .B_addr(B_addr),\n        .A(A), .B(B), .imm(imm),\n        .pc_chg(pc_chg_p1), .pc_out(pc_in_p1),\n        .mem_we(mem_we_p3), .data(data_p3), .addr(addr_p3),\n        .reg_addr(reg_addr_p3), .ctrl_out(ctrl_out_p3)\n    );\n\n    pipeline4 pipe4(\n        .clk_in(clk_in), .RST(RST),\n        .ctrl_in(ctrl_out_p3),\n        .we(mem_we_p3), .data(data_p3), .addr(addr_p3),\n        .reg_addr_in(reg_addr_p3),\n        .reg_data_out(reg_data_out_p4), .reg_addr_out(reg_addr_out_p4),\n        .ctrl_out(ctrl_out_p4)\n    );\n\n    pipeline5 pipe5(\n        .clk_in(clk_in), .RST(RST),\n        .ctrl_in(ctrl_out_p4),\n        .data(reg_data_out_p4), .addr(reg_addr_out_p4),\n        .data_out(reg_data_p2), .addr_out(reg_addr_p2), .en_out(reg_en_p2)\n    );\n\nendmodule"}
{"task_id": 882, "completion": "// \u5de6\u53f3\u58f0\u9053\u6570\u636e\u751f\u6210\u903b\u8f91\n        reg [15:0] left_data_reg;\n        reg [15:0] right_data_reg;\n\n        assign left_data = left_data_reg;\n        assign right_data = right_data_reg;\n\n        always @(posedge lrck or posedge reset) begin\n            if (reset) begin\n                left_data_reg <= 0;\n                right_data_reg <= 0;\n            end else begin\n                case (sound_code)\n                    3'b000: begin\n                        left_data_reg <= 16'h0001; // \u793a\u4f8b\u6570\u636e\n                        right_data_reg <= 16'h0001;\n                    end\n                    3'b001: begin\n                        left_data_reg <= 16'h0002;\n                        right_data_reg <= 16'h0002;\n                    end\n                    3'b010: begin\n                        left_data_reg <= 16'h0003;\n                        right_data_reg <= 16'h0003;\n                    end\n                    3'b011: begin\n                        left_data_reg <= 16'h0004;\n                        right_data_reg <= 16'h0004;\n                    end\n                    // \u5176\u4ed6\u58f0\u97f3\u4ee3\u7801\u5904\u7406...\n                    default: begin\n                        left_data_reg <= 16'h0000;\n                        right_data_reg <= 16'h0000;\n                    end\n                endcase\n            end\n        end\n\n    endmodule"}
{"task_id": 852, "completion": "supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\nendmodule"}
{"task_id": 847, "completion": "output Y ;\n    input  A1;\n    input  A2;\n    input  A3;\n    input  A4;\n    input  B1;\n\n    wire and0_out  ;\n    wire nor0_out_Y;\n\n    and and0 (and0_out  , A1, A2, A3, A4 );\n    nor nor0 (nor0_out_Y, B1, and0_out   );\n    buf buf0 (Y         , nor0_out_Y     );\n\nendmodule"}
{"task_id": 871, "completion": "wire sys_clk; \npll pll_inst(\n    .refclk(CLOCK_50),\n    .rst(!KEY[0]), \n    .outclk_0(VGA_CLK), // 25 MHz\n    .outclk_1(sys_clk) // 100 MHz\n);\n\nassign VGA_SYNC_N = 1'b0;\n\nvga_controller vga_ins(\n    .reset(!KEY[0]),\n    .sys_clk(sys_clk),\n    .vga_clk(VGA_CLK),\n    .blank_n(VGA_BLANK_N),\n    .HS(VGA_HS),\n    .VS(VGA_VS),\n    .red(VGA_R),\n    .green(VGA_G),\n    .blue(VGA_B)\n);\n\nendmodule"}
{"task_id": 886, "completion": "output Q      ;\n    output Q_N    ;\n    input  D      ;\n    input  CLK    ;\n    input  SET_B  ;\n    input  RESET_B;\n\n    sky130_fd_sc_ms__dfbbp base (\n        .Q(Q),\n        .Q_N(Q_N),\n        .D(D),\n        .CLK(CLK),\n        .SET_B(SET_B),\n        .RESET_B(RESET_B),\n        .VPWR(VPWR),\n        .VGND(VGND),\n        .VPB(VPB),\n        .VNB(VNB)\n    );\n\nendmodule"}
{"task_id": 506, "completion": "reg int_mema14,int_mema15;\n    reg int_romcs_n,int_ramcs_n;\n    wire int_memoe_n,int_memwe_n;\n    wire int_cs;\n\n    wire ext_romcs_n,\n         ext_memoe_n,\n         ext_memwe_n;\n\n    reg [1:0] memcfg; \n    reg disbl; \n    reg was_cold_reset_n; \n\n    reg  [1:0] dbout;\n    wire [1:0] dbin;\n\n    wire memcfg_write_n;\n    wire rescfg_write_n;\n\n    wire coldrstf_read_n;\n    wire fpgastat_read_n;\n\n    assign dbin[1] = d[7];\n    assign dbin[0] = d[0];\n\n    reg [3:0] rstcount; \n    reg [2:0] disbl_sync;\n\n    clocker clk( .clk1(clk24in),\n                 .clk2(clk20in),\n                 .clksel(clksel1),\n                 .divsel(clksel0),\n                 .clkout(clkout)\n               );\n\n    always @(negedge config_n,posedge init_done)\n    begin\n        if( !config_n ) \n            disbl <= 0;\n        else \n            disbl <= 1;\n    end\n\n    assign mema14  = disbl ? 1'bZ : int_mema14;\n    assign mema15  = disbl ? 1'bZ : int_mema15;\n    assign romcs_n = disbl ? 1'bZ : int_romcs_n;\n    assign memoe_n = disbl ? 1'bZ : int_memoe_n;\n    assign memwe_n = disbl ? 1'bZ : int_memwe_n;\n    assign cs      = disbl ? 1'bZ : int_cs;\n\n    assign ext_romcs_n = romcs_n;\n    assign ext_memoe_n = memoe_n;\n    assign ext_memwe_n = memwe_n;\n\n    always @*\n    begin\n        casex( {a15,a14,memcfg[1]} )\n        3'b00x:\n            {int_mema15,int_mema14,int_romcs_n,int_ramcs_n} <= 4'b0001;\n        3'b01x:\n            {int_mema15,int_mema14,int_romcs_n,int_ramcs_n} <= 4'b0010;\n        3'b1x0:\n            {int_mema15,int_mema14,int_romcs_n,int_ramcs_n} <= {memcfg[0],a14,2'b01};\n        3'b1x1:\n            {int_mema15,int_mema14,int_romcs_n,int_ramcs_n} <= {memcfg[0],a14,2'b10};\n        endcase\n    end\n\n    assign int_memoe_n = mreq_n | rd_n;\n    assign int_memwe_n = mreq_n | wr_n;\n\n    assign memcfg_write_n = iorq_n | wr_n | a7 | ~a6;\n\n    always @(negedge coldres_n, posedge memcfg_write_n)\n    begin\n        if( !coldres_n ) \n            memcfg <= 2'b00;\n        else \n            memcfg <= dbin;\n    end\n\n    assign rescfg_write_n = iorq_n | wr_n | ~a7 | a6;\n\n    always @(posedge rescfg_write_n, negedge coldres_n)\n    begin\n        if( !coldres_n ) \n        begin\n            was_cold_reset_n <= 0; \n            config_n <= 0; \n        end\n        else \n        begin\n            config_n <= dbin[0];\n            was_cold_reset_n <= dbin[1] | was_cold_reset_n;\n        end\n    end\n\n    assign int_cs = a7 & a6;\n    assign coldrstf_read_n = iorq_n | rd_n | a7 | ~a6;\n    assign fpgastat_read_n = iorq_n | rd_n | ~a7 | a6;\n\n    always @*\n    begin\n        case( {coldrstf_read_n,fpgastat_read_n} )\n            2'b01:\n                dbout = { was_cold_reset_n, 1'bX };\n            2'b10:\n                dbout = { status_n, conf_done };\n            default:\n                dbout = 2'bXX;\n        endcase\n    end\n\n    always @(posedge clkin)\n    begin\n        disbl_sync[2:0]={disbl_sync[1:0],disbl};\n    end\n\n    always @(negedge coldres_n,posedge clkin)\n    begin\n        if( coldres_n==0 ) \n        begin\n            rstcount <= (-1);\n            warmres_n <= 0;\n        end\n        else \n        begin\n            if( disbl_sync[2]==0 && disbl_sync[1]==1 ) \n            begin\n                warmres_n <= 0;\n                rstcount <= (-1);\n            end\n            else \n            begin\n                rstcount <= rstcount - 1;\n                if( |rstcount == 0 )\n                    warmres_n <= 1'bZ;\n            end\n        end\n    end\n\n    assign d = ( (!coldrstf_read_n)||(!fpgastat_read_n) )   ?\n               { dbout[1], 6'bXXXXXX, dbout[0] }            :\n               ( (ext_romcs_n&&(!ext_memoe_n)) ? rd : 8'bZZZZZZZZ );\n\n    assign rd = (ext_romcs_n&&(!ext_memwe_n)) ? d : 8'bZZZZZZZZ;\n    assign ra6  = a6;\n    assign ra7  = a7;\n    assign ra10 = a10;\n    assign ra11 = a11;\n    assign ra12 = a12;\n    assign ra13 = a13;\n    assign out_ramcs0_n = disbl ? ( in_ramcs0_n & in_ramcs1_n ) : int_ramcs_n;\n    assign out_ramcs1_n = disbl ? ( in_ramcs2_n & in_ramcs3_n ) : 1'b1;\n    assign mema19 = disbl ? ( in_ramcs0_n & in_ramcs2_n ) : 1'b0;\n\nendmodule"}
{"task_id": 888, "completion": "output Y   ;\n    input  A1  ;\n    input  A2  ;\n    input  A3  ;\n    input  A4  ;\n    input  B1  ;\n    input  VPWR;\n    input  VGND;\n    input  VPB ;\n    input  VNB ;\n    sky130_fd_sc_ms__o41ai base (\n        .Y(Y),\n        .A1(A1),\n        .A2(A2),\n        .A3(A3),\n        .A4(A4),\n        .B1(B1),\n        .VPWR(VPWR),\n        .VGND(VGND),\n        .VPB(VPB),\n        .VNB(VNB)\n    );\n\nendmodule"}
{"task_id": 449, "completion": "reg             mmcm_swrst;\n  reg             mmcm_start;\n  reg             mmcm_start_d;\n  reg     [15:0]  mmcm_clk_out_1;\n  reg     [15:0]  mmcm_clk_out_2;\n  reg     [15:0]  mmcm_clk_div;\n  reg     [15:0]  mmcm_clk_fb_1;\n  reg     [15:0]  mmcm_clk_fb_2;\n  reg     [15:0]  mmcm_lock_1;\n  reg     [15:0]  mmcm_lock_2;\n  reg     [15:0]  mmcm_lock_3;\n  reg     [15:0]  mmcm_filter_1;\n  reg     [15:0]  mmcm_filter_2;\n  reg     [31:0]  up_rdata;\n  reg             up_sel_d;\n  reg             up_sel_2d;\n  reg             up_ack;\n  reg             mmcm_rst;\n  reg     [ 6:0]  mmcm_addr;\n  reg             mmcm_sel;\n  reg     [15:0]  mmcm_rdata;\n  reg     [15:0]  mmcm_wdata;\n  reg             mmcm_wr;\n  reg     [ 3:0]  mmcm_count;\n  reg     [ 2:0]  mmcm_state;\n\n  wire            up_wr_s;\n  wire            up_ack_s;\n  wire            mmcm_start_s;\n  wire    [15:0]  mmcm_wdata_s;\n  reg     [38:0]  mmcm_data_s;\n  wire    [15:0]  mmcm_rdata_s;\n  wire            mmcm_ready_s;\n  wire            mmcm_locked_s;\n  wire            mmcm_clk_s;\n  wire            mmcm_fb_clk_s;\n  wire            buf_fb_clk_s;\n\n  assign up_wr_s = up_sel & ~up_rwn;\n  assign up_ack_s = up_sel_d & ~up_sel_2d;\n  assign mmcm_start_s = mmcm_start & ~mmcm_start_d;\n  assign mmcm_wdata_s = ~mmcm_data_s[31:16] & mmcm_data_s[15:0];\n\n  always @(mmcm_count or mmcm_clk_out_1 or mmcm_clk_out_2 or mmcm_clk_div or\n    mmcm_clk_fb_1 or mmcm_clk_fb_2 or mmcm_lock_1 or mmcm_lock_2 or mmcm_lock_3 or\n    mmcm_filter_1 or mmcm_filter_2) begin\n    case (mmcm_count)\n      4'b0101: mmcm_data_s = {7'h28, 16'h0000, 16'hffff};\n      4'b0110: mmcm_data_s = {7'h08, 16'h1000, mmcm_clk_out_1};\n      4'b0111: mmcm_data_s = {7'h09, 16'hfc00, mmcm_clk_out_2};\n      4'b1000: mmcm_data_s = {7'h16, 16'hc000, mmcm_clk_div};\n      4'b1001: mmcm_data_s = {7'h14, 16'h1000, mmcm_clk_fb_1};\n      4'b1010: mmcm_data_s = {7'h15, 16'hfc00, mmcm_clk_fb_2};\n      4'b1011: mmcm_data_s = {7'h18, 16'hfc00, mmcm_lock_1};\n      4'b1100: mmcm_data_s = {7'h19, 16'h8000, mmcm_lock_2};\n      4'b1101: mmcm_data_s = {7'h1a, 16'h8000, mmcm_lock_3};\n      4'b1110: mmcm_data_s = {7'h4e, 16'h66ff, mmcm_filter_1};\n      4'b1111: mmcm_data_s = {7'h4f, 16'h666f, mmcm_filter_2};\n      default: mmcm_data_s = 'd0;\n    endcase\n  end\n\n  always @(negedge up_rstn or posedge up_clk) begin\n    if (up_rstn == 0) begin\n      mmcm_swrst <= 'd0;\n      mmcm_start <= 'd0;\n      mmcm_start_d <= 'd0;\n      mmcm_clk_out_1 <= 'd0;\n      mmcm_clk_out_2 <= 'd0;\n      mmcm_clk_div <= 'd0;\n      mmcm_clk_fb_1 <= 'd0;\n      mmcm_clk_fb_2 <= 'd0;\n      mmcm_lock_1 <= 'd0;\n      mmcm_lock_2 <= 'd0;\n      mmcm_lock_3 <= 'd0;\n      mmcm_filter_1 <= 'd0;\n      mmcm_filter_2 <= 'd0;\n    end else begin\n      if ((up_addr == 5'h01) && (up_wr_s == 1'b1)) begin\n        mmcm_swrst <= up_wdata[1];\n        mmcm_start <= up_wdata[0];\n      end\n      mmcm_start_d <= mmcm_start;\n      if ((up_addr == 5'h02) && (up_wr_s == 1'b1)) begin\n        mmcm_clk_out_1 <= up_wdata[15:0];\n      end\n      if ((up_addr == 5'h03) && (up_wr_s == 1'b1)) begin\n        mmcm_clk_out_2 <= up_wdata[15:0];\n      end\n      if ((up_addr == 5'h04) && (up_wr_s == 1'b1)) begin\n        mmcm_clk_div <= up_wdata[15:0];\n      end\n      if ((up_addr == 5'h05) && (up_wr_s == 1'b1)) begin\n        mmcm_clk_fb_1 <= up_wdata[15:0];\n      end\n      if ((up_addr == 5'h06) && (up_wr_s == 1'b1)) begin\n        mmcm_clk_fb_2 <= up_wdata[15:0];\n      end\n      if ((up_addr == 5'h07) && (up_wr_s == 1'b1)) begin\n        mmcm_lock_1 <= up_wdata[15:0];\n      end\n      if ((up_addr == 5'h08) && (up_wr_s == 1'b1)) begin\n        mmcm_lock_2 <= up_wdata[15:0];\n      end\n      if ((up_addr == 5'h09) && (up_wr_s == 1'b1)) begin\n        mmcm_lock_3 <= up_wdata[15:0];\n      end\n      if ((up_addr == 5'h0a) && (up_wr_s == 1'b1)) begin\n        mmcm_filter_1 <= up_wdata[15:0];\n      end\n      if ((up_addr == 5'h0b) && (up_wr_s == 1'b1)) begin\n        mmcm_filter_2 <= up_wdata[15:0];\n      end\n    end\n  end\n\n  always @(negedge up_rstn or posedge up_clk) begin\n    if (up_rstn == 0) begin\n      up_rdata <= 'd0;\n      up_sel_d <= 'd0;\n      up_sel_2d <= 'd0;\n      up_ack <= 'd0;\n    end else begin\n      case (up_addr)\n        5'h00: up_rdata <= 32'h00010061;\n        5'h01: up_rdata <= {30'd0, mmcm_swrst, mmcm_start};\n        5'h02: up_rdata <= {16'd0, mmcm_clk_out_1};\n        5'h03: up_rdata <= {16'd0, mmcm_clk_out_2};\n        5'h04: up_rdata <= {16'd0, mmcm_clk_div};\n        5'h05: up_rdata <= {16'd0, mmcm_clk_fb_1};\n        5'h06: up_rdata <= {16'd0, mmcm_clk_fb_2};\n        5'h07: up_rdata <= {16'd0, mmcm_lock_1};\n        5'h08: up_rdata <= {16'd0, mmcm_lock_2};\n        5'h09: up_rdata <= {16'd0, mmcm_lock_3};\n        5'h0a: up_rdata <= {16'd0, mmcm_filter_1};\n        5'h0b: up_rdata <= {16'd0, mmcm_filter_2};\n        5'h1f: up_rdata <= {30'd0, mmcm_rst, mmcm_locked_s};\n        default: up_rdata <= 0;\n      endcase\n      up_sel_d <= up_sel;\n      up_sel_2d <= up_sel_d;\n      up_ack <= up_ack_s;\n    end\n  end\n\n  always @(negedge up_rstn or posedge up_clk) begin\n    if (up_rstn == 0) begin\n      mmcm_rst <= 'd1;\n      mmcm_addr <= 'd0;\n      mmcm_sel <= 'd0;\n      mmcm_rdata <= 'd0;\n      mmcm_wdata <= 'd0;\n      mmcm_wr <= 'd0;\n      mmcm_count <= 'd0;\n      mmcm_state <= 'd0;\n    end else begin\n      if (mmcm_state == MMCM_IDLE) begin\n        mmcm_rst <= mmcm_swrst;\n      end else begin\n        mmcm_rst <= 1'b1;\n      end\n      if (mmcm_state == MMCM_READ) begin\n        mmcm_addr <= mmcm_data_s[38:32];\n      end else if (mmcm_state == MMCM_IDLE) begin\n        mmcm_addr <= 'd0;\n      end\n      if ((mmcm_state == MMCM_READ) || (mmcm_state == MMCM_WRITE)) begin\n        mmcm_sel <= 1'b1;\n      end else begin\n        mmcm_sel <= 1'b0;\n      end\n      if ((mmcm_state == MMCM_RDRDY) && (mmcm_ready_s == 1'b1)) begin\n        mmcm_rdata <= mmcm_rdata_s;\n      end\n      if (mmcm_state == MMCM_WRITE) begin\n        mmcm_wdata <= (mmcm_data_s[31:16] & mmcm_rdata) | mmcm_wdata_s;\n      end else begin\n        mmcm_wdata <= 'd0;\n      end\n      if (mmcm_state == MMCM_WRITE) begin\n        mmcm_wr <= 1'b1;\n      end else begin\n        mmcm_wr <= 1'b0;\n      end\n      if (mmcm_state == MMCM_IDLE) begin\n        mmcm_count <= 4'h5;\n      end else if (mmcm_state == MMCM_WRITE) begin\n        mmcm_count <= mmcm_count + 1'b1;\n      end\n      case (mmcm_state)\n        MMCM_IDLE: begin\n          if ((mmcm_locked_s == 1'b1) && (mmcm_start_s == 1'b1)) begin\n            mmcm_state <= MMCM_READ;\n          end else begin\n            mmcm_state <= MMCM_IDLE;\n          end\n        end\n        MMCM_READ: begin\n          mmcm_state <= MMCM_RDRDY;\n        end\n        MMCM_RDRDY: begin\n          if (mmcm_ready_s == 1'b1) begin\n            mmcm_state <= MMCM_WRITE;\n          end else begin\n            mmcm_state <= MMCM_RDRDY;\n          end\n        end\n        MMCM_WRITE: begin\n          mmcm_state <= MMCM_WRRDY;\n        end\n        MMCM_WRRDY: begin\n          if (mmcm_ready_s == 1'b0) begin\n            mmcm_state <= MMCM_WRRDY;\n          end else if (mmcm_count == 0) begin\n            mmcm_state <= MMCM_IDLE;\n          end else begin\n            mmcm_state <= MMCM_READ;\n          end\n        end\n        default: begin\n          mmcm_state <= MMCM_IDLE;\n        end\n      endcase\n    end\n  end\n\n  generate\n  if (MMCM_TYPE == 1) begin\n  MMCM_ADV #(\n    .BANDWIDTH (\"OPTIMIZED\"),\n    .CLKOUT4_CASCADE (\"FALSE\"),\n    .CLOCK_HOLD (\"FALSE\"),\n    .COMPENSATION (\"ZHOLD\"),\n    .STARTUP_WAIT (\"FALSE\"),\n    .DIVCLK_DIVIDE (11),\n    .CLKFBOUT_MULT_F (49.000),\n    .CLKFBOUT_PHASE (0.000),\n    .CLKFBOUT_USE_FINE_PS (\"FALSE\"),\n    .CLKOUT0_DIVIDE_F (6.000),\n    .CLKOUT0_PHASE (0.000),\n    .CLKOUT0_DUTY_CYCLE (0.500),\n    .CLKOUT0_USE_FINE_PS (\"FALSE\"),\n    .CLKIN1_PERIOD (5.000),\n    .REF_JITTER1 (0.010))\n  i_mmcm (\n    .CLKFBOUT (mmcm_fb_clk_s),\n    .CLKFBIN (buf_fb_clk_s),\n    .CLKFBOUTB (),\n    .CLKOUT0 (mmcm_clk_s),\n    .CLKOUT0B (),\n    .CLKOUT1 (),\n    .CLKOUT1B (),\n    .CLKOUT2 (),\n    .CLKOUT2B (),\n    .CLKOUT3 (),\n    .CLKOUT3B (),\n    .CLKOUT4 (),\n    .CLKOUT5 (),\n    .CLKOUT6 (),\n    .CLKIN1 (ref_clk),\n    .CLKIN2 (1'b0),\n    .CLKINSEL (1'b1),\n    .DCLK (up_clk),\n    .DADDR (mmcm_addr),\n    .DEN (mmcm_sel),\n    .DI (mmcm_wdata),\n    .DO (mmcm_rdata_s),\n    .DRDY (mmcm_ready_s),\n    .DWE (mmcm_wr),\n    .PSCLK (1'b0),\n    .PSEN (1'b0),\n    .PSINCDEC (1'b0),\n    .PSDONE (),\n    .LOCKED (mmcm_locked_s),\n    .CLKINSTOPPED (),\n    .CLKFBSTOPPED (),\n    .PWRDWN (1'b0),\n    .RST (mmcm_rst));\n  end else begin\n  MMCME2_ADV #(\n    .BANDWIDTH (\"OPTIMIZED\"),\n    .CLKOUT4_CASCADE (\"FALSE\"),\n    .COMPENSATION (\"ZHOLD\"),\n    .STARTUP_WAIT (\"FALSE\"),\n    .DIVCLK_DIVIDE (11),\n    .CLKFBOUT_MULT_F (49.000),\n    .CLKFBOUT_PHASE (0.000),\n    .CLKFBOUT_USE_FINE_PS (\"FALSE\"),\n    .CLKOUT0_DIVIDE_F (6.000),\n    .CLKOUT0_PHASE (0.000),\n    .CLKOUT0_DUTY_CYCLE (0.500),\n    .CLKOUT0_USE_FINE_PS (\"FALSE\"),\n    .CLKIN1_PERIOD (5.000),\n    .REF_JITTER1 (0.010))\n  i_mmcm (\n    .CLKFBOUT (mmcm_fb_clk_s),\n    .CLKFBIN (buf_fb_clk_s),\n    .CLKFBOUTB (),\n    .CLKOUT0 (mmcm_clk_s),\n    .CLKOUT0B (),\n    .CLKOUT1 (),\n    .CLKOUT1B (),\n    .CLKOUT2 (),\n    .CLKOUT2B (),\n    .CLKOUT3 (),\n    .CLKOUT3B (),\n    .CLKOUT4 (),\n    .CLKOUT5 (),\n    .CLKOUT6 (),\n    .CLKIN1 (ref_clk),\n    .CLKIN2 (1'b0),\n    .CLKINSEL (1'b1),\n    .DCLK (up_clk),\n    .DADDR (mmcm_addr),\n    .DEN (mmcm_sel),\n    .DI (mmcm_wdata),\n    .DO (mmcm_rdata_s),\n    .DRDY (mmcm_ready_s),\n    .DWE (mmcm_wr),\n    .PSCLK (1'b0),\n    .PSEN (1'b0),\n    .PSINCDEC (1'b0),\n    .PSDONE (),\n    .LOCKED (mmcm_locked_s),\n    .CLKINSTOPPED (),\n    .CLKFBSTOPPED (),\n    .PWRDWN (1'b0),\n    .RST (mmcm_rst));\n  end\n  endgenerate\n\n  BUFG i_fb_buf (\n    .I (mmcm_fb_clk_s),\n    .O (buf_fb_clk_s));\n\n  BUFG i_buf (\n    .I (mmcm_clk_s),\n    .O (clk));\nendmodule"}
{"task_id": 791, "completion": "wire [39:0]vect_char_a;\n    wire [39:0]vect_char_b;\n    wire [39:0]vect_char_c;\n    wire [39:0]vect_char_d;\n    wire [39:0]vect_char_e;\n    wire [39:0]vect_char_f;\n    wire [39:0]vect_char_g;\n    wire [39:0]vect_char_h;\n    wire [39:0]vect_char_i;\n    wire [39:0]vect_char_j;\n    wire [39:0]vect_char_k;\n    wire [39:0]vect_char_l;\n    wire [39:0]vect_char_m;\n    wire [39:0]vect_char_n;\n    wire [39:0]vect_char_o;\n    wire [39:0]vect_char_p;\n    wire [39:0]vect_char_q;\n    wire [39:0]vect_char_r;\n    wire [39:0]vect_char_s;\n    wire [39:0]vect_char_t;\n    wire [39:0]vect_char_u;\n    wire [39:0]vect_char_v;\n    wire [39:0]vect_char_w;\n    wire [39:0]vect_char_x;\n    wire [39:0]vect_char_y;\n    wire [39:0]vect_char_z;\n\n    wire [39:0]vect_num_0;\n    wire [39:0]vect_num_1;\n    wire [39:0]vect_num_2;\n    wire [39:0]vect_num_3;\n    wire [39:0]vect_num_4;\n    wire [39:0]vect_num_5;\n    wire [39:0]vect_num_6;\n    wire [39:0]vect_num_7;\n    wire [39:0]vect_num_8;\n    wire [39:0]vect_num_9;\n    wire [39:0]vect_num_p;\n\n    wire [39:0]vect_op_suma;\n    wire [39:0]vect_op_mult;\n    wire [39:0]vect_op_resta;\n    wire [39:0]vect_op_AND;\n    wire [39:0]vect_op_OR;\n    wire [39:0]vect_char_E;\n    wire [39:0]vect_char_X;\n    wire [39:0]vect_char_C;\n    wire [39:0]vect_char_space;\n    wire [39:0]vect_char_D;\n    wire [39:0]vect_char_H;\n\n    assign vect_char_a={5'b00000,5'b11110,5'b10001,5'b11110,5'b10000,5'b01110,5'b00000,5'b00000};\n    assign vect_char_b={5'b00000,5'b01111,5'b10001,5'b10001,5'b10011,5'b01101,5'b00001,5'b00001};\n    assign vect_char_c={5'b00000,5'b01110,5'b10001,5'b00001,5'b00001,5'b01110,5'b00000,5'b00000};\n    assign vect_char_d={5'b00000,5'b11110,5'b10001,5'b10001,5'b11001,5'b10110,5'b10000,5'b10000};\n    assign vect_char_e={5'b00000,5'b01110,5'b00001,5'b11111,5'b10001,5'b01110,5'b00000,5'b00000};\n    assign vect_char_f={5'b00000,5'b00010,5'b00010,5'b00010,5'b00111,5'b00010,5'b10010,5'b01100};\n    assign vect_char_g={5'b00000,5'b01110,5'b10000,5'b11110,5'b10001,5'b10001,5'b11110,5'b00000};\n    assign vect_char_h={5'b00000,5'b10001,5'b10001,5'b10001,5'b10011,5'b01101,5'b00001,5'b00001};\n    assign vect_char_i={5'b00000,5'b01110,5'b00100,5'b00100,5'b00100,5'b00110,5'b00000,5'b00100};\n    assign vect_char_j={5'b00000,5'b00110,5'b01001,5'b01000,5'b01000,5'b01100,5'b00000,5'b01000};\n    assign vect_char_k={5'b00000,5'b01001,5'b00101,5'b00011,5'b00101,5'b01001,5'b00001,5'b00001};\n    assign vect_char_l={5'b00000,5'b01110,5'b00100,5'b00100,5'b00100,5'b00100,5'b00100,5'b00110};\n    assign vect_char_m={5'b00000,5'b10001,5'b10001,5'b10101,5'b10101,5'b01011,5'b00000,5'b00000};\n    assign vect_char_n={5'b00000,5'b10001,5'b10001,5'b10001,5'b10011,5'b01101,5'b00000,5'b00000};\n    assign vect_char_o={5'b00000,5'b01110,5'b10001,5'b10001,5'b10001,5'b01110,5'b00000,5'b00000};\n    assign vect_char_p={5'b00000,5'b00001,5'b00001,5'b01111,5'b10001,5'b01111,5'b00000,5'b00000};\n    assign vect_char_q={5'b00000,5'b10000,5'b10000,5'b11110,5'b11001,5'b10110,5'b00000,5'b00000};\n    assign vect_char_r={5'b00000,5'b00001,5'b00001,5'b00001,5'b10011,5'b01101,5'b00000,5'b00000};\n    assign vect_char_s={5'b00000,5'b01111,5'b10000,5'b01110,5'b00001,5'b01110,5'b00000,5'b00000};\n    assign vect_char_t={5'b00000,5'b01100,5'b10010,5'b00010,5'b00010,5'b00111,5'b00010,5'b00010};\n    assign vect_char_u={5'b00000,5'b10110,5'b11001,5'b10001,5'b10001,5'b10001,5'b00000,5'b00000};\n    assign vect_char_v={5'b00000,5'b00100,5'b01010,5'b10001,5'b10001,5'b10001,5'b00000,5'b00000};\n    assign vect_char_w={5'b00000,5'b01010,5'b10101,5'b10101,5'b10001,5'b10001,5'b00000,5'b00000};\n    assign vect_char_x={5'b00000,5'b10001,5'b01010,5'b00100,5'b01010,5'b10001,5'b00000,5'b00000};\n    assign vect_char_y={5'b00000,5'b01110,5'b10000,5'b11110,5'b10001,5'b10001,5'b00000,5'b00000};\n    assign vect_char_z={5'b00000,5'b11111,5'b00010,5'b00100,5'b01000,5'b11111,5'b00000,5'b00000};\n    assign vect_char_E={5'b00000,5'b11111,5'b00001,5'b00001,5'b01111,5'b00001,5'b00001,5'b11111};\n    assign vect_char_C={5'b00000,5'b01110,5'b10001,5'b00001,5'b00001,5'b00001,5'b10001,5'b01110};\n    assign vect_char_X={5'b00000,5'b10001,5'b10001,5'b01010,5'b00100,5'b01010,5'b10001,5'b10001};\n    assign vect_char_space={5'b00000,5'b00000,5'b00000,5'b00000,5'b00000,5'b00000,5'b00000,5'b00000};\n    assign vect_char_D={5'b00000,5'b00111,5'b01001,5'b10001,5'b10001,5'b10001,5'b01001,5'b00111};\n    assign vect_char_H={5'b00000,5'b10001,5'b10001,5'b10001,5'b11111,5'b10001,5'b10001,5'b10001};\n\n    assign vect_op_AND={5'b00000,5'b10110,5'b01001,5'b10101,5'b00010,5'b00101,5'b01001,5'b00110};\n    assign vect_op_mult={5'b00000,5'b00100,5'b10101,5'b01110,5'b10101,5'b00100,5'b00000,5'b00000};\n    assign vect_op_suma={5'b00000,5'b00100,5'b00100,5'b11111,5'b00100,5'b00100,5'b00000,5'b00000};\n    assign vect_op_OR={5'b00100,5'b00100,5'b00100,5'b00100,5'b00100,5'b00100,5'b00100,5'b00100};\n    assign vect_op_resta={5'b00000,5'b00000,5'b00000,5'b11111,5'b00000,5'b00000,5'b00000,5'b00000};\n\n    assign vect_num_0={5'b00000,5'b01110,5'b10001,5'b10011,5'b10101,5'b11001,5'b10001,5'b01110};\n    assign vect_num_1={5'b00000,5'b01110,5'b00100,5'b00100,5'b00100,5'b00100,5'b00110,5'b00100};\n    assign vect_num_2={5'b00000,5'b11111,5'b00010,5'b00100,5'b01000,5'b10000,5'b10001,5'b01110};\n    assign vect_num_3={5'b00000,5'b01110,5'b10001,5'b10000,5'b01000,5'b00100,5'b01000,5'b11111};\n    assign vect_num_4={5'b00000,5'b01000,5'b01000,5'b11111,5'b01001,5'b01010,5'b01100,5'b01000};\n    assign vect_num_5={5'b00000,5'b0110,5'b10001,5'b10000,5'b10000,5'b01111,5'b00010,5'b11111};\n    assign vect_num_6={5'b00000,5'b01110,5'b10001,5'b10001,5'b01111,5'b00001,5'b00010,5'b01100};\n    assign vect_num_7={5'b00000,5'b00010,5'b00010,5'b00010,5'b00100,5'b01000,5'b10000,5'b11111};\n    assign vect_num_8={5'b00000,5'b01110,5'b10001,5'b10001,5'b01110,5'b10001,5'b10001,5'b01110};\n    assign vect_num_9={5'b00000,5'b00110,5'b01000,5'b10000,5'b11110,5'b10001,5'b10001,5'b01110};\n    assign vect_num_p={5'b00000,5'b00110,5'b00110,5'b00000,5'b00000,5'b00000,5'b00000,5'b00000};\n\n    always@(*)\n        case(select)\n            8'd0:vec_char=vect_num_0;\n            8'd1:vec_char=vect_num_1;\n            8'd2:vec_char=vect_num_2;\n            8'd3:vec_char=vect_num_3;\n            8'd4:vec_char=vect_num_4;\n            8'd5:vec_char=vect_num_5;\n            8'd6:vec_char=vect_num_6;\n            8'd7:vec_char=vect_num_7;\n            8'd8:vec_char=vect_num_8;\n            8'd9:vec_char=vect_num_9;\n            8'd46:vec_char=vect_num_p;\n            \"+\":vec_char=vect_op_suma;\n            \"*\":vec_char=vect_op_mult;\n            \"-\":vec_char=vect_op_resta;\n            \"|\":vec_char=vect_op_OR;\n            \"&\":vec_char=vect_op_AND;\n            \" \":vec_char=vect_char_space;\n            8'd10:vec_char=vect_char_a;\n            8'd11:vec_char=vect_char_b;\n            8'd12:vec_char=vect_char_c;\n            8'd13:vec_char=vect_char_d;\n            8'd14:vec_char=vect_char_e;\n            8'd15:vec_char=vect_char_f;\n            8'd103:vec_char=vect_char_g;\n            8'd104:vec_char=vect_char_h;\n            8'd105:vec_char=vect_char_i;\n            8'd106:vec_char=vect_char_j;\n            8'd107:vec_char=vect_char_k;\n            8'd108:vec_char=vect_char_l;\n            8'd109:vec_char=vect_char_m;\n            8'd110:vec_char=vect_char_n;\n            8'd111:vec_char=vect_char_o;\n            8'd112:vec_char=vect_char_p;\n            8'd113:vec_char=vect_char_q;\n            8'd114:vec_char=vect_char_r;\n            8'd115:vec_char=vect_char_s;\n            8'd116:vec_char=vect_char_t;\n            8'd117:vec_char=vect_char_u;\n            8'd118:vec_char=vect_char_v;\n            8'd119:vec_char=vect_char_w;\n            8'd120:vec_char=vect_char_x;\n            8'd121:vec_char=vect_char_y;\n            8'd122:vec_char=vect_char_z;\n            8'd201:vec_char=vect_char_E;\n            8'd199:vec_char=vect_char_C;\n            8'd220:vec_char=vect_char_X;\n            8'd200:vec_char=vect_char_D;\n            8'd204:vec_char=vect_char_H;\n            default :vec_char=vect_num_p;\n        endcase\nendmodule"}
{"task_id": 762, "completion": "axi_dwidth_converter_v2_1_11_top #(    .C_FAMILY(\"artix7\"),    .C_AXI_PROTOCOL(0),    .C_S_AXI_ID_WIDTH(1),    .C_SUPPORTS_ID(0),    .C_AXI_ADDR_WIDTH(32),    .C_S_AXI_DATA_WIDTH(32),    .C_M_AXI_DATA_WIDTH(128),    .C_AXI_SUPPORTS_WRITE(1),    .C_AXI_SUPPORTS_READ(1),    .C_FIFO_MODE(0),    .C_S_AXI_ACLK_RATIO(1),    .C_M_AXI_ACLK_RATIO(2),    .C_AXI_IS_ACLK_ASYNC(0),    .C_MAX_SPLIT_BEATS(16),    .C_PACKING_LEVEL(1),    .C_SYNCHRONIZER_STAGE(3)  ) inst (    .s_axi_aclk(s_axi_aclk),    .s_axi_aresetn(s_axi_aresetn),    .s_axi_awid(1'H0),    .s_axi_awaddr(s_axi_awaddr),    .s_axi_awlen(s_axi_awlen),    .s_axi_awsize(s_axi_awsize),    .s_axi_awburst(s_axi_awburst),    .s_axi_awlock(s_axi_awlock),    .s_axi_awcache(s_axi_awcache),    .s_axi_awprot(s_axi_awprot),    .s_axi_awregion(s_axi_awregion),    .s_axi_awqos(s_axi_awqos),    .s_axi_awvalid(s_axi_awvalid),    .s_axi_awready(s_axi_awready),    .s_axi_wdata(s_axi_wdata),    .s_axi_wstrb(s_axi_wstrb),    .s_axi_wlast(s_axi_wlast),    .s_axi_wvalid(s_axi_wvalid),    .s_axi_wready(s_axi_wready),    .s_axi_bid(),    .s_axi_bresp(s_axi_bresp),    .s_axi_bvalid(s_axi_bvalid),    .s_axi_bready(s_axi_bready),    .s_axi_arid(1'H0),    .s_axi_araddr(s_axi_araddr),    .s_axi_arlen(s_axi_arlen),    .s_axi_arsize(s_axi_arsize),    .s_axi_arburst(s_axi_arburst),    .s_axi_arlock(s_axi_arlock),    .s_axi_arcache(s_axi_arcache),    .s_axi_arprot(s_axi_arprot),    .s_axi_arregion(s_axi_arregion),    .s_axi_arqos(s_axi_arqos),    .s_axi_arvalid(s_axi_arvalid),    .s_axi_arready(s_axi_arready),    .s_axi_rid(),    .s_axi_rdata(s_axi_rdata),    .s_axi_rresp(s_axi_rresp),    .s_axi_rlast(s_axi_rlast),    .s_axi_rvalid(s_axi_rvalid),    .s_axi_rready(s_axi_rready),    .m_axi_aclk(1'H0),    .m_axi_aresetn(1'H0),    .m_axi_awaddr(m_axi_awaddr),    .m_axi_awlen(m_axi_awlen),    .m_axi_awsize(m_axi_awsize),    .m_axi_awburst(m_axi_awburst),    .m_axi_awlock(m_axi_awlock),    .m_axi_awcache(m_axi_awcache),    .m_axi_awprot(m_axi_awprot),    .m_axi_awregion(m_axi_awregion),    .m_axi_awqos(m_axi_awqos),    .m_axi_awvalid(m_axi_awvalid),    .m_axi_awready(m_axi_awready),    .m_axi_wdata(m_axi_wdata),    .m_axi_wstrb(m_axi_wstrb),    .m_axi_wlast(m_axi_wlast),    .m_axi_wvalid(m_axi_wvalid),    .m_axi_wready(m_axi_wready),    .m_axi_bresp(m_axi_bresp),    .m_axi_bvalid(m_axi_bvalid),    .m_axi_bready(m_axi_bready),    .m_axi_araddr(m_axi_araddr),    .m_axi_arlen(m_axi_arlen),    .m_axi_arsize(m_axi_arsize),    .m_axi_arburst(m_axi_arburst),    .m_axi_arlock(m_axi_arlock),    .m_axi_arcache(m_axi_arcache),    .m_axi_arprot(m_axi_arprot),    .m_axi_arregion(m_axi_arregion),    .m_axi_arqos(m_axi_arqos),    .m_axi_arvalid(m_axi_arvalid),    .m_axi_arready(m_axi_arready),    .m_axi_rdata(m_axi_rdata),    .m_axi_rresp(m_axi_rresp),    .m_axi_rlast(m_axi_rlast),    .m_axi_rvalid(m_axi_rvalid),    .m_axi_rready(m_axi_rready)  );endmodule"}
{"task_id": 897, "completion": "output Z   ;\n    input  A   ;\n    input  TE_B;\n    input  VPWR;\n    input  VGND;\n    input  VPB ;\n    input  VNB ;\n\n    wire pwrgood_pp0_out_A  ;\n    wire pwrgood_pp1_out_teb;\n\n    sky130_fd_sc_lp__udp_pwrgood_pp$PG pwrgood_pp0 (pwrgood_pp0_out_A  , A, VPWR, VGND                         );\n    sky130_fd_sc_lp__udp_pwrgood_pp$PG pwrgood_pp1 (pwrgood_pp1_out_teb, TE_B, VPWR, VGND                      );\n    notif0                             notif00     (Z                  , pwrgood_pp0_out_A, pwrgood_pp1_out_teb);\n\nendmodule"}
{"task_id": 899, "completion": "logic [32+packet_ID_width_p-1:0] data; config_s config_in; config_s [RELAY_NUM-1:0] relay_output; assign config_in.cfg_clk = cfg_clk_i; assign config_in.cfg_bit = cfg_bit_i; relay_node relay_0 (.config_i(config_in), .config_o(relay_output[0])); genvar inst; generate for (inst = 1; inst < RELAY_NUM; inst = inst + 1) begin: gen_block relay_node relay(.config_i(relay_output[inst-1]), .config_o(relay_output[inst])); end endgenerate config_node#(.id_p(1), .data_bits_p(36), .default_p(36'd52)) cfg_node_1 (.clk(clk), .reset(reset), .config_i(relay_output[RELAY_NUM-1]), .data_o(data)); cfgtaggw#(.packet_ID_width_p(packet_ID_width_p)) cfgtagGW (.clk(clk), .reset(reset), .cfgtag_data_i(data), .credit_i(credit_i), .valid_o(valid_o), .data_o(data_o));endmodule"}
{"task_id": 793, "completion": "blk_mem_gen_v8_3_5 #(\n    .C_FAMILY(\"artix7\"),\n    .C_XDEVICEFAMILY(\"artix7\"),\n    .C_ELABORATION_DIR(\"./\"),\n    .C_INTERFACE_TYPE(0),\n    .C_AXI_TYPE(1),\n    .C_AXI_SLAVE_TYPE(0),\n    .C_USE_BRAM_BLOCK(0),\n    .C_ENABLE_32BIT_ADDRESS(0),\n    .C_CTRL_ECC_ALGO(\"NONE\"),\n    .C_HAS_AXI_ID(0),\n    .C_AXI_ID_WIDTH(4),\n    .C_MEM_TYPE(0),\n    .C_BYTE_SIZE(9),\n    .C_ALGORITHM(1),\n    .C_PRIM_TYPE(1),\n    .C_LOAD_INIT_FILE(1),\n    .C_INIT_FILE_NAME(\"pikachu_down_pixel.mif\"),\n    .C_INIT_FILE(\"pikachu_down_pixel.mem\"),\n    .C_USE_DEFAULT_DATA(0),\n    .C_DEFAULT_DATA(\"0\"),\n    .C_HAS_RSTA(0),\n    .C_RST_PRIORITY_A(\"CE\"),\n    .C_RSTRAM_A(0),\n    .C_INITA_VAL(\"0\"),\n    .C_HAS_ENA(0),\n    .C_HAS_REGCEA(0),\n    .C_USE_BYTE_WEA(0),\n    .C_WEA_WIDTH(1),\n    .C_WRITE_MODE_A(\"WRITE_FIRST\"),\n    .C_WRITE_WIDTH_A(12),\n    .C_READ_WIDTH_A(12),\n    .C_WRITE_DEPTH_A(5589),\n    .C_READ_DEPTH_A(5589),\n    .C_ADDRA_WIDTH(13),\n    .C_HAS_RSTB(0),\n    .C_RST_PRIORITY_B(\"CE\"),\n    .C_RSTRAM_B(0),\n    .C_INITB_VAL(\"0\"),\n    .C_HAS_ENB(0),\n    .C_HAS_REGCEB(0),\n    .C_USE_BYTE_WEB(0),\n    .C_WEB_WIDTH(1),\n    .C_WRITE_MODE_B(\"WRITE_FIRST\"),\n    .C_WRITE_WIDTH_B(12),\n    .C_READ_WIDTH_B(12),\n    .C_WRITE_DEPTH_B(5589),\n    .C_READ_DEPTH_B(5589),\n    .C_ADDRB_WIDTH(13),\n    .C_HAS_MEM_OUTPUT_REGS_A(1),\n    .C_HAS_MEM_OUTPUT_REGS_B(0),\n    .C_HAS_MUX_OUTPUT_REGS_A(0),\n    .C_HAS_MUX_OUTPUT_REGS_B(0),\n    .C_MUX_PIPELINE_STAGES(0),\n    .C_HAS_SOFTECC_INPUT_REGS_A(0),\n    .C_HAS_SOFTECC_OUTPUT_REGS_B(0),\n    .C_USE_SOFTECC(0),\n    .C_USE_ECC(0),\n    .C_EN_ECC_PIPE(0),\n    .C_HAS_INJECTERR(0),\n    .C_SIM_COLLISION_CHECK(\"ALL\"),\n    .C_COMMON_CLK(0),\n    .C_DISABLE_WARN_BHV_COLL(0),\n    .C_EN_SLEEP_PIN(0),\n    .C_USE_URAM(0),\n    .C_EN_RDADDRA_CHG(0),\n    .C_EN_RDADDRB_CHG(0),\n    .C_EN_DEEPSLEEP_PIN(0),\n    .C_EN_SHUTDOWN_PIN(0),\n    .C_EN_SAFETY_CKT(0),\n    .C_DISABLE_WARN_BHV_RANGE(0),\n    .C_COUNT_36K_BRAM(\"2\"),\n    .C_COUNT_18K_BRAM(\"1\"),\n    .C_EST_POWER_SUMMARY(\"Estimated Power for IP     :     4.681258 mW\")\n  ) inst (\n    .clka(clka),\n    .rsta(1'D0),\n    .ena(1'D0),\n    .regcea(1'D0),\n    .wea(wea),\n    .addra(addra),\n    .dina(dina),\n    .douta(douta),\n    .clkb(1'D0),\n    .rstb(1'D0),\n    .enb(1'D0),\n    .regceb(1'D0),\n    .web(1'B0),\n    .addrb(13'B0),\n    .dinb(12'B0),\n    .doutb(),\n    .injectsbiterr(1'D0),\n    .injectdbiterr(1'D0),\n    .eccpipece(1'D0),\n    .sbiterr(),\n    .dbiterr(),\n    .rdaddrecc(),\n    .sleep(1'D0),\n    .deepsleep(1'D0),\n    .shutdown(1'D0),\n    .rsta_busy(),\n    .rstb_busy(),\n    .s_aclk(1'H0),\n    .s_aresetn(1'D0),\n    .s_axi_awid(4'B0),\n    .s_axi_awaddr(32'B0),\n    .s_axi_awlen(8'B0),\n    .s_axi_awsize(3'B0),\n    .s_axi_awburst(2'B0),\n    .s_axi_awvalid(1'D0),\n    .s_axi_awready(),\n    .s_axi_wdata(12'B0),\n    .s_axi_wstrb(1'B0),\n    .s_axi_wlast(1'D0),\n    .s_axi_wvalid(1'D0),\n    .s_axi_wready(),\n    .s_axi_bid(),\n    .s_axi_bresp(),\n    .s_axi_bvalid(),\n    .s_axi_bready(1'D0),\n    .s_axi_arid(4'B0),\n    .s_axi_araddr(32'B0),\n    .s_axi_arlen(8'B0),\n    .s_axi_arsize(3'B0),\n    .s_axi_arburst(2'B0),\n    .s_axi_arvalid(1'D0),\n    .s_axi_arready(),\n    .s_axi_rid(),\n    .s_axi_rdata(),\n    .s_axi_rresp(),\n    .s_axi_rlast(),\n    .s_axi_rvalid(),\n    .s_axi_rready(1'D0),\n    .s_axi_injectsbiterr(1'D0),\n    .s_axi_injectdbiterr(1'D0),\n    .s_axi_sbiterr(),\n    .s_axi_dbiterr(),\n    .s_axi_rdaddrecc()\n  );\nendmodule"}
{"task_id": 861, "completion": "frequency_analyzer_manager #(\n    .C_S00_AXI_DATA_WIDTH(32),\n    .C_S00_AXI_ADDR_WIDTH(4)\n  ) inst (\n    .data(data),\n    .pixel_clock(pixel_clock),\n    .start(start),\n    .stop(stop),\n    .clear(clear),\n    .irq(irq),\n    .s00_axi_aclk(s00_axi_aclk),\n    .s00_axi_aresetn(s00_axi_aresetn),\n    .s00_axi_awaddr(s00_axi_awaddr),\n    .s00_axi_awprot(s00_axi_awprot),\n    .s00_axi_awvalid(s00_axi_awvalid),\n    .s00_axi_awready(s00_axi_awready),\n    .s00_axi_wdata(s00_axi_wdata),\n    .s00_axi_wstrb(s00_axi_wstrb),\n    .s00_axi_wvalid(s00_axi_wvalid),\n    .s00_axi_wready(s00_axi_wready),\n    .s00_axi_bresp(s00_axi_bresp),\n    .s00_axi_bvalid(s00_axi_bvalid),\n    .s00_axi_bready(s00_axi_bready),\n    .s00_axi_araddr(s00_axi_araddr),\n    .s00_axi_arprot(s00_axi_arprot),\n    .s00_axi_arvalid(s00_axi_arvalid),\n    .s00_axi_arready(s00_axi_arready),\n    .s00_axi_rdata(s00_axi_rdata),\n    .s00_axi_rresp(s00_axi_rresp),\n    .s00_axi_rvalid(s00_axi_rvalid),\n    .s00_axi_rready(s00_axi_rready)\n  );\nendmodule"}
{"task_id": 894, "completion": "output Q      ;\n    output Q_N    ;\n    input  D      ;\n    input  CLK    ;\n    input  SET_B  ;\n    input  RESET_B;\n    input  VPWR   ;\n    input  VGND   ;\n    input  VPB    ;\n    input  VNB    ;\n\n    wire RESET          ;\n    wire SET            ;\n    wire buf_Q          ;\n    wire CLK_delayed    ;\n    wire RESET_B_delayed;\n    wire SET_B_delayed  ;\n    reg  notifier       ;\n    wire D_delayed      ;\n    wire awake          ;\n    wire cond0          ;\n    wire cond1          ;\n    wire condb          ;\n\n    not                                  not0 (RESET , RESET_B_delayed                                         );\n    not                                  not1 (SET   , SET_B_delayed                                           );\n    sky130_fd_sc_lp__udp_dff$NSR_pp$PG$N dff0 (buf_Q , SET, RESET, CLK_delayed, D_delayed, notifier, VPWR, VGND);\n    assign awake = ( VPWR === 1'b1 );\n    assign cond0 = ( awake && ( RESET_B_delayed === 1'b1 ) );\n    assign cond1 = ( awake && ( SET_B_delayed === 1'b1 ) );\n    assign condb = ( cond0 & cond1 );\n    buf                                  buf0 (Q     , buf_Q                                                   );\n    not                                  not2 (Q_N   , buf_Q                                                   );\n\nendmodule"}
{"task_id": 736, "completion": "wire do_write;\n    wire do_read;\n    wire do_auto_precharge;\n    wire do_activate;\n    wire do_precharge;\n\n    wire  [CFG_MEM_IF_CHIP-1:0]    do_precharge_all;\n    wire  [CFG_MEM_IF_CHIP-1:0]    do_refresh;\n    wire  [CFG_MEM_IF_CHIP-1:0]    do_self_refresh;\n    wire  [CFG_MEM_IF_CHIP-1:0]    do_power_down;\n    wire  [CFG_MEM_IF_CHIP-1:0]    do_deep_pwrdwn;\n\n    wire do_lmr;\n\n    wire do_lmr_read;\n    wire do_refresh_1bank;\n    wire do_burst_terminate;\n    \n    reg   [2:0]    temp_bank_addr;\n    reg   [14:0]   temp_row_addr;\n    reg   [11:0]   temp_col_addr;\n\n    wire    [(CFG_MEM_IF_CKE_WIDTH * (CFG_DWIDTH_RATIO/2)) - 1:0]   afi_cke;\n    wire    [(CFG_MEM_IF_CHIP * (CFG_DWIDTH_RATIO/2)) - 1:0]        afi_cs_n;\n    wire    [(CFG_MEM_IF_ADDR_WIDTH * (CFG_DWIDTH_RATIO/2)) - 1:0]  afi_addr;\n    wire    [(CFG_DWIDTH_RATIO/2) - 1:0]                            afi_rst_n;\n    \n    reg [(CFG_MEM_IF_CKE_WIDTH) - 1:0]      int_cke;\n    reg [(CFG_MEM_IF_CKE_WIDTH) - 1:0]      int_cke_r;\n    reg [(CFG_MEM_IF_CHIP) - 1:0]           int_cs_n;\n    reg [(CFG_MEM_IF_ADDR_WIDTH) - 1:0]     int_addr;\n    \n    reg [(CFG_MEM_IF_CKE_WIDTH) - 1:0]      combi_cke;\n    reg [(CFG_MEM_IF_CHIP) - 1:0]           combi_cs_n;\n    reg [(CFG_MEM_IF_ADDR_WIDTH) - 1:0]     combi_addr;\n    reg [(CFG_MEM_IF_CKE_WIDTH) - 1:0]      combi_cke_r;\n    reg [(CFG_MEM_IF_CHIP) - 1:0]           combi_cs_n_r;\n    reg [(CFG_MEM_IF_ADDR_WIDTH) - 1:0]     combi_addr_r;\n    \n    reg   [CFG_MEM_IF_CHIP - 1:0]           do_power_down_r;\n    reg   [CFG_MEM_IF_CHIP - 1:0]           do_self_refresh_r;\n    reg   [CFG_MEM_IF_CHIP - 1:0]           do_deep_pwrdwn_r;\n    reg   [CFG_MEM_IF_CHIP - 1:0]           int_do_power_down;\n    reg   [CFG_MEM_IF_CHIP - 1:0]           int_do_self_refresh;\n    reg   [CFG_MEM_IF_CHIP - 1:0]           int_do_deep_pwrdwn;\n    \n    assign afi_rst_n    = {(CFG_DWIDTH_RATIO/2){1'b1}};\n    \n    generate\n        if (CFG_DWIDTH_RATIO == 2) begin\n            assign afi_cke      = int_cke;\n            assign afi_cs_n     = int_cs_n;\n            assign afi_addr     = int_addr;\n        end\n        else begin\n            assign afi_cke      = {int_cke,int_cke};\n            assign afi_cs_n     = (do_burst_terminate)? {int_cs_n,int_cs_n} :{int_cs_n,{CFG_MEM_IF_CHIP{1'b1}}};\n            assign afi_addr     = {int_addr,int_addr};\n        end        \n    endgenerate\n    \n    always @(posedge ctl_clk, negedge ctl_reset_n)            \n        begin\n            if (!ctl_reset_n)\n                begin\n                    do_power_down_r   <= {(CFG_MEM_IF_CHIP){1'b0}};\n                    do_self_refresh_r <= {(CFG_MEM_IF_CHIP){1'b0}};\n                    do_deep_pwrdwn_r  <= {(CFG_MEM_IF_CHIP){1'b0}};\n                end\n            else\n                begin\n                    do_power_down_r   <= ~do_power_down;\n                    do_self_refresh_r <= ~do_self_refresh;\n                    do_deep_pwrdwn_r  <= ~do_deep_pwrdwn;\n                end\n        end\n    \n    always @(*)\n        begin\n            int_do_power_down   = do_power_down   & do_power_down_r;\n            int_do_self_refresh = do_self_refresh & do_self_refresh_r;\n            int_do_deep_pwrdwn  = do_deep_pwrdwn  & do_deep_pwrdwn_r;\n        end\n    \n    always @ (posedge ctl_clk or negedge ctl_reset_n) \n    begin\n        if (~ctl_reset_n)\n        begin\n            combi_cke_r   <= {CFG_MEM_IF_CKE_WIDTH{1'b1}} ;\n            combi_cs_n_r  <= {CFG_MEM_IF_CHIP{1'b1}}  ;\n            combi_addr_r  <= {CFG_MEM_IF_ADDR_WIDTH{1'b0}};\n        end\n        else\n        begin\n            combi_cke_r   <= combi_cke  ;\n            combi_cs_n_r  <= combi_cs_n ;\n            combi_addr_r  <= combi_addr ;\n        end\n    end\n\n    always @(*)\n        begin\n            if (cfg_output_regd)\n                begin\n                    int_cke     =  combi_cke_r;\n                    int_cs_n    =  combi_cs_n_r;\n                    int_addr    =  combi_addr_r;\n                end\n            else\n                begin\n                    int_cke     =  combi_cke;\n                    int_cs_n    =  combi_cs_n;\n                    int_addr    =  combi_addr;\n                end\n        end\n    \n    always @ (*) \n    begin\n        temp_row_addr    = {CFG_MEM_IF_ROW_WIDTH{1'b0}} ;\n        temp_col_addr    = {CFG_MEM_IF_COL_WIDTH{1'b0}} ;\n        temp_bank_addr   = {CFG_MEM_IF_BA_WIDTH {1'b0}} ;\n        temp_row_addr    = to_row ;\n        temp_col_addr    = to_col ;\n        temp_bank_addr   = to_bank;\n    end\n    \n    always @(*)\n        begin\n            if (ctl_cal_success)\n               begin \n                    combi_cke = ~(do_self_refresh | do_power_down | do_deep_pwrdwn);\n               end\n            else\n               begin\n                    combi_cke = {(CFG_MEM_IF_CKE_WIDTH){1'b1}};\n               end\n        end\n    \n    always @(*)\n        begin\n            if (ctl_cal_success)\n                begin\n                    combi_cs_n    =   {(CFG_MEM_IF_CHIP){1'b1}};\n                    combi_addr    =   {(CFG_MEM_IF_ADDR_WIDTH){1'b0}};\n                    if (|do_refresh)\n                        begin\n                            combi_cs_n                                          =  ~do_refresh;\n                            combi_addr[3:0]                                     =   4'b1100;\n                            combi_addr[(CFG_MEM_IF_ADDR_WIDTH/2) - 1 : 4]       =  {(CFG_MEM_IF_ADDR_WIDTH/2 - 4){1'b0}};\n                            combi_addr[CFG_MEM_IF_ADDR_WIDTH - 1 : 10]          =  {(CFG_MEM_IF_ADDR_WIDTH/2){1'b0}};\n                        end\n                    if (do_refresh_1bank)\n                        begin\n                            combi_cs_n                                          =  ~to_chip;\n                            combi_addr[3:0]                                     =   4'b0100;\n                            combi_addr[(CFG_MEM_IF_ADDR_WIDTH/2) - 1 : 4]       =  {(CFG_MEM_IF_ADDR_WIDTH/2 - 4){1'b0}};\n                            combi_addr[CFG_MEM_IF_ADDR_WIDTH - 1 : 10]          =  {(CFG_MEM_IF_ADDR_WIDTH/2){1'b0}};\n                        end\n                    if (|do_precharge_all)\n                        begin\n                            combi_cs_n                                          = ~do_precharge_all;\n                            combi_addr[3:0]                                     =  4'b1011;\n                            combi_addr[(CFG_MEM_IF_ADDR_WIDTH/2) - 1 : 4]       = {temp_bank_addr,2'b00,(|do_precharge_all)};\n                            combi_addr[CFG_MEM_IF_ADDR_WIDTH - 1 : 10]          = {(CFG_MEM_IF_ADDR_WIDTH/2){1'b0}};\n                        end\n                    if (do_activate)\n                        begin\n                            combi_cs_n                                          =  ~to_chip;\n                            combi_addr[3:0]                                     =  {temp_row_addr[9:8],2'b10};\n                            combi_addr[(CFG_MEM_IF_ADDR_WIDTH/2) - 1 : 4]       =  {temp_bank_addr,temp_row_addr[12:10]};\n                            combi_addr[CFG_MEM_IF_ADDR_WIDTH - 1 : 10]          =  {temp_row_addr[14:13],temp_row_addr[7:0]};\n                        end\n                    if (do_precharge)\n                        begin\n                            combi_cs_n                                          = ~to_chip;\n                            combi_addr[3:0]                                     = 4'b1011;\n                            combi_addr[(CFG_MEM_IF_ADDR_WIDTH/2) - 1 : 4]       = {temp_bank_addr,3'b000};\n                            combi_addr[CFG_MEM_IF_ADDR_WIDTH - 1 : 10]          = {temp_row_addr[14:13],temp_row_addr[7:0]};\n                        end\n                    if (do_write)\n                        begin\n                            combi_cs_n                                          =  ~to_chip;\n                            combi_addr[3:0]                                     =  4'b0001;\n                            combi_addr[(CFG_MEM_IF_ADDR_WIDTH/2) - 1 : 4]       =  {temp_bank_addr,temp_col_addr[2:1],1'b0};\n                            combi_addr[CFG_MEM_IF_ADDR_WIDTH - 1 : 10]          =  {temp_col_addr[11:3],do_auto_precharge};\n                        end\n                    if (do_read)\n                        begin\n                            combi_cs_n                                          =  ~to_chip;\n                            combi_addr[3:0]                                     =  4'b0101;\n                            combi_addr[(CFG_MEM_IF_ADDR_WIDTH/2) - 1 : 4]       =  {temp_bank_addr,temp_col_addr[2:1],1'b0};\n                            combi_addr[CFG_MEM_IF_ADDR_WIDTH - 1 : 10]          =  {temp_col_addr[11:3],do_auto_precharge};\n                        end\n                    if (|int_do_power_down)\n                        begin\n                            combi_cs_n                                          =  {(CFG_MEM_IF_CHIP){1'b1}};\n                            combi_addr[3:0]                                     =  4'b0000;\n                            combi_addr[(CFG_MEM_IF_ADDR_WIDTH/2) - 1 : 4]       =  {(CFG_MEM_IF_ADDR_WIDTH/2 - 4){1'b0}};\n                            combi_addr[CFG_MEM_IF_ADDR_WIDTH - 1 : 10]          =  {(CFG_MEM_IF_ADDR_WIDTH/2){1'b0}};\n                        end\n                    if (|int_do_deep_pwrdwn)\n                        begin\n                            if (cfg_enable_chipsel_for_sideband)\n                                begin\n                                    combi_cs_n                                  = ~int_do_deep_pwrdwn;\n                                end\n                            else\n                                begin\n                                    combi_cs_n                                  =  {(CFG_MEM_IF_CHIP){1'b1}};\n                                end\n                            combi_addr[3:0]                                     =  4'b0011;\n                            combi_addr[(CFG_MEM_IF_ADDR_WIDTH/2) - 1 : 4]       =  {(CFG_MEM_IF_ADDR_WIDTH/2 - 4){1'b0}};\n                            combi_addr[CFG_MEM_IF_ADDR_WIDTH - 1 : 10]          =  {(CFG_MEM_IF_ADDR_WIDTH/2){1'b0}};\n                        end\n                    if (|int_do_self_refresh)\n                        begin\n                            if (cfg_enable_chipsel_for_sideband)\n                                begin\n                                    combi_cs_n                                  = ~int_do_self_refresh;\n                                end\n                            else\n                                begin\n                                    combi_cs_n                                  =  {(CFG_MEM_IF_CHIP){1'b1}};\n                                end\n                            combi_addr[3:0]                                     =  4'b0100;\n                            combi_addr[(CFG_MEM_IF_ADDR_WIDTH/2) - 1 : 4]       =  {(CFG_MEM_IF_ADDR_WIDTH/2 - 4){1'b0}};\n                            combi_addr[CFG_MEM_IF_ADDR_WIDTH - 1 : 10]          =  {(CFG_MEM_IF_ADDR_WIDTH/2){1'b0}};\n                        end\n                    if (do_lmr)\n                        begin\n                            combi_cs_n                                          =  ~to_chip;\n                            combi_addr[3:0]                                     =  4'b0000;\n                            combi_addr[(CFG_MEM_IF_ADDR_WIDTH/2) - 1 : 4]       =  to_lmr[5:0];\n                            combi_addr[CFG_MEM_IF_ADDR_WIDTH - 1 : 10]          =  {to_lmr[7:6],lmr_opcode};\n                        end\n                    if (do_lmr_read)\n                        begin\n                            combi_cs_n                                          =  ~to_chip;\n                            combi_addr[3:0]                                     =  4'b1000;\n                            combi_addr[(CFG_MEM_IF_ADDR_WIDTH/2) - 1 : 4]       =  to_lmr[5:0];\n                            combi_addr[CFG_MEM_IF_ADDR_WIDTH - 1 : 10]          =  {to_lmr[7:6],{8{1'b0}}};\n                        end\n                    if (do_burst_terminate)\n                        begin\n                            combi_cs_n                                          =  ~to_chip;\n                            combi_addr[3:0]                                     =  4'b0011;\n                            combi_addr[(CFG_MEM_IF_ADDR_WIDTH/2) - 1 : 4]       =  {(CFG_MEM_IF_ADDR_WIDTH/2 - 4){1'b0}};\n                            combi_addr[CFG_MEM_IF_ADDR_WIDTH - 1 : 10]          =  {(CFG_MEM_IF_ADDR_WIDTH/2){1'b0}};\n                        end\n                end\n            else\n                begin\n                    combi_cs_n                                                  =  {(CFG_MEM_IF_CHIP){1'b1}};\n                    combi_addr                                                  =  {(CFG_MEM_IF_ADDR_WIDTH){1'b0}};\n                end\n        end\nendmodule"}
{"task_id": 768, "completion": "generate\n        if (DUMMY)\n            ram_dummy #(\n                .LOG2WIDTH_RD(LOG2WIDTH_RD)\n            ) ramp_dummy_i (\n                .data_out(data_out) \n            );\n        else if ((LOG2WIDTH_WR == 6) && (LOG2WIDTH_RD == 6))\n            ram_64w_64r #(\n                .REGISTERS    (REGISTERS)\n            ) ram_i (\n                .rclk         (rclk),     // input\n                .raddr        (raddr),    // input[8:0] \n                .ren          (ren),      // input\n                .regen        (regen),    // input\n                .data_out     (data_out), // output[63:0] \n                .wclk         (wclk),     // input\n                .waddr        (waddr),    // input[8:0] \n                .we           (we),       // input\n                .web          (web),      // input[7:0] \n                .data_in      (data_in)   // input[63:0] \n            );\n        else if ((LOG2WIDTH_WR == 6) && (LOG2WIDTH_RD < 6))\n            ram_64w_lt64r #(\n                .REGISTERS    (REGISTERS),\n                .LOG2WIDTH_RD (LOG2WIDTH_RD)\n            ) ram_i (\n                .rclk         (rclk),     // input\n                .raddr        (raddr),    // input[(>8):0] \n                .ren          (ren),      // input\n                .regen        (regen),    // input\n                .data_out     (data_out), // output[(<32):0] \n                .wclk         (wclk),     // input\n                .waddr        (waddr),    // input[8:0] \n                .we           (we),       // input\n                .web          (web),      // input[7:0] \n                .data_in      (data_in)   // input[63:0] \n            );\n        else if ((LOG2WIDTH_WR < 6) && (LOG2WIDTH_RD == 6))\n            ram_lt64w_64r #(\n                .REGISTERS    (REGISTERS),\n                .LOG2WIDTH_WR (LOG2WIDTH_WR)\n            ) ram_i (\n                .rclk         (rclk),     // input\n                .raddr        (raddr),    // input[8:0] \n                .ren          (ren),      // input\n                .regen        (regen),    // input\n                .data_out     (data_out), // output[63:0] \n                .wclk         (wclk),     // input\n                .waddr        (waddr),    // input[(>8):0] \n                .we           (we),       // input\n                .web          (web),      // input[7:0] \n                .data_in      (data_in)   // input[(<32):0] \n            );\n        else if ((LOG2WIDTH_WR < 6) && (LOG2WIDTH_RD < 6))\n            ram_lt64w_lt64r #(\n                .REGISTERS    (REGISTERS),\n                .LOG2WIDTH_WR (LOG2WIDTH_WR),\n                .LOG2WIDTH_RD (LOG2WIDTH_RD)\n            ) ram_i (\n                .rclk         (rclk),     // input\n                .raddr        (raddr),    // input[(>8):0] \n                .ren          (ren),      // input\n                .regen        (regen),    // input\n                .data_out     (data_out), // output[(<32):0] \n                .wclk         (wclk),     // input\n                .waddr        (waddr),    // input[(>8):0] \n                .we           (we),       // input\n                .web          (web),      // input[7:0] \n                .data_in      (data_in)   // input[(<32):0] \n            );\n    endgenerate\nendmodule"}
{"task_id": 214, "completion": "wire clk_125mhz_ibufg;\n\nwire clk_125mhz_mmcm_out;\nwire clk_125mhz_int;\nwire rst_125mhz_int;\n\nwire clk_156mhz_int;\nwire rst_156mhz_int;\n\nwire mmcm_rst = reset;\nwire mmcm_locked;\nwire mmcm_clkfb;\n\nIBUFGDS #(\n   .DIFF_TERM(\"FALSE\"),\n   .IBUF_LOW_PWR(\"FALSE\")   \n)\nclk_125mhz_ibufg_inst (\n   .O   (clk_125mhz_ibufg),\n   .I   (clk_125mhz_p),\n   .IB  (clk_125mhz_n) \n);\n\nMMCME3_BASE #(\n    .BANDWIDTH(\"OPTIMIZED\"),\n    .CLKOUT0_DIVIDE_F(5),\n    .CLKOUT0_DUTY_CYCLE(0.5),\n    .CLKOUT0_PHASE(0),\n    .CLKOUT1_DIVIDE(1),\n    .CLKOUT1_DUTY_CYCLE(0.5),\n    .CLKOUT1_PHASE(0),\n    .CLKOUT2_DIVIDE(1),\n    .CLKOUT2_DUTY_CYCLE(0.5),\n    .CLKOUT2_PHASE(0),\n    .CLKOUT3_DIVIDE(1),\n    .CLKOUT3_DUTY_CYCLE(0.5),\n    .CLKOUT3_PHASE(0),\n    .CLKOUT4_DIVIDE(1),\n    .CLKOUT4_DUTY_CYCLE(0.5),\n    .CLKOUT4_PHASE(0),\n    .CLKOUT5_DIVIDE(1),\n    .CLKOUT5_DUTY_CYCLE(0.5),\n    .CLKOUT5_PHASE(0),\n    .CLKOUT6_DIVIDE(1),\n    .CLKOUT6_DUTY_CYCLE(0.5),\n    .CLKOUT6_PHASE(0),\n    .CLKFBOUT_MULT_F(5),\n    .CLKFBOUT_PHASE(0),\n    .DIVCLK_DIVIDE(1),\n    .REF_JITTER1(0.010),\n    .CLKIN1_PERIOD(8.0),\n    .STARTUP_WAIT(\"FALSE\"),\n    .CLKOUT4_CASCADE(\"FALSE\")\n)\nclk_mmcm_inst (\n    .CLKIN1(clk_125mhz_ibufg),\n    .CLKFBIN(mmcm_clkfb),\n    .RST(mmcm_rst),\n    .PWRDWN(1'b0),\n    .CLKOUT0(clk_125mhz_mmcm_out),\n    .LOCKED(mmcm_locked)\n);\n\nBUFG\nclk_125mhz_bufg_inst (\n    .I(clk_125mhz_mmcm_out),\n    .O(clk_125mhz_int)\n);\n\nsync_reset #(\n    .N(4)\n)\nsync_reset_125mhz_inst (\n    .clk(clk_125mhz_int),\n    .rst(~mmcm_locked),\n    .out(rst_125mhz_int)\n);\n\n// GPIO\nwire btnu_int;\nwire btnl_int;\nwire btnd_int;\nwire btnr_int;\nwire btnc_int;\nwire [3:0] sw_int;\n\ndebounce_switch #(\n    .WIDTH(9),\n    .N(4),\n    .RATE(156000)\n)\ndebounce_switch_inst (\n    .clk(clk_156mhz_int),\n    .rst(rst_156mhz_int),\n    .in({btnu,\n        btnl,\n        btnd,\n        btnr,\n        btnc,\n        sw}),\n    .out({btnu_int,\n        btnl_int,\n        btnd_int,\n        btnr_int,\n        btnc_int,\n        sw_int})\n);\n\nwire uart_rxd_int;\nwire uart_cts_int;\n\nsync_signal #(\n    .WIDTH(2),\n    .N(2)\n)\nsync_signal_inst (\n    .clk(clk_156mhz_int),\n    .in({uart_rxd, uart_cts}),\n    .out({uart_rxd_int, uart_cts_int})\n);\n\n// SI570 I2C\nwire i2c_scl_i;\nwire i2c_scl_o = 1'b1;\nwire i2c_scl_t = 1'b1;\nwire i2c_sda_i;\nwire i2c_sda_o = 1'b1;\nwire i2c_sda_t = 1'b1;\n\nassign i2c_scl_i = i2c_scl;\nassign i2c_scl = i2c_scl_t ? 1'bz : i2c_scl_o;\nassign i2c_sda_i = i2c_sda;\nassign i2c_sda = i2c_sda_t ? 1'bz : i2c_sda_o;\n\n// XGMII 10G PHY\nassign qsfp_modsell = 1'b0;\nassign qsfp_resetl = 1'b1;\nassign qsfp_lpmode = 1'b0;\n\n// More internal wiring and instances follow...\n\nendmodule"}
{"task_id": 901, "completion": "output Y;\n    input  A;\n\n    // Voltage supply signals\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    sky130_fd_sc_lp__invlp base (\n        .Y(Y),\n        .A(A)\n    );\n\nendmodule"}
{"task_id": 913, "completion": "`ifdef FPGA_SOURCE\nsirv_sim_ram #(\n    .FORCE_X2ZERO (1'b0),\n    .DP (DP),\n    .AW (AW),\n    .MW (MW),\n    .DW (DW) \n)u_sirv_sim_ram (\n    .clk   (clk),\n    .din   (din),\n    .addr  (addr),\n    .cs    (cs),\n    .we    (we),\n    .wem   (wem),\n    .dout  (dout)\n);\n`else\n\nsirv_sim_ram #(\n    .FORCE_X2ZERO (FORCE_X2ZERO),\n    .DP (DP),\n    .AW (AW),\n    .MW (MW),\n    .DW (DW) \n)u_sirv_sim_ram (\n    .clk   (clk),\n    .din   (din),\n    .addr  (addr),\n    .cs    (cs),\n    .we    (we),\n    .wem   (wem),\n    .dout  (dout)\n);\n`endif\n\nendmodule"}
{"task_id": 905, "completion": "assign Y = !((A1 | A2) & B1 & C1 & D1);\nendmodule"}
{"task_id": 880, "completion": "supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\nendmodule"}
{"task_id": 898, "completion": "parameter BYTE_WIDTH = KEEP_ENABLE ? DATA_WIDTH / KEEP_WIDTH : DATA_WIDTH;\n\n    assign avst_ready = axis_tready;\n\n    generate\n\n    genvar n;\n\n    if (BYTE_REVERSE) begin : rev\n        for (n = 0; n < KEEP_WIDTH; n = n + 1) begin\n            assign axis_tdata[n*BYTE_WIDTH +: BYTE_WIDTH] = avst_data[(KEEP_WIDTH-n-1)*BYTE_WIDTH +: BYTE_WIDTH];\n        end\n    end else begin\n        assign axis_tdata = avst_data;\n    end\n\n    endgenerate\n\n    assign axis_tkeep = KEEP_ENABLE ? {KEEP_WIDTH{1'b1}} >> avst_empty : 0;\n\n    assign axis_tvalid = avst_valid;\n    assign axis_tlast = avst_endofpacket;\n    assign axis_tuser = avst_error;\n\nendmodule"}
{"task_id": 851, "completion": "wire [31:0] mem_address; wire [31:0] mem_data_w; wire [3:0] mem_byte_sel; wire mem_write; wire [31:0] opcode; wire [5:0] rs_index; wire [5:0] rt_index; wire [5:0] rd_index; wire [5:0] rd_indexD; wire [31:0] reg_source; wire [31:0] reg_target; wire [31:0] reg_dest; wire [31:0] reg_destD; wire [31:0] a_bus; wire [31:0] a_busD; wire [31:0] b_bus; wire [31:0] b_busD; wire [31:0] c_bus; wire [31:0] c_alu; wire [31:0] c_shift; wire [31:0] c_mult; wire [31:0] c_memory; wire [15:0] imm; wire [31:0] pc; wire [31:0] pc_plus4; wire [3:0] alu_func; wire [3:0] alu_funcD; wire [1:0] shift_func; wire [1:0] shift_funcD; wire [3:0] mult_func; wire [3:0] mult_funcD; wire [2:0] branch_func; wire take_branch; wire [1:0] a_source; wire [1:0] b_source; wire [2:0] c_source; wire [1:0] pc_source; wire [3:0] mem_source; wire pause_mult; wire pause_ctrl; wire pause_pipeline; wire pause_any; wire pause_non_ctrl; wire pause_bank; wire nullify_op; wire intr_enable; reg intr_signal_s1; reg intr_signal_s2; wire intr_signal = intr_signal_s1 | intr_signal_s2; reg [3:0] reset_reg; wire reset; assign pause_any = (mem_pause | pause_ctrl) | (pause_mult | pause_pipeline); assign pause_non_ctrl = (mem_pause | pause_mult) | pause_pipeline; assign pause_bank = (mem_pause | pause_ctrl | pause_mult) & ~pause_pipeline; assign nullify_op = (pc_source == `from_lbranch & take_branch)? 1'b1 : 1'b0; assign c_bus = c_alu | c_shift | c_mult; assign reset = (reset_in | reset_reg != 4'b1111) ? 1'b1 : 1'b0; always @(posedge clk or posedge reset_in) begin if (reset_in) reset_reg <= 4'b0000; else if (reset_reg != 4'b1111) reset_reg <= reset_reg + 1; end always @(posedge clk or posedge reset_in) begin if (reset_in) intr_signal_s1 <= 1'b0 ; else begin if (intr_in & intr_enable & (pc_source == `from_inc4) & ~pc[2] & ~pause_any) intr_signal_s1 <= 1'b1 ; else intr_signal_s1 <= 1'b0 ; end end always @(posedge clk or posedge reset_in) begin if (reset_in) intr_signal_s2 <= 1'b0 ; else begin intr_signal_s2 <= intr_signal_s1 ; end end pc_next u1_pc_next (.clk (clk), .reset (reset), .take_branch (take_branch), .pause_in (pause_any), .pc_new (c_bus[31:2]), .opcode25_0 (opcode[25:0]), .pc_source (pc_source), .pc_out (pc), .pc_out_plus4 (pc_plus4)); mem_ctrl u2_mem_ctrl(.clk (clk), .reset (reset), .pause_in (pause_non_ctrl), .nullify_op (nullify_op), .address_pc (pc), .opcode_out (opcode), .address_data (c_bus), .mem_source (mem_source), .data_write (reg_target), .data_read (c_memory), .pause_out (pause_ctrl), .mem_address (mem_address), .mem_data_w (mem_data_w), .mem_data_r (mem_data_r), .mem_byte_sel (mem_byte_sel), .mem_write (mem_write)); control u3_control(.opcode (opcode), .intr_signal (intr_signal), .rs_index (rs_index), .rt_index (rt_index), .rd_index (rd_index), .imm_out (imm), .alu_func (alu_func), .shift_func (shift_func), .mult_func (mult_func), .branch_func (branch_func), .a_source_out (a_source), .b_source_out (b_source), .c_source_out (c_source), .pc_source_out (pc_source), .mem_source_out(mem_source)); reg_bank u4_reg_bank(.clk (clk), .reset (reset), .pause (pause_bank), .rs_index (rs_index), .rt_index (rt_index), .rd_index (rd_indexD), .reg_source_out(reg_source), .reg_target_out(reg_target), .reg_dest_new (reg_destD), .intr_enable (intr_enable)); bus_mux u5_bus_mux (.imm_in (imm), .reg_source (reg_source), .a_mux (a_source), .a_out (a_bus), .reg_target (reg_target), .b_mux (b_source), .b_out (b_bus), .c_bus (c_bus), .c_memory (c_memory), .c_pc (pc), .c_pc_plus4 (pc_plus4), .c_mux (c_source), .reg_dest_out(reg_dest), .branch_func (branch_func), .take_branch (take_branch)); alu u6_alu(.a_in (a_busD), .b_in (b_busD), .alu_function (alu_funcD), .c_alu (c_alu)); shifter u7_shifter(.value (b_busD), .shift_amount (a_busD[4:0]), .shift_func (shift_funcD), .c_shift (c_shift)); mult u8_mult(.clk (clk), .reset (reset), .a (a_busD), .b (b_busD), .mult_func (mult_funcD), .c_mult (c_mult), .pause_out (pause_mult)); `ifdef mlite_cpu_pipeline2 assign a_busD = a_bus; assign b_busD = b_bus; assign alu_funcD = alu_func; assign shift_funcD = shift_func; assign mult_funcD = mult_func; assign rd_indexD = rd_index; assign reg_destD = reg_dest; assign pause_pipeline = 1'b0; `endif //pipeline2 `ifdef mlite_cpu_pipeline3 pipeline u9_pipeline(.clk (clk), .reset (reset), .a_bus (a_bus), .a_busD (a_busD), .b_bus (b_bus), .b_busD (b_busD), .alu_func (alu_func), .alu_funcD (alu_funcD), .shift_func (shift_func), .shift_funcD (shift_funcD), .mult_func (mult_func), .mult_funcD (mult_funcD), .reg_dest (reg_dest), .reg_destD (reg_destD), .rd_index (rd_index), .rd_indexD (rd_indexD), .rs_index (rs_index), .rt_index (rt_index), .pc_source (pc_source), .mem_source (mem_source), .a_source (a_source), .b_source (b_source), .c_source (c_source), .c_bus (c_bus), .pause_any (pause_any), .pause_pipeline(pause_pipeline)); `endif //pipeline3 endmodule"}
{"task_id": 919, "completion": "parameter guarded = 1;\n   input                  CLK;\n   input                  RST;\n   input                  ENQ;\n   input                  DEQ;\n   input                  CLR ;\n   output                 FULL_N;\n   output                 EMPTY_N;\n   reg                    empty_reg ;\n   assign                 EMPTY_N = empty_reg ;\n   assign FULL_N = !empty_reg;\n   always@(posedge CLK `BSV_ARESET_EDGE_META)\n     begin\n        if (RST == `BSV_RESET_VALUE)\n          begin\n             empty_reg <= `BSV_ASSIGNMENT_DELAY 1'b0;\n          end // if (RST == `BSV_RESET_VALUE)\n        else\n           begin\n              if (CLR)\n                begin\n                   empty_reg <= `BSV_ASSIGNMENT_DELAY 1'b0;\n                end\n              else if (ENQ)\n                begin\n                   empty_reg <= `BSV_ASSIGNMENT_DELAY 1'b1;\n                end\n              else if (DEQ)\n                begin\n                   empty_reg <= `BSV_ASSIGNMENT_DELAY 1'b0;\n                end // if (DEQ)\n           end // else: !if(RST == `BSV_RESET_VALUE)\n     end // always@ (posedge CLK or `BSV_RESET_EDGE RST)\n   always@(posedge CLK)\n     begin: error_checks\n        reg deqerror, enqerror ;\n        deqerror =  0;\n        enqerror = 0;\n        if (RST == ! `BSV_RESET_VALUE)\n           begin\n              if ( ! empty_reg && DEQ )\n                begin\n                   deqerror = 1 ;\n                   $display( \"Warning: FIFO10: %m -- Dequeuing from empty fifo\" ) ;\n                end\n              if ( ! FULL_N && ENQ && (!DEQ || guarded) )\n                begin\n                   enqerror =  1 ;\n                   $display( \"Warning: FIFO10: %m -- Enqueuing to a full fifo\" ) ;\n                end\n           end // if (RST == ! `BSV_RESET_VALUE)\n     end\nendmodule"}
{"task_id": 891, "completion": "wire wRdTxDataValid; wire wRdTxDataReady; wire wRdTxDataStartFlag; wire [C_DATA_WIDTH-1:0] wRdTxData; wire [(C_DATA_WIDTH/32)-1:0] wRdTxDataEndFlags; wire [(C_DATA_WIDTH/32)-1:0] wRdTxDataWordValid; tx_data_shift #(.C_PIPELINE_OUTPUT(0), .C_PIPELINE_INPUT(C_PIPELINE_INPUT), .C_DATA_WIDTH(C_DATA_WIDTH), .C_VENDOR(C_VENDOR)) tx_shift_inst (.RD_TX_DATA(wRdTxData), .RD_TX_DATA_VALID(wRdTxDataValid), .RD_TX_DATA_START_FLAG(wRdTxDataStartFlag), .RD_TX_DATA_WORD_VALID(wRdTxDataWordValid), .RD_TX_DATA_END_FLAGS(wRdTxDataEndFlags), .RD_TX_DATA_READY(wRdTxDataReady), .WR_TX_DATA_READY(WR_TX_DATA_READY), .CLK(CLK), .RST_IN(RST_IN), .WR_TX_DATA_VALID(WR_TX_DATA_VALID), .WR_TX_DATA(WR_TX_DATA[C_DATA_WIDTH-1:0]), .WR_TX_DATA_START_FLAG(WR_TX_DATA_START_FLAG), .WR_TX_DATA_START_OFFSET(WR_TX_DATA_START_OFFSET[clog2s(C_DATA_WIDTH/32)-1:0]), .WR_TX_DATA_END_FLAG(WR_TX_DATA_END_FLAG), .WR_TX_DATA_END_OFFSET(WR_TX_DATA_END_OFFSET[clog2s(C_DATA_WIDTH/32)-1:0])); tx_data_fifo #(.C_PIPELINE_INPUT(1), .C_DEPTH_PACKETS(C_DEPTH_PACKETS), .C_DATA_WIDTH(C_DATA_WIDTH), .C_MAX_PAYLOAD_DWORDS(C_MAX_PAYLOAD_DWORDS)) txdf_inst (.WR_TX_DATA_READY(wRdTxDataReady), .RD_TX_DATA(RD_TX_DATA[C_DATA_WIDTH-1:0]), .RD_TX_DATA_START_FLAG(RD_TX_DATA_START_FLAG), .RD_TX_DATA_WORD_VALID(RD_TX_DATA_WORD_VALID[(C_DATA_WIDTH/32)-1:0]), .RD_TX_DATA_END_FLAGS(RD_TX_DATA_END_FLAGS[(C_DATA_WIDTH/32)-1:0]), .RD_TX_DATA_PACKET_VALID(RD_TX_DATA_PACKET_VALID), .WR_TX_DATA(wRdTxData), .WR_TX_DATA_VALID(wRdTxDataValid), .WR_TX_DATA_START_FLAG(wRdTxDataStartFlag), .WR_TX_DATA_WORD_VALID(wRdTxDataWordValid), .WR_TX_DATA_END_FLAGS(wRdTxDataEndFlags), .RD_TX_DATA_WORD_READY(RD_TX_DATA_WORD_READY), .CLK(CLK), .RST_IN(RST_IN)); endmodule"}
{"task_id": 912, "completion": "supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    wire or0_out    ;\n    wire or1_out    ;\n    wire nand0_out_Y;\n\n    or   or0   (or0_out    , B2, B1              );\n    or   or1   (or1_out    , A2, A1              );\n    nand nand0 (nand0_out_Y, or1_out, or0_out, C1);\n    buf  buf0  (Y          , nand0_out_Y         );\n\nendmodule"}
{"task_id": 844, "completion": "BLK_MEM_GEN_V6_3 #(\n    .C_ADDRA_WIDTH(10),\n    .C_ADDRB_WIDTH(15),\n    .C_ALGORITHM(1),\n    .C_AXI_ID_WIDTH(4),\n    .C_AXI_SLAVE_TYPE(0),\n    .C_AXI_TYPE(1),\n    .C_BYTE_SIZE(9),\n    .C_COMMON_CLK(0),\n    .C_DEFAULT_DATA(\"0\"),\n    .C_DISABLE_WARN_BHV_COLL(0),\n    .C_DISABLE_WARN_BHV_RANGE(0),\n    .C_ENABLE_32BIT_ADDRESS(0),\n    .C_FAMILY(\"virtex6\"),\n    .C_HAS_AXI_ID(0),\n    .C_HAS_ENA(0),\n    .C_HAS_ENB(0),\n    .C_HAS_INJECTERR(0),\n    .C_HAS_MEM_OUTPUT_REGS_A(0),\n    .C_HAS_MEM_OUTPUT_REGS_B(1),\n    .C_HAS_MUX_OUTPUT_REGS_A(0),\n    .C_HAS_MUX_OUTPUT_REGS_B(0),\n    .C_HAS_REGCEA(0),\n    .C_HAS_REGCEB(0),\n    .C_HAS_RSTA(0),\n    .C_HAS_RSTB(0),\n    .C_HAS_SOFTECC_INPUT_REGS_A(0),\n    .C_HAS_SOFTECC_OUTPUT_REGS_B(0),\n    .C_INIT_FILE_NAME(\"no_coe_file_loaded\"),\n    .C_INITA_VAL(\"0\"),\n    .C_INITB_VAL(\"0\"),\n    .C_INTERFACE_TYPE(0),\n    .C_LOAD_INIT_FILE(0),\n    .C_MEM_TYPE(2),\n    .C_MUX_PIPELINE_STAGES(0),\n    .C_PRIM_TYPE(1),\n    .C_READ_DEPTH_A(1024),\n    .C_READ_DEPTH_B(32768),\n    .C_READ_WIDTH_A(256),\n    .C_READ_WIDTH_B(8),\n    .C_RST_PRIORITY_A(\"CE\"),\n    .C_RST_PRIORITY_B(\"CE\"),\n    .C_RST_TYPE(\"SYNC\"),\n    .C_RSTRAM_A(0),\n    .C_RSTRAM_B(0),\n    .C_SIM_COLLISION_CHECK(\"ALL\"),\n    .C_USE_BYTE_WEA(0),\n    .C_USE_BYTE_WEB(0),\n    .C_USE_DEFAULT_DATA(0),\n    .C_USE_ECC(0),\n    .C_USE_SOFTECC(0),\n    .C_WEA_WIDTH(1),\n    .C_WEB_WIDTH(1),\n    .C_WRITE_DEPTH_A(1024),\n    .C_WRITE_DEPTH_B(32768),\n    .C_WRITE_MODE_A(\"WRITE_FIRST\"),\n    .C_WRITE_MODE_B(\"WRITE_FIRST\"),\n    .C_WRITE_WIDTH_A(256),\n    .C_WRITE_WIDTH_B(8),\n    .C_XDEVICEFAMILY(\"virtex6\")\n  )\n  inst (\n    .CLKA(clka),\n    .WEA(wea),\n    .ADDRA(addra),\n    .DINA(dina),\n    .DOUTA(douta),\n    .CLKB(clkb),\n    .WEB(web),\n    .ADDRB(addrb),\n    .DINB(dinb),\n    .DOUTB(doutb),\n    .RSTA(),\n    .ENA(),\n    .REGCEA(),\n    .RSTB(),\n    .ENB(),\n    .REGCEB(),\n    .INJECTSBITERR(),\n    .INJECTDBITERR(),\n    .SBITERR(),\n    .DBITERR(),\n    .RDADDRECC(),\n    .S_ACLK(),\n    .S_ARESETN(),\n    .S_AXI_AWID(),\n    .S_AXI_AWADDR(),\n    .S_AXI_AWLEN(),\n    .S_AXI_AWSIZE(),\n    .S_AXI_AWBURST(),\n    .S_AXI_AWVALID(),\n    .S_AXI_AWREADY(),\n    .S_AXI_WDATA(),\n    .S_AXI_WSTRB(),\n    .S_AXI_WLAST(),\n    .S_AXI_WVALID(),\n    .S_AXI_WREADY(),\n    .S_AXI_BID(),\n    .S_AXI_BRESP(),\n    .S_AXI_BVALID(),\n    .S_AXI_BREADY(),\n    .S_AXI_ARID(),\n    .S_AXI_ARADDR(),\n    .S_AXI_ARLEN(),\n    .S_AXI_ARSIZE(),\n    .S_AXI_ARBURST(),\n    .S_AXI_ARVALID(),\n    .S_AXI_ARREADY(),\n    .S_AXI_RID(),\n    .S_AXI_RDATA(),\n    .S_AXI_RRESP(),\n    .S_AXI_RLAST(),\n    .S_AXI_RVALID(),\n    .S_AXI_RREADY(),\n    .S_AXI_INJECTSBITERR(),\n    .S_AXI_INJECTDBITERR(),\n    .S_AXI_SBITERR(),\n    .S_AXI_DBITERR(),\n    .S_AXI_RDADDRECC()\n  );\n\nendmodule"}
{"task_id": 925, "completion": "output X;\n    input  A;\n\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    sky130_fd_sc_hd__buf base (\n        .X(X),\n        .A(A)\n    );\n\nendmodule"}
{"task_id": 900, "completion": "input clk;\n    input reset;\n    input [10:0] ctrl;\n    input [`WIDTH_D0:0] d0;\n    input [`WIDTH:0] d1, d2;\n    output [`WIDTH:0] out;\n    \n    reg [`WIDTH_D0:0] R0;\n    reg [`WIDTH:0] R1, R2, R3;\n    wire [1:0] e0, e1, e2;\n    wire [`WIDTH:0] ppg0, ppg1, ppg2,\n                    mx0, mx1, mx2, mx3, mx4, mx5, mx6, mx7,\n                    ad0, ad1, ad2,\n                    cu0, cu1, cu2, cu3,\n                    mo0, mo1, mo2,\n                    t0, t1, t2;\n    wire c0,c1,c2,c3,c4,c5,c6,c7,c8,c9,c10;\n    \n    assign {c0,c1,c2,c3,c4,c5,c6,c7,c8,c9,c10} = ctrl;\n    assign mx0 = c0 ? d1 : ad2;\n    assign mx1 = c2 ? d2 : ad2;\n    always @ (posedge clk)\n        if(reset) R1 <= 0;\n        else if (c1) R1 <= mx0;\n    always @ (posedge clk)\n        if(reset) R2 <= 0;\n        else if (c3) R2 <= mx1;\n    always @ (posedge clk)\n        if(reset) R0 <= 0;\n        else if (c4) R0 <= d0;\n        else if (c5) R0 <= R0 << 6;\n    assign {e2,e1,e0} = R0[`WIDTH_D0:(`WIDTH_D0-5)];\n    PPG\n        ppg_0 (e0, R1, ppg0),\n        ppg_1 (e1, R2, ppg1),\n        ppg_2 (e2, R1, ppg2);\n    v0  v0_ (ppg0, cu0);\n    v1  v1_ (ppg1, cu1);\n    v2  v2_ (ppg2, cu2);\n    v3  v3_ (R2,   cu3);\n    assign mx2 = c6 ? ppg0 : cu0;\n    assign mx3 = c6 ? ppg1 : cu1;\n    assign mx4 = c6 ? mo1 : cu2;\n    assign mx5 = c7 ? mo2 : R3;\n    mod_p\n        mod_p_0 (mx3, mo0),\n        mod_p_1 (ppg2, t0),\n        mod_p_2 (t0, mo1),\n        mod_p_3 (R3, t1),\n        mod_p_4 (t1, t2),\n        mod_p_5 (t2, mo2);\n    assign mx6 = c9 ? mo0 : mx3;\n    assign mx7 = c6 ? (c8 ? mx5 : 0) : cu3;\n    f3m_add\n        f3m_add_0 (mx2, mx6, ad0),\n        f3m_add_1 (mx4, mx7, ad1),\n        f3m_add_2 (ad0, ad1, ad2);\n    always @ (posedge clk)\n        if (reset) R3 <= 0;\n        else if (c10) R3 <= ad2;\n        else R3 <= 0;\n    assign out = R3;\nendmodule"}
{"task_id": 929, "completion": "supply1 VPWR;\n    supply0 VGND;\n\nendmodule"}
{"task_id": 908, "completion": "input  VPWR   ;\n    input  VGND   ;\n    output Q      ;\n    output Q_N    ;\n    input  RESET_B;\n    input  D      ;\n    input  GATE   ;\n\n    wire RESET          ;\n    reg  notifier       ;\n    wire D_delayed      ;\n    wire GATE_delayed   ;\n    wire RESET_delayed  ;\n    wire RESET_B_delayed;\n    wire buf_Q          ;\n    wire awake          ;\n    wire cond0          ;\n    wire cond1          ;\n\n    not                             not0            (RESET , RESET_B_delayed                                     );\n    sky130_fd_sc_hs__u_dl_p_r_no_pg u_dl_p_r_no_pg0 (buf_Q , D_delayed, GATE_delayed, RESET, notifier, VPWR, VGND);\n    assign awake = ( VPWR === 1'b1 );\n    assign cond0 = ( awake && ( RESET_B_delayed === 1'b1 ) );\n    assign cond1 = ( awake && ( RESET_B === 1'b1 ) );\n    buf                             buf0            (Q     , buf_Q                                               );\n    not                             not1            (Q_N   , buf_Q                                               );\n\nendmodule"}
{"task_id": 887, "completion": "always @(*) begin\n        case(aluop)\n            4'b0000: begin alucontrol <= 3'b010; signd <= 1'b1; multseld <= 1'b0; end           \n            4'b0010: begin\n                case(funct)         \n                    6'b100000: begin alucontrol <= 3'b010; signd <= 1'b1; multseld <= 1'b0; end \n                    6'b100001: begin alucontrol <= 3'b010; signd <= 1'b0; multseld <= 1'b0; end \n                    6'b100010: begin alucontrol <= 3'b110; signd <= 1'b1; multseld <= 1'b0; end \n                    6'b100011: begin alucontrol <= 3'b110; signd <= 1'b0; multseld <= 1'b0; end \n                    6'b100100: begin alucontrol <= 3'b000; signd <= 1'b1; multseld <= 1'b0; end \n                    6'b100101: begin alucontrol <= 3'b001; signd <= 1'b1; multseld <= 1'b0; end \n                    6'b101010: begin alucontrol <= 3'b111; signd <= 1'b1; multseld <= 1'b0; end \n                    6'b101011: begin alucontrol <= 3'b111; signd <= 1'b0; multseld <= 1'b0; end \n                    6'b100110: begin alucontrol <= 3'b011; signd <= 1'b1; multseld <= 1'b0; end \n                    6'b011000: begin alucontrol <= 3'bxxx; signd <= 1'b1; multseld <= 1'b1; end \n                    6'b011001: begin alucontrol <= 3'bxxx; signd <= 1'b0; multseld <= 1'b1; end \n                    default:     begin alucontrol <= 3'bxxx; signd <= 1'b0; multseld <= 1'b0; end \n                endcase\n            end\n            4'b0001: begin alucontrol <= 3'b110; signd <= 1'b1; multseld <= 1'b0; end          \n            4'b0011: begin alucontrol <= 3'b001; signd <= 1'b1; multseld <= 1'b0; end          \n            4'b0100: begin alucontrol <= 3'b000; signd <= 1'b1; multseld <= 1'b0; end          \n            4'b0101: begin alucontrol <= 3'b011; signd <= 1'b1; multseld <= 1'b0; end          \n            4'b0110: begin alucontrol <= 3'b111; signd <= 1'b1; multseld <= 1'b0; end          \n            4'b0111: begin alucontrol <= 3'b011; signd <= 1'b0; multseld <= 1'b0; end          \n            4'b1000: begin alucontrol <= 3'b111; signd <= 1'b0; multseld <= 1'b0; end          \n            default: begin alucontrol <= 3'bxxx; signd <= 1'b0; multseld <= 1'b0; end          \n        endcase\n    end\nendmodule"}
{"task_id": 937, "completion": "supply1 VPWR;\n    supply0 VGND;\nendmodule"}
{"task_id": 935, "completion": "output X   ;\n    input  A1  ;\n    input  A2  ;\n    input  B1  ;\n    input  C1  ;\n    input  D1  ;\n    input  VPWR;\n    input  VGND;\n    input  VPB ;\n    input  VNB ;\n    sky130_fd_sc_hd__o2111a base (\n        .X(X),\n        .A1(A1),\n        .A2(A2),\n        .B1(B1),\n        .C1(C1),\n        .D1(D1),\n        .VPWR(VPWR),\n        .VGND(VGND),\n        .VPB(VPB),\n        .VNB(VNB)\n    );\n\nendmodule"}
{"task_id": 923, "completion": "wire [14:0]DDR_addr;\n  wire [2:0]DDR_ba;\n  wire DDR_cas_n;\n  wire DDR_ck_n;\n  wire DDR_ck_p;\n  wire DDR_cke;\n  wire DDR_cs_n;\n  wire [3:0]DDR_dm;\n  wire [31:0]DDR_dq;\n  wire [3:0]DDR_dqs_n;\n  wire [3:0]DDR_dqs_p;\n  wire DDR_odt;\n  wire DDR_ras_n;\n  wire DDR_reset_n;\n  wire DDR_we_n;\n  wire FIXED_IO_ddr_vrn;\n  wire FIXED_IO_ddr_vrp;\n  wire [53:0]FIXED_IO_mio;\n  wire FIXED_IO_ps_clk;\n  wire FIXED_IO_ps_porb;\n  wire FIXED_IO_ps_srstb;\n  wire [7:0]leds_8bits_tri_o;\n\n  zynq_design_1 zynq_design_1_i\n       (.DDR_addr(DDR_addr),\n        .DDR_ba(DDR_ba),\n        .DDR_cas_n(DDR_cas_n),\n        .DDR_ck_n(DDR_ck_n),\n        .DDR_ck_p(DDR_ck_p),\n        .DDR_cke(DDR_cke),\n        .DDR_cs_n(DDR_cs_n),\n        .DDR_dm(DDR_dm),\n        .DDR_dq(DDR_dq),\n        .DDR_dqs_n(DDR_dqs_n),\n        .DDR_dqs_p(DDR_dqs_p),\n        .DDR_odt(DDR_odt),\n        .DDR_ras_n(DDR_ras_n),\n        .DDR_reset_n(DDR_reset_n),\n        .DDR_we_n(DDR_we_n),\n        .FIXED_IO_ddr_vrn(FIXED_IO_ddr_vrn),\n        .FIXED_IO_ddr_vrp(FIXED_IO_ddr_vrp),\n        .FIXED_IO_mio(FIXED_IO_mio),\n        .FIXED_IO_ps_clk(FIXED_IO_ps_clk),\n        .FIXED_IO_ps_porb(FIXED_IO_ps_porb),\n        .FIXED_IO_ps_srstb(FIXED_IO_ps_srstb),\n        .leds_8bits_tri_o(leds_8bits_tri_o));\nendmodule"}
{"task_id": 933, "completion": "input  VPWR;    input  VGND;    output Y;    input  A;    input  B;    input  C;    input  D;    wire   nor0_out_Y;    wire   u_vpwr_vgnd0_out_Y;    nor                          nor0         (nor0_out_Y        , A, B, C, D            );    sky130_fd_sc_hs__u_vpwr_vgnd u_vpwr_vgnd0 (u_vpwr_vgnd0_out_Y, nor0_out_Y, VPWR, VGND);    buf                          buf0         (Y                 , u_vpwr_vgnd0_out_Y    );endmodule"}
{"task_id": 817, "completion": "wire [15:0] sub_wire0;\n            wire [15:0] result = sub_wire0[15:0];    \n\n            wire [7:0] wire_dataa;   \n            assign wire_dataa[7:0] = dataa_0;\n\n            wire [7:0] wire_datab;   \n            assign wire_datab[7:0] = datab_0;\n\n            altera_mult_add        altera_mult_add_component (\n                                        .clock0 (clock0),\n                                        .dataa (wire_dataa),\n                                        .datab (wire_datab),\n                                        .result (sub_wire0),\n                                        .accum_sload (1'b0),\n                                        .aclr0 (1'b0),\n                                        .aclr1 (1'b0),\n                                        .aclr2 (1'b0),\n                                        .aclr3 (1'b0),\n                                        .addnsub1 (1'b1),\n                                        .addnsub1_round (1'b0),\n                                        .addnsub3 (1'b1),\n                                        .addnsub3_round (1'b0),\n                                        .chainin (1'b0),\n                                        .chainout_round (1'b0),\n                                        .chainout_sat_overflow (),\n                                        .chainout_saturate (1'b0),\n                                        .clock1 (1'b1),\n                                        .clock2 (1'b1),\n                                        .clock3 (1'b1),\n                                        .coefsel0 ({3{1'b0}}),\n                                        .coefsel1 ({3{1'b0}}),\n                                        .coefsel2 ({3{1'b0}}),\n                                        .coefsel3 ({3{1'b0}}),\n                                        .datac ({16{1'b0}}),\n                                        .ena0 (1'b1),\n                                        .ena1 (1'b1),\n                                        .ena2 (1'b1),\n                                        .ena3 (1'b1),\n                                        .mult01_round (1'b0),\n                                        .mult01_saturation (1'b0),\n                                        .mult0_is_saturated (),\n                                        .mult1_is_saturated (),\n                                        .mult23_round (1'b0),\n                                        .mult23_saturation (1'b0),\n                                        .mult2_is_saturated (),\n                                        .mult3_is_saturated (),\n                                        .negate (1'b0),\n                                        .output_round (1'b0),\n                                        .output_saturate (1'b0),\n                                        .overflow (),\n                                        .rotate (1'b0),\n                                        .scanina ({8{1'b0}}),\n                                        .scaninb ({8{1'b0}}),\n                                        .scanouta (),\n                                        .scanoutb (),\n                                        .sclr0 (1'b0),\n                                        .sclr1 (1'b0),\n                                        .sclr2 (1'b0),\n                                        .sclr3 (1'b0),\n                                        .shift_right (1'b0),\n                                        .signa (1'b0),\n                                        .signb (1'b0),\n                                        .sload_accum (1'b0),\n                                        .sourcea ({1{1'b0}}),\n                                        .sourceb ({1{1'b0}}),\n                                        .zero_chainout (1'b0),\n                                        .zero_loopback (1'b0));\n            defparam\n                    altera_mult_add_component.number_of_multipliers = 1,\n                    altera_mult_add_component.width_a = 8,\n                    altera_mult_add_component.width_b = 8,\n                    altera_mult_add_component.width_result = 16,\n                    altera_mult_add_component.output_register = \"CLOCK0\",\n                    altera_mult_add_component.output_aclr = \"NONE\",\n                    altera_mult_add_component.output_sclr = \"NONE\",\n                    altera_mult_add_component.multiplier1_direction = \"ADD\",\n                    altera_mult_add_component.port_addnsub1 = \"PORT_UNUSED\",\n                    altera_mult_add_component.addnsub_multiplier_register1 = \"UNREGISTERED\",\n                    altera_mult_add_component.addnsub_multiplier_aclr1 = \"NONE\",\n                    altera_mult_add_component.addnsub_multiplier_sclr1 = \"NONE\",\n                    altera_mult_add_component.multiplier3_direction = \"ADD\",\n                    altera_mult_add_component.port_addnsub3 = \"PORT_UNUSED\",\n                    altera_mult_add_component.addnsub_multiplier_register3 = \"UNREGISTERED\",\n                    altera_mult_add_component.addnsub_multiplier_aclr3 = \"NONE\",\n                    altera_mult_add_component.addnsub_multiplier_sclr3 = \"NONE\",\n                    altera_mult_add_component.use_subnadd = \"NO\",\n                    altera_mult_add_component.representation_a = \"SIGNED\",\n                    altera_mult_add_component.port_signa = \"PORT_UNUSED\",\n                    altera_mult_add_component.signed_register_a = \"UNREGISTERED\",\n                    altera_mult_add_component.signed_aclr_a = \"NONE\",\n                    altera_mult_add_component.signed_sclr_a = \"NONE\",\n                    altera_mult_add_component.port_signb = \"PORT_UNUSED\",\n                    altera_mult_add_component.representation_b = \"SIGNED\",\n                    altera_mult_add_component.signed_register_b = \"UNREGISTERED\",\n                    altera_mult_add_component.signed_aclr_b = \"NONE\",\n                    altera_mult_add_component.signed_sclr_b = \"NONE\",\n                    altera_mult_add_component.input_register_a0 = \"CLOCK0\",\n                    altera_mult_add_component.input_register_a1 = \"UNREGISTERED\",\n                    altera_mult_add_component.input_register_a2 = \"UNREGISTERED\",\n                    altera_mult_add_component.input_register_a3 = \"UNREGISTERED\",\n                    altera_mult_add_component.input_aclr_a0 = \"NONE\",\n                    altera_mult_add_component.input_aclr_a1 = \"NONE\",\n                    altera_mult_add_component.input_aclr_a2 = \"NONE\",\n                    altera_mult_add_component.input_aclr_a3 = \"NONE\",\n                    altera_mult_add_component.input_sclr_a0 = \"NONE\",\n                    altera_mult_add_component.input_sclr_a1 = \"NONE\",\n                    altera_mult_add_component.input_sclr_a2 = \"NONE\",\n                    altera_mult_add_component.input_sclr_a3 = \"NONE\",\n                    altera_mult_add_component.input_register_b0 = \"CLOCK0\",\n                    altera_mult_add_component.input_register_b1 = \"UNREGISTERED\",\n                    altera_mult_add_component.input_register_b2 = \"UNREGISTERED\",\n                    altera_mult_add_component.input_register_b3 = \"UNREGISTERED\",\n                    altera_mult_add_component.input_aclr_b0 = \"NONE\",\n                    altera_mult_add_component.input_aclr_b1 = \"NONE\",\n                    altera_mult_add_component.input_aclr_b2 = \"NONE\",\n                    altera_mult_add_component.input_aclr_b3 = \"NONE\",\n                    altera_mult_add_component.input_sclr_b0 = \"NONE\",\n                    altera_mult_add_component.input_sclr_b1 = \"NONE\",\n                    altera_mult_add_component.input_sclr_b2 = \"NONE\",\n                    altera_mult_add_component.input_sclr_b3 = \"NONE\",\n                    altera_mult_add_component.width_c = 16,\n                    altera_mult_add_component.input_register_c0 = \"UNREGISTERED\",\n                    altera_mult_add_component.input_register_c1 = \"UNREGISTERED\",\n                    altera_mult_add_component.input_register_c2 = \"UNREGISTERED\",\n                    altera_mult_add_component.input_register_c3 = \"UNREGISTERED\",\n                    altera_mult_add_component.input_aclr_c0 = \"NONE\",\n                    altera_mult_add_component.input_aclr_c1 = \"NONE\",\n                    altera_mult_add_component.input_aclr_c2 = \"NONE\",\n                    altera_mult_add_component.input_aclr_c3 = \"NONE\",\n                    altera_mult_add_component.input_sclr_c0 = \"NONE\",\n                    altera_mult_add_component.input_sclr_c1 = \"NONE\",\n                    altera_mult_add_component.input_sclr_c2 = \"NONE\",\n                    altera_mult_add_component.input_sclr_c3 = \"NONE\",\n                    altera_mult_add_component.width_coef = 18,\n                    altera_mult_add_component.coefsel0_register = \"UNREGISTERED\",\n                    altera_mult_add_component.coefsel1_register = \"UNREGISTERED\",\n                    altera_mult_add_component.coefsel2_register = \"UNREGISTERED\",\n                    altera_mult_add_component.coefsel3_register = \"UNREGISTERED\",\n                    altera_mult_add_component.coefsel0_aclr = \"NONE\",\n                    altera_mult_add_component.coefsel1_aclr = \"NONE\",\n                    altera_mult_add_component.coefsel2_aclr = \"NONE\",\n                    altera_mult_add_component.coefsel3_aclr = \"NONE\",\n                    altera_mult_add_component.coefsel0_sclr = \"NONE\",\n                    altera_mult_add_component.coefsel1_sclr = \"NONE\",\n                    altera_mult_add_component.coefsel2_sclr = \"NONE\",\n                    altera_mult_add_component.coefsel3_sclr = \"NONE\",\n                    altera_mult_add_component.coef0_0 = 0,\n                    altera_mult_add_component.coef0_1 = 0,\n                    altera_mult_add_component.coef0_2 = 0,\n                    altera_mult_add_component.coef0_3 = 0,\n                    altera_mult_add_component.coef0_4 = 0,\n                    altera_mult_add_component.coef0_5 = 0,\n                    altera_mult_add_component.coef0_6 = 0,\n                    altera_mult_add_component.coef0_7 = 0,\n                    altera_mult_add_component.coef1_0 = 0,\n                    altera_mult_add_component.coef1_1 = 0,\n                    altera_mult_add_component.coef1_2 = 0,\n                    altera_mult_add_component.coef1_3 = 0,\n                    altera_mult_add_component.coef1_4 = 0,\n                    altera_mult_add_component.coef1_5 = 0,\n                    altera_mult_add_component.coef1_6 = 0,\n                    altera_mult_add_component.coef1_7 = 0,\n                    altera_mult_add_component.coef2_0 = 0,\n                    altera_mult_add_component.coef2_1 = 0,\n                    altera_mult_add_component.coef2_2 = 0,\n                    altera_mult_add_component.coef2_3 = 0,\n                    altera_mult_add_component.coef2_4 = 0,\n                    altera_mult_add_component.coef2_5 = 0,\n                    altera_mult_add_component.coef2_6 = 0,\n                    altera_mult_add_component.coef2_7 = 0,\n                    altera_mult_add_component.coef3_0 = 0,\n                    altera_mult_add_component.coef3_1 = 0,\n                    altera_mult_add_component.coef3_2 = 0,\n                    altera_mult_add_component.coef3_3 = 0,\n                    altera_mult_add_component.coef3_4 = 0,\n                    altera_mult_add_component.coef3_5 = 0,\n                    altera_mult_add_component.coef3_6 = 0,\n                    altera_mult_add_component.coef3_7 = 0,\n                    altera_mult_add_component.accumulator = \"NO\",\n                    altera_mult_add_component.accum_direction = \"ADD\",\n                    altera_mult_add_component.use_sload_accum_port = \"NO\",\n                    altera_mult_add_component.loadconst_value = 64,\n                    altera_mult_add_component.accum_sload_register = \"UNREGISTERED\",\n                    altera_mult_add_component.accum_sload_aclr = \"NONE\",\n                    altera_mult_add_component.accum_sload_sclr = \"NONE\",\n                    altera_mult_add_component.double_accum = \"NO\",\n                    altera_mult_add_component.width_chainin = 1,\n                    altera_mult_add_component.chainout_adder = \"NO\",\n                    altera_mult_add_component.chainout_adder_direction = \"ADD\",\n                    altera_mult_add_component.port_negate = \"PORT_UNUSED\",\n                    altera_mult_add_component.negate_register = \"UNREGISTERED\",\n                    altera_mult_add_component.negate_aclr = \"NONE\",\n                    altera_mult_add_component.negate_sclr = \"NONE\",\n                    altera_mult_add_component.systolic_delay1 = \"UNREGISTERED\",\n                    altera_mult_add_component.systolic_aclr1 = \"NONE\",\n                    altera_mult_add_component.systolic_sclr1 = \"NONE\",\n                    altera_mult_add_component.systolic_delay3 = \"UNREGISTERED\",\n                    altera_mult_add_component.systolic_aclr3 = \"NONE\",\n                    altera_mult_add_component.systolic_sclr3 = \"NONE\",\n                    altera_mult_add_component.latency = 0,\n                    altera_mult_add_component.input_a0_latency_clock = \"UNREGISTERED\",\n                    altera_mult_add_component.input_a1_latency_clock = \"UNREGISTERED\",\n                    altera_mult_add_component.input_a2_latency_clock = \"UNREGISTERED\",\n                    altera_mult_add_component.input_a3_latency_clock = \"UNREGISTERED\",\n                    altera_mult_add_component.input_a0_latency_aclr = \"NONE\",\n                    altera_mult_add_component.input_a1_latency_aclr = \"NONE\",\n                    altera_mult_add_component.input_a2_latency_aclr = \"NONE\",\n                    altera_mult_add_component.input_a3_latency_aclr = \"NONE\",\n                    altera_mult_add_component.input_a0_latency_sclr = \"NONE\",\n                    altera_mult_add_component.input_a1_latency_sclr = \"NONE\",\n                    altera_mult_add_component.input_a2_latency_sclr = \"NONE\",\n                    altera_mult_add_component.input_a3_latency_sclr = \"NONE\",\n                    altera_mult_add_component.input_b0_latency_clock = \"UNREGISTERED\",\n                    altera_mult_add_component.input_b1_latency_clock = \"UNREGISTERED\",\n                    altera_mult_add_component.input_b2_latency_clock = \"UNREGISTERED\",\n                    altera_mult_add_component.input_b3_latency_clock = \"UNREGISTERED\",\n                    altera_mult_add_component.input_b0_latency_aclr = \"NONE\",\n                    altera_mult_add_component.input_b1_latency_aclr = \"NONE\",\n                    altera_mult_add_component.input_b2_latency_aclr = \"NONE\",\n                    altera_mult_add_component.input_b3_latency_aclr = \"NONE\",\n                    altera_mult_add_component.input_b0_latency_sclr = \"NONE\",\n                    altera_mult_add_component.input_b1_latency_sclr = \"NONE\",\n                    altera_mult_add_component.input_b2_latency_sclr = \"NONE\",\n                    altera_mult_add_component.input_b3_latency_sclr = \"NONE\",\n                    altera_mult_add_component.input_c0_latency_clock = \"UNREGISTERED\",\n                    altera_mult_add_component.input_c1_latency_clock = \"UNREGISTERED\",\n                    altera_mult_add_component.input_c2_latency_clock = \"UNREGISTERED\",\n                    altera_mult_add_component.input_c3_latency_clock = \"UNREGISTERED\",\n                    altera_mult_add_component.input_c0_latency_aclr = \"NONE\",\n                    altera_mult_add_component.input_c1_latency_aclr = \"NONE\",\n                    altera_mult_add_component.input_c2_latency_aclr = \"NONE\",\n                    altera_mult_add_component.input_c3_latency_aclr = \"NONE\",\n                    altera_mult_add_component.input_c0_latency_sclr = \"NONE\",\n                    altera_mult_add_component.input_c1_latency_sclr = \"NONE\",\n                    altera_mult_add_component.input_c2_latency_sclr = \"NONE\",\n                    altera_mult_add_component.input_c3_latency_sclr = \"NONE\",\n                    altera_mult_add_component.coefsel0_latency_clock = \"UNREGISTERED\",\n                    altera_mult_add_component.coefsel1_latency_clock = \"UNREGISTERED\",\n                    altera_mult_add_component.coefsel2_latency_clock = \"UNREGISTERED\",\n                    altera_mult_add_component.coefsel3_latency_clock = \"UNREGISTERED\",\n                    altera_mult_add_component.coefsel0_latency_aclr = \"NONE\",\n                    altera_mult_add_component.coefsel1_latency_aclr = \"NONE\",\n                    altera_mult_add_component.coefsel2_latency_aclr = \"NONE\",\n                    altera_mult_add_component.coefsel3_latency_aclr = \"NONE\",\n                    altera_mult_add_component.coefsel0_latency_sclr = \"NONE\",\n                    altera_mult_add_component.coefsel1_latency_sclr = \"NONE\",\n                    altera_mult_add_component.coefsel2_latency_sclr = \"NONE\",\n                    altera_mult_add_component.coefsel3_latency_sclr = \"NONE\",\n                    altera_mult_add_component.signed_latency_clock_a = \"UNREGISTERED\",\n                    altera_mult_add_component.signed_latency_aclr_a = \"NONE\",\n                    altera_mult_add_component.signed_latency_sclr_a = \"NONE\",\n                    altera_mult_add_component.signed_latency_clock_b = \"UNREGISTERED\",\n                    altera_mult_add_component.signed_latency_aclr_b = \"NONE\",\n                    altera_mult_add_component.signed_latency_sclr_b = \"NONE\",\n                    altera_mult_add_component.addnsub_multiplier_latency_clock1 = \"UNREGISTERED\",\n                    altera_mult_add_component.addnsub_multiplier_latency_aclr1 = \"NONE\",\n                    altera_mult_add_component.addnsub_multiplier_latency_sclr1 = \"NONE\",\n                    altera_mult_add_component.addnsub_multiplier_latency_clock3 = \"UNREGISTERED\",\n                    altera_mult_add_component.addnsub_multiplier_latency_aclr3 = \"NONE\",\n                    altera_mult_add_component.addnsub_multiplier_latency_sclr3 = \"NONE\",\n                    altera_mult_add_component.accum_sload_latency_clock = \"UNREGISTERED\",\n                    altera_mult_add_component.accum_sload_latency_aclr = \"NONE\",\n                    altera_mult_add_component.accum_sload_latency_sclr = \"NONE\",\n                    altera_mult_add_component.negate_latency_clock = \"UNREGISTERED\",\n                    altera_mult_add_component.negate_latency_aclr = \"NONE\",\n                    altera_mult_add_component.negate_latency_sclr = \"NONE\",\n                    altera_mult_add_component.selected_device_family = \"Stratix V\";\n\nendmodule"}
{"task_id": 941, "completion": "endmodule"}
{"task_id": 910, "completion": "// synthesis translate_off\n  BLK_MEM_GEN_V7_3 #(    .C_ADDRA_WIDTH(11),    .C_ADDRB_WIDTH(11),    .C_ALGORITHM(1),    .C_AXI_ID_WIDTH(4),    .C_AXI_SLAVE_TYPE(0),    .C_AXI_TYPE(1),    .C_BYTE_SIZE(9),    .C_COMMON_CLK(1),    .C_DEFAULT_DATA(\"0\"),    .C_DISABLE_WARN_BHV_COLL(0),    .C_DISABLE_WARN_BHV_RANGE(0),    .C_ENABLE_32BIT_ADDRESS(0),    .C_FAMILY(\"spartan3\"),    .C_HAS_AXI_ID(0),    .C_HAS_ENA(0),    .C_HAS_ENB(0),    .C_HAS_INJECTERR(0),    .C_HAS_MEM_OUTPUT_REGS_A(0),    .C_HAS_MEM_OUTPUT_REGS_B(0),    .C_HAS_MUX_OUTPUT_REGS_A(0),    .C_HAS_MUX_OUTPUT_REGS_B(0),    .C_HAS_REGCEA(0),    .C_HAS_REGCEB(0),    .C_HAS_RSTA(0),    .C_HAS_RSTB(0),    .C_HAS_SOFTECC_INPUT_REGS_A(0),    .C_HAS_SOFTECC_OUTPUT_REGS_B(0),    .C_INIT_FILE(\"BlankString\"),    .C_INIT_FILE_NAME(\"no_coe_file_loaded\"),    .C_INITA_VAL(\"0\"),    .C_INITB_VAL(\"0\"),    .C_INTERFACE_TYPE(0),    .C_LOAD_INIT_FILE(0),    .C_MEM_TYPE(2),    .C_MUX_PIPELINE_STAGES(0),    .C_PRIM_TYPE(1),    .C_READ_DEPTH_A(2048),    .C_READ_DEPTH_B(2048),    .C_READ_WIDTH_A(8),    .C_READ_WIDTH_B(8),    .C_RST_PRIORITY_A(\"CE\"),    .C_RST_PRIORITY_B(\"CE\"),    .C_RST_TYPE(\"SYNC\"),    .C_RSTRAM_A(0),    .C_RSTRAM_B(0),    .C_SIM_COLLISION_CHECK(\"ALL\"),    .C_USE_BRAM_BLOCK(0),    .C_USE_BYTE_WEA(0),    .C_USE_BYTE_WEB(0),    .C_USE_DEFAULT_DATA(0),    .C_USE_ECC(0),    .C_USE_SOFTECC(0),    .C_WEA_WIDTH(1),    .C_WEB_WIDTH(1),    .C_WRITE_DEPTH_A(2048),    .C_WRITE_DEPTH_B(2048),    .C_WRITE_MODE_A(\"READ_FIRST\"),    .C_WRITE_MODE_B(\"READ_FIRST\"),    .C_WRITE_WIDTH_A(8),    .C_WRITE_WIDTH_B(8),    .C_XDEVICEFAMILY(\"spartan3\")  )  inst (    .CLKA(clka),    .WEA(wea),    .ADDRA(addra),    .DINA(dina),    .DOUTA(douta),    .CLKB(clkb),    .WEB(web),    .ADDRB(addrb),    .DINB(dinb),    .DOUTB(doutb),    .RSTA(),    .ENA(),    .REGCEA(),    .RSTB(),    .ENB(),    .REGCEB(),    .INJECTSBITERR(),    .INJECTDBITERR(),    .SBITERR(),    .DBITERR(),    .RDADDRECC(),    .S_ACLK(),    .S_ARESETN(),    .S_AXI_AWID(),    .S_AXI_AWADDR(),    .S_AXI_AWLEN(),    .S_AXI_AWSIZE(),    .S_AXI_AWBURST(),    .S_AXI_AWVALID(),    .S_AXI_AWREADY(),    .S_AXI_WDATA(),    .S_AXI_WSTRB(),    .S_AXI_WLAST(),    .S_AXI_WVALID(),    .S_AXI_WREADY(),    .S_AXI_BID(),    .S_AXI_BRESP(),    .S_AXI_BVALID(),    .S_AXI_BREADY(),    .S_AXI_ARID(),    .S_AXI_ARADDR(),    .S_AXI_ARLEN(),    .S_AXI_ARSIZE(),    .S_AXI_ARBURST(),    .S_AXI_ARVALID(),    .S_AXI_ARREADY(),    .S_AXI_RID(),    .S_AXI_RDATA(),    .S_AXI_RRESP(),    .S_AXI_RLAST(),    .S_AXI_RVALID(),    .S_AXI_RREADY(),    .S_AXI_INJECTSBITERR(),    .S_AXI_INJECTDBITERR(),    .S_AXI_SBITERR(),    .S_AXI_DBITERR(),    .S_AXI_RDADDRECC()  );  // synthesis translate_on\nendmodule"}
{"task_id": 930, "completion": "localparam INTWIDTH = 17;   wire [INTWIDTH-1:0]  data_rnd;   wire     stb_rnd;   round_sd #(.WIDTH_IN(WIDTH),.WIDTH_OUT(INTWIDTH)) round_in (.clk(clk),.reset(rst),.in(data_in),.strobe_in(stb_in),.out(data_rnd),.strobe_out(stb_rnd));   reg     stb_rnd_d1;   reg [INTWIDTH-1:0]  data_rnd_d1;   always @(posedge clk) stb_rnd_d1 <= stb_rnd;   always @(posedge clk) data_rnd_d1 <= data_rnd;   wire     go;   reg     phase, go_d1, go_d2, go_d3, go_d4;   always @(posedge clk) if(rst | ~run) phase <= 0; else if(stb_rnd_d1) phase <= ~phase;   assign     go = stb_rnd_d1 & phase;   always @(posedge clk) if(rst | ~run) begin go_d1 <= 0; go_d2 <= 0; go_d3 <= 0; go_d4 <= 0; end else begin go_d1 <= go; go_d2 <= go_d1; go_d3 <= go_d2; go_d4 <= go_d3; end   wire [17:0]     coeff_a = -10690;   wire [17:0]     coeff_b = 75809;   reg [INTWIDTH-1:0]  d1, d2, d3, d4 , d5, d6;   always @(posedge clk) if(stb_rnd_d1 | rst) begin d1 <= data_rnd_d1; d2 <= d1; d3 <= d2; d4 <= d3; d5 <= d4; d6 <= d5; end   reg [17:0] sum_a, sum_b, middle, middle_d1;   always @(posedge clk) if(go) begin sum_a <= {data_rnd_d1[INTWIDTH-1],data_rnd_d1} + {d6[INTWIDTH-1],d6}; sum_b <= {d2[INTWIDTH-1],d2} + {d4[INTWIDTH-1],d4}; middle <= {d3,1'b0}; end   always @(posedge clk) if(go_d1) middle_d1 <= middle;   wire [17:0] sum = go_d1 ? sum_b : sum_a;   wire [17:0] coeff = go_d1 ? coeff_b : coeff_a;   wire [35:0]     prod;   MULT18X18S mult(.C(clk), .CE(go_d1 | go_d2), .R(rst), .P(prod), .A(coeff), .B(sum) );   localparam ACCWIDTH = 30;   reg [ACCWIDTH-1:0]     accum;   always @(posedge clk) if(rst) accum <= 0; else if(go_d2) accum <= {middle_d1[17],middle_d1[17],middle_d1,{(16+ACCWIDTH-36){1'b0}}} + {prod[35:36-ACCWIDTH]}; else if(go_d3) accum <= accum + {prod[35:36-ACCWIDTH]};   wire [WIDTH:0]     accum_rnd;   wire [WIDTH-1:0]     accum_rnd_clip;   wire     stb_round;   round_sd #(.WIDTH_IN(ACCWIDTH),.WIDTH_OUT(WIDTH+1)) round_acc (.clk(clk), .reset(rst), .in(accum), .strobe_in(go_d4), .out(accum_rnd), .strobe_out(stb_round));   clip #(.bits_in(WIDTH+1),.bits_out(WIDTH)) clip (.in(accum_rnd), .out(accum_rnd_clip));   always @(posedge clk) begin stb_out  <= bypass ? stb_in : stb_round; data_out <= bypass ? data_in : accum_rnd_clip; end   endmodule"}
{"task_id": 872, "completion": "reg [3:0] wen_d; reg [3:0] wad; reg [15:0] di_1; reg [15:0] di_2; reg [15:0] di_3; reg [2:0] wpage0; reg [2:0] wpage7; reg [2:0] page_r; reg [2:0] wpage_w; reg wpage0_inc; reg wpage0_inc_d; reg reset_cmd; reg dly_cmd; reg bytes_cmd; reg run_cmd; reg reset_on; reg [1:0] i2c_bytes; reg [7:0] i2c_dly; reg i2c_enrun; reg we_fifo_wp; reg req_clr; wire is_ctl= (wad[3:0]==4'hf); wire is_abs= (wad[3]==0); wire pre_wpage0_inc = (!wen_d[0] && !wen_d[1] && !wpage0_inc) && (req_clr || reset_on); wire [2:0] frame_no=wpage0[2:0]; reg [5:0] fifo_wr_pointers [0:7]; wire [5:0] fifo_wr_pointers_outw=fifo_wr_pointers[wpage_w[2:0]]; wire [5:0] fifo_wr_pointers_outr=fifo_wr_pointers[page_r[2:0]]; reg [5:0] fifo_wr_pointers_outw_r; reg [5:0] fifo_wr_pointers_outr_r; reg [9:0] i2c_cmd_wa; reg i2c_cmd_we; reg [1:0] page_r_inc; reg [5:0] rpointer; reg i2c_start; reg i2c_run; reg i2c_done; reg [1:0] bytes_left; reg [1:0] byte_number; reg [1:0] byte_sending; reg [5:0] i2c_state; reg [7:0] dly_cntr; reg scl_hard; reg sda_hard; reg sda_en_hard; reg wen_i2c_soft; reg scl_en_soft; reg scl_soft; reg sda_en_soft; reg sda_soft; wire [7:0] i2c_data; reg [8:0] i2c_sr; reg i2c_dly_pre_over; wire i2c_dly_pre2_over; reg i2c_dly_over; wire i2c_startseq_last=(i2c_state[5:0]==6'h28); wire i2c_stopseq_last= (i2c_state[5:0]==6'h24); wire i2c_dataseq_last= (i2c_state[5:0]==6'h00); wire i2c_bit_last    = (i2c_state[1:0]==2'h0); wire i2c_is_ackn     = (i2c_state[5:2]==4'h0); wire i2c_is_start    = i2c_state[5] && i2c_state[3]; wire i2c_is_stop     = i2c_state[5] && i2c_state[2]; wire i2c_is_data     = !i2c_state[5] || (!i2c_state[3] && !i2c_state[2]); reg i2c_dataseq_done; reg [1:0] i2c_byte_start; reg i2c_sr_shift; reg i2c_stop_start; reg sda_0; reg scl_0; reg busy; reg [2:0] busy_cntr; assign i2c_dly_pre2_over=(dly_cntr[7:0]==8'h2); always @ (negedge sclk) begin if (wen) wad [ 3:0] <= wa[ 3:0]; if (wen || wen_d[0]) di_1[15:0] <= di[15:0]; di_2[15:0] <= di_1[15:0]; di_3[15:0] <= di_2[15:0]; wen_d[3:0] <= {wen_d[2:1],wen_d[0] && !is_ctl,wen}; wen_i2c_soft <= wen_d[0] && is_ctl; if      (i2c_run)                   scl_en_soft <= 1'b0; else if (wen_i2c_soft & |di_1[1:0]) scl_en_soft <= (di_1[1:0]!=2'h3); if      (i2c_run)                   scl_soft <= 1'b0; else if (wen_i2c_soft & |di_1[1:0]) scl_soft <= (di_1[1:0]==2'h2); if      (i2c_run)                   sda_en_soft <= 1'b0; else if (wen_i2c_soft & |di_1[3:2]) sda_en_soft <= (di_1[3:2]!=2'h3); if      (i2c_run)                   sda_soft <= 1'b0; else if (wen_i2c_soft & |di_1[3:2]) sda_soft <= (di_1[3:2]==2'h2); reset_cmd <=  wen_d[0] && is_ctl && di_1[14]; run_cmd   <=  wen_d[0] && is_ctl && di_1[13]; bytes_cmd <=  wen_d[0] && is_ctl && di_1[11]; dly_cmd   <=  wen_d[0] && is_ctl && di_1[ 8]; if (bytes_cmd) i2c_bytes[1:0] <= di_2[10:9]; if (dly_cmd)   i2c_dly[7:0]   <= di_2[ 7:0]; if (reset_cmd || (run_cmd && !di_2[12])) i2c_enrun <= 1'b0; else if (run_cmd && di_2[12]) i2c_enrun <= 1'b1; wpage0_inc <= pre_wpage0_inc; wpage0_inc_d <= wpage0_inc; if (reset_cmd)       wpage0[2:0]<=3'h0; else if (wpage0_inc) wpage0[2:0]<=wpage0[2:0]+1; if (reset_cmd)       wpage7[2:0]<=3'h7; else if (wpage0_inc) wpage7[2:0]<=wpage0[2:0]; reset_on <= reset_cmd || (reset_on && !(wpage0_inc && ( wpage0[2:0]==3'h7))); req_clr  <= sync || (req_clr && !wpage0_inc); if      (wen_d[0])   wpage_w[2:0] <= is_abs?((wad[2:0]==wpage7[2:0])? wpage0[2:0] : wad[2:0]):(wpage0[2:0]+wad[2:0]); else if (wpage0_inc) wpage_w[2:0] <= wpage7[2:0]; we_fifo_wp <= wen_d[1] || wpage0_inc; if (wen_d[1])  fifo_wr_pointers_outw_r[5:0] <= fifo_wr_pointers_outw[5:0]; if (we_fifo_wp) fifo_wr_pointers[wpage_w[2:0]] <= wpage0_inc_d? 6'h0:(fifo_wr_pointers_outw_r[5:0]+1); fifo_wr_pointers_outr_r[5:0] <= fifo_wr_pointers_outr[5:0]; if (wen_d[1]) i2c_cmd_wa[9:1] <= {wpage_w[2:0],fifo_wr_pointers_outw[5:0]}; i2c_cmd_wa[0] <= !wen_d[1]; i2c_cmd_we    <=  !reset_cmd && (wen_d[1]  || (i2c_cmd_we && !wen_d[3])); if (reset_on)  page_r[2:0]<=3'h0; else if (page_r_inc[0]) page_r[2:0]<=page_r[2:0]+1; if      (reset_cmd || page_r_inc[0])  rpointer[5:0] <= 6'h0; else if (i2c_done) rpointer[5:0] <= rpointer[5:0] + 1; i2c_run <= !reset_cmd && (i2c_start || (i2c_run && !i2c_done)); i2c_start <= i2c_enrun && !i2c_run && !i2c_start && (rpointer[5:0]!= fifo_wr_pointers_outr_r[5:0]) && !page_r_inc[1] && !page_r_inc[0]; page_r_inc[1:0] <= {page_r_inc[0], !i2c_run && !page_r_inc[0] && (rpointer[5:0] == fifo_wr_pointers_outr_r[5:0]) && (page_r[2:0]!=wpage0[2:0])}; if      (!i2c_run)         bytes_left[1:0] <= i2c_bytes[1:0]; else if (i2c_dataseq_done) bytes_left[1:0] <= bytes_left[1:0] -1; if (!i2c_run)              byte_sending[1:0] <= 2'h3; else if (i2c_dataseq_done) byte_sending[1:0] <= byte_sending[1:0] + 1; if (!i2c_run)              byte_number[1:0] <= 2'h3; else if (i2c_byte_start[1])byte_number[1:0] <= byte_number[1:0] - 1; if (!i2c_run || i2c_dly_over) dly_cntr[7:0] <= i2c_dly[7:0]; else dly_cntr[7:0] <= dly_cntr[7:0] - 1; i2c_dly_pre_over <= i2c_dly_pre2_over; i2c_dly_over <=i2c_dly_pre_over; i2c_dataseq_done     <= i2c_dataseq_last &&  i2c_dly_pre_over; i2c_byte_start[1:0]  <= {i2c_byte_start[0], (i2c_startseq_last || (i2c_dataseq_last && (bytes_left[1:0] != 2'h0))) && i2c_dly_pre2_over }; i2c_sr_shift    <=   i2c_bit_last && !(i2c_dataseq_last) && i2c_dly_pre_over; i2c_stop_start  <=   i2c_dataseq_last && (bytes_left[1:0] == 2'h0) && i2c_dly_pre_over; i2c_done     <=  i2c_stopseq_last && i2c_dly_pre_over; if    (i2c_byte_start[1]) i2c_sr[8:0] <= {i2c_data[7:0], 1'b1}; else if (i2c_sr_shift)    i2c_sr[8:0] <= {i2c_sr[7:0],   1'b1}; if      (!i2c_run)          i2c_state[5:0] <= 6'h2a; else if (i2c_stop_start)    i2c_state[5:0] <= 6'h26; else if (i2c_byte_start[1]) i2c_state[5:0] <= 6'h23; else if (i2c_dly_over)      i2c_state[5:0] <= i2c_state[5:0] - 1; scl_0 <= (i2c_is_start && (i2c_state[1:0]!=2'h0)) || (i2c_is_stop  && !i2c_state[1]) || (i2c_is_data  && (i2c_state[1] ^i2c_state[0])) || !i2c_run; sda_0 <= (i2c_is_start &&  i2c_state[1]) || (i2c_is_stop  && (i2c_state[1:0]==2'h0)) || (i2c_is_data  && i2c_sr[8]) || !i2c_run; sda_hard <= sda_0; scl_hard <= scl_0; sda_en_hard <= i2c_run && (!sda_0 || (!i2c_is_ackn && !sda_hard)); if (wen) busy_cntr[2:0] <= 3'h7; else if (|busy_cntr[2:0]) busy_cntr[2:0] <= busy_cntr[2:0]-1; busy <= (i2c_enrun && ((rpointer[5:0]!= fifo_wr_pointers_outr_r[5:0]) || (page_r[2:0]!=wpage0[2:0]))) || |busy_cntr[2:0] || i2c_run || reset_on; end RAMB16_S9_S18 i_fifo (.DOA(i2c_data[7:0]), .DOPA(), .ADDRA({page_r[2:0], rpointer[5:0], byte_number[1:0]}), .CLKA(!sclk), .DIA(8'h0), .DIPA(1'b0), .ENA(i2c_byte_start[0]), .SSRA(1'b0), .WEA(1'b0), .DOB(), .DOPB(), .ADDRB(i2c_cmd_wa[9:0]), .CLKB(!sclk), .DIB(di_3[15:0]), .DIPB(2'b0), .ENB(i2c_cmd_we), .SSRB(1'b0), .WEB(1'b1)); endmodule"}
{"task_id": 824, "completion": "wire [7 : 0] sbox [0 : 255];  assign new_sboxw[31 : 24] = sbox[sboxw[31 : 24]];  assign new_sboxw[23 : 16] = sbox[sboxw[23 : 16]];  assign new_sboxw[15 : 08] = sbox[sboxw[15 : 08]];  assign new_sboxw[07 : 00] = sbox[sboxw[07 : 00]];  assign sbox[8'h00] = 8'h63;  assign sbox[8'h01] = 8'h7c;  assign sbox[8'h02] = 8'h77;  assign sbox[8'h03] = 8'h7b;  assign sbox[8'h04] = 8'hf2;  assign sbox[8'h05] = 8'h6b;  assign sbox[8'h06] = 8'h6f;  assign sbox[8'h07] = 8'hc5;  assign sbox[8'h08] = 8'h30;  assign sbox[8'h09] = 8'h01;  assign sbox[8'h0a] = 8'h67;  assign sbox[8'h0b] = 8'h2b;  assign sbox[8'h0c] = 8'hfe;  assign sbox[8'h0d] = 8'hd7;  assign sbox[8'h0e] = 8'hab;  assign sbox[8'h0f] = 8'h76;  assign sbox[8'h10] = 8'hca;  assign sbox[8'h11] = 8'h82;  assign sbox[8'h12] = 8'hc9;  assign sbox[8'h13] = 8'h7d;  assign sbox[8'h14] = 8'hfa;  assign sbox[8'h15] = 8'h59;  assign sbox[8'h16] = 8'h47;  assign sbox[8'h17] = 8'hf0;  assign sbox[8'h18] = 8'had;  assign sbox[8'h19] = 8'hd4;  assign sbox[8'h1a] = 8'ha2;  assign sbox[8'h1b] = 8'haf;  assign sbox[8'h1c] = 8'h9c;  assign sbox[8'h1d] = 8'ha4;  assign sbox[8'h1e] = 8'h72;  assign sbox[8'h1f] = 8'hc0;  assign sbox[8'h20] = 8'hb7;  assign sbox[8'h21] = 8'hfd;  assign sbox[8'h22] = 8'h93;  assign sbox[8'h23] = 8'h26;  assign sbox[8'h24] = 8'h36;  assign sbox[8'h25] = 8'h3f;  assign sbox[8'h26] = 8'hf7;  assign sbox[8'h27] = 8'hcc;  assign sbox[8'h28] = 8'h34;  assign sbox[8'h29] = 8'ha5;  assign sbox[8'h2a] = 8'he5;  assign sbox[8'h2b] = 8'hf1;  assign sbox[8'h2c] = 8'h71;  assign sbox[8'h2d] = 8'hd8;  assign sbox[8'h2e] = 8'h31;  assign sbox[8'h2f] = 8'h15;  assign sbox[8'h30] = 8'h04;  assign sbox[8'h31] = 8'hc7;  assign sbox[8'h32] = 8'h23;  assign sbox[8'h33] = 8'hc3;  assign sbox[8'h34] = 8'h18;  assign sbox[8'h35] = 8'h96;  assign sbox[8'h36] = 8'h05;  assign sbox[8'h37] = 8'h9a;  assign sbox[8'h38] = 8'h07;  assign sbox[8'h39] = 8'h12;  assign sbox[8'h3a] = 8'h80;  assign sbox[8'h3b] = 8'he2;  assign sbox[8'h3c] = 8'heb;  assign sbox[8'h3d] = 8'h27;  assign sbox[8'h3e] = 8'hb2;  assign sbox[8'h3f] = 8'h75;  assign sbox[8'h40] = 8'h09;  assign sbox[8'h41] = 8'h83;  assign sbox[8'h42] = 8'h2c;  assign sbox[8'h43] = 8'h1a;  assign sbox[8'h44] = 8'h1b;  assign sbox[8'h45] = 8'h6e;  assign sbox[8'h46] = 8'h5a;  assign sbox[8'h47] = 8'ha0;  assign sbox[8'h48] = 8'h52;  assign sbox[8'h49] = 8'h3b;  assign sbox[8'h4a] = 8'hd6;  assign sbox[8'h4b] = 8'hb3;  assign sbox[8'h4c] = 8'h29;  assign sbox[8'h4d] = 8'he3;  assign sbox[8'h4e] = 8'h2f;  assign sbox[8'h4f] = 8'h84;  assign sbox[8'h50] = 8'h53;  assign sbox[8'h51] = 8'hd1;  assign sbox[8'h52] = 8'h00;  assign sbox[8'h53] = 8'hed;  assign sbox[8'h54] = 8'h20;  assign sbox[8'h55] = 8'hfc;  assign sbox[8'h56] = 8'hb1;  assign sbox[8'h57] = 8'h5b;  assign sbox[8'h58] = 8'h6a;  assign sbox[8'h59] = 8'hcb;  assign sbox[8'h5a] = 8'hbe;  assign sbox[8'h5b] = 8'h39;  assign sbox[8'h5c] = 8'h4a;  assign sbox[8'h5d] = 8'h4c;  assign sbox[8'h5e] = 8'h58;  assign sbox[8'h5f] = 8'hcf;  assign sbox[8'h60] = 8'hd0;  assign sbox[8'h61] = 8'hef;  assign sbox[8'h62] = 8'haa;  assign sbox[8'h63] = 8'hfb;  assign sbox[8'h64] = 8'h43;  assign sbox[8'h65] = 8'h4d;  assign sbox[8'h66] = 8'h33;  assign sbox[8'h67] = 8'h85;  assign sbox[8'h68] = 8'h45;  assign sbox[8'h69] = 8'hf9;  assign sbox[8'h6a] = 8'h02;  assign sbox[8'h6b] = 8'h7f;  assign sbox[8'h6c] = 8'h50;  assign sbox[8'h6d] = 8'h3c;  assign sbox[8'h6e] = 8'h9f;  assign sbox[8'h6f] = 8'ha8;  assign sbox[8'h70] = 8'h51;  assign sbox[8'h71] = 8'ha3;  assign sbox[8'h72] = 8'h40;  assign sbox[8'h73] = 8'h8f;  assign sbox[8'h74] = 8'h92;  assign sbox[8'h75] = 8'h9d;  assign sbox[8'h76] = 8'h38;  assign sbox[8'h77] = 8'hf5;  assign sbox[8'h78] = 8'hbc;  assign sbox[8'h79] = 8'hb6;  assign sbox[8'h7a] = 8'hda;  assign sbox[8'h7b] = 8'h21;  assign sbox[8'h7c] = 8'h10;  assign sbox[8'h7d] = 8'hff;  assign sbox[8'h7e] = 8'hf3;  assign sbox[8'h7f] = 8'hd2;  assign sbox[8'h80] = 8'hcd;  assign sbox[8'h81] = 8'h0c;  assign sbox[8'h82] = 8'h13;  assign sbox[8'h83] = 8'hec;  assign sbox[8'h84] = 8'h5f;  assign sbox[8'h85] = 8'h97;  assign sbox[8'h86] = 8'h44;  assign sbox[8'h87] = 8'h17;  assign sbox[8'h88] = 8'hc4;  assign sbox[8'h89] = 8'ha7;  assign sbox[8'h8a] = 8'h7e;  assign sbox[8'h8b] = 8'h3d;  assign sbox[8'h8c] = 8'h64;  assign sbox[8'h8d] = 8'h5d;  assign sbox[8'h8e] = 8'h19;  assign sbox[8'h8f] = 8'h73;  assign sbox[8'h90] = 8'h60;  assign sbox[8'h91] = 8'h81;  assign sbox[8'h92] = 8'h4f;  assign sbox[8'h93] = 8'hdc;  assign sbox[8'h94] = 8'h22;  assign sbox[8'h95] = 8'h2a;  assign sbox[8'h96] = 8'h90;  assign sbox[8'h97] = 8'h88;  assign sbox[8'h98] = 8'h46;  assign sbox[8'h99] = 8'hee;  assign sbox[8'h9a] = 8'hb8;  assign sbox[8'h9b] = 8'h14;  assign sbox[8'h9c] = 8'hde;  assign sbox[8'h9d] = 8'h5e;  assign sbox[8'h9e] = 8'h0b;  assign sbox[8'h9f] = 8'hdb;  assign sbox[8'ha0] = 8'he0;  assign sbox[8'ha1] = 8'h32;  assign sbox[8'ha2] = 8'h3a;  assign sbox[8'ha3] = 8'h0a;  assign sbox[8'ha4] = 8'h49;  assign sbox[8'ha5] = 8'h06;  assign sbox[8'ha6] = 8'h24;  assign sbox[8'ha7] = 8'h5c;  assign sbox[8'ha8] = 8'hc2;  assign sbox[8'ha9] = 8'hd3;  assign sbox[8'haa] = 8'hac;  assign sbox[8'hab] = 8'h62;  assign sbox[8'hac] = 8'h91;  assign sbox[8'had] = 8'h95;  assign sbox[8'hae] = 8'he4;  assign sbox[8'haf] = 8'h79;  assign sbox[8'hb0] = 8'he7;  assign sbox[8'hb1] = 8'hc8;  assign sbox[8'hb2] = 8'h37;  assign sbox[8'hb3] = 8'h6d;  assign sbox[8'hb4] = 8'h8d;  assign sbox[8'hb5] = 8'hd5;  assign sbox[8'hb6] = 8'h4e;  assign sbox[8'hb7] = 8'ha9;  assign sbox[8'hb8] = 8'h6c;  assign sbox[8'hb9] = 8'h56;  assign sbox[8'hba] = 8'hf4;  assign sbox[8'hbb] = 8'hea;  assign sbox[8'hbc] = 8'h65;  assign sbox[8'hbd] = 8'h7a;  assign sbox[8'hbe] = 8'hae;  assign sbox[8'hbf] = 8'h08;  assign sbox[8'hc0] = 8'hba;  assign sbox[8'hc1] = 8'h78;  assign sbox[8'hc2] = 8'h25;  assign sbox[8'hc3] = 8'h2e;  assign sbox[8'hc4] = 8'h1c;  assign sbox[8'hc5] = 8'ha6;  assign sbox[8'hc6] = 8'hb4;  assign sbox[8'hc7] = 8'hc6;  assign sbox[8'hc8] = 8'he8;  assign sbox[8'hc9] = 8'hdd;  assign sbox[8'hca] = 8'h74;  assign sbox[8'hcb] = 8'h1f;  assign sbox[8'hcc] = 8'h4b;  assign sbox[8'hcd] = 8'hbd;  assign sbox[8'hce] = 8'h8b;  assign sbox[8'hcf] = 8'h8a;  assign sbox[8'hd0] = 8'h70;  assign sbox[8'hd1] = 8'h3e;  assign sbox[8'hd2] = 8'hb5;  assign sbox[8'hd3] = 8'h66;  assign sbox[8'hd4] = 8'h48;  assign sbox[8'hd5] = 8'h03;  assign sbox[8'hd6] = 8'hf6;  assign sbox[8'hd7] = 8'h0e;  assign sbox[8'hd8] = 8'h61;  assign sbox[8'hd9] = 8'h35;  assign sbox[8'hda] = 8'h57;  assign sbox[8'hdb] = 8'hb9;  assign sbox[8'hdc] = 8'h86;  assign sbox[8'hdd] = 8'hc1;  assign sbox[8'hde] = 8'h1d;  assign sbox[8'hdf] = 8'h9e;  assign sbox[8'he0] = 8'he1;  assign sbox[8'he1] = 8'hf8;  assign sbox[8'he2] = 8'h98;  assign sbox[8'he3] = 8'h11;  assign sbox[8'he4] = 8'h69;  assign sbox[8'he5] = 8'hd9;  assign sbox[8'he6] = 8'h8e;  assign sbox[8'he7] = 8'h94;  assign sbox[8'he8] = 8'h9b;  assign sbox[8'he9] = 8'h1e;  assign sbox[8'hea] = 8'h87;  assign sbox[8'heb] = 8'he9;  assign sbox[8'hec] = 8'hce;  assign sbox[8'hed] = 8'h55;  assign sbox[8'hee] = 8'h28;  assign sbox[8'hef] = 8'hdf;  assign sbox[8'hf0] = 8'h8c;  assign sbox[8'hf1] = 8'ha1;  assign sbox[8'hf2] = 8'h89;  assign sbox[8'hf3] = 8'h0d;  assign sbox[8'hf4] = 8'hbf;  assign sbox[8'hf5] = 8'he6;  assign sbox[8'hf6] = 8'h42;  assign sbox[8'hf7] = 8'h68;  assign sbox[8'hf8] = 8'h41;  assign sbox[8'hf9] = 8'h99;  assign sbox[8'hfa] = 8'h2d;  assign sbox[8'hfb] = 8'h0f;  assign sbox[8'hfc] = 8'hb0;  assign sbox[8'hfd] = 8'h54;  assign sbox[8'hfe] = 8'hbb;  assign sbox[8'hff] = 8'h16;  endmodule"}
{"task_id": 934, "completion": "wire [`IR_SIZE-1:0] ir;\n  wire [15:0] off;\n  wire [15:0] imm;\n  wire wr_ip0;\n  wire [15:0] cs;\n  wire [15:0] ip;\n  wire of;\n  wire zf;\n  wire ifl;\n  wire iflm;\n  wire tfl;\n  wire tflm;\n  wire iflss;\n  wire wr_ss;\n  wire cx_zero;\n  wire div_exc;\n  wire [19:0] addr_exec;\n  wire byte_fetch;\n  wire byte_exec;\n  wire [`MICRO_ADDR_WIDTH-1:0] seq_addr;\n  wire [3:0] src;\n  wire [3:0] dst;\n  wire [3:0] base;\n  wire [3:0] index;\n  wire [1:0] seg;\n  wire end_seq;\n  wire [2:0] fdec;\n  wire div;\n  wire [7:0] opcode;\n  wire [7:0] modrm;\n  wire rep;\n  wire exec_st;\n  wire ld_base;\n  wire [2:0] sop_l;\n  wire need_modrm;\n  wire need_off;\n  wire need_imm;\n  wire off_size;\n  wire imm_size;\n  wire ext_int;\n  wire [15:0] off_l;\n  wire [15:0] imm_l;\n  wire [15:0] imm_d;\n  wire [`IR_SIZE-1:0] rom_ir;\n  wire [5:0] ftype;\n  wire [15:0] imm_f;\n  wire block_or_hlt;\n  wire hlt_op;\n  wire hlt_in;\n  wire hlt_out;\n  reg hlt_op_old;\n  reg hlt;\n  reg nmir;\n  reg nmi_old;\n  reg nmia_old;\n  wire use_eintp;\n  zet_fetch fetch (...);\n  zet_decode decode (...);\n  zet_micro_data micro_data (...);\n  zet_exec exec (...);\n  assign cpu_adr_o  = exec_st ? addr_exec : pc;\n  assign cpu_byte_o = exec_st ? byte_exec : byte_fetch;\n  assign cpu_mem_op = ir[`MEM_OP];\n  assign ir = exec_st ? rom_ir : `ADD_IP;\n  assign imm = exec_st ? imm_d : imm_f;\n  assign ftype = rom_ir[28:23];\n  assign hlt_op = ((opcode == `OP_HLT) && exec_st); \n  assign hlt_in = (hlt_op && !hlt_op_old && !hlt_out);\n  assign hlt_out = (intr & ifl) | nmir;\n  assign block_or_hlt = cpu_block | hlt | hlt_in;\n  always @(posedge clk)\n    if (rst)\n      hlt_op_old <= 1'b0;\n    else\n      if (hlt_op)\n        hlt_op_old <= 1'b1;\n      else\n        hlt_op_old <= 1'b0;\n  always @(posedge clk)\n    if (rst)\n      hlt <= 1'b0;\n    else\n      if (hlt_in)\n        hlt <= 1'b1;\n      else if (hlt_out)\n        hlt <= 1'b0;\n  always @(posedge clk)\n    if (rst)\n    begin\n      nmir <= 1'b0;\n      nmi_old <= 1'b0;\n      nmia_old <= 1'b0;\n    end\n    else\n    begin\n      nmi_old <= nmi;\n      nmia_old <= nmia; \n      if (nmi & ~nmi_old)\n        nmir <= 1'b1;\n      else if (nmia_old)\n        nmir <= 1'b0;\n    end\nendmodule"}
{"task_id": 814, "completion": "wire clk_125mhz_ibufg;\n\n    wire clk_125mhz_mmcm_out;\n    wire clk_125mhz_int;\n    wire rst_125mhz_int;\n\n    wire mmcm_rst = reset;\n    wire mmcm_locked;\n    wire mmcm_clkfb;\n\n    IBUFGDS #(\n       .DIFF_TERM(\"FALSE\"),\n       .IBUF_LOW_PWR(\"FALSE\")   \n    )\n    clk_125mhz_ibufg_inst (\n       .O   (clk_125mhz_ibufg),\n       .I   (clk_125mhz_p),\n       .IB  (clk_125mhz_n) \n    );\n\n    MMCME3_BASE #(\n        .BANDWIDTH(\"OPTIMIZED\"),\n        .CLKOUT0_DIVIDE_F(5),\n        .CLKOUT0_DUTY_CYCLE(0.5),\n        .CLKOUT0_PHASE(0),\n        .CLKOUT1_DIVIDE(1),\n        .CLKOUT1_DUTY_CYCLE(0.5),\n        .CLKOUT1_PHASE(0),\n        .CLKOUT2_DIVIDE(1),\n        .CLKOUT2_DUTY_CYCLE(0.5),\n        .CLKOUT2_PHASE(0),\n        .CLKOUT3_DIVIDE(1),\n        .CLKOUT3_DUTY_CYCLE(0.5),\n        .CLKOUT3_PHASE(0),\n        .CLKOUT4_DIVIDE(1),\n        .CLKOUT4_DUTY_CYCLE(0.5),\n        .CLKOUT4_PHASE(0),\n        .CLKOUT5_DIVIDE(1),\n        .CLKOUT5_DUTY_CYCLE(0.5),\n        .CLKOUT5_PHASE(0),\n        .CLKOUT6_DIVIDE(1),\n        .CLKOUT6_DUTY_CYCLE(0.5),\n        .CLKOUT6_PHASE(0),\n        .CLKFBOUT_MULT_F(5),\n        .CLKFBOUT_PHASE(0),\n        .DIVCLK_DIVIDE(1),\n        .REF_JITTER1(0.010),\n        .CLKIN1_PERIOD(8.0),\n        .STARTUP_WAIT(\"FALSE\"),\n        .CLKOUT4_CASCADE(\"FALSE\")\n    )\n    clk_mmcm_inst (\n        .CLKIN1(clk_125mhz_ibufg),\n        .CLKFBIN(mmcm_clkfb),\n        .RST(mmcm_rst),\n        .PWRDWN(1'b0),\n        .CLKOUT0(clk_125mhz_mmcm_out),\n        .CLKFBOUT(mmcm_clkfb),\n        .LOCKED(mmcm_locked)\n    );\n\n    BUFG\n    clk_125mhz_bufg_inst (\n        .I(clk_125mhz_mmcm_out),\n        .O(clk_125mhz_int)\n    );\n\n    sync_reset #(\n        .N(4)\n    )\n    sync_reset_125mhz_inst (\n        .clk(clk_125mhz_int),\n        .rst(~mmcm_locked),\n        .out(rst_125mhz_int)\n    );\n\n    wire btnu_int;\n    wire btnl_int;\n    wire btnd_int;\n    wire btnr_int;\n    wire btnc_int;\n    wire [3:0] sw_int;\n\n    debounce_switch #(\n        .WIDTH(9),\n        .N(4),\n        .RATE(125000)\n    )\n    debounce_switch_inst (\n        .clk(clk_125mhz_int),\n        .rst(rst_125mhz_int),\n        .in({btnu,\n            btnl,\n            btnd,\n            btnr,\n            btnc,\n            sw}),\n        .out({btnu_int,\n            btnl_int,\n            btnd_int,\n            btnr_int,\n            btnc_int,\n            sw_int})\n    );\n\n    wire uart_rxd_int;\n    wire uart_cts_int;\n\n    sync_signal #(\n        .WIDTH(2),\n        .N(2)\n    )\n    sync_signal_inst (\n        .clk(clk_125mhz_int),\n        .in({uart_rxd, uart_cts}),\n        .out({uart_rxd_int, uart_cts_int})\n    );\n\n    wire phy_gmii_clk_int;\n    wire phy_gmii_rst_int;\n    wire phy_gmii_clk_en_int;\n    wire [7:0] phy_gmii_txd_int;\n    wire phy_gmii_tx_en_int;\n    wire phy_gmii_tx_er_int;\n    wire [7:0] phy_gmii_rxd_int;\n    wire phy_gmii_rx_dv_int;\n    wire phy_gmii_rx_er_int;\n\n    wire [15:0] pcspma_status_vector;\n\n    wire pcspma_status_link_status              = pcspma_status_vector[0];\n    wire pcspma_status_link_synchronization     = pcspma_status_vector[1];\n    wire pcspma_status_rudi_c                   = pcspma_status_vector[2];\n    wire pcspma_status_rudi_i                   = pcspma_status_vector[3];\n    wire pcspma_status_rudi_invalid             = pcspma_status_vector[4];\n    wire pcspma_status_rxdisperr                = pcspma_status_vector[5];\n    wire pcspma_status_rxnotintable             = pcspma_status_vector[6];\n    wire pcspma_status_phy_link_status          = pcspma_status_vector[7];\n    wire [1:0] pcspma_status_remote_fault_encdg = pcspma_status_vector[9:8];\n    wire [1:0] pcspma_status_speed              = pcspma_status_vector[11:10];\n    wire pcspma_status_duplex                   = pcspma_status_vector[12];\n    wire pcspma_status_remote_fault             = pcspma_status_vector[13];\n    wire [1:0] pcspma_status_pause              = pcspma_status_vector[15:14];\n\n    wire [4:0] pcspma_config_vector;\n\n    assign pcspma_config_vector[4] = 1'b1; // autonegotiation enable\n    assign pcspma_config_vector[3] = 1'b0; // isolate\n    assign pcspma_config_vector[2] = 1'b0; // power down\n    assign pcspma_config_vector[1] = 1'b0; // loopback enable\n    assign pcspma_config_vector[0] = 1'b0; // unidirectional enable\n\n    wire [15:0] pcspma_an_config_vector;\n\n    assign pcspma_an_config_vector[15]    = 1'b1;    // SGMII link status\n    assign pcspma_an_config_vector[14]    = 1'b1;    // SGMII Acknowledge\n    assign pcspma_an_config_vector[13:12] = 2'b01;   // full duplex\n    assign pcspma_an_config_vector[11:10] = 2'b10;   // SGMII speed\n    assign pcspma_an_config_vector[9]     = 1'b0;    // reserved\n    assign pcspma_an_config_vector[8:7]   = 2'b00;   // pause frames - SGMII reserved\n    assign pcspma_an_config_vector[6]     = 1'b0;    // reserved\n    assign pcspma_an_config_vector[5]     = 1'b0;    // full duplex - SGMII reserved\n    assign pcspma_an_config_vector[4:1]   = 4'b0000; // reserved\n    assign pcspma_an_config_vector[0]     = 1'b1;    // SGMII\n\n    gig_ethernet_pcs_pma_0 \n    eth_pcspma (\n        .txp                    (phy_sgmii_tx_p),\n        .txn                    (phy_sgmii_tx_n),\n        .rxp                    (phy_sgmii_rx_p),\n        .rxn                    (phy_sgmii_rx_n),\n        .refclk625_p            (phy_sgmii_clk_p),\n        .refclk625_n            (phy_sgmii_clk_n),\n        .reset                  (rst_125mhz_int),\n        .clk125_out             (phy_gmii_clk_int),\n        .rst_125_out            (phy_gmii_rst_int),\n        .sgmii_clk_en           (phy_gmii_clk_en_int),\n        .GMII txd               (phy_gmii_txd_int),\n        .gmii_tx_en             (phy_gmii_tx_en_int),\n        .gmii_tx_er             (phy_gmii_tx_er_int),\n        .gmii_rxd               (phy_gmii_rxd_int),\n        .gmii_rx_dv             (phy_gmii_rx_dv_int),\n        .gmii_rx_er             (phy_gmii_rx_er_int),\n        .configuration_vector   (pcspma_config_vector),\n        .an_adv_config_vector   (pcspma_an_config_vector),\n        .status_vector          (pcspma_status_vector)\n    );\n\n    wire [7:0] led_int;\n\n    assign led = sw[0] ? (sw[1] ? pcspma_status_vector[15:8] : pcspma_status_vector[7:0]) : led_int;\n\n    fpga_core\n    core_inst (\n        .clk(clk_125mhz_int),\n        .rst(rst_125mhz_int),\n        .btnu(btnu_int),\n        .btnl(btnl_int),\n        .btnd(btnd_int),\n        .btnr(btnr_int),\n        .btnc(btnc_int),\n        .sw(sw_int),\n        .led(led_int),\n        .phy_gmii_clk(phy_gmii_clk_int),\n        .phy_gmii_rst(phy_gmii_rst_int),\n        .phy_gmii_clk_en(phy_gmii_clk_en_int),\n        .phy_gmii_rxd(phy_gmii_rxd_int),\n        .phy_gmii_rx_dv(phy_gmii_rx_dv_int),\n        .phy_gmii_rx_er(phy_gmii_rx_er_int),\n        .phy_gmii_txd(phy_gmii_txd_int),\n        .phy_gmii_tx_en(phy_gmii_tx_en_int),\n        .phy_gmii_tx_er(phy_gmii_tx_er_int),\n        .phy_reset_n(phy_reset_n),\n        .phy_int_n(phy_int_n),\n        .uart_rxd(uart_rxd_int),\n        .uart_txd(uart_txd),\n        .uart_rts(uart_rts),\n        .uart_cts(uart_cts_int)\n    );\n\nendmodule"}
{"task_id": 629, "completion": "reg                         read_rst;\nreg                         read_rst_r;\n\nreg                         write_rst;\nreg                         write_rst_r;\n\nalways @ (posedge read_clk or posedge rst)\n  if (rst) read_rst <=  1;\n  else if (!read_rst_r) read_rst <=  0;\n\nalways @ (posedge read_clk or posedge rst)\n  if (rst) read_rst_r <=  1;\n  else read_rst <=  0;\n\nalways @ (posedge write_clk or posedge rst)\n  if (rst) write_rst  <=  1;\n  else if (!write_rst_r) write_rst <=  0;\n\nalways @ (posedge write_clk or posedge rst)\n  if (rst) write_rst_r  <=  1;\n  else write_rst_r <=  0;\n\nreg                         read_clear;\nreg                         read_clear_r;\n\nreg                         write_clear;\nreg                         write_clear_r;\n\nalways @ (posedge read_clk or posedge clear)\n  if (clear) read_clear <=  1;\n  else if (!read_clear_r) read_clear <= 0;\n\nalways @ (posedge read_clk or posedge clear)\n  if (clear) read_clear_r <=  1;\n  else read_clear_r <=  0;\n\nalways @ (posedge write_clk or posedge clear)\n  if (clear) write_clear <=  1;\n  else if (!write_clear_r) write_clear  <=  0;\n\nalways @ (posedge write_clk or posedge clear)\n  if (clear) write_clear_r  <=  1;\n  else write_clear_r  <=  0;\n\nreg [ADDRESS_WIDTH:0]       wp_bin;\nreg [ADDRESS_WIDTH:0]       wp_gray;\n\nreg [ADDRESS_WIDTH:0]       rp_bin;\nreg [ADDRESS_WIDTH:0]       rp_gray;\n\nreg     [DATA_WIDTH - 1: 0]       mem [(1 << ADDRESS_WIDTH) - 1: 0];\n\nalways @ (posedge write_clk) begin\n  if (write) begin\n    mem[addra]   <=  data_in;\n  end\nend\n\nalways @ (posedge read_clk) begin\n  doutb          <=  mem[rp_bin[ADDRESS_WIDTH - 1: 0]];\nend\n\nreg                         full;\nreg                         empty;\nreg                         ready;\n\nwire  [ADDRESS_WIDTH:0]     wp_bin_next;\nwire  [ADDRESS_WIDTH:0]     wp_gray_next;\n\nwire  [ADDRESS_WIDTH:0]     rp_bin_next;\nwire  [ADDRESS_WIDTH:0]     rp_gray_next;\n\nalways @ (posedge write_clk) begin\n  if      (write_rst)   wp_bin  <=  {ADDRESS_WIDTH + 1{1'b0}};\n  else if (write_clear) wp_bin  <=  {ADDRESS_WIDTH + 1{1'b0}};\n  else if (write)       wp_bin  <=  wp_bin_next;\nend\nalways @ (posedge write_clk) begin\n  if      (write_rst)   wp_gray <=  {ADDRESS_WIDTH + 1{1'b0}};\n  else if (write_clear) wp_gray <=  {ADDRESS_WIDTH + 1{1'b0}};\n  else if (write)       wp_gray <=  wp_gray_next;\nend\n\nassign  wp_bin_next     = wp_bin +  {{ADDRESS_WIDTH{1'b0}}, 1'b1};\nassign  wp_gray_next    = wp_bin_next ^ {1'b0, wp_bin_next[ADDRESS_WIDTH: 1]};\n\nalways @ (posedge read_clk) begin\n  ready <=  0;\n  if      (read_rst)    rp_bin  <=  {ADDRESS_WIDTH + 1{1'b0}};\n  else if (read_clear)  rp_bin  <=  {ADDRESS_WIDTH + 1{1'b0}};\n  else if (read && !empty) begin\n    rp_bin  <=  rp_bin_next;\n    ready <=  1;\n  end\nend\nalways @ (posedge read_clk) begin\n  if      (read_rst)    rp_gray <=  {ADDRESS_WIDTH + 1{1'b0}};\n  else if (read_clear)  rp_gray <=  {ADDRESS_WIDTH + 1{1'b0}};\n  else if (read && !empty) rp_gray <=  rp_gray_next;\nend\n\nassign  rp_bin_next     = rp_bin  + {{ADDRESS_WIDTH{1'b0}}, 1'b1};\nassign  rp_gray_next    = rp_bin_next ^ {1'b0, rp_bin_next[ADDRESS_WIDTH: 1]};\n\nreg                         wp_sync;\nreg                         rp_sync;\n\nalways @ (posedge write_clk)   wp_sync <=  wp_gray;\nalways  @ (posedge read_clk) rp_sync <=  rp_gray;\n\nwire  [ADDRESS_WIDTH:0]     wp_bin_x;\nwire  [ADDRESS_WIDTH:0]     rp_bin_x;\n\nassign  wp_bin_x  = wp_sync ^ {1'b0, wp_bin_x[ADDRESS_WIDTH:1]};\nassign  rp_bin_x  = rp_sync ^ {1'b0, rp_bin_x[ADDRESS_WIDTH:1]};\n\nalways @ (posedge read_clk) begin\n  if (wp_gray == rp_gray || (read & (wp_gray == rp_gray_next))) begin\n    empty <=  1;\n  end\n  else if ((empty == 1) && (wp_sync != rp_gray))begin\n    empty <=  0;\n  end\nend\n\nalways @ (posedge write_clk) begin\n  full  <=  ((wp_bin[ADDRESS_WIDTH - 1:0]  == rp_bin_x[ADDRESS_WIDTH - 1:0]) &\n             (wp_bin[ADDRESS_WIDTH - 1: 0] != rp_bin_x[ADDRESS_WIDTH])) |\n            (write & (wp_bin_next[ADDRESS_WIDTH - 1:0] == rp_bin_x[ADDRESS_WIDTH - 1:0]) &\n             (wp_bin_next[ADDRESS_WIDTH] != rp_bin_x[ADDRESS_WIDTH]));\nend\n\nalways @ (posedge write_clk) begin\n  if (write && full) begin\n    $display (\"%m WARNING: Writing while FIFO is full (%t)\", $time);\n  end\nend\n\nalways @ (posedge read_clk) begin\n  if (read && (wp_gray == rp_gray)) begin\n    $display (\"%m WARNING: Reading while FIFO is empty (%t)\", $time);\n  end\nend\n\nendmodule"}
{"task_id": 950, "completion": "wire                    rst_n;\n   assign rst_n = ~reset;\n   reg                     read_delete;\n   wire                    read_full;\n   wire [WDTH-1:0]         read_data;\n   wire                    write_error;\n   wire                    read_error;\n\n   buffer_BB #(WDTH, `BUFFER_LENGTH, `LOG_BUFFER_LENGTH)\n   the_buffer \n     (.clk(clk),\n      .rst_n(rst_n),\n      .write_strobe(in_nd),\n      .write_data(in_data),\n      .read_delete(read_delete),\n      .read_full(read_full),\n      .read_data(read_data),\n      .write_error(write_error),\n      .read_error(read_error)\n      );\n\n   always @ (posedge clk)\n     begin\n        if (!rst_n)\n          begin\n             read_delete <= 1'b0;\n             out_data <= {WDTH{1'b0}};\n             out_nd <= 1'b0;\n          end\n        else\n          if (write_error)\n            begin\n               out_nd <= 1'b1;\n               out_data <= `WRITEERRORCODE;\n               read_delete <= 1'b0;\n            end\n          else if (read_error)\n            begin\n               out_nd <= 1'b1;\n               out_data <= `READERRORCODE;\n               read_delete <= 1'b0;\n            end\n          else\n            begin\n               if (read_full)\n                 begin\n                    read_delete <= 1'b1;\n                    out_nd <= 1'b1;\n                    out_data <= read_data;\n                 end\n               else\n                 begin\n                    read_delete <= 1'b0;\n                    out_nd <= 1'b0;\n                 end\n            end\n     end\n   \nendmodule"}
{"task_id": 940, "completion": "bd_clk_wiz_0_0_clk_wiz inst\n  (\n  .clk_ref_i(clk_ref_i),\n  .aclk(aclk),\n  .sys_clk_i(sys_clk_i),\n  .resetn(resetn), \n  .clk_in1(clk_in1)\n  );\n\nendmodule"}
{"task_id": 921, "completion": "output\tcluster_grst_l ;\noutput\tso ;\noutput\tdbginit_l ;\noutput\trclk ;\ninput\tsi ;\ninput\tse ;\ninput\tadbginit_l ;\ninput\tgdbginit_l ;\ninput\tarst_l ;\ninput\tgrst_l ;\ninput\tcluster_cken ;\ninput\tgclk ;\n\nwire [3:0]\tclk3 ;\nwire [1:0]\tclk4 ;\nwire\tclk5 ;\nwire\tcclk ;\n\n\nbw_clk_cclk_inv_64x xc3a (\n     .clkout          (clk3[0] ),\n     .clkin           (clk4[0] ) );\nbw_clk_cclk_inv_128x xgriddrv_3_ (\n     .clkout          (rclk ),\n     .clkin           (clk3[0] ) );\nbw_clk_cclk_inv_64x xc3b (\n     .clkout          (clk3[1] ),\n     .clkin           (clk4[0] ) );\nbw_clk_cclk_inv_64x xc3c (\n     .clkout          (clk3[2] ),\n     .clkin           (clk4[1] ) );\nbw_clk_cclk_inv_64x xc3d (\n     .clkout          (clk3[3] ),\n     .clkin           (clk4[1] ) );\nbw_clk_cclk_inv_128x xgriddrv_11_ (\n     .clkout          (rclk ),\n     .clkin           (clk3[2] ) );\nbw_clk_cclk_inv_64x xc4a (\n     .clkout          (clk4[0] ),\n     .clkin           (clk5 ) );\nbw_clk_cclk_inv_128x xgriddrv_2_ (\n     .clkout          (rclk ),\n     .clkin           (clk3[0] ) );\nbw_clk_cclk_inv_64x xc4b (\n     .clkout          (clk4[1] ),\n     .clkin           (clk5 ) );\nbw_clk_cclk_hdr_48x xCCHdr (\n     .rst_l           (cluster_grst_l ),\n     .dbginit_l       (dbginit_l ),\n     .clk             (cclk ),\n     .so              (so ),\n     .gclk            (gclk ),\n     .cluster_cken    (cluster_cken ),\n     .arst_l          (arst_l ),\n     .grst_l          (grst_l ),\n     .adbginit_l      (adbginit_l ),\n     .gdbginit_l      (gdbginit_l ),\n     .si              (si ),\n     .se              (se ),\n     .rclk            (rclk ) );\nbw_clk_cclk_inv_128x xgriddrv_9_ (\n     .clkout          (rclk ),\n     .clkin           (clk3[2] ) );\nbw_clk_cclk_inv_128x xgriddrv_1_ (\n     .clkout          (rclk ),\n     .clkin           (clk3[0] ) );\nbw_clk_cclk_inv_128x xgriddrv_8_ (\n     .clkout          (rclk ),\n     .clkin           (clk3[2] ) );\nbw_clk_cclk_inv_128x xgriddrv_0_ (\n     .clkout          (rclk ),\n     .clkin           (clk3[0] ) );\nbw_clk_cclk_inv_128x xgriddrv_10_ (\n     .clkout          (rclk ),\n     .clkin           (clk3[2] ) );\nbw_clk_cclk_inv_48x xc5 (\n     .clkout          (clk5 ),\n     .clkin           (cclk ) );\nbw_clk_cclk_inv_128x xgriddrv_7_ (\n     .clkout          (rclk ),\n     .clkin           (clk3[1] ) );\nterminator I22 (\n     .TERM            (clk3[3] ) );\nbw_clk_cclk_inv_128x xgriddrv_6_ (\n     .clkout          (rclk ),\n     .clkin           (clk3[1] ) );\nbw_clk_cclk_inv_128x xgriddrv_5_ (\n     .clkout          (rclk ),\n     .clkin           (clk3[1] ) );\nbw_clk_cclk_inv_128x xgriddrv_4_ (\n     .clkout          (rclk ),\n     .clkin           (clk3[1] ) );\nendmodule"}
{"task_id": 865, "completion": "logic [`BSG_SAFE_CLOG2(num_channels_p)*num_channels_p-1:0] fwd_sel , fwd_dpath_sel ,fwd_sel_r, fwd_dpath_sel_r;   logic [`BSG_SAFE_CLOG2(num_channels_p)*num_channels_p-1:0] bk_sel ,  bk_dpath_sel ,bk_sel_r,  bk_dpath_sel_r;   genvar i,j;   bsg_scatter_gather #(.vec_size_lp(num_channels_p)) bsg (.vec_i(channel_active_i) ,.fwd_o (fwd_sel) ,.fwd_datapath_o(fwd_dpath_sel) ,.bk_o (bk_sel) ,.bk_datapath_o (bk_dpath_sel));   always @(posedge clk_i) begin fwd_sel_r <= fwd_sel; fwd_dpath_sel_r <= fwd_dpath_sel; bk_sel_r <= bk_sel; bk_dpath_sel_r <= bk_dpath_sel; end   wire [num_channels_p-1:0 ] in_v_o_int;   wire [channel_width_p-1:0] in_data_o_int [num_channels_p-1:0];   wire [num_channels_p-1:0 ] in_yumi_i_int;   wire [num_channels_p-1:0 ] out_me_v_i_int;   wire [channel_width_p-1:0] out_me_data_i_int [num_channels_p-1:0];   wire [num_channels_p-1:0 ] out_me_ready_o_int;   for (i = 0; i < num_channels_p; i = i + 1) begin : sbox if (one_hot_p) begin : fi1hot logic [num_channels_p-1:0][num_channels_p-1:0] fwd_sel_one_hot_r; always @(posedge clk_i) fwd_sel_one_hot_r[i] <= (1 << fwd_sel[i*`BSG_SAFE_CLOG2(num_channels_p)+:`BSG_SAFE_CLOG2(num_channels_p)]); assign in_v_o_int[i] = |(in_v_i & fwd_sel_one_hot_r[i]); end else assign in_v_o_int[i] = in_v_i [fwd_sel_r[i*`BSG_SAFE_CLOG2(num_channels_p)+:`BSG_SAFE_CLOG2(num_channels_p)]]; assign in_yumi_o[i] = in_yumi_i_int[bk_sel_r[i*`BSG_SAFE_CLOG2(num_channels_p)+:`BSG_SAFE_CLOG2(num_channels_p)]]; wire [channel_width_p-1:0] forward [num_channels_p-i-1:0]; for (j = 0; j < num_channels_p - i; j++) begin assign forward[j] = in_data_i[i+j]; end assign in_data_o_int[i] = forward[fwd_dpath_sel_r[(i*`BSG_SAFE_CLOG2(num_channels_p))+:`BSG_SAFE_CLOG2(num_channels_p)]]; assign out_me_v_o[i] = out_me_v_i_int [bk_sel_r[(i*`BSG_SAFE_CLOG2(num_channels_p))+:`BSG_SAFE_CLOG2(num_channels_p)]]; assign out_me_ready_o_int[i] = out_me_ready_i[fwd_sel_r[(i*`BSG_SAFE_CLOG2(num_channels_p))+:`BSG_SAFE_CLOG2(num_channels_p)]]; wire [channel_width_p-1:0] backward [i+1-1:0]; for (j = 0; j <= i; j++) begin : rofj assign backward[j] = out_me_data_i_int[j]; end assign out_me_data_o[i] = backward[bk_dpath_sel_r[(i*`BSG_SAFE_CLOG2(num_channels_p))+:`BSG_SAFE_CLOG2(num_channels_p)]]; if (pipeline_indir_p) begin :pipe_in wire ready_int; assign in_yumi_i_int[i] = ready_int & in_v_o_int[i]; bsg_two_fifo #(.width_p(channel_width_p)) infifo (.clk_i(clk_i) ,.reset_i(reset_i) ,.ready_o(ready_int) ,.data_i(in_data_o_int[i]) ,.v_i (in_v_o_int [i] & calibration_done_i) ,.v_o (in_v_o [i]) ,.data_o(in_data_o [i]) ,.yumi_i(in_yumi_i [i]) ); end else begin : pipe_in assign in_v_o [i] = in_v_o_int [i]; assign in_data_o [i] = in_data_o_int[i]; assign in_yumi_i_int[i] = in_yumi_i [i]; end if (pipeline_outdir_p) begin : pipe_out bsg_two_fifo #(.width_p(channel_width_p)) outfifo (.clk_i(clk_i) ,.reset_i(reset_i) ,.ready_o(out_me_ready_o [i]) ,.data_i(out_me_data_i [i]) ,.v_i (out_me_v_i [i] & calibration_done_i) ,.v_o (out_me_v_i_int [i]) ,.data_o(out_me_data_i_int [i]) ,.yumi_i(out_me_ready_o_int [i] & out_me_v_i_int[i]) ); end else begin : pipe_out assign out_me_v_i_int [i] = out_me_v_i [i]; assign out_me_data_i_int [i] = out_me_data_i [i]; assign out_me_ready_o [i] = out_me_ready_o_int [i]; end end endmodule"}
{"task_id": 954, "completion": "parameter HFRONT = 48;\n    parameter HSYNCP = 112;\n    parameter HBACK = 248;\n    parameter HLINE = 1688;\n\n    parameter VFRONT = 1;\n    parameter VSYNCP = 3;\n    parameter VBACK = 38;\n    parameter VFRAME = 1066;\n\n    assign vsync = (line_count >= VFRONT & line_count < (VFRONT + VSYNCP));\n    assign fb_enable = pixel_count >= (HFRONT + HSYNCP + HBACK) & line_count >= (VFRONT + VSYNCP + VBACK);\n\n    always @(posedge clk) begin\n      pixel_count <= next_pixel_count;\n      line_count <= next_line_count;\n      fb_reset <= next_fb_reset;\n      hsync <= (pixel_count >= HFRONT & pixel_count < (HFRONT + HSYNCP)); \n    end \n\n    reg [11:0] next_pixel_count, next_line_count;\n    reg next_fb_reset;\n    reg next_hsync;\n\n    always @(*) begin\n      next_pixel_count = (pixel_count == (HLINE - 1)) ? 0 : pixel_count + 1;\n      next_line_count = (pixel_count == (HLINE - 1)) ? ((line_count == (VFRAME - 1)) ? 0 : line_count + 1) : line_count;\n      next_fb_reset = (pixel_count == 0) & (line_count == 0);\n    end\n\nendmodule"}
{"task_id": 953, "completion": "reg    [DATA_SZ-1:0] r;    wire   [DATA_SZ-1:0] wire_0;    wire   [DATA_SZ-1:0] wire_1;    wire   [DATA_SZ-1:0] wire_2;    wire   [DATA_SZ-1:0] wire_3;    assign wire_0 = r;    assign wire_1 = EN_write_0 ? write_0 : wire_0;    assign wire_2 = EN_write_1 ? write_1 : wire_1;    assign wire_3 = EN_write_2 ? write_2 : wire_2;    assign read_0 = wire_0;    assign read_1 = wire_1;    assign read_2 = wire_2;    always @(posedge CLK) begin        r <= wire_3;    endendmodule"}
{"task_id": 942, "completion": "supply1 VCCD   ;\n    supply1 VCCHIB ;\n    supply1 VDDA   ;\n    supply1 VDDIO  ;\n    supply1 VDDIO_Q;\n    supply0 VSSD   ;\n    supply0 VSSIO  ;\n    supply0 VSSIO_Q;\n    supply1 VSWITCH;\n    supply0 VSSA   ;\n\nendmodule"}
{"task_id": 965, "completion": "wire or0_out   ;\n    wire or1_out   ;\n    wire and0_out_X;\n\n    or  or0  (or0_out   , B2, B1              );\n    or  or1  (or1_out   , A2, A1              );\n    and and0 (and0_out_X, or0_out, or1_out, C1);\n    buf buf0 (X         , and0_out_X          );\n\nendmodule"}
{"task_id": 956, "completion": "output Y   ;\n    input  A1  ;\n    input  A2  ;\n    input  A3  ;\n    input  B1  ;\n    input  VPWR;\n    input  VGND;\n    input  VPB ;\n    input  VNB ;\n\n    wire and0_out         ;\n    wire nor0_out_Y       ;\n    wire pwrgood_pp0_out_Y;\n\n    and                                and0        (and0_out         , A3, A1, A2            );\n    nor                                nor0        (nor0_out_Y       , B1, and0_out          );\n    sky130_fd_sc_lp__udp_pwrgood_pp$PG pwrgood_pp0 (pwrgood_pp0_out_Y, nor0_out_Y, VPWR, VGND);\n    buf                                buf0        (Y                , pwrgood_pp0_out_Y     );\n\nendmodule"}
{"task_id": 944, "completion": "endmodule"}
{"task_id": 966, "completion": "output X;\n    input  A;\n    input  B;\n    input  C;\n\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    wire or0_out  ;\n    wire and0_out ;\n    wire and1_out ;\n    wire or1_out_X;\n\n    or  or0  (or0_out  , B, A              );\n    and and0 (and0_out , or0_out, C        );\n    and and1 (and1_out , A, B              );\n    or  or1  (or1_out_X, and1_out, and0_out);\n    buf buf0 (X        , or1_out_X         );\n\nendmodule"}
{"task_id": 936, "completion": "parameter INIT_0 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\n\tparameter INIT_1 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\n\tparameter INIT_2 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\n\tparameter INIT_3 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\n\tparameter INIT_4 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\n\tparameter INIT_5 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\n\tparameter INIT_6 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\n\tparameter INIT_7 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\n\tparameter INIT_8 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\n\tparameter INIT_9 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\n\tparameter INIT_A = 256'h0000000000000000000000000000000000000000000000000000000000000000;\n\tparameter INIT_B = 256'h0000000000000000000000000000000000000000000000000000000000000000;\n\tparameter INIT_C = 256'h0000000000000000000000000000000000000000000000000000000000000000;\n\tparameter INIT_D = 256'h0000000000000000000000000000000000000000000000000000000000000000;\n\tparameter INIT_E = 256'h0000000000000000000000000000000000000000000000000000000000000000;\n\tparameter INIT_F = 256'h0000000000000000000000000000000000000000000000000000000000000000;\n\n\twire [15:0] rd;\n\n\tSB_RAM40_4K #(\n\t  .WRITE_MODE(3),\n\t  .READ_MODE(3),\n\t  .INIT_0(INIT_0),\n\t  .INIT_1(INIT_1),\n\t  .INIT_2(INIT_2),\n\t  .INIT_3(INIT_3),\n\t  .INIT_4(INIT_4),\n\t  .INIT_5(INIT_5),\n\t  .INIT_6(INIT_6),\n\t  .INIT_7(INIT_7),\n\t  .INIT_8(INIT_8),\n\t  .INIT_9(INIT_9),\n\t  .INIT_A(INIT_A),\n\t  .INIT_B(INIT_B),\n\t  .INIT_C(INIT_C),\n\t  .INIT_D(INIT_D),\n\t  .INIT_E(INIT_E),\n\t  .INIT_F(INIT_F)\n\t) _ram (\n\t  .RDATA(rd),\n\t  .RADDR(RADDR),\n\t  .RCLK(RCLK), .RCLKE(RCLKE), .RE(RE),\n\t  .WCLK(WCLK), .WCLKE(WCLKE), .WE(WE),\n\t  .WADDR(WADDR),\n\t  .MASK(16'h0000), .WDATA({4'b0, WDATA[1], 7'b0, WDATA[0], 3'b0}));\n\n\tassign RDATA[0] = rd[3];\n\tassign RDATA[1] = rd[11];\n\nendmodule"}
{"task_id": 971, "completion": "input clk;\n  input [4:0]  writerege,writerege2;\n  input [31:0] aluoute,writedatae,aluoute2,writedatae2;\n  input memwritee,memwritee2,regwritee,regwritee2,memtorege,memtorege2,stallm,stallm2;\n  output reg regwritem,memtoregm,memwritem,regwritem2,memtoregm2,memwritem2;\n  output reg [4:0] writeregm, writeregm2;\n  output reg [31:0] aluoutm,writedatam,aluoutm2,writedatam2;\n  \n  always @ (posedge clk) begin\n    if (!stallm) begin\n      regwritem<=regwritee;\n      memtoregm<=memtorege;\n      memwritem<=memwritee;\n      aluoutm<=aluoute;\n      writedatam<=writedatae;\n      writeregm<=writerege;\n      regwritem2<=regwritee2;\n      memtoregm2<=memtorege2;\n      memwritem2<=memwritee2;\n      aluoutm2<=aluoute2;\n      writedatam2<=writedatae2;\n      writeregm2<=writerege2;\n    end\n  end\nendmodule"}
{"task_id": 957, "completion": "output Q;\n    input  D;\n    input  GATE_N;\n    input  VPWR;\n    input  VGND;\n    input  VPB;\n    input  VNB;\n\n    wire GATE;\n    wire buf_Q;\n    wire GATE_N_delayed;\n    wire D_delayed;\n    reg  notifier;\n\n    sky130_fd_sc_lp__udp_dlatch$P_pp$PG$N dlatch0 (buf_Q, D_delayed, GATE, notifier, VPWR, VGND);\n    not not0 (GATE, GATE_N_delayed);\n    buf buf0 (Q, buf_Q);\n\nendmodule"}
{"task_id": 632, "completion": "reg             dds_format_n_m1 = 'd0;  reg             dds_format_n = 'd0;  reg     [ 1:0]  dds_sel_m1 = 'd0;  reg     [ 1:0]  dds_sel = 'd0;  reg             dds_master_frame_d = 'd0;  reg             dds_enable_m1 = 'd0;  reg             dds_enable_m2 = 'd0;  reg             dds_enable_m3 = 'd0;  reg             dds_enable_m4 = 'd0;  reg     [15:0]  ddsp_data_1a = 'd0;  reg     [15:0]  ddsp_data_1b = 'd0;  reg     [15:0]  ddsp_data_2a = 'd0;  reg     [15:0]  ddsp_data_2b = 'd0;  reg             dds_enable = 'd0;  reg             ddsp_sel = 'd0;  reg     [ 2:0]  ddsp_frame_0 = 'd0;  reg     [15:0]  ddsp_data_00 = 'd0;  reg     [15:0]  ddsp_data_01 = 'd0;  reg     [15:0]  ddsp_data_02 = 'd0;  reg     [ 2:0]  ddsp_frame_1 = 'd0;  reg     [15:0]  ddsp_data_10 = 'd0;  reg     [15:0]  ddsp_data_11 = 'd0;  reg     [15:0]  ddsp_data_12 = 'd0;  reg     [ 2:0]  dds_frame_0 = 'd0;  reg     [15:0]  dds_data_00 = 'd0;  reg     [15:0]  dds_data_01 = 'd0;  reg     [15:0]  dds_data_02 = 'd0;  reg     [ 2:0]  dds_frame_1 = 'd0;  reg     [15:0]  dds_data_10 = 'd0;  reg     [15:0]  dds_data_11 = 'd0;  reg     [15:0]  dds_data_12 = 'd0;  wire            dds_master_frame_s;  wire    [15:0]  ddsx_data_00_s;  wire    [15:0]  ddsx_data_01_s;  wire    [15:0]  ddsx_data_02_s;  wire    [15:0]  ddsx_data_10_s;  wire    [15:0]  ddsx_data_11_s;  wire    [15:0]  ddsx_data_12_s;  wire    [15:0]  ddsv_data_00_s;  wire    [15:0]  ddsv_data_01_s;  wire    [15:0]  ddsv_data_02_s;  wire    [15:0]  ddsv_data_10_s;  wire    [15:0]  ddsv_data_11_s;  wire    [15:0]  ddsv_data_12_s;  assign dds_master_frame_s = dds_master_frame & ~dds_master_frame_d;  always @(posedge dac_div3_clk) begin    dds_format_n_m1 <= ~up_dds_format;    dds_format_n <= dds_format_n_m1;    dds_sel_m1 <= {up_dds_psel, up_dds_sel};    dds_sel <= dds_sel_m1;    dds_master_frame_d <= dds_master_frame;    dds_enable_m1 <= dds_master_enable;    dds_enable_m2 <= dds_enable_m1;    dds_enable_m3 <= dds_enable_m2;    dds_enable_m4 <= dds_enable_m3;    if ((dds_enable_m2 == 1'b1) && (dds_enable_m3 == 1'b0)) begin      ddsp_data_1a <= up_dds_data_1a;      ddsp_data_1b <= up_dds_data_1b;      ddsp_data_2a <= up_dds_data_2a;      ddsp_data_2b <= up_dds_data_2b;    end  end  always @(posedge dac_div3_clk) begin    dds_enable <= dds_enable_m4;    ddsp_sel <= ~ddsp_sel;    if (dds_enable == 1'b0) begin      ddsp_frame_0 <= 3'd0;      ddsp_data_00 <= 16'd0;      ddsp_data_01 <= 16'd0;      ddsp_data_02 <= 16'd0;      ddsp_frame_1 <= 3'd0;      ddsp_data_10 <= 16'd0;      ddsp_data_11 <= 16'd0;      ddsp_data_12 <= 16'd0;    end else if (ddsp_sel == 1'b0) begin      ddsp_frame_0 <= 3'b101;      ddsp_data_00 <= ddsp_data_1a;      ddsp_data_01 <= ddsp_data_1b;      ddsp_data_02 <= ddsp_data_1a;      ddsp_frame_1 <= 3'b101;      ddsp_data_10 <= ddsp_data_2a;      ddsp_data_11 <= ddsp_data_2b;      ddsp_data_12 <= ddsp_data_2a;    end else begin      ddsp_frame_0 <= 3'b010;      ddsp_data_00 <= ddsp_data_1b;      ddsp_data_01 <= ddsp_data_1a;      ddsp_data_02 <= ddsp_data_1b;      ddsp_frame_1 <= 3'b010;      ddsp_data_10 <= ddsp_data_2b;      ddsp_data_11 <= ddsp_data_2a;      ddsp_data_12 <= ddsp_data_2b;    end  end  always @(posedge dac_div3_clk) begin    case (dds_sel)      2'b10: begin        dds_frame_0 <= ddsp_frame_0;        dds_data_00 <= ddsp_data_00;        dds_data_01 <= ddsp_data_01;        dds_data_02 <= ddsp_data_02;        dds_frame_1 <= ddsp_frame_1;        dds_data_10 <= ddsp_data_10;        dds_data_11 <= ddsp_data_11;        dds_data_12 <= ddsp_data_12;      end      2'b01: begin        dds_frame_0 <= {2'd0, dds_master_frame_s};        dds_data_00 <= ddsv_data_00_s;        dds_data_01 <= ddsv_data_01_s;        dds_data_02 <= ddsv_data_02_s;        dds_frame_1 <= {2'd0, dds_master_frame_s};        dds_data_10 <= ddsv_data_10_s;        dds_data_11 <= ddsv_data_11_s;        dds_data_12 <= ddsv_data_12_s;      end      default: begin        dds_frame_0 <= {2'd0, dds_master_frame_s};        dds_data_00 <= ddsx_data_00_s;        dds_data_01 <= ddsx_data_01_s;        dds_data_02 <= ddsx_data_02_s;        dds_frame_1 <= {2'd0, dds_master_frame_s};        dds_data_10 <= ddsx_data_10_s;        dds_data_11 <= ddsx_data_11_s;        dds_data_12 <= ddsx_data_12_s;      end    endcase  end  cf_ddsx i_ddsx (    .dac_div3_clk (dac_div3_clk),    .dds_master_enable (dds_master_enable),    .dds_data_00 (ddsx_data_00_s),    .dds_data_01 (ddsx_data_01_s),    .dds_data_02 (ddsx_data_02_s),    .dds_data_10 (ddsx_data_10_s),    .dds_data_11 (ddsx_data_11_s),    .dds_data_12 (ddsx_data_12_s),    .dds_format_n (dds_format_n),    .up_dds_init_1a (up_dds_init_1a),    .up_dds_incr_1a (up_dds_incr_1a),    .up_dds_scale_1a (up_dds_scale_1a),    .up_dds_init_1b (up_dds_init_1b),    .up_dds_incr_1b (up_dds_incr_1b),    .up_dds_scale_1b (up_dds_scale_1b),    .up_dds_init_2a (up_dds_init_2a),    .up_dds_incr_2a (up_dds_incr_2a),    .up_dds_scale_2a (up_dds_scale_2a),    .up_dds_init_2b (up_dds_init_2b),    .up_dds_incr_2b (up_dds_incr_2b),    .up_dds_scale_2b (up_dds_scale_2b),    .debug_data (),    .debug_trigger ());  cf_ddsv i_ddsv (    .vdma_clk (vdma_clk),    .vdma_fs (vdma_fs),    .vdma_valid (vdma_valid),    .vdma_data (vdma_data),    .vdma_ready (vdma_ready),    .vdma_ovf (vdma_ovf),    .vdma_unf (vdma_unf),    .dac_div3_clk (dac_div3_clk),    .dds_master_enable (dds_master_enable),    .dds_data_00 (ddsv_data_00_s),    .dds_data_01 (ddsv_data_01_s),    .dds_data_02 (ddsv_data_02_s),    .dds_data_10 (ddsv_data_10_s),    .dds_data_11 (ddsv_data_11_s),    .dds_data_12 (ddsv_data_12_s),    .dds_format_n (dds_format_n),    .up_intp_enable (up_intp_enable),    .up_intp_scale_a (up_intp_scale_a),    .up_intp_scale_b (up_intp_scale_b),    .up_vdma_fscnt (up_vdma_fscnt),    .vdma_dbg_data (vdma_dbg_data),    .vdma_dbg_trigger (vdma_dbg_trigger),    .dac_dbg_data (dac_dbg_data),    .dac_dbg_trigger (dac_dbg_trigger));endmodule"}
{"task_id": 968, "completion": "supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    wire RESET;\n    wire SET;\n    wire CLK;\n    wire buf_Q;\n    reg notifier;\n    wire D_delayed;\n    wire SCD_delayed;\n    wire SCE_delayed;\n    wire CLK_N_delayed;\n    wire SET_B_delayed;\n    wire RESET_B_delayed;\n    wire mux_out;\n    wire awake;\n    wire cond0;\n    wire cond1;\n    wire condb;\n    wire cond_D;\n    wire cond_SCD;\n    wire cond_SCE;\n\n    not not0 (RESET, RESET_B_delayed);\n    not not1 (SET, SET_B_delayed);\n    not not2 (CLK, CLK_N_delayed);\n    sky130_fd_sc_ls__udp_mux_2to1 mux_2to10 (mux_out, D_delayed, SCD_delayed, SCE_delayed);\n    sky130_fd_sc_ls__udp_dff$NSR_pp$PG$N dff0 (buf_Q, SET, RESET, CLK, mux_out, notifier, VPWR, VGND);\n    assign awake = (VPWR === 1'b1);\n    assign cond0 = (awake && (RESET_B_delayed === 1'b1));\n    assign cond1 = (awake && (SET_B_delayed === 1'b1));\n    assign condb = (cond0 & cond1);\n    assign cond_D = ((SCE_delayed === 1'b0) && condb);\n    assign cond_SCD = ((SCE_delayed === 1'b1) && condb);\n    assign cond_SCE = ((D_delayed !== SCD_delayed) && condb);\n    buf buf0 (Q, buf_Q);\n    not not3 (Q_N, buf_Q);\n\nendmodule"}
{"task_id": 981, "completion": "input slowest_sync_clk;\n  input ext_reset_in;\n  input aux_reset_in;\n  input mb_debug_sys_rst;\n  input dcm_locked;\n  output mb_reset;\n  output [0:0]bus_struct_reset;\n  output [0:0]peripheral_reset;\n  output [0:0]interconnect_aresetn;\n  output [0:0]peripheral_aresetn;\nendmodule"}
{"task_id": 970, "completion": "`ifndef ALTERA_RESERVED_QIS\n // synopsys translate_off\n `endif\n tri1 clock;\n `ifndef ALTERA_RESERVED_QIS\n // synopsys translate_on\n `endif\n endmodule"}
{"task_id": 983, "completion": "wire [7:0] disp0,disp1;\n\twire displayClock;\n\treg [7:0] storedValue;\n\twire [7:0] dispValue, sum, diff;\n\n\tassign led[4:0]=sw[4:0];\n\tassign sum=storedValue+sw;\n\tassign diff=storedValue-sw;\n\tassign dispValue=BTN3?diff:\n\t\t BTN1?sum:\n\t\t BTN2?storedValue:\n\t\t sw;\n\n    always @(negedge BTN_N) begin\n\t\tstoredValue<=sw;\n    end\n\n\tnibble_to_seven_seg nibble0(\n\t\t.nibblein(dispValue[3:0]),\n\t\t.segout(disp0)\n\t);\n\t \n\tnibble_to_seven_seg nibble1(\n\t\t.nibblein(dispValue[7:4]),\n\t\t.segout(disp1)\n\t); \n\t \n\tclkdiv displayClockGen(\n\t\t.clk(CLK),\n\t\t.clkout(displayClock)\n\t);\n\n\tseven_seg_mux display(\n\t\t.clk(displayClock),\n\t\t.disp0(disp0),\n\t\t.disp1(disp1),\n\t\t.segout(seg),\n\t\t.disp_sel(ca)\n\t);\n\nendmodule"}
{"task_id": 946, "completion": "wire [14:0] carry;\n   wire [15:0] g, p;\n   wire [4:0] gout, pout;\n\n   rfa rfa0(sum[0], g[0], p[0], a[0], b[0], 1'b0);\n   rfa rfa1(sum[1], g[1], p[1], a[1], b[1], carry[0]);\n   rfa rfa2(sum[2], g[2], p[2], a[2], b[2], carry[1]);\n   rfa rfa3(sum[3], g[3], p[3], a[3], b[3], carry[2]);\n   bclg4 bclg30(carry[2:0], gout[0], pout[0], g[3:0], p[3:0], 1'b0);\n   \n   rfa rfa4(sum[4], g[4], p[4], a[4], b[4], carry[3]);\n   rfa rfa5(sum[5], g[5], p[5], a[5], b[5], carry[4]);\n   rfa rfa6(sum[6], g[6], p[6], a[6], b[6], carry[5]);\n   rfa rfa7(sum[7], g[7], p[7], a[7], b[7], carry[6]);\n   bclg4 bclg74(carry[6:4], gout[1], pout[1], g[7:4], p[7:4], carry[3]);\n   \n   rfa rfa8(sum[8], g[8], p[8], a[8], b[8], carry[7]);\n   rfa rfa9(sum[9], g[9], p[9], a[9], b[9], carry[8]);\n   rfa rfa10(sum[10], g[10], p[10], a[10], b[10], carry[9]);\n   rfa rfa11(sum[11], g[11], p[11], a[11], b[11], carry[10]);\n   bclg4 bclg118(carry[10:8], gout[2], pout[2], g[11:8], p[11:8], carry[7]);\n   \n   rfa rfa12(sum[12], g[12], p[12], a[12], b[12], carry[11]);\n   rfa rfa13(sum[13], g[13], p[13], a[13], b[13], carry[12]);\n   rfa rfa14(sum[14], g[14], p[14], a[14], b[14], carry[13]);\n   rfa rfa15(sum[15], g[15], p[15], a[15], b[15], carry[14]);\n   bclg4 bclg1512(carry[14:12], gout[3], pout[3], g[15:12], p[15:12], carry[11]);\n\n   bclg4 bclg_150({carry[11], carry[7], carry[3]}, gout[4], pout[4], {gout[3], gout[2], gout[1], gout[0]}, {pout[3], pout[2], pout[1], pout[0]}, 1'b0);\n\n   assign sum[16] = gout[4]; \n\nendmodule"}
{"task_id": 986, "completion": "output Y ;\n    input  A1;\n    input  A2;\n    input  A3;\n    input  B1;\n\n    wire and0_out  ;\n    wire nor0_out_Y;\n\n    and and0 (and0_out  , A3, A1, A2     );\n    nor nor0 (nor0_out_Y, B1, and0_out   );\n    buf buf0 (Y         , nor0_out_Y     );\n\nendmodule"}
{"task_id": 991, "completion": "instio instio (\n          .lower_out(lower_out),\n          .sec_out(sec_out),\n          .lower_io(lower_io),\n          .sec_io(sec_io),\n          .lower_ina(lower_ina),\n          .sec_ina(sec_ina));\nendmodule"}
{"task_id": 987, "completion": "output Y;\n    input  A_N;\n    input  B_N;\n    input  C;\n    input  D;\n    input  VPWR;\n    input  VGND;\n    sky130_fd_sc_hs__nand4bb base (\n        .Y(Y),\n        .A_N(A_N),\n        .B_N(B_N),\n        .C(C),\n        .D(D),\n        .VPWR(VPWR),\n        .VGND(VGND)\n    );\n\nendmodule"}
{"task_id": 992, "completion": "wire [8:0] sum; \n    assign sum = A_in + B_in + C_in; \n    assign Result_out = (Opcode_in == 3'b000) ? sum[7:0] : \n                        (Opcode_in == 3'b001) ? A_in - B_in : \n                        (Opcode_in == 3'b010) ? (A_in & B_in) : \n                        (Opcode_in == 3'b011) ? (A_in | B_in) : \n                        (Opcode_in == 3'b100) ? (A_in % B_in) : 8'b0; \n    assign C_out = sum[8]; \nendmodule"}
{"task_id": 856, "completion": "`include \"definition/Definition.v\"\n    parameter    MDIR        = BLANKFILE;\n    output    reg            [WORD-1:0]                                A_dout;\n    input            [WORD-1:0]                                A_din;\n    input            [WORD-1:0]                                A_address;\n    input            [LOGWORDBYTE-1:0]                        A_size;\n    input                                                        A_read_write;\n    input                                                        A_enable;\n    output    reg            [WORD-1:0]                                B_dout;\n    input            [WORD-1:0]                                B_din;\n    input            [WORD-1:0]                                B_address;\n    input            [LOGWORDBYTE-1:0]                        B_size;\n    input                                                        B_read_write;\n    input                                                        B_enable;\n    input                                                        clk;\n    input                                                        reset;\n            wire        [WORD-1:0]                                A_stripe_dout            [WORDBYTE-1:0];\n            reg            [WORD-1:0]                                A_stripe_din            [WORDBYTE-1:0];\n            reg            [WORD-1:0]                                A_stripe_address        [WORDBYTE-1:0];\n            reg            [LOGWORDBYTE-1:0]                        A_stripe_size            [WORDBYTE-1:0];\n            reg                                                    A_stripe_read_write        [WORDBYTE-1:0];\n            reg                                                    A_stripe_enable            [WORDBYTE-1:0];\n            wire        [WORD-1:0]                                B_stripe_dout            [WORDBYTE-1:0];\n            reg            [WORD-1:0]                                B_stripe_din            [WORDBYTE-1:0];\n            reg            [WORD-1:0]                                B_stripe_address        [WORDBYTE-1:0];\n            reg            [LOGWORDBYTE-1:0]                        B_stripe_size            [WORDBYTE-1:0];\n            reg                                                    B_stripe_read_write        [WORDBYTE-1:0];\n            reg                                                    B_stripe_enable            [WORDBYTE-1:0];\n            reg            [LOGWORDBYTE-1:0]                        A_end_left;\n            reg            [LOGWORDBYTE-1:0]                        A_end_right;\n            reg            [LOGWORDBYTE-1:0]                        A_off_addr                [WORDBYTE-1:0];\n            reg            [WORD-1:0]                                A_div_addr                [WORDBYTE-1:0];\n            reg            [LOGWORDBYTE-1:0]                        A_iselect                [WORDBYTE-1:0];\n            reg            [LOGWORDBYTE-1:0]                        A_oselect                [WORDBYTE-1:0];\n            reg            [BYTE-1:0]                                A_breakout_din            [WORDBYTE-1:0];\n            reg            [LOGWORDBYTE-1:0]                        A_d_size;\n            reg            [LOGWORDBYTE-1:0]                        A_d_oselect                [WORDBYTE-1:0];\n            reg            [LOGWORDBYTE-1:0]                        B_end_left;\n            reg            [LOGWORDBYTE-1:0]                        B_end_right;\n            reg            [LOGWORDBYTE-1:0]                        B_off_addr                [WORDBYTE-1:0];\n            reg            [WORD-1:0]                                B_div_addr                [WORDBYTE-1:0];\n            reg            [LOGWORDBYTE-1:0]                        B_iselect                [WORDBYTE-1:0];\n            reg            [LOGWORDBYTE-1:0]                        B_oselect                [WORDBYTE-1:0];\n            reg            [BYTE-1:0]                                B_breakout_din            [WORDBYTE-1:0];\n            reg            [LOGWORDBYTE-1:0]                        B_d_size;\n            reg            [LOGWORDBYTE-1:0]                        B_d_oselect                [WORDBYTE-1:0];\n    always @(posedge clk) begin\n        if(reset)    begin A_d_size    <= 0;        end\n        else        begin A_d_size    <= A_size;    end\n        if(reset)    begin B_d_size    <= 0;        end\n        else        begin B_d_size    <= B_size;    end\n    end\n    always @(*) begin\n        A_end_left    <= ((A_address+0     ) % WORDBYTE);\n        A_end_right    <= ((A_address+A_size) % WORDBYTE);\n        B_end_left    <= ((B_address+0     ) % WORDBYTE);\n        B_end_right    <= ((B_address+B_size) % WORDBYTE);\n    end\n    genvar i;\n    generate\n        for(i=0; i<WORDBYTE; i=i+1) begin : GENMEM\n            if(MDIR != BLANKFILE) begin\n                DualMemory #(\n                    .MWIDTH            (BYTE                    ),    \n                    .LOGWORDBYTE    (LOGWORDBYTE            ),    \n                    .LOGMEM            (LOGMEM-LOGWORDBYTE        )    \n                )\n                mem (\n                    .A_dout            (A_stripe_dout[i]        ),\n                    .A_din            (A_stripe_din[i]        ),\n                    .A_address        (A_stripe_address[i]),\n                    .A_size            (A_stripe_size[i]        ),\n                    .A_read_write    (A_stripe_read_write[i]    ),\n                    .A_enable        (A_stripe_enable[i]        ),\n                    .B_dout            (B_stripe_dout[i]        ),\n                    .B_din            (B_stripe_din[i]        ),\n                    .B_address        (B_stripe_address[i]    ),\n                    .B_size            (B_stripe_size[i]        ),\n                    .B_read_write    (B_stripe_read_write[i]    ),\n                    .B_enable        (B_stripe_enable[i]        ),\n                    .reset            (reset                    ),\n                    .clk            (clk                    )\n                );\n            end\n            else begin\n                DualMemory #(\n                    .MFILE            (BLANKFILE                ),    \n                    .MWIDTH            (BYTE                    ),    \n                    .LOGWORDBYTE    (LOGWORDBYTE            ),\n                    .LOGMEM            (LOGMEM-LOGWORDBYTE        )    \n                )\n                mem (\n                    .A_dout            (A_stripe_dout[i]        ),\n                    .A_din            (A_stripe_din[i]        ),\n                    .A_address        (A_stripe_address[i]),\n                    .A_size            (A_stripe_size[i]        ),\n                    .A_read_write    (A_stripe_read_write[i]    ),\n                    .A_enable        (A_stripe_enable[i]        ),\n                    .B_dout            (B_stripe_dout[i]        ),\n                    .B_din            (B_stripe_din[i]        ),\n                    .B_address        (B_stripe_address[i]    ),\n                    .B_size            (B_stripe_size[i]        ),\n                    .B_read_write    (B_stripe_read_write[i]    ),\n                    .B_enable        (B_stripe_enable[i]        ),\n                    .reset            (reset                    ),\n                    .clk            (clk                    )\n                );\n            end\n            always @(*) begin\n                A_stripe_address[i]        <= A_div_addr[i];\n                A_stripe_read_write[i] <= A_read_write;\n                A_stripe_enable[i]        <= A_enable && (\n                                                (A_end_left <= A_end_right) ?\n                                                    ((A_end_left<=i) && (i<=A_end_right)) :\n                                                    ((A_end_left<=i) || (i<=A_end_right)) \n                                            );\n                A_stripe_size[i]        <= 0;\n                A_off_addr[i]            <= A_end_left <= i ? i-A_end_left : (WORDBYTE-A_end_left)+i;\n                A_div_addr[i]            <= (A_address+A_off_addr[i]) / WORDBYTE;\n                A_stripe_din[i]            <= A_breakout_din[A_iselect[i]];\n                A_iselect[i]            <= (i + WORDBYTE - A_end_left) % WORDBYTE;\n                A_oselect[i]            <= (i + WORDBYTE + A_end_left) % WORDBYTE;\n                A_breakout_din[i]        <= A_din[ (BYTE*(i+1))-1 : (BYTE*(i+0)) ];\n                A_dout[ (BYTE*(i+1))-1 : (BYTE*(i+0))-0 ]    <= (i<=A_d_size) ? A_stripe_dout[A_d_oselect[i]] : 0;\n                B_stripe_address[i]        <= B_div_addr[i];\n                B_stripe_read_write[i] <= B_read_write;\n                B_stripe_enable[i]        <= B_enable && (\n                                                (B_end_left <= B_end_right) ?\n                                                    ((B_end_left<=i) && (i<=B_end_right)) :\n                                                    ((B_end_left<=i) || (i<=B_end_right)) \n                                            );\n                B_stripe_size[i]        <= 0;\n                B_off_addr[i]            <= B_end_left <= i ? i-B_end_left : (WORDBYTE-B_end_left)+i;\n                B_div_addr[i]            <= (B_address+B_off_addr[i]) / WORDBYTE;\n                B_stripe_din[i]            <= B_breakout_din[B_iselect[i]];\n                B_iselect[i]            <= (i + WORDBYTE - B_end_left) % WORDBYTE;\n                B_oselect[i]            <= (i + WORDBYTE + B_end_left) % WORDBYTE;\n                B_breakout_din[i]        <= B_din[ (BYTE*(i+1))-1 : (BYTE*(i+0)) ];\n                B_dout[ (BYTE*(i+1))-1 : (BYTE*(i+0))-0 ]    <= (i<=B_d_size) ? B_stripe_dout[B_d_oselect[i]] : 0;\n            end\n            always @(posedge clk) begin\n                if(reset)    begin A_d_oselect[i]    <= 0;                end\n                else        begin A_d_oselect[i]    <= A_oselect[i];    end    \n                if(reset)    begin B_d_oselect[i]    <= 0;                end\n                else        begin B_d_oselect[i]    <= B_oselect[i];    end    \n            end\n        end\n    endgenerate\nendmodule"}
{"task_id": 990, "completion": "output Q  ;\n    input  CLK;\n    input  D  ;\n    input  DE ;\n\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    wire buf_Q      ;\n    reg  notifier   ;\n    wire D_delayed  ;\n    wire DE_delayed ;\n    wire CLK_delayed;\n    wire mux_out    ;\n    wire awake      ;\n    wire cond0      ;\n\n    sky130_fd_sc_ms__udp_mux_2to1      mux_2to10 (mux_out, buf_Q, D_delayed, DE_delayed              );\n    sky130_fd_sc_ms__udp_dff$P_pp$PG$N dff0      (buf_Q  , mux_out, CLK_delayed, notifier, VPWR, VGND);\n    assign awake = ( VPWR === 1'b1 );\n    assign cond0 = ( awake && ( DE_delayed === 1'b1 ) );\n    buf                                buf0      (Q      , buf_Q                                     );\n\nendmodule"}
{"task_id": 665, "completion": "wire Bsr_out;\n    wire MB_out;\n    wire Pr_out;\n    wire SEQ_n_3;\n    wire SEQ_n_4;\n    wire aux_reset_in;\n    wire [0:0]bus_struct_reset;\n    wire dcm_locked;\n    wire ext_reset_in;\n    wire [0:0]interconnect_aresetn;\n    wire lpf_int;\n    wire mb_debug_sys_rst;\n    wire mb_reset;\n    wire [0:0]peripheral_aresetn;\n    wire [0:0]peripheral_reset;\n    wire slowest_sync_clk;\n\n    (* box_type = \"PRIMITIVE\" *) \n    FDRE #(\n        .INIT(1'b0),\n        .IS_C_INVERTED(1'b0),\n        .IS_D_INVERTED(1'b0),\n        .IS_R_INVERTED(1'b0)) \n        \\ACTIVE_LOW_BSR_OUT_DFF[0].FDRE_BSR_N \n           (.C(slowest_sync_clk),\n            .CE(1'b1),\n            .D(SEQ_n_3),\n            .Q(interconnect_aresetn),\n            .R(1'b0));\n    (* box_type = \"PRIMITIVE\" *) \n    FDRE #(\n        .INIT(1'b0),\n        .IS_C_INVERTED(1'b0),\n        .IS_D_INVERTED(1'b0),\n        .IS_R_INVERTED(1'b0)) \n        \\ACTIVE_LOW_PR_OUT_DFF[0].FDRE_PER_N \n           (.C(slowest_sync_clk),\n            .CE(1'b1),\n            .D(SEQ_n_4),\n            .Q(peripheral_aresetn),\n            .R(1'b0));\n    (* box_type = \"PRIMITIVE\" *) \n    FDRE #(\n        .INIT(1'b1),\n        .IS_C_INVERTED(1'b0),\n        .IS_D_INVERTED(1'b0),\n        .IS_R_INVERTED(1'b0)) \n        \\BSR_OUT_DFF[0].FDRE_BSR \n           (.C(slowest_sync_clk),\n            .CE(1'b1),\n            .D(Bsr_out),\n            .Q(bus_struct_reset),\n            .R(1'b0));\n    zybo_zynq_design_rst_ps7_0_100M_0_lpf EXT_LPF\n           (.aux_reset_in(aux_reset_in),\n            .dcm_locked(dcm_locked),\n            .ext_reset_in(ext_reset_in),\n            .lpf_int(lpf_int),\n            .mb_debug_sys_rst(mb_debug_sys_rst),\n            .slowest_sync_clk(slowest_sync_clk));\n    (* box_type = \"PRIMITIVE\" *) \n    FDRE #(\n        .INIT(1'b1),\n        .IS_C_INVERTED(1'b0),\n        .IS_D_INVERTED(1'b0),\n        .IS_R_INVERTED(1'b0)) \n        FDRE_inst\n           (.C(slowest_sync_clk),\n            .CE(1'b1),\n            .D(MB_out),\n            .Q(mb_reset),\n            .R(1'b0));\n    (* box_type = \"PRIMITIVE\" *) \n    FDRE #(\n        .INIT(1'b1),\n        .IS_C_INVERTED(1'b0),\n        .IS_D_INVERTED(1'b0),\n        .IS_R_INVERTED(1'b0)) \n        \\PR_OUT_DFF[0].FDRE_PER \n           (.C(slowest_sync_clk),\n            .CE(1'b1),\n            .D(Pr_out),\n            .Q(peripheral_reset),\n            .R(1'b0));\n    zybo_zynq_design_rst_ps7_0_100M_0_sequence_psr SEQ\n           (.\n            \\ACTIVE_LOW_BSR_OUT_DFF[0].FDRE_BSR_N (SEQ_n_3),\n            .\\ACTIVE_LOW_PR_OUT_DFF[0].FDRE_PER_N (SEQ_n_4),\n            .Bsr_out(Bsr_out),\n            .MB_out(MB_out),\n            .Pr_out(Pr_out),\n            .lpf_int(lpf_int),\n            .slowest_sync_clk(slowest_sync_clk));\nendmodule"}
{"task_id": 978, "completion": "input   SCTxPortRdyIn;\ninput   clk;\ninput   [7:0] directCntlCntl;\ninput   [7:0] directCntlData;\ninput   directCntlReq;\ninput   directCntlWEn;\ninput   rst;\ninput   [7:0] sendPacketCntl;\ninput   [7:0] sendPacketData;\ninput   sendPacketReq;\ninput   sendPacketWEn;\noutput  [7:0] SCTxPortCntl;\noutput  [7:0] SCTxPortData;\noutput  SCTxPortRdyOut;\noutput  SCTxPortWEnable;\noutput  directCntlGnt;\noutput  sendPacketGnt;\n\nreg     [7:0] SCTxPortCntl, next_SCTxPortCntl;\nreg     [7:0] SCTxPortData, next_SCTxPortData;\nwire    SCTxPortRdyIn;\nreg     SCTxPortRdyOut, next_SCTxPortRdyOut;\nreg     SCTxPortWEnable, next_SCTxPortWEnable;\nwire    clk;\nwire    [7:0] directCntlCntl;\nwire    [7:0] directCntlData;\nreg     directCntlGnt, next_directCntlGnt;\nwire    directCntlReq;\nwire    directCntlWEn;\nwire    rst;\nwire    [7:0] sendPacketCntl;\nwire    [7:0] sendPacketData;\nreg     sendPacketGnt, next_sendPacketGnt;\nwire    sendPacketReq;\nwire    sendPacketWEn;\n\nreg  muxDCEn, next_muxDCEn;\n\nreg [1:0] CurrState_SCTxArb;\nreg [1:0] NextState_SCTxArb;\n\nalways @(SCTxPortRdyIn)\nbegin\n    SCTxPortRdyOut <= SCTxPortRdyIn;\nend\nalways @(muxDCEn or\n                directCntlWEn or directCntlData or directCntlCntl or\n                directCntlWEn or directCntlData or directCntlCntl or\n                sendPacketWEn or sendPacketData or sendPacketCntl)\nbegin\nif (muxDCEn == 1'b1)\n    begin\n        SCTxPortWEnable <= directCntlWEn;\n        SCTxPortData <= directCntlData;\n        SCTxPortCntl <= directCntlCntl;\n    end\nelse\n    begin\n        SCTxPortWEnable <= sendPacketWEn;\n        SCTxPortData <= sendPacketData;\n        SCTxPortCntl <= sendPacketCntl;\n    end\nend\n\nalways @ (sendPacketReq or directCntlReq or sendPacketGnt or muxDCEn or directCntlGnt or CurrState_SCTxArb)\nbegin : SCTxArb_NextState\n  NextState_SCTxArb <= CurrState_SCTxArb;\n  next_sendPacketGnt <= sendPacketGnt;\n  next_muxDCEn <= muxDCEn;\n  next_directCntlGnt <= directCntlGnt;\n  case (CurrState_SCTxArb)\n    `SARB1_WAIT_REQ:\n      if (sendPacketReq == 1'b1)    \n      begin\n        NextState_SCTxArb <= `SARB_SEND_PACKET;\n        next_sendPacketGnt <= 1'b1;\n        next_muxDCEn <= 1'b0;\n      end\n      else if (directCntlReq == 1'b1)    \n      begin\n        NextState_SCTxArb <= `SARB_DC;\n        next_directCntlGnt <= 1'b1;\n        next_muxDCEn <= 1'b1;\n      end\n    `SARB_SEND_PACKET:\n      if (sendPacketReq == 1'b0)    \n      begin\n        NextState_SCTxArb <= `SARB1_WAIT_REQ;\n        next_sendPacketGnt <= 1'b0;\n      end\n    `SARB_DC:\n      if (directCntlReq == 1'b0)    \n      begin\n        NextState_SCTxArb <= `SARB1_WAIT_REQ;\n        next_directCntlGnt <= 1'b0;\n      end\n    `START_SARB:\n      NextState_SCTxArb <= `SARB1_WAIT_REQ;\n  endcase\nend\n\nalways @ (posedge clk)\nbegin : SCTxArb_CurrentState\n  if (rst)    \n    CurrState_SCTxArb <= `START_SARB;\n  else\n    CurrState_SCTxArb <= NextState_SCTxArb;\nend\n\nalways @ (posedge clk)\nbegin : SCTxArb_RegOutput\n  if (rst)    \n  begin\n    muxDCEn <= 1'b0;\n    sendPacketGnt <= 1'b0;\n    directCntlGnt <= 1'b0;\n  end\n  else \n  begin\n    muxDCEn <= next_muxDCEn;\n    sendPacketGnt <= next_sendPacketGnt;\n    directCntlGnt <= next_directCntlGnt;\n  end\nend\n\nendmodule"}
{"task_id": 902, "completion": "localparam [1:0]\n        STATE_IDLE = 2'd0,\n        STATE_ARP_QUERY = 2'd1,\n        STATE_WAIT_PACKET = 2'd2;\n\n    reg [1:0] state_reg = STATE_IDLE, state_next;\n\n    reg outgoing_ip_hdr_valid_reg = 1'b0, outgoing_ip_hdr_valid_next;\n    wire outgoing_ip_hdr_ready;\n    reg [47:0] outgoing_eth_dest_mac_reg = 48'h000000000000, outgoing_eth_dest_mac_next;\n    wire outgoing_ip_payload_axis_tready;\n\n    ip_eth_rx\n    ip_eth_rx_inst (\n        .clk(clk),\n        .rst(rst),\n        .s_eth_hdr_valid(s_eth_hdr_valid),\n        .s_eth_hdr_ready(s_eth_hdr_ready),\n        .s_eth_dest_mac(s_eth_dest_mac),\n        .s_eth_src_mac(s_eth_src_mac),\n        .s_eth_type(s_eth_type),\n        .s_eth_payload_axis_tdata(s_eth_payload_axis_tdata),\n        .s_eth_payload_axis_tvalid(s_eth_payload_axis_tvalid),\n        .s_eth_payload_axis_tready(s_eth_payload_axis_tready),\n        .s_eth_payload_axis_tlast(s_eth_payload_axis_tlast),\n        .s_eth_payload_axis_tuser(s_eth_payload_axis_tuser),\n        .m_ip_hdr_valid(m_ip_hdr_valid),\n        .m_ip_hdr_ready(m_ip_hdr_ready),\n        .m_eth_dest_mac(m_ip_eth_dest_mac),\n        .m_eth_src_mac(m_ip_eth_src_mac),\n        .m_eth_type(m_ip_eth_type),\n        .m_ip_version(m_ip_version),\n        .m_ip_ihl(m_ip_ihl),\n        .m_ip_dscp(m_ip_dscp),\n        .m_ip_ecn(m_ip_ecn),\n        .m_ip_length(m_ip_length),\n        .m_ip_identification(m_ip_identification),\n        .m_ip_flags(m_ip_flags),\n        .m_ip_fragment_offset(m_ip_fragment_offset),\n        .m_ip_ttl(m_ip_ttl),\n        .m_ip_protocol(m_ip_protocol),\n        .m_ip_header_checksum(m_ip_header_checksum),\n        .m_ip_source_ip(m_ip_source_ip),\n        .m_ip_dest_ip(m_ip_dest_ip),\n        .m_ip_payload_axis_tdata(m_ip_payload_axis_tdata),\n        .m_ip_payload_axis_tvalid(m_ip_payload_axis_tvalid),\n        .m_ip_payload_axis_tready(m_ip_payload_axis_tready),\n        .m_ip_payload_axis_tlast(m_ip_payload_axis_tlast),\n        .m_ip_payload_axis_tuser(m_ip_payload_axis_tuser),\n        .busy(rx_busy),\n        .error_header_early_termination(rx_error_header_early_termination),\n        .error_payload_early_termination(rx_error_payload_early_termination),\n        .error_invalid_header(rx_error_invalid_header),\n        .error_invalid_checksum(rx_error_invalid_checksum)\n    );\n\n    ip_eth_tx\n    ip_eth_tx_inst (\n        .clk(clk),\n        .rst(rst),\n        .s_ip_hdr_valid(outgoing_ip_hdr_valid_reg),\n        .s_ip_hdr_ready(outgoing_ip_hdr_ready),\n        .s_eth_dest_mac(outgoing_eth_dest_mac_reg),\n        .s_eth_src_mac(local_mac),\n        .s_eth_type(16'h0800),\n        .s_ip_dscp(s_ip_dscp),\n        .s_ip_ecn(s_ip_ecn),\n        .s_ip_length(s_ip_length),\n        .s_ip_identification(16'd0),\n        .s_ip_flags(3'b010),\n        .s_ip_fragment_offset(13'd0),\n        .s_ip_ttl(s_ip_ttl),\n        .s_ip_protocol(s_ip_protocol),\n        .s_ip_source_ip(s_ip_source_ip),\n        .s_ip_dest_ip(s_ip_dest_ip),\n        .s_ip_payload_axis_tdata(s_ip_payload_axis_tdata),\n        .s_ip_payload_axis_tvalid(s_ip_payload_axis_tvalid),\n        .s_ip_payload_axis_tready(outgoing_ip_payload_axis_tready),\n        .s_ip_payload_axis_tlast(s_ip_payload_axis_tlast),\n        .s_ip_payload_axis_tuser(s_ip_payload_axis_tuser),\n        .m_eth_hdr_valid(m_eth_hdr_valid),\n        .m_eth_hdr_ready(m_eth_hdr_ready),\n        .m_eth_dest_mac(m_eth_dest_mac),\n        .m_eth_src_mac(m_eth_src_mac),\n        .m_eth_type(m_eth_type),\n        .m_eth_payload_axis_tdata(m_eth_payload_axis_tdata),\n        .m_eth_payload_axis_tvalid(m_eth_payload_axis_tvalid),\n        .m_eth_payload_axis_tready(m_eth_payload_axis_tready),\n        .m_eth_payload_axis_tlast(m_eth_payload_axis_tlast),\n        .m_eth_payload_axis_tuser(m_eth_payload_axis_tuser),\n        .busy(tx_busy),\n        .error_payload_early_termination(tx_error_payload_early_termination)\n    );\n\n    reg s_ip_hdr_ready_reg = 1'b0, s_ip_hdr_ready_next;\n\n    reg arp_request_valid_reg = 1'b0, arp_request_valid_next;\n\n    reg arp_response_ready_reg = 1'b0, arp_response_ready_next;\n\n    reg drop_packet_reg = 1'b0, drop_packet_next;\n\n    assign s_ip_hdr_ready = s_ip_hdr_ready_reg;\n    assign s_ip_payload_axis_tready = outgoing_ip_payload_axis_tready || drop_packet_reg;\n\n    assign arp_request_valid = arp_request_valid_reg;\n    assign arp_request_ip = s_ip_dest_ip;\n    assign arp_response_ready = arp_response_ready_reg;\n\n    assign tx_error_arp_failed = arp_response_error;\n\n    always @* begin\n        state_next = STATE_IDLE;\n\n        arp_request_valid_next = arp_request_valid_reg && !arp_request_ready;\n        arp_response_ready_next = 1'b0;\n        drop_packet_next = 1'b0;\n\n        s_ip_hdr_ready_next = 1'b0;\n\n        outgoing_ip_hdr_valid_next = outgoing_ip_hdr_valid_reg && !outgoing_ip_hdr_ready;\n        outgoing_eth_dest_mac_next = outgoing_eth_dest_mac_reg;\n\n        case (state_reg)\n            STATE_IDLE: begin\n                if (s_ip_hdr_valid) begin\n                    arp_request_valid_next = 1'b1;\n                    arp_response_ready_next = 1'b1;\n                    state_next = STATE_ARP_QUERY;\n                end else begin\n                    state_next = STATE_IDLE;\n                end\n            end\n            STATE_ARP_QUERY: begin\n                arp_response_ready_next = 1'b1;\n\n                if (arp_response_valid) begin\n                    if (arp_response_error) begin\n                        s_ip_hdr_ready_next = 1'b1;\n                        drop_packet_next = 1'b1;\n                        state_next = STATE_WAIT_PACKET;\n                    end else begin\n                        s_ip_hdr_ready_next = 1'b1;\n                        outgoing_ip_hdr_valid_next = 1'b1;\n                        outgoing_eth_dest_mac_next = arp_response_mac;\n                        state_next = STATE_WAIT_PACKET;\n                    end\n                end else begin\n                    state_next = STATE_ARP_QUERY;\n                end\n            end\n            STATE_WAIT_PACKET: begin\n                drop_packet_next = drop_packet_reg;\n\n                if (s_ip_payload_axis_tlast && s_ip_payload_axis_tready && s_ip_payload_axis_tvalid) begin\n                    state_next = STATE_IDLE;\n                end else begin\n                    state_next = STATE_WAIT_PACKET;\n                end\n            end\n        endcase\n    end\n\n    always @(posedge clk) begin\n        if (rst) begin\n            state_reg <= STATE_IDLE;\n            arp_request_valid_reg <= 1'b0;\n            arp_response_ready_reg <= 1'b0;\n            drop_packet_reg <= 1'b0;\n            s_ip_hdr_ready_reg <= 1'b0;\n            outgoing_ip_hdr_valid_reg <= 1'b0;\n        end else begin\n            state_reg <= state_next;\n\n            arp_request_valid_reg <= arp_request_valid_next;\n            arp_response_ready_reg <= arp_response_ready_next;\n            drop_packet_reg <= drop_packet_next;\n\n            s_ip_hdr_ready_reg <= s_ip_hdr_ready_next;\n\n            outgoing_ip_hdr_valid_reg <= outgoing_ip_hdr_valid_next;\n        end\n\n        outgoing_eth_dest_mac_reg <= outgoing_eth_dest_mac_next;\n    end\nendmodule"}
{"task_id": 863, "completion": "(* ASYNC_REG = \"TRUE\" *)\n  reg gmii_col_reg;\n  reg gmii_col_reg_reg ;\n\n  wire gmii_rx_dv_delay;\n  wire gmii_rx_er_delay;\n  wire [7:0] gmii_rxd_delay;\n  wire gmii_rx_clk_bufio;\n\n  wire rx_clk_int;\n\n\n  ODDR gmii_tx_clk_ddr_iob (\n      .Q (gmii_tx_clk),\n      .C (tx_clk),\n      .CE (1'b1),\n      .D1 (1'b0),\n      .D2 (1'b1),\n      .R (1'b0),\n      .S (1'b0)\n   );\n\n   always @(posedge tx_clk)\n   begin\n      gmii_tx_en <= tx_en_from_mac;\n      gmii_tx_er <= tx_er_from_mac;\n      gmii_txd <= txd_from_mac;\n   end\n\n   assign crs_to_mac = gmii_crs;\n\n   always @(posedge tx_clk)\n   begin\n      if (tx_reset == 1'b1) begin\n         gmii_col_reg <= 1'b0;\n         gmii_col_reg_reg <= 1'b0;\n      end\n      else begin\n         gmii_col_reg <= gmii_col;\n         gmii_col_reg_reg <= gmii_col_reg;\n      end\n   end\n\n   assign col_to_mac = gmii_col_reg_reg | gmii_col_reg | gmii_col;\n\n   BUFIO bufio_gmii_rx_clk (\n      .I (gmii_rx_clk),\n      .O (gmii_rx_clk_bufio)\n   );\n\n   BUFR bufr_gmii_rx_clk (\n      .I (gmii_rx_clk),\n      .CE (1'b1),\n      .CLR (1'b0),\n      .O (rx_clk_int)\n   );\n   assign rx_clk = rx_clk_int;\n\n   IODELAYE1 #(\n      .IDELAY_TYPE (\"FIXED\"),\n      .DELAY_SRC (\"I\")\n   )\n   delay_gmii_rx_dv (\n      .IDATAIN (gmii_rx_dv),\n      .ODATAIN (1'b0),\n      .DATAOUT (gmii_rx_dv_delay),\n      .DATAIN (1'b0),\n      .C (1'b0),\n      .T (1'b1),\n      .CE (1'b0),\n      .CINVCTRL (1'b0),\n      .CLKIN (1'b0),\n      .CNTVALUEIN (5'h0),\n      .CNTVALUEOUT (),\n      .INC (1'b0),\n      .RST (1'b0)\n   );\n\n   IODELAYE1 #(\n      .IDELAY_TYPE (\"FIXED\"),\n      .DELAY_SRC (\"I\")\n   )\n   delay_gmii_rx_er (\n      .IDATAIN (gmii_rx_er),\n      .ODATAIN (1'b0),\n      .DATAOUT (gmii_rx_er_delay),\n      .DATAIN (1'b0),\n      .C (1'b0),\n      .T (1'b1),\n      .CE (1'b0),\n      .CINVCTRL (1'b0),\n      .CLKIN (1'b0),\n      .CNTVALUEIN (5'h0),\n      .CNTVALUEOUT (),\n      .INC (1'b0),\n      .RST (1'b0)\n   );\n\n   genvar i;\n   generate for (i=0; i<8; i=i+1)\n     begin : gmii_data_bus0\n      IODELAYE1 #(\n         .IDELAY_TYPE (\"FIXED\"),\n         .DELAY_SRC (\"I\")\n      )\n      delay_gmii_rxd (\n         .IDATAIN (gmii_rxd[i]),\n         .ODATAIN (1'b0),\n         .DATAOUT (gmii_rxd_delay[i]),\n         .DATAIN (1'b0),\n         .C (1'b0),\n         .T (1'b1),\n         .CE (1'b0),\n         .CINVCTRL (1'b0),\n         .CLKIN (1'b0),\n         .CNTVALUEIN (5'h0),\n         .CNTVALUEOUT (),\n         .INC (1'b0),\n         .RST (1'b0)\n      );\n     end\n   endgenerate\n\n   always @(posedge gmii_rx_clk_bufio)\n   begin\n      rx_dv_to_mac <= gmii_rx_dv_delay;\n      rx_er_to_mac <= gmii_rx_er_delay;\n      rxd_to_mac <= gmii_rxd_delay;\n   end\n\nendmodule"}
{"task_id": 1002, "completion": "supply1 VPWR;\n    supply0 VGND;\n\nendmodule"}
{"task_id": 1005, "completion": "output X ;    input  A1;    input  A2;    input  B1;    wire or0_out   ;    wire and0_out_X;    or  or0  (or0_out   , A2, A1         );    and and0 (and0_out_X, or0_out, B1    );    buf buf0 (X         , and0_out_X     );    endmodule"}
{"task_id": 943, "completion": "localparam RST_SYNC_NUM = 25;\n  localparam CLK_PERIOD_NS = C_INCLK_PERIOD / 1000.0;\n  localparam CLK_PERIOD_INT = C_INCLK_PERIOD/1000;\n\n  wire                       clk_2x_0;\n  wire                       clk_2x_180;\n  wire                       clk0_bufg;\n  wire                       clk0_bufg_in;\n  wire                       mcb_drp_clk_bufg_in;\n  wire                       clkfbout_clkfbin;\n  wire                       locked;\n  reg [RST_SYNC_NUM-1:0]     rst0_sync_r    /* synthesis syn_maxfan = 10 */;\n  wire                       rst_tmp;\n  reg                        powerup_pll_locked;\n\n  wire                       sys_rst;\n  wire                       bufpll_mcb_locked;\n  wire                       sys_clk_ibufg;\n\n  assign sys_rst = C_RST_ACT_LOW ? ~sys_rst_n: sys_rst_n;\n  assign clk0        = clk0_bufg;\n  assign pll_lock    = bufpll_mcb_locked;\n\n  generate\n    if (C_INPUT_CLK_TYPE == \"DIFFERENTIAL\") begin: diff_input_clk\n\n    end else if (C_INPUT_CLK_TYPE == \"SINGLE_ENDED\") begin: se_input_clk\n      assign sys_clk_ibufg = sys_clk;\n    end\n  endgenerate\n\n    PLL_ADV #(\n      .SIM_DEVICE  (\"SPARTAN6\"),\n      .BANDWIDTH          (\"OPTIMIZED\"),\n      .CLKIN1_PERIOD      (CLK_PERIOD_NS),\n      .CLKIN2_PERIOD      (CLK_PERIOD_NS),\n      .CLKOUT0_DIVIDE     (C_CLKOUT0_DIVIDE),\n      .CLKOUT1_DIVIDE     (C_CLKOUT1_DIVIDE),\n      .CLKOUT2_DIVIDE     (C_CLKOUT2_DIVIDE),\n      .CLKOUT3_DIVIDE     (C_CLKOUT3_DIVIDE),\n      .CLKOUT4_DIVIDE     (1),\n      .CLKOUT5_DIVIDE     (1),\n      .CLKOUT0_PHASE      (0.000),\n      .CLKOUT1_PHASE      (180.000),\n      .CLKOUT2_PHASE      (0.000),\n      .CLKOUT3_PHASE      (0.000),\n      .CLKOUT4_PHASE      (0.000),\n      .CLKOUT5_PHASE      (0.000),\n      .CLKOUT0_DUTY_CYCLE (0.500),\n      .CLKOUT1_DUTY_CYCLE (0.500),\n      .CLKOUT2_DUTY_CYCLE (0.500),\n      .CLKOUT3_DUTY_CYCLE (0.500),\n      .CLKOUT4_DUTY_CYCLE (0.500),\n      .CLKOUT5_DUTY_CYCLE (0.500),\n      .COMPENSATION       (\"INTERNAL\"),\n      .DIVCLK_DIVIDE      (C_DIVCLK_DIVIDE),\n      .CLKFBOUT_MULT      (C_CLKFBOUT_MULT),\n      .CLKFBOUT_PHASE     (0.0),\n      .REF_JITTER         (0.005000)\n    ) u_pll_adv (\n      .CLKFBIN     (clkfbout_clkfbin),\n      .CLKINSEL    (1'b1),\n      .CLKIN1      (sys_clk_ibufg),\n      .CLKIN2      (1'b0),\n      .DADDR       (5'b0),\n      .DCLK        (1'b0),\n      .DEN         (1'b0),\n      .DI          (16'b0),\n      .DWE         (1'b0),\n      .REL         (1'b0),\n      .RST         (sys_rst),\n      .CLKFBDCM    (),\n      .CLKFBOUT    (clkfbout_clkfbin),\n      .CLKOUTDCM0  (),\n      .CLKOUTDCM1  (),\n      .CLKOUTDCM2  (),\n      .CLKOUTDCM3  (),\n      .CLKOUTDCM4  (),\n      .CLKOUTDCM5  (),\n      .CLKOUT0     (clk_2x_0),\n      .CLKOUT1     (clk_2x_180),\n      .CLKOUT2     (clk0_bufg_in),\n      .CLKOUT3     (mcb_drp_clk_bufg_in),\n      .CLKOUT4     (),\n      .CLKOUT5     (),\n      .DO          (),\n      .DRDY        (),\n      .LOCKED      (locked)\n    );\n\n   BUFG U_BUFG_CLK0 (\n     .O (clk0_bufg),\n     .I (clk0_bufg_in)\n   );\n\n   BUFG U_BUFG_CLK1 (\n     .O (mcb_drp_clk),\n     .I (mcb_drp_clk_bufg_in)\n   );\n\n  always @(posedge clk0_bufg , posedge sys_rst)\n      if(sys_rst)\n         powerup_pll_locked <= 1'b0;\n      else if (bufpll_mcb_locked)\n         powerup_pll_locked <= 1'b1;\n\n  assign rst_tmp = sys_rst | ~powerup_pll_locked;\n  always @(posedge clk0_bufg or posedge rst_tmp)\n    if (rst_tmp)\n      rst0_sync_r <= {RST_SYNC_NUM{1'b1}};\n    else\n      rst0_sync_r <= rst0_sync_r << 1;\n\n  assign rst0    = rst0_sync_r[RST_SYNC_NUM-1];\n\n  BUFPLL_MCB BUFPLL_MCB1 (\n    .IOCLK0         (sysclk_2x),  \n    .IOCLK1         (sysclk_2x_180), \n    .LOCKED         (locked),\n    .GCLK           (mcb_drp_clk),\n    .SERDESSTROBE0  (pll_ce_0), \n    .SERDESSTROBE1  (pll_ce_90), \n    .PLLIN0         (clk_2x_0),  \n    .PLLIN1         (clk_2x_180),\n    .LOCK           (bufpll_mcb_locked) \n  );\n\nendmodule"}
{"task_id": 1008, "completion": "output Y   ;\n    input  A_N ;\n    input  B   ;\n    input  VPWR;\n    input  VGND;\n    input  VPB ;\n    input  VNB ;\n\n    wire not0_out         ;\n    wire or0_out_Y        ;\n    wire pwrgood_pp0_out_Y;\n\n    not                                not0        (not0_out         , B                    );\n    or                                 or0         (or0_out_Y        , not0_out, A_N        );\n    sky130_fd_sc_lp__udp_pwrgood_pp$PG pwrgood_pp0 (pwrgood_pp0_out_Y, or0_out_Y, VPWR, VGND);\n    buf                                buf0        (Y                , pwrgood_pp0_out_Y    );\n\nendmodule"}
{"task_id": 989, "completion": "localparam integer DIN_N = 6;\n    localparam integer DOUT_N = `N;\n\n    reg [DIN_N-1:0] din;\n    wire [DOUT_N-1:0] dout;\n\n    reg [DIN_N-1:0] din_shr;\n    reg [DOUT_N-1:0] dout_shr;\n\n    always @(posedge clk) begin\n        din_shr <= {din_shr, di};\n        dout_shr <= {dout_shr, din_shr[DIN_N-1]};\n        if (stb) begin\n            din <= din_shr;\n            dout_shr <= dout;\n        end\n    end\n\n    assign do = dout_shr[DOUT_N-1];\n\n    roi roi (\n        .clk(clk),\n        .din(din),\n        .dout(dout)\n    );\nendmodule\n\nmodule roi(input clk, input [5:0] din, output [`N-1:0] dout);\n    function [31:0] xorshift32(input [31:0] v);\n        begin\n            xorshift32 = v;\n            xorshift32 = xorshift32 ^ (xorshift32 << 13);\n            xorshift32 = xorshift32 ^ (xorshift32 >> 17);\n            xorshift32 = xorshift32 ^ (xorshift32 <<  5);\n        end\n    endfunction\n\n    function [31:0] hash32(input [31:0] v);\n        begin\n            hash32 = v ^ `SEED;\n            hash32 = xorshift32(hash32);\n            hash32 = xorshift32(hash32);\n            hash32 = xorshift32(hash32);\n            hash32 = xorshift32(hash32);\n        end\n    endfunction\n\n    function [63:0] hash64(input [31:0] v);\n        begin\n            hash64[63:32] = hash32(v);\n            hash64[31: 0] = hash32(~v);\n        end\n    endfunction\n\n    genvar i;\n    generate\n        for (i = 0; i < `N; i = i+1) begin:is\n            wire o6;\n            wire o2_5;\n            wire o2_6;\n            wire [3:0] hash = hash32(i);\n            wire opt_out = |hash;\n            assign dout[i] = o6 & o2_5 & o2_6 & opt_out;\n\n            LUT6 #(\n                .INIT(64'h8000_0000_0000_0001 + (i << 16))\n            ) lut6 (\n                .I0(din[0]),\n                .I1(din[1]),\n                .I2(din[2]),\n                .I3(din[3]),\n                .I4(din[4]),\n                .I5(din[5]),\n                .O(o6)\n            );\n            LUT6_2 #(\n                .INIT(64'h8000_0000_0000_0001 + (i << 8))\n            ) lut62 (\n                .I0(din[0]),\n                .I1(din[1]),\n                .I2(din[2]),\n                .I3(din[3]),\n                .I4(din[4]),\n                .I5(din[5]),\n                .O5(o2_5),\n                .O6(o2_6)\n            );\n        end\n    endgenerate\nendmodule"}
{"task_id": 1011, "completion": "// VGA \u4fe1\u53f7\u751f\u6210\u548c\u989c\u8272\u8f93\u51fa\u903b\u8f91\n    // TBD: \u5b9e\u73b0\u76f8\u5173\u903b\u8f91\nendmodule"}
{"task_id": 973, "completion": "localparam VERSION = 1;\n    wire SOFT_RST;\n    assign SOFT_RST = (BUS_ADD==0 && BUS_WR);\n    wire RST;\n    assign RST = BUS_RST | SOFT_RST;\n    reg CONF_EN;\n    reg CONF_TIMESTAMP_HEADER;\n    always @(posedge BUS_CLK) begin\n        if(RST) begin\n            CONF_EN <= 0;\n            CONF_TIMESTAMP_HEADER <= 0;\n        end\n        else if(BUS_WR) begin\n            if(BUS_ADD == 2) begin\n                CONF_EN <= BUS_DATA_IN[0];\n                CONF_TIMESTAMP_HEADER <= BUS_DATA_IN[1];\n            end\n        end\n    end\n    reg [7:0] LOST_DATA_CNT;\n    always @(posedge BUS_CLK) begin\n        if(BUS_RD) begin\n            if(BUS_ADD == 0)\n                BUS_DATA_OUT <= VERSION;\n            else if(BUS_ADD == 2)\n                BUS_DATA_OUT <= {6'b0, CONF_TIMESTAMP_HEADER, CONF_EN};\n            else if(BUS_ADD == 3)\n                BUS_DATA_OUT <= LOST_DATA_CNT;\n            else\n                BUS_DATA_OUT <= 8'b0;\n        end\n    end\n    wire RST_SYNC;\n    wire RST_SOFT_SYNC;\n    cdc_reset_sync rst_pulse_sync (.clk_in(BUS_CLK), .pulse_in(RST), .clk_out(CLK_RX), .pulse_out(RST_SOFT_SYNC));\n    assign RST_SYNC = RST_SOFT_SYNC;\n    wire CONF_EN_SYNC;\n    assign CONF_EN_SYNC  = CONF_EN;\n    wire MKD_RX_IO;\n    IDDR IDDR_inst_mkd (\n       .Q1(), \n       .Q2(MKD_RX_IO), \n       .C(CLK_RX),   \n       .CE(1'b1), \n       .D(MKD_RX), \n       .R(1'b0),\n       .S(1'b0) \n    );\n    wire [1:0] DATA_RX_IO;\n    IDDR IDDR_inst_rx0 (\n       .Q1(), \n       .Q2(DATA_RX_IO[0]), \n       .C(CLK_RX),   \n       .CE(1'b1), \n       .D(DATA_RX[0]), \n       .R(1'b0),\n       .S(1'b0) \n    );\n    IDDR IDDR_inst_rx1 (\n       .Q1(), \n       .Q2(DATA_RX_IO[1]), \n       .C(CLK_RX),   \n       .CE(1'b1), \n       .D(DATA_RX[1]), \n       .R(1'b0),\n       .S(1'b0) \n    );\n    reg [4:0] MKD_DLY;\n    always@(posedge CLK_RX)\n        MKD_DLY[4:0] <= {MKD_DLY[3:0], MKD_RX_IO};\n    reg [4:0] DATA1_DLY;\n    always@(posedge CLK_RX)\n        DATA1_DLY[4:0] <= {DATA1_DLY[3:0], DATA_RX_IO[1]};\n    reg [4:0] DATA0_DLY;\n    always@(posedge CLK_RX)\n        DATA0_DLY[4:0] <= {DATA0_DLY[3:0], DATA_RX_IO[0]};\n    wire [1:0] WRITE;\n    wire FRAME_START, FRAME_START1;\n    wire [15:0] DATA [1:0];\n    m26_rx_ch m26_rx_ch0(\n        .RST(RST_SYNC), .CLK_RX(CLK_RX), .MKD_RX(MKD_DLY[0]), .DATA_RX(DATA0_DLY[0]),\n        .WRITE(WRITE[0]), .FRAME_START(FRAME_START), .DATA(DATA[0])\n    ); \n    m26_rx_ch m26_rx_ch1(\n        .RST(RST_SYNC), .CLK_RX(CLK_RX), .MKD_RX(MKD_DLY[4]), .DATA_RX(DATA1_DLY[4]),\n        .WRITE(WRITE[1]), .FRAME_START(FRAME_START1), .DATA(DATA[1])\n    ); \n    reg [31:0] TIMESTAMP_save;\n    always@(posedge CLK_RX)\n        if(FRAME_START)\n            TIMESTAMP_save <= TIMESTAMP;\n    wire [17:0] cdc_data;\n    wire fifo_full, cdc_fifo_empty;\n    wire cdc_fifo_write;\n    reg data_lost_flag;\n    reg [15:0] data_field;\n    always@(*) begin\n        if(CONF_TIMESTAMP_HEADER & (WRITE[0] && FRAME_START))\n            data_field = TIMESTAMP[15:0];\n        else if(CONF_TIMESTAMP_HEADER & (WRITE[1] && FRAME_START1))\n            data_field = TIMESTAMP_save[31:16];\n        else if(WRITE[0])\n            data_field = DATA[0];\n        else\n            data_field = DATA[1];\n    end\n    assign cdc_data[17] = data_lost_flag;\n    assign cdc_data[16] = FRAME_START;\n    assign cdc_data[15:0] = data_field;\n    assign cdc_fifo_write = |WRITE & CONF_EN_SYNC;\n    wire wfull;\n    always@(posedge CLK_RX) begin\n        if(RST_SYNC)\n            LOST_DATA_CNT <= 0;\n        else if (wfull && cdc_fifo_write && LOST_DATA_CNT != -1)\n            LOST_DATA_CNT <= LOST_DATA_CNT +1;\n    end\n    always@(posedge CLK_RX) begin\n        if(RST_SYNC)\n            data_lost_flag <= 0;\n        else if (cdc_fifo_write) begin\n                if(wfull)\n                    data_lost_flag <= 1;\n                else\n                    data_lost_flag <= 0;\n        end\n    end\n    wire [17:0] cdc_data_out;\n    cdc_syncfifo #(.DSIZE(18), .ASIZE(3)) cdc_syncfifo_i\n    (\n        .rdata(cdc_data_out),\n        .wfull(wfull),\n        .rempty(cdc_fifo_empty),\n        .wdata(cdc_data),\n        .winc(cdc_fifo_write), .wclk(CLK_RX), .wrst(RST_SYNC),\n        .rinc(!fifo_full), .rclk(BUS_CLK), .rrst(RST)\n    );\n    gerneric_fifo #(.DATA_SIZE(18), .DEPTH(1024))  fifo_i\n    ( .clk(BUS_CLK), .reset(RST), \n        .write(!cdc_fifo_empty),\n        .read(FIFO_READ), \n        .data_in(cdc_data_out), \n        .full(fifo_full), \n        .empty(FIFO_EMPTY), \n        .data_out(FIFO_DATA[17:0]), .size() \n    );\n    assign FIFO_DATA[19:18]  =  0; \n    assign FIFO_DATA[23:20]  =  IDENTYFIER[3:0]; \n    assign FIFO_DATA[31:24]  =  HEADER[7:0]; \n    assign LOST_ERROR = LOST_DATA_CNT != 0;\nendmodule"}
{"task_id": 974, "completion": "localparam ADDR_AP_CTRL = 5'h00; localparam ADDR_GIE = 5'h04; localparam ADDR_IER = 5'h08; localparam ADDR_ISR = 5'h0c; localparam ADDR_P_MODE_DATA_0 = 5'h10; localparam ADDR_P_MODE_CTRL = 5'h14; localparam WRIDLE = 2'd0; localparam WRDATA = 2'd1; localparam WRRESP = 2'd2; localparam RDIDLE = 2'd0; localparam RDDATA = 2'd1; localparam ADDR_BITS = 5; reg [1:0] wstate; reg [1:0] wnext; reg [ADDR_BITS-1:0] waddr; wire [31:0] wmask; wire aw_hs; wire w_hs; reg [1:0] rstate; reg [1:0] rnext; reg [31:0] rdata; wire ar_hs; wire [ADDR_BITS-1:0] raddr; wire int_ap_idle; wire int_ap_ready; reg int_ap_done; reg int_ap_start; reg int_auto_restart; reg int_gie; reg [1:0] int_ier; reg [1:0] int_isr; reg [31:0] int_P_mode; assign AWREADY = (wstate == WRIDLE); assign WREADY  = (wstate == WRDATA); assign BRESP   = 2'b00; assign BVALID  = (wstate == WRRESP); assign wmask   = { {8{WSTRB[3]}}, {8{WSTRB[2]}}, {8{WSTRB[1]}}, {8{WSTRB[0]}} }; assign aw_hs   = AWVALID & AWREADY; assign w_hs    = WVALID & WREADY; always @(posedge ACLK) begin if (ARESET) wstate <= WRIDLE; else if (ACLK_EN) wstate <= wnext; end always @(*) begin case (wstate) WRIDLE: if (AWVALID) wnext = WRDATA; else wnext = WRIDLE; WRDATA: if (WVALID) wnext = WRRESP; else wnext = WRDATA; WRRESP: if (BREADY) wnext = WRIDLE; else wnext = WRRESP; default: wnext = WRIDLE; endcase end always @(posedge ACLK) begin if (ACLK_EN) begin if (aw_hs) waddr <= AWADDR[ADDR_BITS-1:0]; end end assign ARREADY = (rstate == RDIDLE); assign RDATA   = rdata; assign RRESP   = 2'b00; assign RVALID  = (rstate == RDDATA); assign ar_hs   = ARVALID & ARREADY; assign raddr   = ARADDR[ADDR_BITS-1:0]; always @(posedge ACLK) begin if (ARESET) rstate <= RDIDLE; else if (ACLK_EN) rstate <= rnext; end always @(*) begin case (rstate) RDIDLE: if (ARVALID) rnext = RDDATA; else rnext = RDIDLE; RDDATA: if (RREADY & RVALID) rnext = RDIDLE; else rnext = RDDATA; default: rnext = RDIDLE; endcase end always @(posedge ACLK) begin if (ACLK_EN) begin if (ar_hs) begin rdata <= 1'b0; case (raddr) ADDR_AP_CTRL: begin rdata[0] <= int_ap_start; rdata[1] <= int_ap_done; rdata[2] <= int_ap_idle; rdata[3] <= int_ap_ready; rdata[7] <= int_auto_restart; end ADDR_GIE: begin rdata <= int_gie; end ADDR_IER: begin rdata <= int_ier; end ADDR_ISR: begin rdata <= int_isr; end ADDR_P_MODE_DATA_0: begin rdata <= int_P_mode[31:0]; end endcase end end end assign interrupt = int_gie & (|int_isr); assign ap_start = int_ap_start; assign int_ap_idle = ap_idle; assign int_ap_ready = ap_ready; assign P_mode = int_P_mode; always @(posedge ACLK) begin if (ARESET) int_ap_start <= 1'b0; else if (ACLK_EN) begin if (w_hs && waddr == ADDR_AP_CTRL && WSTRB[0] && WDATA[0]) int_ap_start <= 1'b1; else if (int_ap_ready) int_ap_start <= int_auto_restart; end end always @(posedge ACLK) begin if (ARESET) int_ap_done <= 1'b0; else if (ACLK_EN) begin if (ap_done) int_ap_done <= 1'b1; else if (ar_hs && raddr == ADDR_AP_CTRL) int_ap_done <= 1'b0; end end always @(posedge ACLK) begin if (ARESET) int_auto_restart <= 1'b0; else if (ACLK_EN) begin if (w_hs && waddr == ADDR_AP_CTRL && WSTRB[0]) int_auto_restart <= WDATA[7]; end end always @(posedge ACLK) begin if (ARESET) int_gie <= 1'b0; else if (ACLK_EN) begin if (w_hs && waddr == ADDR_GIE && WSTRB[0]) int_gie <= WDATA[0]; end end always @(posedge ACLK) begin if (ARESET) int_ier <= 1'b0; else if (ACLK_EN) begin if (w_hs && waddr == ADDR_IER && WSTRB[0]) int_ier <= WDATA[1:0]; end end always @(posedge ACLK) begin if (ARESET) int_isr[0] <= 1'b0; else if (ACLK_EN) begin if (int_ier[0] & ap_done) int_isr[0] <= 1'b1; else if (w_hs && waddr == ADDR_ISR && WSTRB[0]) int_isr[0] <= int_isr[0] ^ WDATA[0]; end end always @(posedge ACLK) begin if (ARESET) int_isr[1] <= 1'b0; else if (ACLK_EN) begin if (int_ier[1] & ap_ready) int_isr[1] <= 1'b1; else if (w_hs && waddr == ADDR_ISR && WSTRB[0]) int_isr[1] <= int_isr[1] ^ WDATA[1]; end end always @(posedge ACLK) begin if (ARESET) int_P_mode[31:0] <= 0; else if (ACLK_EN) begin if (w_hs && waddr == ADDR_P_MODE_DATA_0) int_P_mode[31:0] <= (WDATA[31:0] & wmask) | (int_P_mode[31:0] & ~wmask); end end endmodule"}
{"task_id": 962, "completion": "wire clk_200mhz_ibufg;\n\nwire clk_mmcm_out;\nwire clk_int;\nwire clk90_mmcm_out;\nwire clk90_int;\nwire rst_int;\n\nwire clk_200mhz_mmcm_out;\nwire clk_200mhz_int;\n\nwire mmcm_rst = reset;\nwire mmcm_locked;\nwire mmcm_clkfb;\n\nIBUFGDS\nclk_200mhz_ibufgds_inst(\n    .I(clk_200mhz_p),\n    .IB(clk_200mhz_n),\n    .O(clk_200mhz_ibufg)\n);\n\nMMCME2_BASE #(\n    .BANDWIDTH(\"OPTIMIZED\"),\n    .CLKOUT0_DIVIDE_F(8),\n    .CLKOUT0_DUTY_CYCLE(0.5),\n    .CLKOUT0_PHASE(0),\n    .CLKOUT1_DIVIDE(8),\n    .CLKOUT1_DUTY_CYCLE(0.5),\n    .CLKOUT1_PHASE(90),\n    .CLKOUT2_DIVIDE(5),\n    .CLKOUT2_DUTY_CYCLE(0.5),\n    .CLKOUT2_PHASE(0),\n    .CLKOUT3_DIVIDE(1),\n    .CLKOUT3_DUTY_CYCLE(0.5),\n    .CLKOUT3_PHASE(0),\n    .CLKOUT4_DIVIDE(1),\n    .CLKOUT4_DUTY_CYCLE(0.5),\n    .CLKOUT4_PHASE(0),\n    .CLKOUT5_DIVIDE(1),\n    .CLKOUT5_DUTY_CYCLE(0.5),\n    .CLKOUT5_PHASE(0),\n    .CLKOUT6_DIVIDE(1),\n    .CLKOUT6_DUTY_CYCLE(0.5),\n    .CLKOUT6_PHASE(0),\n    .CLKFBOUT_MULT_F(5),\n    .CLKFBOUT_PHASE(0),\n    .DIVCLK_DIVIDE(1),\n    .REF_JITTER1(0.010),\n    .CLKIN1_PERIOD(5.0),\n    .STARTUP_WAIT(\"FALSE\"),\n    .CLKOUT4_CASCADE(\"FALSE\")\n)\nclk_mmcm_inst (\n    .CLKIN1(clk_200mhz_ibufg),\n    .CLKFBIN(mmcm_clkfb),\n    .RST(mmcm_rst),\n    .PWRDWN(1'b0),\n    .CLKOUT0(clk_mmcm_out),\n    .CLKOUT0B(),\n    .CLKOUT1(clk90_mmcm_out),\n    .CLKOUT1B(),\n    .CLKOUT2(clk_200mhz_mmcm_out),\n    .CLKOUT2B(),\n    .CLKOUT3(),\n    .CLKOUT3B(),\n    .CLKOUT4(),\n    .CLKOUT5(),\n    .CLKOUT6(),\n    .CLKFBOUT(mmcm_clkfb),\n    .CLKFBOUTB(),\n    .LOCKED(mmcm_locked)\n);\n\nBUFG\nclk_bufg_inst (\n    .I(clk_mmcm_out),\n    .O(clk_int)\n);\n\nBUFG\nclk90_bufg_inst (\n    .I(clk90_mmcm_out),\n    .O(clk90_int)\n);\n\nBUFG\nclk_200mhz_bufg_inst (\n    .I(clk_200mhz_mmcm_out),\n    .O(clk_200mhz_int)\n);\n\nsync_reset #(\n    .N(4)\n)\nsync_reset_inst (\n    .clk(clk_int),\n    .rst(~mmcm_locked),\n    .out(rst_int)\n);\n\nwire btnu_int;\nwire btnl_int;\nwire btnd_int;\nwire btnr_int;\nwire btnc_int;\nwire [3:0] sw_int;\n\ndebounce_switch #(\n    .WIDTH(9),\n    .N(4),\n    .RATE(125000)\n)\ndebounce_switch_inst (\n    .clk(clk_int),\n    .rst(rst_int),\n    .in({btnu,\n        btnl,\n        btnd,\n        btnr,\n        btnc,\n        sw}),\n    .out({btnu_int,\n        btnl_int,\n        btnd_int,\n        btnr_int,\n        btnc_int,\n        sw_int})\n);\n\nwire uart_rxd_int;\nwire uart_cts_int;\n\nsync_signal #(\n    .WIDTH(2),\n    .N(2)\n)\nsync_signal_inst (\n    .clk(clk_int),\n    .in({uart_rxd, uart_cts}),\n    .out({uart_rxd_int, uart_cts_int})\n);\n\nwire [3:0] phy_rxd_delay;\nwire phy_rx_ctl_delay;\n\nIDELAYCTRL\nidelayctrl_inst (\n    .REFCLK(clk_200mhz_int),\n    .RST(rst_int),\n    .RDY()\n);\n\nIDELAYE2 #(\n    .IDELAY_TYPE(\"FIXED\")\n)\nphy_rxd_idelay_0 (\n    .IDATAIN(phy_rxd[0]),\n    .DATAOUT(phy_rxd_delay[0]),\n    .DATAIN(1'b0),\n    .C(1'b0),\n    .CE(1'b0),\n    .INC(1'b0),\n    .CINVCTRL(1'b0),\n    .CNTVALUEIN(5'd0),\n    .CNTVALUEOUT(),\n    .LD(1'b0),\n    .LDPIPEEN(1'b0),\n    .REGRST(1'b0)\n);\n\nIDELAYE2 #(\n    .IDELAY_TYPE(\"FIXED\")\n)\nphy_rxd_idelay_1 (\n    .IDATAIN(phy_rxd[1]),\n    .DATAOUT(phy_rxd_delay[1]),\n    .DATAIN(1'b0),\n    .C(1'b0),\n    .CE(1'b0),\n    .INC(1'b0),\n    .CINVCTRL(1'b0),\n    .CNTVALUEIN(5'd0),\n    .CNTVALUEOUT(),\n    .LD(1'b0),\n    .LDPIPEEN(1'b0),\n    .REGRST(1'b0)\n);\n\nIDELAYE2 #(\n    .IDELAY_TYPE(\"FIXED\")\n)\nphy_rxd_idelay_2 (\n    .IDATAIN(phy_rxd[2]),\n    .DATAOUT(phy_rxd_delay[2]),\n    .DATAIN(1'b0),\n    .C(1'b0),\n    .CE(1'b0),\n    .INC(1'b0),\n    .CINVCTRL(1'b0),\n    .CNTVALUEIN(5'd0),\n    .CNTVALUEOUT(),\n    .LD(1'b0),\n    .LDPIPEEN(1'b0),\n    .REGRST(1'b0)\n);\n\nIDELAYE2 #(\n    .IDELAY_TYPE(\"FIXED\")\n)\nphy_rxd_idelay_3 (\n    .IDATAIN(phy_rxd[3]),\n    .DATAOUT(phy_rxd_delay[3]),\n    .DATAIN(1'b0),\n    .C(1'b0),\n    .CE(1'b0),\n    .INC(1'b0),\n    .CINVCTRL(1'b0),\n    .CNTVALUEIN(5'd0),\n    .CNTVALUEOUT(),\n    .LD(1'b0),\n    .LDPIPEEN(1'b0),\n    .REGRST(1'b0)\n);\n\nIDELAYE2 #(\n    .IDELAY_TYPE(\"FIXED\")\n)\nphy_rx_ctl_idelay (\n    .IDATAIN(phy_rx_ctl),\n    .DATAOUT(phy_rx_ctl_delay),\n    .DATAIN(1'b0),\n    .C(1'b0),\n    .CE(1'b0),\n    .INC(1'b0),\n    .CINVCTRL(1'b0),\n    .CNTVALUEIN(5'd0),\n    .CNTVALUEOUT(),\n    .LD(1'b0),\n    .LDPIPEEN(1'b0),\n    .REGRST(1'b0)\n);\n\nfpga_core #(\n    .TARGET(\"XILINX\")\n)\ncore_inst (\n    .clk(clk_int),\n    .clk90(clk90_int),\n    .rst(rst_int),\n    .btnu(btnu_int),\n    .btnl(btnl_int),\n    .btnd(btnd_int),\n    .btnr(btnr_int),\n    .btnc(btnc_int),\n    .sw(sw_int),\n    .led(led),\n    .phy_rx_clk(phy_rx_clk),\n    .phy_rxd(phy_rxd_delay),\n    .phy_rx_ctl(phy_rx_ctl_delay),\n    .phy_tx_clk(phy_tx_clk),\n    .phy_txd(phy_txd),\n    .phy_tx_ctl(phy_tx_ctl),\n    .phy_reset_n(phy_reset_n),\n    .phy_int_n(phy_int_n),\n    .uart_rxd(uart_rxd_int),\n    .uart_txd(uart_txd),\n    .uart_rts(uart_rts),\n    .uart_cts(uart_cts_int)\n);\n\nendmodule"}
{"task_id": 895, "completion": "wire sys_clk_ibufg; wire clk_125mhz_mmcm_out; wire clk_125mhz_int; wire clk90_125mhz_mmcm_out; wire clk90_125mhz_int; wire rst_125mhz_int; wire mmcm_rst = reset; wire mmcm_locked; wire mmcm_clkfb; IBUFGDS clk_ibufgds_inst(.I(sys_clk_p),.IB(sys_clk_n),.O(sys_clk_ibufg)); MMCM_BASE #( .BANDWIDTH(\"OPTIMIZED\"), .CLKOUT0_DIVIDE_F(8), .CLKOUT0_DUTY_CYCLE(0.5), .CLKOUT0_PHASE(0), .CLKOUT1_DIVIDE(8), .CLKOUT1_DUTY_CYCLE(0.5), .CLKOUT1_PHASE(90), .CLKOUT2_DIVIDE(1), .CLKOUT2_DUTY_CYCLE(0.5), .CLKOUT2_PHASE(0), .CLKOUT3_DIVIDE(1), .CLKOUT3_DUTY_CYCLE(0.5), .CLKOUT3_PHASE(0), .CLKOUT4_DIVIDE(1), .CLKOUT4_DUTY_CYCLE(0.5), .CLKOUT4_PHASE(0), .CLKOUT5_DIVIDE(1), .CLKOUT5_DUTY_CYCLE(0.5), .CLKOUT5_PHASE(0), .CLKOUT6_DIVIDE(1), .CLKOUT6_DUTY_CYCLE(0.5), .CLKOUT6_PHASE(0), .CLKFBOUT_MULT_F(5), .CLKFBOUT_PHASE(0), .DIVCLK_DIVIDE(1), .REF_JITTER1(0.100), .CLKIN1_PERIOD(5.0), .STARTUP_WAIT(\"FALSE\"), .CLKOUT4_CASCADE(\"FALSE\") ) clk_mmcm_inst ( .CLKIN1(sys_clk_ibufg), .CLKFBIN(mmcm_clkfb), .RST(mmcm_rst), .PWRDWN(1'b0), .CLKOUT0(clk_125mhz_mmcm_out), .CLKOUT0B(), .CLKOUT1(clk90_125mhz_mmcm_out), .CLKOUT1B(), .CLKOUT2(), .CLKOUT2B(), .CLKOUT3(), .CLKOUT3B(), .CLKOUT4(), .CLKOUT5(), .CLKOUT6(), .CLKFBOUT(mmcm_clkfb), .CLKFBOUTB(), .LOCKED(mmcm_locked) ); BUFG clk_125mhz_bufg_inst (.I(clk_125mhz_mmcm_out), .O(clk_125mhz_int)); BUFG clk90_125mhz_bufg_inst (.I(clk90_125mhz_mmcm_out), .O(clk90_125mhz_int)); sync_reset #( .N(4) ) sync_reset_125mhz_inst ( .clk(clk_125mhz_int), .rst(~mmcm_locked), .out(rst_125mhz_int) ); wire btnu_int; wire btnl_int; wire btnd_int; wire btnr_int; wire btnc_int; wire [7:0] sw_int; wire ledu_int; wire ledl_int; wire ledd_int; wire ledr_int; wire ledc_int; wire [7:0] led_int; wire uart_rxd_int; wire uart_txd_int; wire uart_rts_int; wire uart_cts_int; debounce_switch #( .WIDTH(13), .N(4), .RATE(125000) ) debounce_switch_inst ( .clk(clk_125mhz_int), .rst(rst_125mhz_int), .in({btnu,btnl,btnd,btnr,btnc,sw}), .out({btnu_int,btnl_int,btnd_int,btnr_int,btnc_int,sw_int}) ); sync_signal #( .WIDTH(2), .N(2) ) sync_signal_inst ( .clk(clk_125mhz_int), .in({uart_txd,uart_rts}), .out({uart_txd_int,uart_rts_int}) ); assign ledu = ledu_int; assign ledl = ledl_int; assign ledd = ledd_int; assign ledr = ledr_int; assign ledc = ledc_int; assign led = led_int; assign uart_rxd = uart_rxd_int; assign uart_cts = uart_cts_int; fpga_core #( .TARGET(\"XILINX\") ) core_inst ( .clk_125mhz(clk_125mhz_int), .clk90_125mhz(clk90_125mhz_int), .rst_125mhz(rst_125mhz_int), .btnu(btnu_int), .btnl(btnl_int), .btnd(btnd_int), .btnr(btnr_int), .btnc(btnc_int), .sw(sw_int), .ledu(ledu_int), .ledl(ledl_int), .ledd(ledd_int), .ledr(ledr_int), .ledc(ledc_int), .led(led_int), .phy_rx_clk(phy_rx_clk), .phy_rxd(phy_rxd), .phy_rx_ctl(phy_rx_ctl), .phy_tx_clk(phy_tx_clk), .phy_txd(phy_txd), .phy_tx_ctl(phy_tx_ctl), .phy_reset_n(phy_reset_n), .uart_rxd(uart_rxd_int), .uart_txd(uart_txd_int), .uart_rts(uart_rts_int), .uart_cts(uart_cts_int) ); endmodule"}
{"task_id": 996, "completion": "reg[4:0] c;\n    reg sig_fa_0_a;\n    reg sig_fa_0_b;\n    reg sig_fa_0_ci;\n    wire sig_fa_0_co;\n    wire sig_fa_0_s;\n    reg sig_fa_1_a;\n    reg sig_fa_1_b;\n    reg sig_fa_1_ci;\n    wire sig_fa_1_co;\n    wire sig_fa_1_s;\n    reg sig_fa_2_a;\n    reg sig_fa_2_b;\n    reg sig_fa_2_ci;\n    wire sig_fa_2_co;\n    wire sig_fa_2_s;\n    reg sig_fa_3_a;\n    reg sig_fa_3_b;\n    reg sig_fa_3_ci;\n    wire sig_fa_3_co;\n    wire sig_fa_3_s;\n    FullAdder fa_0_inst (\n        .a(sig_fa_0_a),\n        .b(sig_fa_0_b),\n        .ci(sig_fa_0_ci),\n        .co(sig_fa_0_co),\n        .s(sig_fa_0_s)\n    );\n\n    FullAdder fa_1_inst (\n        .a(sig_fa_1_a),\n        .b(sig_fa_1_b),\n        .ci(sig_fa_1_ci),\n        .co(sig_fa_1_co),\n        .s(sig_fa_1_s)\n    );\n\n    FullAdder fa_2_inst (\n        .a(sig_fa_2_a),\n        .b(sig_fa_2_b),\n        .ci(sig_fa_2_ci),\n        .co(sig_fa_2_co),\n        .s(sig_fa_2_s)\n    );\n\n    FullAdder fa_3_inst (\n        .a(sig_fa_3_a),\n        .b(sig_fa_3_b),\n        .ci(sig_fa_3_ci),\n        .co(sig_fa_3_co),\n        .s(sig_fa_3_s)\n    );\n\n    always @(ci, sig_fa_0_co, sig_fa_1_co, sig_fa_2_co, sig_fa_3_co) begin: assig_process_c\n        c = {{{{sig_fa_3_co, sig_fa_2_co}, sig_fa_1_co}, sig_fa_0_co}, ci};\n    end\n\n    always @(c) begin: assig_process_co\n        co = c[4];\n    end\n\n    always @(sig_fa_0_s, sig_fa_1_s, sig_fa_2_s, sig_fa_3_s) begin: assig_process_s\n        s = {{{sig_fa_3_s, sig_fa_2_s}, sig_fa_1_s}, sig_fa_0_s};\n    end\n\n    always @(a) begin: assig_process_sig_fa_0_a\n        sig_fa_0_a = a[0];\n    end\n\n    always @(b) begin: assig_process_sig_fa_0_b\n        sig_fa_0_b = b[0];\n    end\n\n    always @(c) begin: assig_process_sig_fa_0_ci\n        sig_fa_0_ci = c[0];\n    end\n\n    always @(a) begin: assig_process_sig_fa_1_a\n        sig_fa_1_a = a[1];\n    end\n\n    always @(b) begin: assig_process_sig_fa_1_b\n        sig_fa_1_b = b[1];\n    end\n\n    always @(c) begin: assig_process_sig_fa_1_ci\n        sig_fa_1_ci = c[1];\n    end\n\n    always @(a) begin: assig_process_sig_fa_2_a\n        sig_fa_2_a = a[2];\n    end\n\n    always @(b) begin: assig_process_sig_fa_2_b\n        sig_fa_2_b = b[2];\n    end\n\n    always @(c) begin: assig_process_sig_fa_2_ci\n        sig_fa_2_ci = c[2];\n    end\n\n    always @(a) begin: assig_process_sig_fa_3_a\n        sig_fa_3_a = a[3];\n    end\n\n    always @(b) begin: assig_process_sig_fa_3_b\n        sig_fa_3_b = b[3];\n    end\n\n    always @(c) begin: assig_process_sig_fa_3_ci\n        sig_fa_3_ci = c[3];\n    end\n\n    generate if (p_wordlength != 4)\n        $error(\"%m Generated only for this param value\");\n    endgenerate\n\nendmodule"}
{"task_id": 969, "completion": "parameter integer S = 8;\n\ninput clkin1;\ninput clkin2;\noutput rxioclkp;\noutput rxioclkn;\noutput rx_serdesstrobe;\noutput rx_bufg_x1;\n\nwire ddly_m;\nwire ddly_s;\nwire rx_clk_in;\nwire iob_data_in_p;\nwire iob_data_in_n;\n\nparameter RX_SWAP_CLK = 1'b0;\n\nIBUFG iob_clk_in1 (\n\t.I (clkin1),\n\t.O (rx_clk_in_p));\n\nIBUFG iob_clk_in2 (\n\t.I (clkin2),\n\t.O (rx_clk_in_n));\n\nassign iob_data_in_p = rx_clk_in_p ^ RX_SWAP_CLK;\nassign iob_data_in_n = ~rx_clk_in_n ^ RX_SWAP_CLK;\n\nIODELAY2 #(\n\t.DATA_RATE (\"SDR\"),\n\t.SIM_TAPDELAY_VALUE (49),\n\t.IDELAY_VALUE (0),\n\t.IDELAY2_VALUE (0),\n\t.ODELAY_VALUE (0),\n\t.IDELAY_MODE (\"NORMAL\"),\n\t.SERDES_MODE (\"MASTER\"),\n\t.IDELAY_TYPE (\"FIXED\"),\n\t.COUNTER_WRAPAROUND (\"STAY_AT_LIMIT\"),\n\t.DELAY_SRC (\"IDATAIN\"))\niodelay_m (\n\t.IDATAIN (iob_data_in_p),\n\t.TOUT (),\n\t.DOUT (),\n\t.T (1'b1),\n\t.ODATAIN (1'b0),\n\t.DATAOUT (ddly_m),\n\t.DATAOUT2 (),\n\t.IOCLK0 (1'b0),\n\t.IOCLK1 (1'b0),\n\t.CLK (1'b0),\n\t.CAL (1'b0),\n\t.INC (1'b0),\n\t.CE (1'b0),\n\t.RST (1'b0),\n\t.BUSY ());\n\nIODELAY2 #(\n\t.DATA_RATE (\"SDR\"),\n\t.SIM_TAPDELAY_VALUE (49),\n\t.IDELAY_VALUE (0),\n\t.IDELAY2_VALUE (0),\n\t.ODELAY_VALUE (0),\n\t.IDELAY_MODE (\"NORMAL\"),\n\t.SERDES_MODE (\"SLAVE\"),\n\t.IDELAY_TYPE (\"FIXED\"),\n\t.COUNTER_WRAPAROUND (\"STAY_AT_LIMIT\"),\n\t.DELAY_SRC (\"IDATAIN\"))\niodelay_s (\n\t.IDATAIN (iob_data_in_n),\n\t.TOUT (),\n\t.DOUT (),\n\t.T (1'b1),\n\t.ODATAIN (1'b0),\n\t.DATAOUT (ddly_s),\n\t.DATAOUT2 (),\n\t.IOCLK0 (1'b0),\n\t.IOCLK1 (1'b0),\n\t.CLK (1'b0),\n\t.CAL (1'b0),\n\t.INC (1'b0),\n\t.CE (1'b0),\n\t.RST (1'b0),\n\t.BUSY ());\n\nBUFG buf_pll_x1 (.I(rx_bufio2_x1), .O(rx_bufg_x1));\n\nBUFIO2_2CLK #(\n\t.DIVIDE (S))\nbufio2_2clk_inst (\n\t.I (ddly_m),\n\t.IB (ddly_s),\n\t.IOCLK (rxioclkp),\n\t.DIVCLK (rx_bufio2_x1),\n\t.SERDESSTROBE (rx_serdesstrobe));\n\nBUFIO2 #(\n\t.I_INVERT (\"FALSE\"),\n\t.DIVIDE_BYPASS (\"FALSE\"),\n\t.USE_DOUBLER (\"FALSE\"))\nbufio2_inst (\n\t.I (ddly_s),\n\t.IOCLK (rxioclkn),\n\t.DIVCLK (),\n\t.SERDESSTROBE ());\n\nendmodule"}
{"task_id": 1019, "completion": "supply1 VPWR;    supply0 VGND;    supply1 VPB;    supply0 VNB;    wire and0_out;    wire nor0_out;    wire or0_out_X;    and and0 (and0_out, B1, B2);    nor nor0 (nor0_out, A1_N, A2_N);    or or0 (or0_out_X, nor0_out, and0_out);    buf buf0 (X, or0_out_X);    endmodule"}
{"task_id": 1023, "completion": "wire or0_out_X;\n\n    or  or0  (or0_out_X, B, A, C        );\n    buf buf0 (X        , or0_out_X      );\n\nendmodule"}
{"task_id": 1004, "completion": "supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\nendmodule"}
{"task_id": 1027, "completion": "endmodule"}
{"task_id": 1026, "completion": "function integer com_msb (input integer com_idx);\n    begin\n\tcom_msb = C_IN_COMP_WIDTH * (com_idx + 1) - 1;\n    end\n    endfunction\n\n    function integer com_lsb_shrink (input integer com_idx);\n    begin\n\tcom_lsb_shrink = C_IN_COMP_WIDTH * (com_idx + 1) - C_OUT_COMP_WIDTH;\n    end\n    endfunction\n\n    function integer com_lsb_extent (input integer com_idx);\n    begin\n\tcom_lsb_extent = C_IN_COMP_WIDTH * com_idx;\n    end\n    endfunction\n\n    localparam integer C_EXTENT = C_OUT_COMP_WIDTH - C_IN_COMP_WIDTH;\n\n    assign active_data = vid_active_video;\n\n    if (C_IN_COMP_WIDTH >= C_OUT_COMP_WIDTH) begin\n\tassign r = vid_data[com_msb(2):com_lsb_shrink(2)];\n\tassign g = vid_data[com_msb(1):com_lsb_shrink(1)];\n\tassign b = vid_data[com_msb(0):com_lsb_shrink(0)];\n    end\n    else begin\n\tassign r = { vid_data[com_msb(2):com_lsb_extent(2)], {C_EXTENT{1'b1}} };\n\tassign g = { vid_data[com_msb(1):com_lsb_extent(1)], {C_EXTENT{1'b1}} };\n\tassign b = { vid_data[com_msb(0):com_lsb_extent(0)], {C_EXTENT{1'b1}} };\n    end\n\n    assign hsync_out = vid_hsync;\n    assign vsync_out = vid_vsync;\n    assign out_clk = vid_io_in_clk;\n\nendmodule"}
{"task_id": 332, "completion": "assign equivalent = (a === b); endmodule"}
{"task_id": 1031, "completion": "supply1 VPWR;    supply0 VGND;    supply1 VPB ;    supply0 VNB ;    wire xor0_out_SUM ;    wire a_b          ;    wire a_ci         ;    wire b_ci         ;    wire or0_out_coutn;    xor xor0 (xor0_out_SUM , A, B, CI       );    buf buf0 (SUM          , xor0_out_SUM   );    nor nor0 (a_b          , A, B           );    nor nor1 (a_ci         , A, CI          );    nor nor2 (b_ci         , B, CI          );    or  or0  (or0_out_coutn, a_b, a_ci, b_ci);    buf buf1 (COUT_N       , or0_out_coutn  );    endmodule"}
{"task_id": 1024, "completion": "wire        a_tvalid;    wire [31:0] a_tdata;    wire        r_tvalid;    wire [63:0] r_tdata;    HLS_accel_ap_fpext_0_no_dsp_32 HLS_accel_ap_fpext_0_no_dsp_32_u (.s_axis_a_tvalid ( a_tvalid ), .s_axis_a_tdata ( a_tdata ), .m_axis_result_tvalid ( r_tvalid ), .m_axis_result_tdata ( r_tdata ));    assign a_tvalid = 1'b1;    assign a_tdata  = din0==='bx ? 'b0 : din0;    assign dout     = r_tdata;endmodule"}
{"task_id": 1038, "completion": "endmodule"}
{"task_id": 1046, "completion": "assign o_0 = i_0; assign o_1 = i_2; assign o_2 = i_1; assign o_3 = i_3; endmodule"}
{"task_id": 1042, "completion": "wire buf_Q;\n    wire SET;\n    wire mux_out;\n\n    not not0 (SET, SET_B);\n    sky130_fd_sc_hdll__udp_mux_2to1 mux_2to10 (mux_out, D, SCD, SCE);\n    sky130_fd_sc_hdll__udp_dff$PS `UNIT_DELAY dff0 (buf_Q, mux_out, CLK, SET);\n    buf buf0 (Q, buf_Q);\n    not not1 (Q_N, buf_Q);\n\nendmodule"}
{"task_id": 926, "completion": "localparam [1:0]\n    STATE_IDLE = 2'd0,\n    STATE_ARP_QUERY = 2'd1,\n    STATE_WAIT_PACKET = 2'd2;\n\nreg [1:0] state_reg = STATE_IDLE, state_next;\n\nreg outgoing_ip_hdr_valid_reg = 1'b0, outgoing_ip_hdr_valid_next;\nwire outgoing_ip_hdr_ready;\nreg [47:0] outgoing_eth_dest_mac_reg = 48'h000000000000, outgoing_eth_dest_mac_next;\nwire outgoing_ip_payload_axis_tready;\n\nip_eth_rx_64\nip_eth_rx_64_inst (\n    .clk(clk),\n    .rst(rst),\n    .s_eth_hdr_valid(s_eth_hdr_valid),\n    .s_eth_hdr_ready(s_eth_hdr_ready),\n    .s_eth_dest_mac(s_eth_dest_mac),\n    .s_eth_src_mac(s_eth_src_mac),\n    .s_eth_type(s_eth_type),\n    .s_eth_payload_axis_tdata(s_eth_payload_axis_tdata),\n    .s_eth_payload_axis_tkeep(s_eth_payload_axis_tkeep),\n    .s_eth_payload_axis_tvalid(s_eth_payload_axis_tvalid),\n    .s_eth_payload_axis_tready(s_eth_payload_axis_tready),\n    .s_eth_payload_axis_tlast(s_eth_payload_axis_tlast),\n    .s_eth_payload_axis_tuser(s_eth_payload_axis_tuser),\n    .m_ip_hdr_valid(m_ip_hdr_valid),\n    .m_ip_hdr_ready(m_ip_hdr_ready),\n    .m_eth_dest_mac(m_ip_eth_dest_mac),\n    .m_eth_src_mac(m_ip_eth_src_mac),\n    .m_eth_type(m_ip_eth_type),\n    .m_ip_version(m_ip_version),\n    .m_ip_ihl(m_ip_ihl),\n    .m_ip_dscp(m_ip_dscp),\n    .m_ip_ecn(m_ip_ecn),\n    .m_ip_length(m_ip_length),\n    .m_ip_identification(m_ip_identification),\n    .m_ip_flags(m_ip_flags),\n    .m_ip_fragment_offset(m_ip_fragment_offset),\n    .m_ip_ttl(m_ip_ttl),\n    .m_ip_protocol(m_ip_protocol),\n    .m_ip_header_checksum(m_ip_header_checksum),\n    .m_ip_source_ip(m_ip_source_ip),\n    .m_ip_dest_ip(m_ip_dest_ip),\n    .m_ip_payload_axis_tdata(m_ip_payload_axis_tdata),\n    .m_ip_payload_axis_tkeep(m_ip_payload_axis_tkeep),\n    .m_ip_payload_axis_tvalid(m_ip_payload_axis_tvalid),\n    .m_ip_payload_axis_tready(m_ip_payload_axis_tready),\n    .m_ip_payload_axis_tlast(m_ip_payload_axis_tlast),\n    .m_ip_payload_axis_tuser(m_ip_payload_axis_tuser),\n    .busy(rx_busy),\n    .error_header_early_termination(rx_error_header_early_termination),\n    .error_payload_early_termination(rx_error_payload_early_termination),\n    .error_invalid_header(rx_error_invalid_header),\n    .error_invalid_checksum(rx_error_invalid_checksum)\n);\n\nip_eth_tx_64\nip_eth_tx_64_inst (\n    .clk(clk),\n    .rst(rst),\n    .s_ip_hdr_valid(outgoing_ip_hdr_valid_reg),\n    .s_ip_hdr_ready(outgoing_ip_hdr_ready),\n    .s_eth_dest_mac(outgoing_eth_dest_mac_reg),\n    .s_eth_src_mac(local_mac),\n    .s_eth_type(16'h0800),\n    .s_ip_dscp(s_ip_dscp),\n    .s_ip_ecn(s_ip_ecn),\n    .s_ip_length(s_ip_length),\n    .s_ip_identification(16'd0),\n    .s_ip_flags(3'b010),\n    .s_ip_fragment_offset(13'd0),\n    .s_ip_ttl(s_ip_ttl),\n    .s_ip_protocol(s_ip_protocol),\n    .s_ip_source_ip(s_ip_source_ip),\n    .s_ip_dest_ip(s_ip_dest_ip),\n    .s_ip_payload_axis_tdata(s_ip_payload_axis_tdata),\n    .s_ip_payload_axis_tkeep(s_ip_payload_axis_tkeep),\n    .s_ip_payload_axis_tvalid(s_ip_payload_axis_tvalid),\n    .s_ip_payload_axis_tready(outgoing_ip_payload_axis_tready),\n    .s_ip_payload_axis_tlast(s_ip_payload_axis_tlast),\n    .s_ip_payload_axis_tuser(s_ip_payload_axis_tuser),\n    .m_eth_hdr_valid(m_eth_hdr_valid),\n    .m_eth_hdr_ready(m_eth_hdr_ready),\n    .m_eth_dest_mac(m_eth_dest_mac),\n    .m_eth_src_mac(m_eth_src_mac),\n    .m_eth_type(m_eth_type),\n    .m_eth_payload_axis_tdata(m_eth_payload_axis_tdata),\n    .m_eth_payload_axis_tkeep(m_eth_payload_axis_tkeep),\n    .m_eth_payload_axis_tvalid(m_eth_payload_axis_tvalid),\n    .m_eth_payload_axis_tready(m_eth_payload_axis_tready),\n    .m_eth_payload_axis_tlast(m_eth_payload_axis_tlast),\n    .m_eth_payload_axis_tuser(m_eth_payload_axis_tuser),\n    .busy(tx_busy),\n    .error_payload_early_termination(tx_error_payload_early_termination)\n);\n\nreg s_ip_hdr_ready_reg = 1'b0, s_ip_hdr_ready_next;\n\nreg arp_request_valid_reg = 1'b0, arp_request_valid_next;\n\nreg arp_response_ready_reg = 1'b0, arp_response_ready_next;\n\nreg drop_packet_reg = 1'b0, drop_packet_next;\n\nassign s_ip_hdr_ready = s_ip_hdr_ready_reg;\nassign s_ip_payload_axis_tready = outgoing_ip_payload_axis_tready || drop_packet_reg;\nassign arp_request_valid = arp_request_valid_reg;\nassign arp_request_ip = s_ip_dest_ip;\nassign arp_response_ready = arp_response_ready_reg;\nassign tx_error_arp_failed = arp_response_error;\nalways @* begin\n    state_next = STATE_IDLE;\n    arp_request_valid_next = arp_request_valid_reg && !arp_request_ready;\n    arp_response_ready_next = 1'b0;\n    drop_packet_next = 1'b0;\n    s_ip_hdr_ready_next = 1'b0;\n    outgoing_ip_hdr_valid_next = outgoing_ip_hdr_valid_reg && !outgoing_ip_hdr_ready;\n    outgoing_eth_dest_mac_next = outgoing_eth_dest_mac_reg;\n    case (state_reg)\n        STATE_IDLE: begin\n            if (s_ip_hdr_valid) begin\n                arp_request_valid_next = 1'b1;\n                arp_response_ready_next = 1'b1;\n                state_next = STATE_ARP_QUERY;\n            end else begin\n                state_next = STATE_IDLE;\n            end\n        end\n        STATE_ARP_QUERY: begin\n            arp_response_ready_next = 1'b1;\n            if (arp_response_valid) begin\n                if (arp_response_error) begin\n                    s_ip_hdr_ready_next = 1'b1;\n                    drop_packet_next = 1'b1;\n                    state_next = STATE_WAIT_PACKET;\n                end else begin\n                    s_ip_hdr_ready_next = 1'b1;\n                    outgoing_ip_hdr_valid_next = 1'b1;\n                    outgoing_eth_dest_mac_next = arp_response_mac;\n                    state_next = STATE_WAIT_PACKET;\n                end\n            end else begin\n                state_next = STATE_ARP_QUERY;\n            end\n        end\n        STATE_WAIT_PACKET: begin\n            drop_packet_next = drop_packet_reg;\n            if (s_ip_payload_axis_tlast && s_ip_payload_axis_tready && s_ip_payload_axis_tvalid) begin\n                state_next = STATE_IDLE;\n            end else begin\n                state_next = STATE_WAIT_PACKET;\n            end\n        end\n    endcase\nend\nalways @(posedge clk) begin\n    if (rst) begin\n        state_reg <= STATE_IDLE;\n        arp_request_valid_reg <= 1'b0;\n        arp_response_ready_reg <= 1'b0;\n        drop_packet_reg <= 1'b0;\n        s_ip_hdr_ready_reg <= 1'b0;\n        outgoing_ip_hdr_valid_reg <= 1'b0;\n    end else begin\n        state_reg <= state_next;\n        arp_request_valid_reg <= arp_request_valid_next;\n        arp_response_ready_reg <= arp_response_ready_next;\n        drop_packet_reg <= drop_packet_next;\n        s_ip_hdr_ready_reg <= s_ip_hdr_ready_next;\n        outgoing_ip_hdr_valid_reg <= outgoing_ip_hdr_valid_next;\n    end\n    outgoing_eth_dest_mac_reg <= outgoing_eth_dest_mac_next;\nend\nendmodule"}
{"task_id": 1041, "completion": "wire buf_Q;\n    wire RESET;\n    wire mux_out;\n\n    not                                             not0      (RESET  , RESET_B                          );\n    sky130_fd_sc_ls__udp_mux_2to1                   mux_2to10 (mux_out, D, SCD, SCE                      );\n    sky130_fd_sc_ls__udp_dff$PR_pp$PG$N `UNIT_DELAY dff0      (buf_Q  , mux_out, CLK, RESET, , VPWR, VGND);\n    buf                                             buf0      (Q      , buf_Q                            );\n\nendmodule"}
{"task_id": 1020, "completion": "input wire\tRESET;\ninput wire\tCLOCK_50;\ninput wire\tPS2_CLK;\ninput wire\tPS2_DAT;\noutput wire\tVGA_HS;\noutput wire\tVGA_VS;\noutput wire\tVGA_BLANK_N;\noutput wire\tVGA_CLK;\noutput wire\t[7:0] LED;\noutput wire\t[7:0] VGA_B;\noutput wire\t[7:0] VGA_G;\noutput wire\t[7:0] VGA_R;\n\nwire\tscan_ready;\nwire\t[7:0] scan_code;\nwire\tw_reset;\nwire\t[15:0] SYNTHESIZED_WIRE_31;\nwire\t[15:0] SYNTHESIZED_WIRE_32;\nwire\tSYNTHESIZED_WIRE_5;\nwire\t[14:0] SYNTHESIZED_WIRE_6;\nwire\t[15:0] SYNTHESIZED_WIRE_7;\nwire\t[7:0] SYNTHESIZED_WIRE_33;\nwire\t[12:0] SYNTHESIZED_WIRE_9;\nwire\t[15:0] SYNTHESIZED_WIRE_11;\nwire\t[15:0] SYNTHESIZED_WIRE_13;\nwire\t[14:0] SYNTHESIZED_WIRE_34;\nwire\t[15:0] SYNTHESIZED_WIRE_17;\nwire\t[10:0] SYNTHESIZED_WIRE_18;\nwire\t[10:0] SYNTHESIZED_WIRE_19;\nwire\tmemory_ready;\nwire\tmemory_ready_n;\nwire\treset_n;\nwire\tclk_25;\nwire\t[23:0] SYNTHESIZED_WIRE_28;\n\nassign VGA_CLK = clk_25;\nassign reset_n = ~RESET;\nassign memory_ready_n = ~memory_ready;\nassign w_reset = memory_ready_n | reset_n;\n\nclock_25 pixel_clock(\n\t.CLOCK_50(CLOCK_50),\n\t.CLOCK_25(clk_25));\n\nps2decoder kb_decoder(\n\t.reset(w_reset),\n\t.i_clock(PS2_CLK),\n\t.i_data(PS2_DAT),\n\t.scan_ready(scan_ready),\n\t.scan_code(scan_code));\n    \nascii b2v_ascii(\n\t.clk(CLOCK_50),\n\t.scan_ready(scan_ready),\n\t.scan_code(scan_code),\n\t.ascii(SYNTHESIZED_WIRE_33));\n\ncpu\tb2v_cpu_inst(\n\t.clk(CLOCK_50),\n\t.reset(w_reset),\n\t.inM(SYNTHESIZED_WIRE_31),\n\t.instruction(SYNTHESIZED_WIRE_32),\n\t.writeM(SYNTHESIZED_WIRE_5),\n\t.addressM(SYNTHESIZED_WIRE_6),\n\t.areg(SYNTHESIZED_WIRE_11),\n\t.dreg(SYNTHESIZED_WIRE_13),\n\t.outM(SYNTHESIZED_WIRE_7),\n\t.pc(SYNTHESIZED_WIRE_34));\n\nmemory b2v_data_memory(\n\t.clk(CLOCK_50),\n\t.load(SYNTHESIZED_WIRE_5),\n\t.address(SYNTHESIZED_WIRE_6),\n\t.in(SYNTHESIZED_WIRE_7),\n\t.keyboard(SYNTHESIZED_WIRE_33),\n\t.screen_read_address(SYNTHESIZED_WIRE_9),\n\t.ready(memory_ready),\n\t.out(SYNTHESIZED_WIRE_31),\n\t.read_value(SYNTHESIZED_WIRE_17));\n\nleds b2v_debug_leds(\n\t.count(scan_code),\n\t.led_0(LED[0]),\n\t.led_1(LED[1]),\n\t.led_2(LED[2]),\n\t.led_3(LED[3]),\n\t.led_4(LED[4]),\n\t.led_5(LED[5]),\n\t.led_6(LED[6]),\n\t.led_7(LED[7]));\n\nframe_buffer b2v_fb(\n\t.clk(CLOCK_50),\n\t.areg(SYNTHESIZED_WIRE_11),\n\t.data_register(SYNTHESIZED_WIRE_31),\n\t.dreg(SYNTHESIZED_WIRE_13),\n\t.instruction(SYNTHESIZED_WIRE_32),\n\t.keyboard(SYNTHESIZED_WIRE_33),\n\t.pc(SYNTHESIZED_WIRE_34),\n\t.read_value(SYNTHESIZED_WIRE_17),\n\t.vga_h(SYNTHESIZED_WIRE_18),\n\t.vga_v(SYNTHESIZED_WIRE_19),\n\t.pixel_out(SYNTHESIZED_WIRE_28),\n\t.read_address(SYNTHESIZED_WIRE_9));\n\ninstruction_memory b2v_program_memory(\n\t.clk(CLOCK_50),\n\t.read_address(SYNTHESIZED_WIRE_34),\n\t.q(SYNTHESIZED_WIRE_32));\n\nvga_controller b2v_vga(\n\t.reset(w_reset),\n\t.sys_clk(w_reset),\n\t.vga_clk(VGA_CLK),\n\t.pixel(SYNTHESIZED_WIRE_28),\n\t.blank_n(VGA_BLANK_N),\n\t.HS(VGA_HS),\n\t.VS(VGA_VS),\n\t.blue(VGA_B),\n\t.green(VGA_G),\n\t.next_pixel_h(SYNTHESIZED_WIRE_18),\n\t.next_pixel_v(SYNTHESIZED_WIRE_19),\n\t.red(VGA_R));\n\nendmodule"}
{"task_id": 1045, "completion": "wire [3:0]a;\n    tp_channel_mux mux_1a(clk, reset, sela[4:0], tp1, a[0]);\n    tp_channel_mux mux_2a(clk, reset, sela[4:0], tp2, a[1]);\n    tp_channel_mux mux_3a(clk, reset, sela[4:0], tp3, a[2]);\n    tp_channel_mux mux_4a(clk, reset, sela[4:0], tp4, a[3]);\n    tp_group_mux mux_a   (clk, reset, sela[6:5],   a, tpa );\n    wire [3:0]b;\n    tp_channel_mux mux_1b(clk, reset, selb[4:0], tp1, b[0]);\n    tp_channel_mux mux_2b(clk, reset, selb[4:0], tp2, b[1]);\n    tp_channel_mux mux_3b(clk, reset, selb[4:0], tp3, b[2]);\n    tp_channel_mux mux_4b(clk, reset, selb[4:0], tp4, b[3]);\n    tp_group_mux mux_b   (clk, reset, selb[6:5],   b, tpb);\nendmodule"}
{"task_id": 1039, "completion": "wire [3:0] A = {A3, A2, A1, A0};\n    assign X = A[{S1, S0}];\nendmodule"}
{"task_id": 1025, "completion": "reg SDO; reg SCLK; reg END; reg [31:0]SD; reg [6:0]SD_COUNTER; wire I2C_SCLK=SCLK | ( ((SD_COUNTER >= 4) & (SD_COUNTER <=39))? ~CLOCK :0 ); wire I2C_SDAT=SDO?1'bz:0; reg ACK1,ACK2,ACK3,ACK4; wire ACK=ACK1 | ACK2 |ACK3 |ACK4; always @(negedge RESET or posedge CLOCK ) begin if (!RESET) SD_COUNTER=6'b111111; else begin if (GO==0) SD_COUNTER=0; else if (SD_COUNTER < 41) SD_COUNTER=SD_COUNTER+1; end end always @(negedge RESET or  posedge CLOCK ) begin if (!RESET) begin SCLK=1;SDO=1; ACK1=0;ACK2=0;ACK3=0;ACK4=0; END=1; end else case (SD_COUNTER) 6'd0  : begin ACK1=0 ;ACK2=0 ;ACK3=0 ;ACK4=0 ; END=0; SDO=1; SCLK=1;end 6'd1  : begin SD=I2C_DATA;SDO=0;end 6'd2  : SCLK=0; 6'd3  : SDO=SD[31]; 6'd4  : SDO=SD[30]; 6'd5  : SDO=SD[29]; 6'd6  : SDO=SD[28]; 6'd7  : SDO=SD[27]; 6'd8  : SDO=SD[26]; 6'd9  : SDO=SD[25]; 6'd10 : SDO=SD[24]; 6'd11 : SDO=1'b1; 6'd12  : begin SDO=SD[23]; ACK1=I2C_SDAT; end 6'd13  : SDO=SD[22]; 6'd14  : SDO=SD[21]; 6'd15  : SDO=SD[20]; 6'd16  : SDO=SD[19]; 6'd17  : SDO=SD[18]; 6'd18  : SDO=SD[17]; 6'd19  : SDO=SD[16]; 6'd20  : SDO=1'b1; 6'd21  : begin SDO=SD[15]; ACK2=I2C_SDAT; end 6'd22  : SDO=SD[14]; 6'd23  : SDO=SD[13]; 6'd24  : SDO=SD[12]; 6'd25  : SDO=SD[11]; 6'd26  : SDO=SD[10]; 6'd27  : SDO=SD[9]; 6'd28  : SDO=SD[8]; 6'd29  : SDO=1'b1; 6'd30  : begin SDO=SD[7]; ACK3=I2C_SDAT; end 6'd31  : SDO=SD[6]; 6'd32  : SDO=SD[5]; 6'd33  : SDO=SD[4]; 6'd34  : SDO=SD[3]; 6'd35  : SDO=SD[2]; 6'd36  : SDO=SD[1]; 6'd37  : SDO=SD[0]; 6'd38  : SDO=1'b1; 6'd39 : begin SDO=1'b0; SCLK=1'b0; ACK4=I2C_SDAT; end 6'd40 : SCLK=1'b1; 6'd41 : begin SDO=1'b1; END=1; end endcase end endmodule"}
{"task_id": 1053, "completion": "assign Y = !( (A1 & A2) | B1 );\nendmodule"}
{"task_id": 1047, "completion": "reg sclk_d, sclk_q;   reg [7:0] shift_in_d, shift_in_q, shift_out_d, shift_out_q;   reg [7:0] counter;   reg toggle, latch_d, latch_q, active_d, active_q;   reg [4:0] bits_d, bits_q;   assign sclk = sclk_q;   assign mosi = shift_out_q[7];   assign finished = active_q & ~active_d;   assign data_out = {shift_in_q[6:0], latch_q};   assign crc_in_bit = latch_q;   assign crc_out_bit = shift_out_q[7];   assign crc_strobe = active_q & toggle & sclk_q;   always @(posedge clk) begin      if (divider == 0)         toggle <= 1'b1;      else         toggle <= (counter+1 == divider);      if (toggle | ~active_q)         counter <= 0;      else         counter <= counter+1;   end   always @(*) begin      sclk_d = sclk_q;      shift_in_d = shift_in_q;      shift_out_d = shift_out_q;      latch_d = latch_q;      bits_d = bits_q;      active_d = active_q;      if (active_q & toggle) begin         sclk_d = ~sclk_q;         if (sclk_q) begin            shift_in_d = {shift_in_q[6:0], latch_q};            shift_out_d = {shift_out_q[6:0], 1'b1};            if ((bits_q == 0) | ~shift_in_q[6]) begin               active_d = 1'b0;            end else begin               bits_d = bits_q-1;            end         end else begin            latch_d = miso;         end      end      if (start) begin         shift_in_d = 8'hff;         shift_out_d = data_in;         bits_d = bits;         active_d = 1'b1;      end   end   always @(posedge clk) begin      if (rst) begin         active_q <= 1'b0;         bits_q <= 5'h00;         sclk_q <= 1'b0;         latch_q <= 1'b0;         shift_in_q <= 8'h00;         shift_out_q <= 8'h00;      end else begin         active_q <= active_d;         bits_q <= bits_d;         sclk_q <= sclk_d;         latch_q <= latch_d;         shift_in_q <= shift_in_d;         shift_out_q <= shift_out_d;      end   endendmodule"}
{"task_id": 1056, "completion": "wire and0_out;\n    wire or0_out_X;\n\n    and and0 (and0_out, A1, A2, A3, A4);\n    or  or0  (or0_out_X, and0_out, B1);\n    buf buf0 (X, or0_out_X);\n\nendmodule"}
{"task_id": 1013, "completion": "wire branch_result;\n   wire [DATA_WIDTH-1:0] alu_b_mux_sel;\n   wire [DATA_WIDTH-1:0] alu_data_in_a;\n   wire [DATA_WIDTH-1:0] alu_data_in_b;\n\n   branch_control\n   #(\n      .DATA_WIDTH(DATA_WIDTH),\n      .PC_WIDTH(PC_WIDTH),\n      .PC_OFFSET_WIDTH(PC_OFFSET_WIDTH)\n   )\n   branch_control_u0\n   (\n      .jmp_inst_in(jmp_inst_in),\n      .jmp_use_r_in(jmp_use_r_in),\n      .branch_use_r_in(branch_use_r_in),\n      .branch_inst_in(branch_inst_in),\n      .branch_result_in(branch_result),\n      .pc_in(new_pc_in),\n      .reg_a_data_in(alu_data_in_a),\n      .reg_b_data_in(alu_data_in_b),\n      .pc_offset_in(pc_offset_in),\n\n      .select_new_pc_out(fetch_select_new_pc_out),\n      .pc_out(fetch_new_pc_out)\n   );\n\n   forward_unit\n   #(\n      .DATA_WIDTH(DATA_WIDTH),\n      .REG_ADDR_WIDTH(REG_ADDR_WIDTH)\n   )\n   forward_unit\n   (\n      .data_alu_a_in(data_alu_a_in),\n      .data_alu_b_in(data_alu_b_in),\n      .addr_alu_a_in(reg_a_addr_in),\n      .addr_alu_b_in(reg_b_addr_in),\n      .ex_mem_reg_a_data_in(ex_mem_reg_a_data_in),\n      .ex_mem_reg_b_data_in(ex_mem_reg_b_data_in),\n      .ex_mem_reg_a_addr_in(ex_mem_reg_a_addr_in),\n      .ex_mem_reg_b_addr_in(ex_mem_reg_b_addr_in),\n      .ex_mem_reg_a_wr_ena_in(ex_mem_reg_a_wr_ena_in),\n      .ex_mem_reg_b_wr_ena_in(ex_mem_reg_b_wr_ena_in),\n      .wb_reg_a_data_in(wb_reg_a_data_in),\n      .wb_reg_b_data_in(wb_reg_b_data_in),\n      .wb_reg_a_addr_in(wb_reg_a_addr_in),\n      .wb_reg_b_addr_in(wb_reg_b_addr_in),\n      .wb_reg_a_wr_ena_in(wb_reg_a_wr_ena_in),\n      .wb_reg_b_wr_ena_in(wb_reg_b_wr_ena_in),\n\n      .alu_a_mux_sel_out(alu_data_in_a),\n      .alu_b_mux_sel_out(alu_b_mux_sel)\n   );\n\n   mux_data\n   #(\n      .DATA_WIDTH(DATA_WIDTH)\n    )\n   mux_data_u0\n   (\n      .data_a_in(alu_b_mux_sel),\n      .data_b_in(constant_in),\n      .mux_sel_in(imm_inst_in),\n      .data_out(alu_data_in_b)\n   );\n\n   alu\n   #(\n      .DATA_WIDTH(DATA_WIDTH),\n      .PC_WIDTH(PC_WIDTH),\n      .OPCODE_WIDTH(OPCODE_WIDTH)\n   )\n   alu_u0\n   (\n     .clk(clk),\n     .rst_n(rst_n),\n     .alu_data_a_in(alu_data_in_a),\n     .alu_data_b_in(alu_data_in_b),\n     .alu_opcode_in(alu_opcode_in),\n     .alu_function_in(alu_function_in),\n     .pc_in(new_pc_in),\n\n     .alu_branch_result_out(branch_result),\n     .alu_data_out(alu_data_out),\n     .hi_data_out(hi_data_out)\n   );\n\n   assign mem_data_out = alu_b_mux_sel;\n\nendmodule"}
{"task_id": 1048, "completion": "parameter INIT_FILE = \"../tracking_camera_system_onchip_memory2_0.hex\";\n\n  wire [31:0] readdata;\n  wire wren;\n  assign wren = chipselect & write;\n\n  altsyncram the_altsyncram\n    (\n      .address_a (address),\n      .byteena_a (byteenable),\n      .clock0 (clk),\n      .clocken0 (clken),\n      .data_a (writedata),\n      .q_a (readdata),\n      .wren_a (wren)\n    );\n\n  defparam the_altsyncram.byte_size = 8,\n           the_altsyncram.init_file = INIT_FILE,\n           the_altsyncram.lpm_type = \"altsyncram\",\n           the_altsyncram.maximum_depth = 4096,\n           the_altsyncram.numwords_a = 4096,\n           the_altsyncram.operation_mode = \"SINGLE_PORT\",\n           the_altsyncram.outdata_reg_a = \"UNREGISTERED\",\n           the_altsyncram.ram_block_type = \"AUTO\",\n           the_altsyncram.read_during_write_mode_mixed_ports = \"DONT_CARE\",\n           the_altsyncram.width_a = 32,\n           the_altsyncram.width_byteena_a = 4,\n           the_altsyncram.widthad_a = 12;\n\nendmodule"}
{"task_id": 1062, "completion": "reg [31:0] memory [0:255];\n    assign dataOut = (readOp) ? memory[address[31:2]] : 32'bz;\n\n    always @(posedge clk) begin\n        if (writeOp) begin\n            memory[address[31:2]] <= dataIn;\n        end\n    end\nendmodule"}
{"task_id": 1037, "completion": "input clk_i;\n    input nrst_i;\n    input [31:0] ad_i;\n    input [3:0] cbe_i;\n    input idsel_i;\n    input [31:25] bar0_i;\n    input memEN_i;\n    input pciadrLD_i;\n    output adrcfg_o;\n    output adrmem_o;\n    output [24:1] adr_o;\n    output [3:0] cmd_o;\n\n    reg [31:0] adr;\n    reg [3:0] cmd;\n    reg idsel_s;\n    wire a1;\n\n    always @( negedge nrst_i or posedge clk_i )\n    begin\n        if( nrst_i == 0 )\n        begin\n            adr <= 23'b1111_1111_1111_1111_1111_111;\n            cmd <= 3'b111;\n            idsel_s <= 1'b0;\n        end\n        else\n            if ( pciadrLD_i == 1 )\n            begin\n                adr <= ad_i;\n                cmd <= cbe_i;\n                idsel_s <= idsel_i;\n            end\n    end\n\n    assign adrmem_o = (\n        ( memEN_i == 1'b1 ) &&\n        ( adr [31:25] == bar0_i ) &&\n        ( adr [1:0] == 2'b00 ) &&\n        ( cmd [3:1] == 3'b011 )\n    ) ? 1'b1 : 1'b0;\n\n    assign adrcfg_o = (\n        ( idsel_s == 1'b1 ) &&\n        ( adr [1:0] == 2'b00 ) &&\n        ( cmd [3:1] == 3'b101 )\n    ) ? 1'b1 : 1'b0;\n\n    assign a1 = ~ ( cbe_i [3] && cbe_i [2] );\n    assign adr_o = {adr [24:2], a1};\n    assign cmd_o = cmd;\n\nendmodule"}
{"task_id": 1021, "completion": "wire [2:0] Rt_out_shift_ctr;\n    wire [31:0] Rt_out_l,Rt_out_r,Rt_out_shift;\n\n    assign Rt_out_shift_ctr[2] = (IR[31])&(!IR[30])&(IR[29])&(((!IR[28])&(IR[27])) | ((IR[27])&(!IR[26])) );\n    assign Rt_out_shift_ctr[1] = (IR[31])&(!IR[30])&(IR[29])&(((!IR[28])&(!IR[27])&(IR[26])) | ((IR[28])&(IR[27])&(!IR[26])));//xor better\n    assign Rt_out_shift_ctr[0] = (IR[31])&(!IR[30])&(IR[29])&(!IR[28])&(IR[27])&(!IR[26]);\n\n    MUX4_1 mux4_1_0(Mem_addr_in[1:0],Rt_out[31:24],8'b0,8'b0,8'b0,Rt_out_l[31:24]);\n    MUX4_1 mux4_1_1(Mem_addr_in[1:0],Rt_out[23:16],Rt_out[31:24],8'b0,8'b0,Rt_out_l[23:16]);\n    MUX4_1 mux4_1_2(Mem_addr_in[1:0],Rt_out[15:8],Rt_out[23:16],Rt_out[31:24],8'b0,Rt_out_l[15:8]);\n    MUX4_1 mux4_1_3(Mem_addr_in[1:0],Rt_out[7:0],Rt_out[15:8],Rt_out[23:16],Rt_out[31:24],Rt_out_l[7:0]);\n    MUX4_1 mux4_1_4(Mem_addr_in[1:0],Rt_out[7:0],Rt_out[15:8],Rt_out[23:16],Rt_out[31:24],Rt_out_r[31:24]);\n    MUX4_1 mux4_1_5(Mem_addr_in[1:0],8'b0,Rt_out[7:0],Rt_out[15:8],Rt_out[23:16],Rt_out_r[23:16]);\n    MUX4_1 mux4_1_6(Mem_addr_in[1:0],8'b0,8'b0,Rt_out[7:0],Rt_out[15:8],Rt_out_r[15:8]);\n    MUX4_1 mux4_1_7(Mem_addr_in[1:0],8'b0,8'b0,8'b0,Rt_out[7:0],Rt_out_r[7:0]);\n\n    MUX8_1 mux8_1_0(Rt_out_shift_ctr[2:0],Rt_out[7:0],8'b0,Rt_out[15:8],8'b0,Rt_out_l[31:24],Rt_out_l[31:24],Rt_out_r[31:24],8'b0,Mem_data_shift[31:24]);\n    MUX8_1 mux8_1_1(Rt_out_shift_ctr[2:0],Rt_out[7:0],8'b0,Rt_out[7:0],8'b0,Rt_out_l[23:16],Rt_out_l[23:16],Rt_out_r[23:16],8'b0,Mem_data_shift[23:16]);\n    MUX8_1 mux8_1_2(Rt_out_shift_ctr[2:0],Rt_out[7:0],8'b0,Rt_out[15:8],8'b0,Rt_out_l[15:8],Rt_out_l[15:8],Rt_out_r[15:8],8'b0,Mem_data_shift[15:8]);\n    MUX8_1 mux8_1_3(Rt_out_shift_ctr[2:0],Rt_out[7:0],8'b0,Rt_out[7:0],8'b0,Rt_out_l[7:0],Rt_out_l[7:0],Rt_out_r[7:0],8'b0,Mem_data_shift[7:0]);\n\nendmodule"}
{"task_id": 999, "completion": "wire writeRead;\n  wire multipleData;\n  wire timeout_enable;\n  wire [3:0] block_count;\n    input cmd_complete;\n  wire cmd_complete;\n  input cmd_index_error;\n  wire cmd_index_error;\n  always @(cmd_complete)\n  regs[5'b11001][0] <= cmd_complete;\n  \n  always @(cmd_index_error)\n  regs[5'b11001][1] <= cmd_index_error;\n   \n   reg [data_witdh-1: 0]    regs [0: reg_witdh-1];\n\n   assign SDMA_System_Address_Low[15:0] = regs[5'b00000][15:0];\n   assign SDMA_System_Address_High[15:0] = regs[5'b00000][31:16];\n\n   assign Block_Size[15:0] = regs[5'b00001][15:0];\n   assign Block_Count[15:0] = regs[5'b00001][31:16];\n   wire [3:0]  blockCount;\n   assign blockCount = Block_Count[3:0];\n\n   assign Argument0[15:0] = regs[ 5'b00010][15: 0];\n   assign Argument1[15:0] = regs[ 5'b00010][31: 16];\n\n   assign Transfer_Mode[15:0] = regs[5'b00011];\n   assign Command[15:0] = regs[5'b00011][31: 16];\n\n   assign Response0[15:0] = regs[5'b00100][15:0];\n   assign Response1[15:0] = regs[5'b00100][31: 16];\n\n   assign Response2[15:0] = regs[5'b00101][15:0];\n   assign Response3[15:0] = regs[5'b00101][31: 16];\n\n   assign Response4[15:0] = regs[5'b00110][15:0];\n   assign Response5[15:0] = regs[5'b00110][31: 16];\n\n   assign Response6[15:0] = regs[5'b00111][15:0];\n   assign Response7[15:0] = regs[5'b00111][31: 16];\n\n   assign Buffer_Data_Port0[15:0] = regs[5'b01000][15:0];\n   assign Buffer_Data_Port1[15:0] = regs[5'b01000][31: 16];\n\n   assign Present_State1[15:0] = regs[5'b01001][15:0];\n   assign Present_State2[15:0] = regs[5'b01001][31: 16];\n\n   assign Host_Control[7:0] = regs[5'b01010][7:0];\n   assign Power_Control[7:0] = regs[5'b01010][15:8];\n   assign Block_Gap_Control[7:0] = regs[5'b01010][23:16];\n   assign Wakeup_Control[7:0] = regs[5'b01010][31:24];\n\n   assign Clock_Control[15:0] = regs[5'b01011][15:0];\n   assign Timeout_Control[7:0] = regs[5'b01011][23:16];\n   assign Software_Reset[7:0] = regs[5'b01011][31:24];\n\n   assign Normal_Interrupt_Status[15:0] = regs[5'b01100][15:0];\n   assign Error_Interrupt_Status[15:0] = regs[5'b01100][31: 16];\n\n   assign Normal_Interrupt_Status_Enable[15:0] = regs[5'b01101][15:0];\n   assign Error_Interrupt_Status_Enable[15:0] = regs[5'b01101][31: 16];\n\n   assign Normal_Interrupt_Signal_Enable[15:0] = regs[5'b01110][15:0];\n   assign Error_Interrupt_Signal_Enable[15:0] = regs[5'b01110][31: 16];\n\n   assign Auto_CMD12_Error_Status[15:0] = regs[5'b01111][15:0];\n   assign Capabilities1[15:0] = regs[5'b10000][15:0];\n   assign Capabilities2[15:0] = regs[5'b10000][31: 16];\n\n   assign Capabilities_Reserved_1[15:0] = regs[5'b10001][15:0];\n   assign Capabilities_Reserved_2[15:0] = regs[5'b10001][31: 16];\n\n   assign Maximum_Current_Capabilities1[15:0] = regs[5'b10010][15:0];\n   assign Maximum_Current_Capabilities2[15:0] = regs[5'b10010][31: 16];\n\n   assign Maximum_Current_Capabilities_Reserved_1[15:0] = regs[5'b10011][15:0];\n   assign Maximum_Current_Capabilities_Reserved_2[15:0] = regs[5'b10011][31: 16];\n\n   assign Force_Event_for_Auto_CMD12_Error_Status[15:0] = regs[5'b10100][15:0];\n   assign Force_Event_for_Error_Interrupt_Status[15:0] = regs[5'b10100][31: 16];\n\n   assign ADMA_Error_Status[7:0] = regs[5'b10101][7:0];\n\n   assign ADMA_System_Address_15[15:0] = regs[5'b10110][15:0];\n   assign ADMA_System_Address_31[15:0] = regs[5'b10110][31: 16];\n\n   assign ADMA_System_Address_47[15:0] = regs[5'b10111][15:0];\n   assign ADMA_System_Address_63[15:0] = regs[5'b10111][31: 16];\n\n   assign Slot_Interrupt_Status[15: 0] = regs[5'b10011][15: 0];\n   assign Host_Controller_Version[15: 0] = regs[5'b10011][31: 16];\n\n   assign Timeout_Reg[15: 0] = regs[5'b11000][15: 0];\n   assign data[15: 0] = regs[5'b11000][31: 16];\n\n  assign timeout_enable = data[0];\n  assign writeRead = data[1];\n  assign multipleData = data[2];\n  assign block_count = data[6:3];\n\n   assign cmd_complete = regs[5'b11001][0];\n   assign cmd_complete = regs[5'b11001][0];\n\n   always @(posedge clk) begin\n      if(req == 1) begin\n\t if (rw == 1) begin\n\t\tdata_out <= regs[addr];\n\t\tack <= 1;\n\t end\n\t else begin\n\t\tregs[addr] <= data_in;\n\t\tack <= 1;\n\t end\n      end\n      else begin\n\t data_out <= data_out;\n\t ack <= 0;\n      end\n   end\n\nendmodule"}
{"task_id": 1012, "completion": "localparam         LO                = 1'b0;\n    localparam         HI                = 1'b1;\n    localparam [31:0]  ZEROS             = {32{LO}};\n    localparam [31:0]  ONES              = {32{HI}};\n\n    reg  [31:0]  data_z1;\n    reg          sof_z1;\n\n    reg  [31:0]  exp_z2;\n    reg  [31:0]  fcs_z2;\n    reg          val_z2;\n\n    reg          val_z3;\n    reg  [31:0]  exp_z3;\n    reg  [31:0]  fcs_z3;\n\n    always @ (posedge pclk_i) begin\n        data_z1[31:0] <= data_i[31:0];\n        sof_z1        <= sof_i;\n\n        val_z2        <= eof_i;\n\n        if (eof_i == HI) begin\n            exp_z2[31:0] <= data_i[31:0];\n        end\n\n        if (sof_z1 == HI) begin\n            fcs_z2[31:0] <= fcs32_32(data_z1[31:0], ONES[31:0]);\n        end else begin\n            fcs_z2[31:0] <= fcs32_32(data_z1[31:0], fcs_z2[31:0]);\n        end\n\n        val_z3       <= val_z2;\n        exp_z3[31:0] <= exp_z2[31:0];\n        fcs_z3[31:0] <= fcs32_brev(fcs_z2[31:0]);\n    end\n\n    always @ (*) begin\n        val_o       = val_z3;\n        res_o[31:0] = fcs_z2[31:0];\n        exp_o[31:0] = exp_z3[31:0];\n        obs_o[31:0] = fcs_z3[31:0];\n    end\nendmodule"}
{"task_id": 1058, "completion": "input  VPWR;\n    input  VGND;\n    output X   ;\n    input  A   ;\n\n    wire   buf0_out_X        ;\n    wire   u_vpwr_vgnd0_out_X;\n\n    buf                          buf0         (buf0_out_X        , A                     );\n    sky130_fd_sc_hs__u_vpwr_vgnd u_vpwr_vgnd0 (u_vpwr_vgnd0_out_X, buf0_out_X, VPWR, VGND);\n    buf                          buf1         (X                 , u_vpwr_vgnd0_out_X    );\n\nendmodule"}
{"task_id": 1070, "completion": "assign {COUT, SUM} = A + B + CI;\nendmodule"}
{"task_id": 440, "completion": "assign reset   = ~cpci_reset;\nwire rgmii_0_tx_clk, rgmii_1_tx_clk, rgmii_2_tx_clk, rgmii_3_tx_clk;\nwire [7:0]    gmii_0_txd,   gmii_1_txd,   gmii_2_txd,   gmii_3_txd;\nwire [7:0]    gmii_0_rxd,   gmii_1_rxd,   gmii_2_rxd,   gmii_3_rxd;\nwire          gmii_0_link,  gmii_1_link,  gmii_2_link,  gmii_3_link;\nwire [1:0]    gmii_0_speed, gmii_1_speed, gmii_2_speed, gmii_3_speed;\nwire          gmii_0_duplex,gmii_1_duplex,gmii_2_duplex,gmii_3_duplex;\nIBUF ibufg_gtx_clk (.I(gtx_clk), .O(gtx_clk_ibufg));\nassign sys_clk = gtx_clk_ibufg;\nwire tx_clk0, tx_clk90;\nDCM RGMII_TX_DCM (\n\t.CLKIN(gtx_clk_ibufg),\n\t.CLKFB(rgmii_tx_clk_int),\n\t.DSSEN(1'b0),\n\t.PSINCDEC(1'b0),\n\t.PSEN(1'b0),\n\t.PSCLK(1'b0),\n\t.RST(reset),\n\t.CLK0(tx_clk0),\n\t.CLK90(tx_clk90),\n\t.CLK180(),\n\t.CLK270(),\n\t.CLK2X(),\n\t.CLK2X180(),\n\t.CLKDV(),\n\t.CLKFX(),\n\t.CLKFX180(),\n\t.PSDONE(),\n\t.STATUS(),\n\t.LOCKED());\nBUFGMUX BUFGMUX_TXCLK (\n\t.O(rgmii_tx_clk_int),\n\t.I0(tx_clk0),\n\t.I1(tx_clk90),  // not used\n\t.S(1'b0)\n);\nBUFGMUX BUFGMUX_TXCLK90 (\n\t.O(rgmii_tx_clk90),\n\t.I1(tx_clk0),  // not used\n\t.I0(tx_clk90),\n\t.S(1'b0)\n);\nFDDRRSE gmii_0_tx_clk_ddr_iob (\n\t.Q (rgmii_0_txc_obuf),\n\t.D0(1'b1),\n\t.D1(1'b0),\n\t.C0(rgmii_tx_clk90),\n\t.C1(~rgmii_tx_clk90),\n\t.CE(1'b1),\n\t.R (reset),\n\t.S (1'b0)\n);\nFDDRRSE gmii_1_tx_clk_ddr_iob (\n\t.Q (rgmii_1_txc_obuf),\n\t.D0(1'b1),\n\t.D1(1'b0),\n\t.C0(rgmii_tx_clk90),\n\t.C1(~rgmii_tx_clk90),\n\t.CE(1'b1),\n\t.R (reset),\n\t.S (1'b0)\n);\nFDDRRSE gmii_2_tx_clk_ddr_iob (\n\t.Q (rgmii_2_txc_obuf),\n\t.D0(1'b1),\n\t.D1(1'b0),\n\t.C0(rgmii_tx_clk90),\n\t.C1(~rgmii_tx_clk90),\n\t.CE(1'b1),\n\t.R (reset),\n\t.S (1'b0)\n);\nFDDRRSE gmii_3_tx_clk_ddr_iob (\n\t.Q (rgmii_3_txc_obuf),\n\t.D0(1'b1),\n\t.D1(1'b0),\n\t.C0(rgmii_tx_clk90),\n\t.C1(~rgmii_tx_clk90),\n\t.CE(1'b1),\n\t.R (reset),\n\t.S (1'b0)\n);\nOBUF drive_rgmii_0_txc (.I(rgmii_0_txc_obuf), .O(rgmii_0_txc));\nOBUF drive_rgmii_1_txc (.I(rgmii_1_txc_obuf), .O(rgmii_1_txc));\nOBUF drive_rgmii_2_txc (.I(rgmii_2_txc_obuf), .O(rgmii_2_txc));\nOBUF drive_rgmii_3_txc (.I(rgmii_3_txc_obuf), .O(rgmii_3_txc));\nassign not_rgmii_tx_clk   = ~rgmii_tx_clk_int;\nassign rgmii_tx_clk       = not_rgmii_tx_clk;\nrgmii_io rgmii_0_io (\n\t.rgmii_txd             (rgmii_0_txd),\n\t.rgmii_tx_ctl          (rgmii_0_tx_ctl),\n\t.rgmii_tx_clk_int      (rgmii_tx_clk_int),\n\t.not_rgmii_tx_clk      (not_rgmii_tx_clk),\n\t.rgmii_rxd             (rgmii_0_rxd),\n\t.rgmii_rx_ctl          (rgmii_0_rx_ctl),\n\t.rgmii_rx_clk          (~rgmii_0_rxc),\n\t.gmii_txd              (gmii_0_txd),\n\t.gmii_tx_en            (gmii_0_tx_en),\n\t.gmii_tx_er            (gmii_0_tx_er),\n\t.gmii_rxd              (gmii_0_rxd),\n\t.gmii_rx_dv            (gmii_0_rx_dv),\n\t.gmii_rx_er            (gmii_0_rx_er),\n\t.link                  (gmii_0_link),\n\t.speed                 (gmii_0_speed),\n\t.duplex                (gmii_0_duplex),\n\t.reset                 (reset)\n);\nrgmii_io rgmii_1_io (\n\t.rgmii_txd             (rgmii_1_txd),\n\t.rgmii_tx_ctl          (rgmii_1_tx_ctl),\n\t.rgmii_tx_clk_int      (rgmii_tx_clk_int),\n\t.not_rgmii_tx_clk      (not_rgmii_tx_clk),\n\t.rgmii_rxd             (rgmii_1_rxd),\n\t.rgmii_rx_ctl          (rgmii_1_rx_ctl),\n\t.rgmii_rx_clk          (~rgmii_1_rxc),\n\t.gmii_txd              (gmii_1_txd),\n\t.gmii_tx_en            (gmii_1_tx_en),\n\t.gmii_tx_er            (gmii_1_tx_er),\n\t.gmii_rxd              (gmii_1_rxd),\n\t.gmii_rx_dv            (gmii_1_rx_dv),\n\t.gmii_rx_er            (gmii_1_rx_er),\n\t.link                  (gmii_1_link),\n\t.speed                 (gmii_1_speed),\n\t.duplex                (gmii_1_duplex),\n\t.reset                 (reset)\n);\n`ifdef ENABE_RGMII2\nrgmii_io rgmii_2_io (\n\t.rgmii_txd             (rgmii_2_txd),\n\t.rgmii_tx_ctl          (rgmii_2_tx_ctl),\n\t.rgmii_tx_clk_int      (rgmii_tx_clk_int),\n\t.not_rgmii_tx_clk      (not_rgmii_tx_clk),\n\t.rgmii_rxd             (rgmii_2_rxd),\n\t.rgmii_rx_ctl          (rgmii_2_rx_ctl),\n\t.rgmii_rx_clk          (~rgmii_2_rxc),\n\t.gmii_txd              (gmii_2_txd),\n\t.gmii_tx_en            (gmii_2_tx_en),\n\t.gmii_tx_er            (gmii_2_tx_er),\n\t.gmii_rxd              (gmii_2_rxd),\n\t.gmii_rx_dv            (gmii_2_rx_dv),\n\t.gmii_rx_er            (gmii_2_rx_er),\n\t.link                  (gmii_2_link),\n\t.speed                 (gmii_2_speed),\n\t.duplex                (gmii_2_duplex),\n\t.reset                 (reset)\n);\n`else\nassign rgmii_2_txd     = 4'hz;\nassign rgmii_2_tx_ctl  = 1'h0;\nassign rgmii_2_txc     = 1'hz;\n`endif\n`ifdef ENABE_RGMII3\nrgmii_io rgmii_3_io (\n\t.rgmii_txd             (rgmii_3_txd),\n\t.rgmii_tx_ctl          (rgmii_3_tx_ctl),\n\t.rgmii_tx_clk_int      (rgmii_tx_clk_int),\n\t.not_rgmii_tx_clk      (not_rgmii_tx_clk),\n\t.rgmii_rxd             (rgmii_3_rxd),\n\t.rgmii_rx_ctl          (rgmii_3_rx_ctl),\n\t.rgmii_rx_clk          (~rgmii_3_rxc),\n\t.gmii_txd              (gmii_3_txd),\n\t.gmii_tx_en            (gmii_3_tx_en),\n\t.gmii_tx_er            (gmii_3_tx_er),\n\t.gmii_rxd              (gmii_3_rxd),\n\t.gmii_rx_dv            (gmii_3_rx_dv),\n\t.gmii_rx_er            (gmii_3_rx_er),\n\t.link                  (gmii_3_link),\n\t.speed                 (gmii_3_speed),\n\t.duplex                (gmii_3_duplex),\n\t.reset                 (reset)\n);\n`else\nassign rgmii_3_txd     = 4'hz;\nassign rgmii_3_tx_ctl  = 1'h0;\nassign rgmii_3_txc     = 1'hz;\n`endif\nwire        tx0_enable;\nwire        tx0_ipv6;\nwire        tx0_fullroute;\nwire        tx0_req_arp;\nwire [15:0] tx0_frame_len;\nwire [31:0] tx0_inter_frame_gap;\nwire [31:0] tx0_ipv4_srcip;\nwire [47:0] tx0_src_mac;\nwire [31:0] tx0_ipv4_gwip;\nwire [127:0] tx0_ipv6_srcip;\nwire [127:0] tx0_ipv6_dstip;\nwire [47:0] tx0_dst_mac;\nwire [31:0] tx0_ipv4_dstip;\nwire [31:0] tx0_pps;\nwire [31:0] tx0_throughput;\nwire [31:0] tx0_ipv4_ip;\nwire [31:0] rx1_pps;\nwire [31:0] rx1_throughput;\nwire [23:0] rx1_latency;\nwire [31:0] rx1_ipv4_ip;\nwire [31:0] rx2_pps;\nwire [31:0] rx2_throughput;\nwire [23:0] rx2_latency;\nwire [31:0] rx2_ipv4_ip;\nwire [31:0] rx3_pps;\nwire [31:0] rx3_throughput;\nwire [23:0] rx3_latency;\nwire [31:0] rx3_ipv4_ip;\nmeasure measure_inst (\n\t.sys_rst(reset),\n\t.sys_clk(sys_clk),\n\t.pci_clk(PCLK2),\n\t.gmii_0_tx_clk(rgmii_tx_clk),\n\t.gmii_0_txd(gmii_0_txd),\n\t.gmii_0_tx_en(gmii_0_tx_en),\n\t.gmii_0_rxd(gmii_0_rxd),\n\t.gmii_0_rx_dv(gmii_0_rx_dv),\n\t.gmii_0_rx_clk(rgmii_0_rxc),\n\t.gmii_1_tx_clk(rgmii_tx_clk),\n\t.gmii_1_txd(gmii_1_txd),\n\t.gmii_1_tx_en(gmii_1_tx_en),\n\t.gmii_1_rxd(gmii_1_rxd),\n\t.gmii_1_rx_dv(gmii_1_rx_dv),\n\t.gmii_1_rx_clk(rgmii_1_rxc),\n\t.gmii_2_tx_clk(rgmii_tx_clk),\n\t.gmii_2_txd(gmii_2_txd),\n\t.gmii_2_tx_en(gmii_2_tx_en),\n\t.gmii_2_rxd(gmii_2_rxd),\n\t.gmii_2_rx_dv(gmii_2_rx_dv),\n\t.gmii_2_rx_clk(rgmii_2_rxc),\n\t.gmii_3_tx_clk(rgmii_tx_clk),\n\t.gmii_3_txd(gmii_3_txd),\n\t.gmii_3_tx_en(gmii_3_tx_en),\n\t.gmii_3_rxd(gmii_3_rxd),\n\t.gmii_3_rx_dv(gmii_3_rx_dv),\n\t.gmii_3_rx_clk(rgmii_3_rxc),\n\t.tx0_enable(tx0_enable),\n\t.tx0_ipv6(tx0_ipv6),\n\t.tx0_fullroute(tx0_fullroute),\n\t.tx0_req_arp(tx0_req_arp),\n\t.tx0_frame_len(tx0_frame_len),\n\t.tx0_inter_frame_gap(tx0_inter_frame_gap),\n\t.tx0_ipv4_srcip(tx0_ipv4_srcip),\n\t.tx0_src_mac(tx0_src_mac),\n\t.tx0_ipv4_gwip(tx0_ipv4_gwip),\n\t.tx0_ipv6_srcip(tx0_ipv6_srcip),\n\t.tx0_ipv6_dstip(tx0_ipv6_dstip),\n\t.tx0_dst_mac(tx0_dst_mac),\n\t.tx0_ipv4_dstip(tx0_ipv4_dstip),\n\t.tx0_pps(tx0_pps),\n\t.tx0_throughput(tx0_throughput),\n\t.tx0_ipv4_ip(tx0_ipv4_ip),\n\t.rx1_pps(rx1_pps),\n\t.rx1_throughput(rx1_throughput),\n\t.rx1_latency(rx1_latency),\n\t.rx1_ipv4_ip(rx1_ipv4_ip),\n\t.rx2_pps(rx2_pps),\n\t.rx2_throughput(rx2_throughput),\n\t.rx2_latency(rx2_latency),\n\t.rx2_ipv4_ip(rx2_ipv4_ip),\n\t.rx3_pps(rx3_pps),\n\t.rx3_throughput(rx3_throughput),\n\t.rx3_latency(rx3_latency),\n\t.rx3_ipv4_ip(rx3_ipv4_ip)\n);\nassign gmii_0_tx_er = 1'b0;\nassign gmii_1_tx_er = 1'b0;\nassign gmii_2_tx_er = 1'b0;\nassign gmii_3_tx_er = 1'b0;\npci pci_inst (\n\t.sys_rst(reset),\n\t.pci_clk(PCLK2),\n\t.AD_IO(AD_IO),\n\t.AD_HIZ(AD_HIZ),\n\t.CBE_IO(CBE_IO),\n\t.CBE_HIZ(CBE_HIZ),\n\t.PAR_IO(PAR_IO),\n\t.PAR_HIZ(PAR_HIZ),\n\t.FRAME_IO(FRAME_IO),\n\t.FRAME_HIZ(FRAME_HIZ),\n\t.TRDY_IO(TRDY_IO),\n\t.TRDY_HIZ(TRDY_HIZ),\n\t.IRDY_IO(IRDY_IO),\n\t.IRDY_HIZ(IRDY_HIZ),\n\t.STOP_IO(STOP_IO),\n\t.STOP_HIZ(STOP_HIZ),\n\t.DEVSEL_IO(DEVSEL_IO),\n\t.DEVSEL_HIZ(DEVSEL_HIZ),\n\t.IDSEL_I(IDSEL_I),\n\t.INTA_O(INTA_O),\n\t.PERR_IO(PERR_IO),\n\t.PERR_HIZ(PERR_HIZ),\n\t.SERR_IO(SERR_IO),\n\t.SERR_HIZ(SERR_HIZ),\n\t.REQ_O(REQ_O),\n\t.GNT_I(GNT_I),\n\t.cpci_id(cpci_id),\n\t.PASS_REQ(PASS_REQ),\n\t.PASS_READY(PASS_READY),\n\t.cpci_debug_data(cpci_debug_data),\n\t.tx0_enable(tx0_enable),\n\t.tx0_ipv6(tx0_ipv6),\n\t.tx0_fullroute(tx0_fullroute),\n\t.tx0_req_arp(tx0_req_arp),\n\t.tx0_frame_len(tx0_frame_len),\n\t.tx0_inter_frame_gap(tx0_inter_frame_gap),\n\t.tx0_ipv4_srcip(tx0_ipv4_srcip),\n\t.tx0_src_mac(tx0_src_mac),\n\t.tx0_ipv4_gwip(tx0_ipv4_gwip),\n\t.tx0_ipv6_srcip(tx0_ipv6_srcip),\n\t.tx0_ipv6_dstip(tx0_ipv6_dstip),\n\t.tx0_dst_mac(tx0_dst_mac),\n\t.tx0_ipv4_dstip(tx0_ipv4_dstip),\n\t.tx0_pps(tx0_pps),\n\t.tx0_throughput(tx0_throughput),\n\t.tx0_ipv4_ip(tx0_ipv4_ip),\n\t.rx1_pps(rx1_pps),\n\t.rx1_throughput(rx1_throughput),\n\t.rx1_latency(rx1_latency),\n\t.rx1_ipv4_ip(rx1_ipv4_ip),\n\t.rx2_pps(rx2_pps),\n\t.rx2_throughput(rx2_throughput),\n\t.rx2_latency(rx2_latency),\n\t.rx2_ipv4_ip(rx2_ipv4_ip),\n\t.rx3_pps(rx3_pps),\n\t.rx3_throughput(rx3_throughput),\n\t.rx3_latency(rx3_latency),\n\t.rx3_ipv4_ip(rx3_ipv4_ip)\n);\n`ifdef DEBUG\nwire [35 : 0] CONTROL;\nwire [ 7: 0] TRIG;\nwire [31: 0] DATA;\ncs_icon INST_ICON (\n        .CONTROL0(CONTROL)\n);\ncs_ila INST_ILA (\n        .CLK(rgmii_1_rxc),\n        .CONTROL(CONTROL),\n        .TRIG0(TRIG),\n        .DATA(DATA)\n);\nassign DATA[7:0]    = gmii_0_rxd[7:0];\nassign DATA[8]      = gmii_0_rx_dv;\nassign DATA[9]      = gmii_0_rx_er;\nassign DATA[10]     = gmii_0_link;\nassign DATA[12:11]  = gmii_0_speed[1:0];\nassign DATA[13]     = gmii_0_duplex;\nassign DATA[23:16]  = gmii_1_rxd[7:0];\nassign DATA[26]     = gmii_1_link;\nassign DATA[28:27]  = gmii_1_speed[1:0];\nassign DATA[29]     = gmii_1_duplex;\nassign DATA[31:30]  = 2'h0;\nassign TRIG[0]      = gmii_0_rx_dv;\n`endif\nendmodule"}
{"task_id": 1069, "completion": "output Y   ;\n    input  A   ;\n    input  B   ;\n    input  C   ;\n    input  D_N ;\n    input  VPWR;\n    input  VGND;\n    input  VPB ;\n    input  VNB ;\n\n    wire not0_out         ;\n    wire nor0_out_Y       ;\n    wire pwrgood_pp0_out_Y;\n\n    not                                not0        (not0_out         , D_N                   );\n    nor                                nor0        (nor0_out_Y       , A, B, C, not0_out     );\n    sky130_fd_sc_lp__udp_pwrgood_pp$PG pwrgood_pp0 (pwrgood_pp0_out_Y, nor0_out_Y, VPWR, VGND);\n    buf                                buf0        (Y                , pwrgood_pp0_out_Y     );\n\nendmodule"}
{"task_id": 1014, "completion": "wire eqbit, gtbit, ltbit;\n   wire eqdbbit, gtdbbit, ltdbbit;\n   wire negative_is_allowed = SW[9];\n   reg unsigned [2*n-1:0] x, y;\n   reg x_negative, y_negative;\n\n   always @(SW)\n   begin: switchAssignments\n\t\tx[0] = SW[4];\n\t\tx[1] = SW[5];\n\t\tx[2] = SW[6];\n\t\tx[3] = SW[7];\n\t\ty[0] = SW[0];\n\t\ty[1] = SW[1];\n\t\ty[2] = SW[2];\n\t\ty[3] = SW[3];\n\n\t\tif (x_negative)\n\t\t\tx = ~x + 4'b0001;\n\t\tif (y_negative)\n\t\t\ty = ~y + 4'b0001;\n   end\n\n   assign status_leds[9] = negative_is_allowed;\n   assign status_leds[8] = 1'b0;\n\n   always @(negative_is_allowed, SW)\n   begin: determineNegative\n\t\tx_negative = SW[7] & negative_is_allowed;\n\t\ty_negative = SW[3] & negative_is_allowed;\n   end\n\n   wire [n:0] eqcarry, gtcarry, ltcarry;\n   assign eqcarry[0] = 1;\n   assign gtcarry[0] = 0;\n   assign ltcarry[0] = 0;\n\n   generate\n      genvar k;\n      for (k = 0; k < 2*n; k = k + 2)\n      begin: comparestage\n\t\tdoublencomparator dnc((x[2*n-1-k]), (x[2*n-2-k]), (y[2*n-1-k]), (y[2*n-2-k]),\n\t\t     (eqcarry[k/2]), (gtcarry[k/2]), (ltcarry[k/2]),\n\t\t     (eqcarry[k/2+1]), (gtcarry[k/2+1]), (ltcarry[k/2+1]);\n      end\n   endgenerate\n\n   assign eqbit = eqcarry[n] & ~(x_negative ^ y_negative);\n   assign gtbit = ((~gtcarry[n] & y_negative) | (gtcarry[n] & ~x_negative)) & ~eqbit;\n   assign ltbit = ~(eqbit | gtbit);\n\n   assign status_leds[7] = eqbit;\n   assign status_leds[6] = gtbit;\n\tassign status_leds[5] = ltbit;\n\n   seg7 hex2(.bnum(x), .led(seg7_2));\n   seg7 hex0(.bnum(y), .led(seg7_0));\n   assign seg7_3[0:5] = 6'b111111;\n   assign seg7_1[0:5] = 6'b111111;\n   assign seg7_3[6] = ~x_negative;\n   assign seg7_1[6] = ~y_negative;\n\n   assign eqdbbit = (x == y) & (x_negative == y_negative);\n   assign gtdbbit = ((~(x > y) & y_negative) | ((x > y) & ~x_negative)) & ~eqdbbit;\n   assign ltdbbit = ~(eqdbbit | gtdbbit);\n   assign status_leds[3] = eqdbbit;\n   assign status_leds[2] = gtdbbit;\n   assign status_leds[1] = ltdbbit;\n   assign status_leds[0] = {eqdbbit, gtdbbit, ltdbbit} == {eqbit, gtbit, ltbit};\nendmodule"}
{"task_id": 1033, "completion": "output TTC0_WAVE0_OUT;\n  output TTC0_WAVE1_OUT;\n  output TTC0_WAVE2_OUT;\n  output [1:0]USB0_PORT_INDCTL;\n  output USB0_VBUS_PWRSELECT;\n  input USB0_VBUS_PWRFAULT;\n  output M_AXI_GP0_ARVALID;\n  output M_AXI_GP0_AWVALID;\n  output M_AXI_GP0_BREADY;\n  output M_AXI_GP0_RREADY;\n  output M_AXI_GP0_WLAST;\n  output M_AXI_GP0_WVALID;\n  output [11:0]M_AXI_GP0_ARID;\n  output [11:0]M_AXI_GP0_AWID;\n  output [11:0]M_AXI_GP0_WID;\n  output [1:0]M_AXI_GP0_ARBURST;\n  output [1:0]M_AXI_GP0_ARLOCK;\n  output [2:0]M_AXI_GP0_ARSIZE;\n  output [1:0]M_AXI_GP0_AWBURST;\n  output [1:0]M_AXI_GP0_AWLOCK;\n  output [2:0]M_AXI_GP0_AWSIZE;\n  output [2:0]M_AXI_GP0_ARPROT;\n  output [2:0]M_AXI_GP0_AWPROT;\n  output [31:0]M_AXI_GP0_ARADDR;\n  output [31:0]M_AXI_GP0_AWADDR;\n  output [31:0]M_AXI_GP0_WDATA;\n  output [3:0]M_AXI_GP0_ARCACHE;\n  output [3:0]M_AXI_GP0_ARLEN;\n  output [3:0]M_AXI_GP0_ARQOS;\n  output [3:0]M_AXI_GP0_AWCACHE;\n  output [3:0]M_AXI_GP0_AWLEN;\n  output [3:0]M_AXI_GP0_AWQOS;\n  output [3:0]M_AXI_GP0_WSTRB;\n  input M_AXI_GP0_ACLK;\n  input M_AXI_GP0_ARREADY;\n  input M_AXI_GP0_AWREADY;\n  input M_AXI_GP0_BVALID;\n  input M_AXI_GP0_RLAST;\n  input M_AXI_GP0_RVALID;\n  input M_AXI_GP0_WREADY;\n  input [11:0]M_AXI_GP0_BID;\n  input [11:0]M_AXI_GP0_RID;\n  input [1:0]M_AXI_GP0_BRESP;\n  input [1:0]M_AXI_GP0_RRESP;\n  input [31:0]M_AXI_GP0_RDATA;\n  output FCLK_CLK0;\n  output FCLK_RESET0_N;\n  inout [53:0]MIO;\n  inout DDR_CAS_n;\n  inout DDR_CKE;\n  inout DDR_Clk_n;\n  inout DDR_Clk;\n  inout DDR_CS_n;\n  inout DDR_DRSTB;\n  inout DDR_ODT;\n  inout DDR_RAS_n;\n  inout DDR_WEB;\n  inout [2:0]DDR_BankAddr;\n  inout [14:0]DDR_Addr;\n  inout DDR_VRN;\n  inout DDR_VRP;\n  inout [3:0]DDR_DM;\n  inout [31:0]DDR_DQ;\n  inout [3:0]DDR_DQS_n;\n  inout [3:0]DDR_DQS;\n  inout PS_SRSTB;\n  inout PS_CLK;\n  inout PS_PORB;\nendmodule"}
{"task_id": 1072, "completion": "wire [31:0] spi_data;    wire spi_ready;    // SPI \u64cd\u4f5c\u548c AXI \u64cd\u4f5c\u7684\u5b9e\u73b0\u903b\u8f91    // \u82e5\u8981\u5b9e\u73b0\u5177\u4f53\u7684\u8bfb\u5199\u903b\u8f91\uff0c\u8bf7\u6dfb\u52a0\u5bf9\u5e94\u7684\u4ee3\u7801\u3002endmodule"}
{"task_id": 1082, "completion": "assign reset = ~locked;endmodule"}
{"task_id": 1044, "completion": "wire and0_out;\n    wire and1_out;\n    wire or0_out_X;\n    wire pwrgood_pp0_out_X;\n\n    and and0 (and0_out, A3, A1, A2);\n    and and1 (and1_out, B1, B2);\n    or or0 (or0_out_X, and1_out, and0_out);\n    sky130_fd_sc_hd__udp_pwrgood_pp$PG pwrgood_pp0 (pwrgood_pp0_out_X, or0_out_X, VPWR, VGND);\n    buf buf0 (X, pwrgood_pp0_out_X);\n\nendmodule"}
{"task_id": 1079, "completion": "wire buf_Q  ;\n    wire RESET  ;\n    wire mux_out;\n\n    not                                             not0      (RESET  , RESET_B                          );\n    sky130_fd_sc_hd__udp_mux_2to1                   mux_2to10 (mux_out, D, SCD, SCE                      );\n    sky130_fd_sc_hd__udp_dff$PR_pp$PG$N `UNIT_DELAY dff0      (buf_Q  , mux_out, CLK, RESET, , VPWR, VGND);\n    buf                                             buf0      (Q      , buf_Q                            );\n\nendmodule"}
{"task_id": 1071, "completion": "// Wires and registers for LFSR implementation\n    reg [LFSR_WIDTH-1:0] lfsr;\n    wire feedback;\n\n    // Feedback calculation based on the polynomial\n    assign feedback = ^(lfsr & LFSR_POLY);\n\n    // LFSR operation\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            lfsr <= LFSR_INIT;\n        end else begin\n            lfsr <= {lfsr[LFSR_WIDTH-2:0], feedback};\n        end\n    end\n\n    // Data output calculation\n    assign data_out = (INVERT) ? ~lfsr[DATA_WIDTH-1:0] : lfsr[DATA_WIDTH-1:0];\n\nendmodule"}
{"task_id": 1093, "completion": "supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\nendmodule"}
{"task_id": 1090, "completion": "output Y   ;\n    input  A1  ;\n    input  A2  ;\n    input  B1  ;\n    input  VPWR;\n    input  VGND;\n    input  VPB ;\n    input  VNB ;\n\n    // Local signals\n    wire or0_out          ;\n    wire nand0_out_Y      ;\n    wire pwrgood_pp0_out_Y;\n\n    //                                 Name         Output             Other arguments\n    or                                 or0         (or0_out          , A2, A1                 );\n    nand                               nand0       (nand0_out_Y      , B1, or0_out            );\n    sky130_fd_sc_hd__udp_pwrgood_pp$PG pwrgood_pp0 (pwrgood_pp0_out_Y, nand0_out_Y, VPWR, VGND);\n    buf                                buf0        (Y                , pwrgood_pp0_out_Y      );\n\nendmodule"}
{"task_id": 984, "completion": "localparam [24-1:0] C_DOUBLE_LEN       = 24'b0000_0000_0000_0000_1111_1111;\n    reg                             first_word;\n    reg  [C_S_AXI_BYTES_LOG-1:0]    current_word_1;\n    reg  [C_S_AXI_BYTES_LOG-1:0]    current_word;\n    wire [C_S_AXI_BYTES_LOG-1:0]    current_word_adjusted;\n    wire [C_RATIO_LOG-1:0]          current_index;\n    wire                            last_beat;\n    wire                            last_word;\n    reg  [C_S_AXI_BYTES_LOG-1:0]    size_mask;\n    wire [C_S_AXI_BYTES_LOG-1:0]    next_word;\n    reg                             first_mi_word;\n    reg  [8-1:0]                    length_counter_1;\n    reg  [8-1:0]                    length_counter;\n    wire [8-1:0]                    next_length_counter;\n    wire                            word_completed;\n    wire                            cmd_ready_i;\n    wire                            pop_mi_data;\n    wire                            mi_stalling;\n    wire                            S_AXI_WREADY_I;\n    wire [C_M_AXI_DATA_WIDTH-1:0]   M_AXI_WDATA_I;\n    wire [C_M_AXI_DATA_WIDTH/8-1:0] M_AXI_WSTRB_I;\n    wire                            M_AXI_WLAST_I;\n    wire                            M_AXI_WVALID_I;\n    wire                            M_AXI_WREADY_I;\n    always @ *\n    begin\n      case (cmd_size)\n        3'b000: size_mask = C_DOUBLE_LEN[8 +: C_S_AXI_BYTES_LOG];\n        3'b001: size_mask = C_DOUBLE_LEN[7 +: C_S_AXI_BYTES_LOG];\n        3'b010: size_mask = C_DOUBLE_LEN[6 +: C_S_AXI_BYTES_LOG];\n        3'b011: size_mask = C_DOUBLE_LEN[5 +: C_S_AXI_BYTES_LOG];\n        3'b100: size_mask = C_DOUBLE_LEN[4 +: C_S_AXI_BYTES_LOG];\n        3'b101: size_mask = C_DOUBLE_LEN[3 +: C_S_AXI_BYTES_LOG];\n        3'b110: size_mask = C_DOUBLE_LEN[2 +: C_S_AXI_BYTES_LOG];\n        3'b111: size_mask = C_DOUBLE_LEN[1 +: C_S_AXI_BYTES_LOG];\n      endcase\n    end\n    assign word_completed = ( cmd_fix ) |\n                            ( cmd_mirror ) |\n                            ( ~cmd_fix & ( ( next_word & size_mask ) == {C_S_AXI_BYTES_LOG{1'b0}} ) ) | \n                            ( ~cmd_fix & last_word );\n    assign S_AXI_WREADY_I = cmd_valid & word_completed & M_AXI_WREADY_I;\n    assign S_AXI_WREADY   = S_AXI_WREADY_I;\n    assign M_AXI_WVALID_I = S_AXI_WVALID & cmd_valid;\n    assign pop_mi_data    = M_AXI_WVALID_I & M_AXI_WREADY_I;\n    assign cmd_ready_i    = cmd_valid & pop_mi_data & last_word;\n    assign cmd_ready      = cmd_ready_i;\n    assign mi_stalling    = M_AXI_WVALID_I & ~M_AXI_WREADY_I;\n    always @ *\n    begin\n      if ( first_word | cmd_fix )\n        current_word = cmd_first_word;\n      else\n        current_word = current_word_1;\n    end\n    assign next_word              = ( current_word + cmd_step ) & cmd_mask;\n    assign current_word_adjusted  = current_word + cmd_offset;\n    assign current_index          = current_word_adjusted[C_S_AXI_BYTES_LOG-C_RATIO_LOG +: C_RATIO_LOG];\n    always @ (posedge ACLK) begin\n      if (ARESET) begin\n        first_word      <= 1'b1;\n        current_word_1  <= 'b0;\n      end else begin\n        if ( pop_mi_data ) begin\n          if ( M_AXI_WLAST_I ) begin\n            first_word      <=  1'b1;\n          end else begin\n            first_word      <=  1'b0;\n          end\n          current_word_1  <= next_word;\n        end\n      end\n    end\n    always @ *\n    begin\n      if ( first_mi_word )\n        length_counter = cmd_length;\n      else\n        length_counter = length_counter_1;\n    end\n    assign next_length_counter = length_counter - 1'b1;\n    always @ (posedge ACLK) begin\n      if (ARESET) begin\n        first_mi_word    <= 1'b1;\n        length_counter_1 <= 8'b0;\n      end else begin\n        if ( pop_mi_data ) begin\n          if ( M_AXI_WLAST_I ) begin\n            first_mi_word    <= 1'b1;\n          end else begin\n            first_mi_word    <= 1'b0;\n          end\n          length_counter_1 <= next_length_counter;\n        end\n      end\n    end\n    assign last_beat = ( length_counter == 8'b0 );\n    assign last_word = ( last_beat );\n    assign M_AXI_WDATA_I  = S_AXI_WDATA[current_index * C_M_AXI_DATA_WIDTH   +: C_M_AXI_DATA_WIDTH];\n    assign M_AXI_WSTRB_I  = S_AXI_WSTRB[current_index * C_M_AXI_DATA_WIDTH/8 +: C_M_AXI_DATA_WIDTH/8];\n    assign M_AXI_WLAST_I  = last_word;\n    assign M_AXI_WDATA    = M_AXI_WDATA_I;\n    assign M_AXI_WSTRB    = M_AXI_WSTRB_I;\n    assign M_AXI_WLAST    = M_AXI_WLAST_I;\n    assign M_AXI_WVALID   = M_AXI_WVALID_I;\n    assign M_AXI_WREADY_I = M_AXI_WREADY;\nendmodule"}
{"task_id": 1001, "completion": "wire wb_ack_o;\n   wire [31:0] wb_dat_o;\n   wire wb_err_o;\n   wire int_o;\n\n   wire [7:0] data_o;\n   wire [3:0] bytes_free_o;\n   wire [3:0] bytes_available_o;\n   reg [7:0] data_in;\n   reg [7:0] rdata;\n   reg wen_tff;\n   reg ren_tff;\n   wire wb_fifo_ack;\n   wire [3:0] wr_bytes_free;\n   wire [3:0] rd_bytes_avail;\n   wire [3:0] wr_bytes_avail;\n   wire rd_bytes_avail_not_zero;\n   wire ren_sff_out;\n   wire [7:0] rd_fifo_data_out;\n   wire [7:0] data_to_wb;\n   wire [7:0] data_from_wb;\n   wire wr_fifo_not_empty;\n   wire rcvr_fifo_rst;\n   wire xmit_fifo_rst;\n   reg wda_rst;\n   reg wpp;\n   reg w_fifo_en;\n   reg ren_rst;\n   reg rdata_en;\n   reg rpp;\n   reg r_fifo_en;\n   reg r_wb_ack;\n   reg w_wb_ack;\n   wire wdata_avail;\n   wire wb_rd;\n   wire wb_wr;\n   wire pop;\n   wire rcz;\n   assign data_o = rdata;\n   always @ (posedge tck_i or posedge rst_i) begin\n     if(rst_i) wen_tff <= 1'b0;\n     else if(wr_strobe_i) wen_tff <= ~wen_tff;\n   end \n   always @ (posedge tck_i or posedge rst_i) begin\n     if(rst_i) ren_tff <= 1'b0;\n     else if(rd_strobe_i) ren_tff <= ~ren_tff;\n   end\n   always @ (posedge tck_i or posedge rst_i) begin\n     if(rst_i) data_in <= 8'h0;\n     else if(wr_strobe_i) data_in <= data_i;\n   end \n   assign rd_bytes_avail_not_zero = !(rd_bytes_avail == 4'h0);\n   assign pop = ren_sff_out & rd_bytes_avail_not_zero;\n   assign rcz = ~rd_bytes_avail_not_zero;\n   assign wb_fifo_ack = r_wb_ack | w_wb_ack;\n   assign wr_fifo_not_empty = !(wr_bytes_avail == 4'h0);\n   always @ (posedge wb_clk_i or posedge rst_i) begin\n     if(rst_i) rdata <= 8'h0;\n     else if(rdata_en) rdata <= rd_fifo_data_out;\n   end\n   syncflop wen_sff (\n      .DEST_CLK(wb_clk_i),\n      .D_SET(1'b0),\n      .D_RST(wda_rst),\n      .RESET(rst_i),\n      .TOGGLE_IN(wen_tff),\n      .D_OUT(wdata_avail)\n   );\n   syncflop ren_sff (\n      .DEST_CLK(wb_clk_i),\n      .D_SET(1'b0),\n      .D_RST(ren_rst),\n      .RESET(rst_i),\n      .TOGGLE_IN(ren_tff),\n      .D_OUT(ren_sff_out)\n   );\n   syncreg freespace_syncreg (\n      .CLKA(wb_clk_i),\n      .CLKB(tck_i),\n      .RST(rst_i),\n      .DATA_IN(wr_bytes_free),\n      .DATA_OUT(bytes_free_o)\n   );\n   syncreg bytesavail_syncreg (\n      .CLKA(wb_clk_i),\n      .CLKB(tck_i),\n      .RST(rst_i),\n      .DATA_IN(rd_bytes_avail),\n      .DATA_OUT(bytes_available_o)\n   );\n   bytefifo wr_fifo (\n      .CLK(wb_clk_i),\n      .RST(rst_i | rcvr_fifo_rst),\n      .DATA_IN(data_in),\n      .DATA_OUT(data_to_wb),\n      .PUSH_POPn(wpp),\n      .EN(w_fifo_en),\n      .BYTES_AVAIL(wr_bytes_avail),\n      .BYTES_FREE(wr_bytes_free)\n   );\n   bytefifo rd_fifo (\n      .CLK(wb_clk_i),\n      .RST(rst_i | xmit_fifo_rst),\n      .DATA_IN(data_from_wb),\n      .DATA_OUT(rd_fifo_data_out),\n      .PUSH_POPn(rpp),\n      .EN(r_fifo_en),\n      .BYTES_AVAIL(rd_bytes_avail),\n      .BYTES_FREE()\n   );\n   reg [1:0] rd_fsm_state;\n   reg [1:0] next_rd_fsm_state;\n   `define STATE_RD_IDLE 2'h0\n   `define STATE_RD_PUSH 2'h1\n   `define STATE_RD_POP 2'h2\n   `define STATE_RD_LATCH 2'h3\n   always @ (posedge wb_clk_i or posedge rst_i) begin\n     if(rst_i) rd_fsm_state <= `STATE_RD_IDLE;\n     else rd_fsm_state <= next_rd_fsm_state; \n   end\n   always @ (rd_fsm_state or wb_wr or pop or rcz) begin\n     case (rd_fsm_state)\n       `STATE_RD_IDLE: begin\n         if(wb_wr) next_rd_fsm_state <= `STATE_RD_PUSH;\n         else if (pop) next_rd_fsm_state <= `STATE_RD_POP;\n         else next_rd_fsm_state <= `STATE_RD_IDLE;\n       end\n       `STATE_RD_PUSH: begin\n         if(rcz) next_rd_fsm_state <= `STATE_RD_LATCH;\n         else if(pop) next_rd_fsm_state <= `STATE_RD_POP;\n         else next_rd_fsm_state <= `STATE_RD_IDLE;\n       end\n       `STATE_RD_POP: begin\n         next_rd_fsm_state <= `STATE_RD_LATCH;\n       end\n       `STATE_RD_LATCH: begin\n         if(wb_wr) next_rd_fsm_state <= `STATE_RD_PUSH;\n         else if(pop) next_rd_fsm_state <= `STATE_RD_POP;\n         else next_rd_fsm_state <= `STATE_RD_IDLE;\n       end\n       default: begin\n         next_rd_fsm_state <= `STATE_RD_IDLE;\n       end\n     endcase\n   end\n   always @ (rd_fsm_state) begin\n     ren_rst <= 1'b0;\n     rpp <= 1'b0;\n     r_fifo_en <= 1'b0;\n     rdata_en <= 1'b0;\n     r_wb_ack <= 1'b0;\n     case (rd_fsm_state)\n       `STATE_RD_IDLE:;\n       `STATE_RD_PUSH: begin\n         rpp <= 1'b1;\n         r_fifo_en <= 1'b1;\n         r_wb_ack <= 1'b1;\n       end\n       `STATE_RD_POP: begin\n         ren_rst <= 1'b1;\n         r_fifo_en <= 1'b1;\n       end\n       `STATE_RD_LATCH: begin\n         rdata_en <= 1'b1;\n       end\n     endcase\n   end\n   reg [1:0] wr_fsm_state;\n   reg [1:0] next_wr_fsm_state;\n   `define STATE_WR_IDLE 2'h0\n   `define STATE_WR_PUSH 2'h1\n   `define STATE_WR_POP 2'h2\n   always @ (posedge wb_clk_i or posedge rst_i) begin\n     if(rst_i) wr_fsm_state <= `STATE_WR_IDLE;\n     else wr_fsm_state <= next_wr_fsm_state; \n   end\n   always @ (wr_fsm_state or wb_rd or wdata_avail) begin\n     case (wr_fsm_state)\n       `STATE_WR_IDLE: begin\n         if(wb_rd) next_wr_fsm_state <= `STATE_WR_POP;\n         else if (wdata_avail) next_wr_fsm_state <= `STATE_WR_PUSH;\n         else next_wr_fsm_state <= `STATE_WR_IDLE;\n       end\n       `STATE_WR_PUSH: begin\n         if(wb_rd) next_wr_fsm_state <= `STATE_WR_POP;\n         else next_wr_fsm_state <= `STATE_WR_IDLE;\n       end\n       `STATE_WR_POP: begin\n         if(wdata_avail) next_wr_fsm_state <= `STATE_WR_PUSH;\n         else next_wr_fsm_state <= `STATE_WR_IDLE;\n       end\n       default: begin\n         next_wr_fsm_state <= `STATE_WR_IDLE;\n       end\n     endcase\n   end\n   always @ (wr_fsm_state) begin\n     wda_rst <= 1'b0;\n     wpp <= 1'b0;\n     w_fifo_en <= 1'b0;\n     w_wb_ack <= 1'b0;\n     case (wr_fsm_state)\n       `STATE_WR_IDLE:;\n       `STATE_WR_PUSH: begin\n         wda_rst <= 1'b1;\n         wpp <= 1'b1;\n         w_fifo_en <= 1'b1;\n       end\n       `STATE_WR_POP: begin\n         w_wb_ack <= 1'b1;\n         w_fifo_en <= 1'b1;\n       end\n     endcase\n   end\n   wire [31:0] bus_data_lo;\n   wire [31:0] bus_data_hi;\n   wire wb_reg_ack;\n   wire rd_fifo_not_full;\n   reg [2:0] iir_gen;\n   wire rd_fifo_becoming_empty;\n   reg reg_dlab_bit;\n   reg [3:0] reg_ier;\n   wire [2:0] reg_iir;\n   reg thr_int_arm;\n   wire [7:0] reg_lsr;\n   wire reg_dlab_bit_wren;\n   wire reg_ier_wren;\n   wire reg_iir_rden;\n   wire [7:0] reg_lcr;\n   wire reg_fcr_wren;\n   wire [7:0] reg_mcr;\n   wire [7:0] reg_msr;\n   wire [7:0] reg_scr;\n   wire fifo_access;\n   assign fifo_access = !wb_adr_i[2] & wb_sel_i[3];\n   assign wb_rd = wb_cyc_i & wb_stb_i & (~wb_we_i) & fifo_access & (~reg_dlab_bit);\n   assign wb_wr = wb_cyc_i & wb_stb_i & wb_we_i & fifo_access & (~reg_dlab_bit);\n   assign wb_ack_o = wb_fifo_ack | wb_reg_ack;\n   assign wb_err_o = 1'b0;\n   assign reg_mcr = 8'h00;\n   assign reg_msr = 8'hB0;\n   assign reg_scr = 8'h00;\n   assign rd_fifo_not_full = !(rd_bytes_avail == 4'h8);\n   assign reg_lcr = {reg_dlab_bit, 7'h03};\n   assign reg_lsr = {1'b0, rd_fifo_not_full, rd_fifo_not_full, 4'b0000, wr_fifo_not_empty};\n   assign reg_dlab_bit_wren = wb_cyc_i & wb_stb_i & wb_we_i & wb_sel_i[0] & (wb_adr_i[2] == 1'b0);\n   assign reg_ier_wren = wb_cyc_i & wb_stb_i & wb_we_i & wb_sel_i[2] & (wb_adr_i[2] == 1'b0) & (~reg_dlab_bit);\n   assign reg_iir_rden = wb_cyc_i & wb_stb_i & (~wb_we_i) & wb_sel_i[1] & (wb_adr_i[2] == 1'b0);\n   assign wb_reg_ack = wb_cyc_i & wb_stb_i & (|wb_sel_i[3:0]) & (reg_dlab_bit | !fifo_access);\n   assign reg_fcr_wren = wb_cyc_i & wb_stb_i & wb_we_i & wb_sel_i[1] & (wb_adr_i[2] == 1'b0);\n   assign rcvr_fifo_rst = reg_fcr_wren & wb_dat_i[9];\n   assign xmit_fifo_rst = reg_fcr_wren & wb_dat_i[10];\n   always @ (posedge wb_clk_i) begin\n     if(wb_rst_i) reg_dlab_bit <= 1'b0;\n     else if(reg_dlab_bit_wren) reg_dlab_bit <= wb_dat_i[7];\n   end\n   always @ (posedge wb_clk_i) begin\n     if(wb_rst_i) reg_ier <= 4'h0;\n     else if(reg_ier_wren) reg_ier <= wb_dat_i[19:16];\n   end\n   assign rd_fifo_becoming_empty = r_fifo_en & (~rpp) & (rd_bytes_avail == 4'h1);\n   always @ (posedge wb_clk_i) begin\n     if(wb_rst_i) thr_int_arm <= 1'b0;\n     else if(wb_wr | rd_fifo_becoming_empty) thr_int_arm <= 1'b1;\n     else if(reg_iir_rden & (~wr_fifo_not_empty)) thr_int_arm <= 1'b0;\n   end\n   always @ (thr_int_arm or rd_fifo_not_full or wr_fifo_not_empty) begin\n     if(wr_fifo_not_empty) iir_gen <= 3'b100;\n     else if(thr_int_arm & rd_fifo_not_full) iir_gen <= 3'b010;\n     else iir_gen <= 3'b001;\n   end\n   assign reg_iir = iir_gen;\n   assign bus_data_lo = {data_to_wb, {4'b0000, reg_ier}, {5'b00000, reg_iir}, reg_lcr};\n   assign bus_data_hi = {reg_mcr, reg_lsr, reg_msr, reg_scr};\n   assign wb_dat_o = (wb_adr_i[2]) ? bus_data_hi : bus_data_lo;\n   assign data_from_wb = wb_dat_i[31:24];\n   assign int_o = (rd_fifo_not_full & thr_int_arm & reg_ier[1]) | (wr_fifo_not_empty & reg_ier[0]);\nendmodule"}
{"task_id": 1110, "completion": "supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\nendmodule"}
{"task_id": 1108, "completion": "output X   ;\n    input  A1  ;\n    input  A2  ;\n    input  B1  ;\n    input  VPWR;\n    input  VGND;\n    input  VPB ;\n    input  VNB ;\n    sky130_fd_sc_ms__a21o base (\n        .X(X),\n        .A1(A1),\n        .A2(A2),\n        .B1(B1),\n        .VPWR(VPWR),\n        .VGND(VGND),\n        .VPB(VPB),\n        .VNB(VNB)\n    );\n\nendmodule"}
{"task_id": 994, "completion": "reg  [C_DATA_WIDTH-1:0] reg_tdata;\nreg                     reg_tvalid;\nreg    [STRB_WIDTH-1:0] reg_tstrb;\nreg               [3:0] reg_tuser;\nreg                     reg_tlast;\nreg                     reg_tready;\n\nreg                     trn_in_packet;\nreg                     axi_in_packet;\nreg                     flush_axi;\nwire                    disable_trn;\nreg                     reg_disable_trn;\n\nwire                    axi_beat_live  = s_axis_tx_tvalid && s_axis_tx_tready;\nwire                    axi_end_packet = axi_beat_live && s_axis_tx_tlast;\n\ngenerate\n  if(C_DATA_WIDTH == 128) begin : td_DW_swap_128\n    assign trn_td = {reg_tdata[31:0],\n                     reg_tdata[63:32],\n                     reg_tdata[95:64],\n                     reg_tdata[127:96]};\n  end\n  else if(C_DATA_WIDTH == 64) begin : td_DW_swap_64\n    assign trn_td = {reg_tdata[31:0], reg_tdata[63:32]};\n  end\n  else begin : td_DW_swap_32\n    assign trn_td = reg_tdata;\n  end\nendgenerate\n\nassign trn_tsof = reg_tvalid && !trn_in_packet;\n\nalways @(posedge user_clk) begin\n  if(user_rst) begin\n    trn_in_packet <= #TCQ 1'b0;\n  end\n  else begin\n    if(trn_tsof && trn_tsrc_rdy && trn_tdst_rdy && !trn_teof) begin\n      trn_in_packet <= #TCQ 1'b1;\n    end\n    else if((trn_in_packet && trn_teof && trn_tsrc_rdy) || !trn_lnk_up) begin\n      trn_in_packet <= #TCQ 1'b0;\n    end\n  end\nend\n\nalways @(posedge user_clk) begin\n  if(user_rst) begin\n    axi_in_packet <= #TCQ 1'b0;\n  end\n  else begin\n    if(axi_beat_live && !s_axis_tx_tlast) begin\n      axi_in_packet <= #TCQ 1'b1;\n    end\n    else if(axi_beat_live) begin\n      axi_in_packet <= #TCQ 1'b0;\n    end\n  end\nend\n\ngenerate\n  if(C_PM_PRIORITY == \"TRUE\") begin : pm_priority_trn_flush\n    always @(posedge user_clk) begin\n      if(user_rst) begin\n        reg_disable_trn    <= #TCQ 1'b1;\n      end\n      else begin\n        if(!trn_lnk_up)\n        begin\n          reg_disable_trn  <= #TCQ 1'b1;\n        end\n        else if(!flush_axi && s_axis_tx_tready) begin\n          reg_disable_trn <= #TCQ 1'b0;\n        end\n      end\n    end\n    assign disable_trn = reg_disable_trn;\n  end\n  else begin : thrtl_ctl_trn_flush\n    always @(posedge user_clk) begin\n      if(user_rst) begin\n        reg_disable_trn    <= #TCQ 1'b0;\n      end\n      else begin\n        if(axi_in_packet && !trn_lnk_up && !axi_end_packet)\n        begin\n          reg_disable_trn  <= #TCQ 1'b1;\n        end\n        else if(axi_end_packet) begin\n          reg_disable_trn <= #TCQ 1'b0;\n        end\n      end\n    end\n    assign disable_trn = reg_disable_trn || !trn_lnk_up;\n  end\nendgenerate\n\ngenerate\n  if(C_DATA_WIDTH == 128) begin : tstrb_to_trem_128\n    wire   axi_DW_1    = reg_tstrb[7];\n    wire   axi_DW_2    = reg_tstrb[11];\n    wire   axi_DW_3    = reg_tstrb[15];\n    assign trn_trem[1] = axi_DW_2;\n    assign trn_trem[0] = axi_DW_3 || (axi_DW_1 && !axi_DW_2);\n  end\n  else if(C_DATA_WIDTH == 64) begin : tstrb_to_trem_64\n    assign trn_trem    = reg_tstrb[7];\n  end\n  else begin : tstrb_to_trem_32\n    assign trn_trem    = 1'b0;\n  end\nendgenerate\n\nassign trn_teof      = reg_tlast;\nassign trn_tecrc_gen = reg_tuser[0];\nassign trn_terrfwd   = reg_tuser[1];\nassign trn_tstr      = reg_tuser[2];\nassign trn_tsrc_dsc  = reg_tuser[3];\ngenerate\n  reg reg_tsrc_rdy;\n  if(C_PM_PRIORITY == \"FALSE\") begin : throttle_ctl_pipeline\n    always @(posedge user_clk) begin\n      if(user_rst) begin\n        reg_tdata        <= #TCQ {C_DATA_WIDTH{1'b0}};\n        reg_tvalid       <= #TCQ 1'b0;\n        reg_tstrb        <= #TCQ {STRB_WIDTH{1'b0}};\n        reg_tlast        <= #TCQ 1'b0;\n        reg_tuser        <= #TCQ 4'h0;\n        reg_tsrc_rdy     <= #TCQ 1'b0;\n      end\n      else begin\n        reg_tdata        <= #TCQ s_axis_tx_tdata;\n        reg_tvalid       <= #TCQ s_axis_tx_tvalid;\n        reg_tstrb        <= #TCQ s_axis_tx_tstrb;\n        reg_tlast        <= #TCQ s_axis_tx_tlast;\n        reg_tuser        <= #TCQ s_axis_tx_tuser;\n        reg_tsrc_rdy     <= #TCQ axi_beat_live && !disable_trn;\n      end\n    end\n    assign trn_tsrc_rdy = reg_tsrc_rdy;\n    assign s_axis_tx_tready = tready_thrtl;\n  end\n  else begin : pm_prioity_pipeline\n    reg  [C_DATA_WIDTH-1:0] tdata_prev;\n    reg                     tvalid_prev;\n    reg    [STRB_WIDTH-1:0] tstrb_prev;\n    reg                     tlast_prev;\n    reg               [3:0] tuser_prev;\n    reg                     reg_tdst_rdy;\n    wire                    data_hold;\n    reg                     data_prev;\n    always @(posedge user_clk) begin\n      if(user_rst) begin\n        tdata_prev   <= #TCQ {C_DATA_WIDTH{1'b0}};\n        tvalid_prev  <= #TCQ 1'b0;\n        tstrb_prev   <= #TCQ {STRB_WIDTH{1'b0}};\n        tlast_prev   <= #TCQ 1'b0;\n        tuser_prev   <= #TCQ 4'h 0;\n      end\n      else begin\n        if(!s_axis_tx_tready) begin\n          tdata_prev   <= #TCQ tdata_prev;\n          tvalid_prev  <= #TCQ tvalid_prev;\n          tstrb_prev   <= #TCQ tstrb_prev;\n          tlast_prev   <= #TCQ tlast_prev;\n          tuser_prev   <= #TCQ tuser_prev;\n        end\n        else begin\n          tdata_prev   <= #TCQ s_axis_tx_tdata;\n          tvalid_prev  <= #TCQ s_axis_tx_tvalid;\n          tstrb_prev   <= #TCQ s_axis_tx_tstrb;\n          tlast_prev   <= #TCQ s_axis_tx_tlast;\n          tuser_prev   <= #TCQ s_axis_tx_tuser;\n        end\n      end\n    end\n    always @(posedge user_clk) begin\n      if(user_rst) begin\n        reg_tdata  <= #TCQ {C_DATA_WIDTH{1'b0}};\n        reg_tvalid <= #TCQ 1'b0;\n        reg_tstrb  <= #TCQ {STRB_WIDTH{1'b0}};\n        reg_tlast  <= #TCQ 1'b0;\n        reg_tuser  <= #TCQ 4'h0;\n        reg_tdst_rdy <= #TCQ 1'b0;\n      end\n      else begin\n        reg_tdst_rdy <= #TCQ trn_tdst_rdy;\n        if(!data_hold) begin\n          if(data_prev) begin\n            reg_tdata  <= #TCQ tdata_prev;\n            reg_tvalid <= #TCQ tvalid_prev;\n            reg_tstrb  <= #TCQ tstrb_prev;\n            reg_tlast  <= #TCQ tlast_prev;\n            reg_tuser  <= #TCQ tuser_prev;\n          end\n          else begin\n            reg_tdata  <= #TCQ s_axis_tx_tdata;\n            reg_tvalid <= #TCQ s_axis_tx_tvalid;\n            reg_tstrb  <= #TCQ s_axis_tx_tstrb;\n            reg_tlast  <= #TCQ s_axis_tx_tlast;\n            reg_tuser  <= #TCQ s_axis_tx_tuser;\n          end\n        end\n      end\n    end\n    assign data_hold = trn_tsrc_rdy && !trn_tdst_rdy;\n    always @(posedge user_clk) begin\n      if(user_rst) begin\n        data_prev <= #TCQ 1'b0;\n      end\n      else begin\n        data_prev <= #TCQ data_hold;\n      end\n    end\n    assign trn_tsrc_rdy = reg_tvalid && !disable_trn;\n    always @(posedge user_clk) begin\n      if(user_rst) begin\n        reg_tready <= #TCQ 1'b0;\n      end\n      else begin\n        if(flush_axi && !axi_end_packet) begin\n          reg_tready <= #TCQ 1'b1;\n        end\n        else if(trn_lnk_up) begin\n          reg_tready <= #TCQ trn_tdst_rdy || !trn_tsrc_rdy;\n        end\n        else begin\n          reg_tready <= #TCQ 1'b0;\n        end\n      end\n    end\n    assign s_axis_tx_tready = reg_tready;\n  end\nendgenerate\nalways @(posedge user_clk) begin\n  if(user_rst) begin\n    flush_axi    <= #TCQ 1'b0;\n  end\n  else begin\n    if(axi_in_packet && !trn_lnk_up && !axi_end_packet) begin\n      flush_axi <= #TCQ 1'b1;\n    end\n    else if(axi_end_packet) begin\n      flush_axi <= #TCQ 1'b0;\n    end\n  end\nend\nendmodule"}
{"task_id": 1096, "completion": "wire ddc_scl_i;\n  wire ddc_scl_o;\n  wire ddc_scl_t;\n  wire ddc_sda_i;\n  wire ddc_sda_o;\n  wire ddc_sda_t;\n\n  IOBUF ddc_scl_iobuf\n       (.I(ddc_scl_o),\n        .IO(ddc_scl_io),\n        .O(ddc_scl_i),\n        .T(ddc_scl_t));\n  IOBUF ddc_sda_iobuf\n       (.I(ddc_sda_o),\n        .IO(ddc_sda_io),\n        .O(ddc_sda_i),\n        .T(ddc_sda_t));\n  design_1 design_1_i\n       (.DDC_scl_i(ddc_scl_i),\n        .DDC_scl_o(ddc_scl_o),\n        .DDC_scl_t(ddc_scl_t),\n        .DDC_sda_i(ddc_sda_i),\n        .DDC_sda_o(ddc_sda_o),\n        .DDC_sda_t(ddc_sda_t),\n        .TMDS_Clk_n(TMDS_Clk_n),\n        .TMDS_Clk_p(TMDS_Clk_p),\n        .TMDS_Data_n(TMDS_Data_n),\n        .TMDS_Data_p(TMDS_Data_p),\n        .clk_in1(clk_in1),\n        .hdmi_hpd(hdmi_hpd),\n        .hdmi_out_en(hdmi_out_en),\n        .led(led),\n        .reset(reset),\n        .vga_pBlue(vga_pBlue),\n        .vga_pGreen(vga_pGreen),\n        .vga_pHSync(vga_pHSync),\n        .vga_pRed(vga_pRed),\n        .vga_pVSync(vga_pVSync));\nendmodule"}
{"task_id": 1092, "completion": "// \u72b6\u6001\u673a\u3001\u4fe1\u53f7\u548c\u5bc4\u5b58\u5668\u58f0\u660e\n    // \u8d1f\u6307\u6570\u8ba1\u7b97\u903b\u8f91\n    // \u5904\u7406\u590d\u4f4d\u548c\u72b6\u6001\u6539\u53d8\u7684 always \u5757\n    // \u8fb9\u7f18\u89e6\u53d1\u7684\u8f93\u51fa\u66f4\u65b0\u903b\u8f91\n    // \u8c03\u8bd5\u4fe1\u606f\u751f\u6210\nendmodule"}
{"task_id": 638, "completion": "wire clk_200K_n;\n    wire clk_blf_n;\n    wire rst_for_cpu_crc16;\n    wire en_crc16_rpy;\n    wire clk_crc16_1;\n    wire clk_crc16_2;\n    wire clk_dr0;\n    wire en_cp_1;\n    wire en_cp_2;\n    wire clk_cp_1;\n    wire clk_cp_2;\n    wire en_prng_idol_for_clk;\n    wire clk_prng_idol;\n    wire clk_blf_for_tx;\n    wire clk_blf_half_for_tx;\n    wire clk_blf_quar_for_tx;\n    wire clk_blf_eigh_for_tx;\n\n    reg en_crc5_d;\n    reg en_crc16_d;\n    reg en_crc16_for_rpy_d;\n    reg [1:0]reply_complete_d;\n    reg clk_dr1;\n    reg [2:0]cnt_dr0_p;\n    reg [2:0]cnt_dr0_n;\n    reg clk_dr0_p;\n    reg clk_dr0_n;\n    reg [1:0]dr_d;\n    reg term_cp_1;\n    reg [1:0]en_2nd_clk_cp_d;\n    reg en_prng_idol_d;\n    reg bs_complete_d;\n    reg clk_blf_half;\n    reg clk_blf_quar;\n    reg clk_blf_eigh;\n    reg en_tx_d;\n    reg rd_complete_d;\n\n    always@(posedge clk_200K or negedge rst_n) begin\n        if(~rst_n) start_working <= 1'b0;\n        else start_working <= 1'b1;\n    end\n\n    assign rst_n = ~rst;\n\n    always@(negedge clk_dpie or negedge rst_n) begin\n        if(~rst_n) rst_for_new_package <= 1'b1;\n        else begin\n            if(~pie_code) rst_for_new_package <= 1'b0;\n            else rst_for_new_package <= 1'b1;\n        end\n    end\n\n    assign rst_for_cpu_crc16 = en_crc16_for_rpy & ~en_crc16_for_rpy_d;\n    assign rst_crc16 = rst_for_new_package & ~rst_for_cpu_crc16;\n\n    always@(negedge clk_dpie or negedge rst_n) begin\n        if(~rst_n) en_crc5_d <= 1'b0;\n        else en_crc5_d <= en_crc5;\n    end\n\n    assign clk_crc5 = en_crc5_d & clk_dpie;\n\n    always@(posedge clk_dpie or negedge rst_n) begin\n        if(~rst_n) en_crc16_d <= 1'b0;\n        else en_crc16_d <= en_crc16;\n    end\n\n    always@(negedge clk_frm or negedge rst_n) begin\n        if(~rst_n) en_crc16_for_rpy_d <= 1'b0;\n        else en_crc16_for_rpy_d <= en_crc16_for_rpy;\n    end\n\n    always@(negedge clk_frm or negedge rst_n) begin\n        if(~rst_n) reply_complete_d <= 2'b0;\n        else reply_complete_d <= {reply_complete_d[0], reply_complete};\n    end\n\n    assign en_crc16_rpy = en_crc16_for_rpy_d & ~reply_complete_d[1];\n\n    assign clk_crc16_1 = en_crc16_d & clk_dpie;\n\n    assign clk_crc16_2 = en_crc16_rpy & clk_frm;\n\n    assign clk_crc16 = en_crc16_for_rpy? clk_crc16_2 : clk_crc16_1;\n\n    always@(posedge clk_200K or negedge rst_n) begin\n        if(~rst_n) clk_dr1 <= 1'b0;\n        else begin\n            if(dr_d[1]) clk_dr1 <= ~clk_dr1;\n        end\n    end\n\n    assign clk_dr0 = clk_dr0_p | clk_dr0_n;\n\n    always@(posedge clk_200K or negedge rst_n) begin\n        if(~rst_n) cnt_dr0_p <= 3'b0;\n        else begin\n            if(~dr_d[1]) begin\n                if(cnt_dr0_p == 3'b100) cnt_dr0_p <= 3'b0;\n                else cnt_dr0_p <= cnt_dr0_p + 3'b1;\n            end\n        end\n    end\n\n    assign clk_200K_n = ~clk_200K;\n\n    always@(posedge clk_200K_n or negedge rst_n) begin\n        if(~rst_n) cnt_dr0_n <= 3'b0;\n        else begin\n            if(~dr_d[1]) begin\n                if(cnt_dr0_n == 3'b100) cnt_dr0_n <= 3'b0;\n                else cnt_dr0_n <= cnt_dr0_n + 3'b1;\n            end\n        end\n    end\n\n    always@(posedge clk_200K or negedge rst_n) begin\n        if(~rst_n) clk_dr0_p <= 1'b0;\n        else begin\n            if(~dr_d[1]) begin\n                if(cnt_dr0_p < 3'b010) clk_dr0_p <= 1'b1;\n                else clk_dr0_p <= 1'b0;\n            end\n        end\n    end\n\n    always@(posedge clk_200K_n or negedge rst_n) begin\n        if(~rst_n) clk_dr0_n <= 1'b0;\n        else begin\n            if(~dr_d[1]) begin\n                if(cnt_dr0_n < 3'b010) clk_dr0_n <= 1'b1;\n                else clk_dr0_n <= 1'b0;\n            end\n        end\n    end\n\n    always@(posedge clk_blf or negedge rst_n) begin\n        if(~rst_n) dr_d <= 0;\n        else dr_d <= {dr_d[0], dr};\n    end\n\n    assign clk_blf = dr_d[1]? clk_dr1 : clk_dr0;\n\n    assign clk_blf_n = ~clk_blf;\n\n    always@(posedge clk_blf_n or negedge rst_n) begin\n        if(~rst_n) term_cp_1 <= 1'b0;\n        else term_cp_1 <= packet_complete_sync;\n    end\n\n    assign en_cp_1 = packet_complete_sync & ~term_cp_1;\n\n    always@(posedge clk_blf_n or negedge rst_n) begin\n        if(~rst_n) en_2nd_clk_cp_d <= 2'b0;\n        else en_2nd_clk_cp_d <= {en_2nd_clk_cp_d[0], en_2nd_clk_cp};\n    end\n\n    assign en_cp_2 = ~en_2nd_clk_cp_d[1] & en_2nd_clk_cp_d[0];\n\n    assign clk_cp_1 = clk_blf & en_cp_1;\n\n    assign clk_cp_2 = clk_blf & en_cp_2;\n\n    assign clk_cp = clk_cp_1 | clk_cp_2;\n\n    always@(posedge clk_blf_n or negedge rst_n) begin\n        if(~rst_n) en_prng_idol_d <= 1'b0;\n        else en_prng_idol_d <= en_prng_idol;\n    end\n\n    assign clk_prng_idol = clk_blf & en_prng_idol_d;\n\n    assign clk_prng = start_working & (clk_prng_idol | en_prng_act);\n\n    always@(posedge clk_blf_n or negedge rst_n) begin\n        if(~rst_n) bs_complete_d <= 1'b0;\n        else bs_complete_d <= bs_complete;\n    end\n\n    always@(posedge clk_blf or negedge rst_n) begin\n        if(~rst_n) en_tx_d <= 1'b0;\n        else en_tx_d <= en_tx;\n    end\n\n    always@(posedge clk_blf or negedge rst_n) begin\n        if(~rst_n) clk_blf_half <= 1'b0;\n        else if(en_tx & (m == 2'b01 | m == 2'b10 | m == 2'b11)) clk_blf_half <= ~clk_blf_half;\n    end\n\n    always@(posedge clk_blf_half or negedge rst_n) begin\n        if(~rst_n) clk_blf_quar <= 1'b0;\n        else if(en_tx & (m == 2'b10 | m == 2'b11)) clk_blf_quar <= ~clk_blf_quar;\n    end\n\n    always@(posedge clk_blf_quar or negedge rst_n) begin\n        if(~rst_n) clk_blf_eigh <= 1'b0;\n        else if(en_tx & m == 2'b11) clk_blf_eigh <= ~clk_blf_eigh;\n    end\n\n    assign clk_blf_for_tx = clk_blf & en_tx_d & ~bs_complete_d;\n\n    assign clk_blf_half_for_tx = clk_blf_half & ~bs_complete_d;\n\n    assign clk_blf_quar_for_tx = clk_blf_quar & ~bs_complete_d;\n\n    assign clk_blf_eigh_for_tx = clk_blf_eigh & ~bs_complete_d;\n\n    always@(*) begin\n        if(en_tx) begin\n            case(m)\n                2'b00 : clk_frm = clk_blf_for_tx;\n                2'b01 : clk_frm = clk_blf_half_for_tx;\n                2'b10 : clk_frm = clk_blf_quar_for_tx;\n                2'b11 : clk_frm = clk_blf_eigh_for_tx;\n            endcase\n        end\n        else clk_frm = 1'b0;\n    end\n\n    assign clk_fm0 = (m == 2'b00)? clk_blf_for_tx : 1'b0;\n\n    always@(*) begin\n        if(en_tx) begin\n            case(m)\n                2'b00 : clk_mil = 1'b0;\n                2'b01 : clk_mil = clk_blf_for_tx;\n                2'b10 : clk_mil = clk_blf_half_for_tx;\n                2'b11 : clk_mil = clk_blf_quar_for_tx;\n            endcase\n        end\n        else clk_mil = 1'b0;\n    end\n\n    always@(negedge clk_frm or negedge rst_n) begin\n        if(~rst_n) rd_complete_d <= 1'b0;\n        else rd_complete_d <= rd_complete;\n    end\n\n    assign clk_if = clk_frm & en_if & ~rd_complete_d;\n\nendmodule"}
{"task_id": 1105, "completion": "reg busy;\n   wire clearbusy;\n   wire [`ADDR_LEN-1:0] effaddr;\n   wire killspec1;\n   reg dstval_latch;\n   reg [`RRF_SEL-1:0] rrftag_latch;\n   reg specbit_latch;\n   reg [`SPECTAG_LEN-1:0] spectag_latch;\n   reg [`DATA_LEN-1:0] lddatasb_latch;\n   reg hitsb_latch;\n   reg insnvalid_latch;\n   assign clearbusy = (killspec1 || dstval || (~dstval && ~fullsb)) ? 1'b1 : 1'b0;\n   assign killspec1 = ((spectag & spectagfix) != 0) && specbit && prmiss;\n   assign kill_speculative = ((spectag_latch & spectagfix) != 0) && specbit_latch && prmiss;\n   assign result = hitsb_latch ? lddatasb_latch : lddatamem;\n   assign rrf_we = dstval_latch & insnvalid_latch;\n   assign rob_we = insnvalid_latch;\n   assign wrrftag = rrftag_latch;\n   assign busy_next = clearbusy ? 1'b0 : busy;\n   assign stfin = ~killspec1 & busy & ~dstval;\n   assign memoccupy_ld = ~killspec1 & busy & dstval;\n   assign storedata = ex_src2;\n   assign storeaddr = effaddr;\n   assign ldaddr = effaddr;\n   assign effaddr = ex_src1 + imm;\n   always @ (posedge clk) begin\n      if (reset | killspec1 | ~busy | (~dstval & fullsb)) begin\n         dstval_latch <= 0;\n         rrftag_latch <= 0;\n         specbit_latch <= 0;\n         spectag_latch <= 0;\n         lddatasb_latch <= 0;\n         hitsb_latch <= 0;\n         insnvalid_latch <= 0;\n      end else begin\n         dstval_latch <= dstval;\n         rrftag_latch <= rrftag;\n         specbit_latch <= specbit;\n         spectag_latch <= spectag;\n         lddatasb_latch <= lddatasb;\n         hitsb_latch <= hitsb;\n         insnvalid_latch <= ~killspec1 & ((busy & dstval) |\n                                          (busy & ~dstval & ~fullsb));\n      end\n   end\n   always @ (posedge clk) begin\n      if (reset | killspec1) begin\n         busy <= 0;\n      end else begin\n         busy <= issue | busy_next;\n      end\n   end\nendmodule"}
{"task_id": 1068, "completion": "input  clk;  input  rst;  output  exception;  input  [31:0] input_timer;  input  input_timer_stb;  output input_timer_ack;  input  [31:0] input_rs232_rx;  input  input_rs232_rx_stb;  output input_rs232_rx_ack;  input  [31:0] input_ps2;  input  input_ps2_stb;  output input_ps2_ack;  input  [31:0] input_i2c;  input  input_i2c_stb;  output input_i2c_ack;  input  [31:0] input_switches;  input  input_switches_stb;  output input_switches_ack;  input  [31:0] input_eth_rx;  input  input_eth_rx_stb;  output input_eth_rx_ack;  input  [31:0] input_buttons;  input  input_buttons_stb;  output input_buttons_ack;  output [31:0] output_seven_segment_annode;  output output_seven_segment_annode_stb;  input  output_seven_segment_annode_ack;  output [31:0] output_eth_tx;  output output_eth_tx_stb;  input  output_eth_tx_ack;  output [31:0] output_rs232_tx;  output output_rs232_tx_stb;  input  output_rs232_tx_ack;  output [31:0] output_leds;  output output_leds_stb;  input  output_leds_ack;  output [31:0] output_audio;  output output_audio_stb;  input  output_audio_ack;  output [31:0] output_led_g;  output output_led_g_stb;  input  output_led_g_ack;  output [31:0] output_seven_segment_cathode;  output output_seven_segment_cathode_stb;  input  output_seven_segment_cathode_ack;  output [31:0] output_led_b;  output output_led_b_stb;  input  output_led_b_ack;  output [31:0] output_i2c;  output output_i2c_stb;  input  output_i2c_ack;  output [31:0] output_vga;  output output_vga_stb;  input  output_vga_ack;  output [31:0] output_led_r;  output output_led_r_stb;  input  output_led_r_ack;  wire   exception_139931283423456;  wire   exception_139931284928272;  wire   exception_139931283803816;  wire   exception_139931284095848;  wire   exception_139931280770256;  wire   exception_139931284093984;  wire   exception_139931280674968;  wire   exception_139931282495824;  wire   exception_139931280736200;  wire   exception_139931283075512;  wire   exception_139931279485624;  wire   exception_139931283398456;  wire   exception_139931279088024;  wire   exception_139931282371216;  wire   exception_139931278433672;  wire   exception_139931280813376;  main_0 main_0_139931283423456(    .clk(clk),    .rst(rst),    .exception(exception_139931283423456),    .input_ps2(input_ps2),    .input_ps2_stb(input_ps2_stb),    .input_ps2_ack(input_ps2_ack),    .input_rs232_rx(input_rs232_rx),    .input_rs232_rx_stb(input_rs232_rx_stb),    .input_rs232_rx_ack(input_rs232_rx_ack),    .output_rs232_tx(output_rs232_tx),    .output_rs232_tx_stb(output_rs232_tx_stb),    .output_rs232_tx_ack(output_rs232_tx_ack));  main_1 main_1_139931284928272(    .clk(clk),    .rst(rst),    .exception(exception_139931284928272),    .input_in(input_timer),    .input_in_stb(input_timer_stb),    .input_in_ack(input_timer_ack));  main_2 main_2_139931283803816(    .clk(clk),    .rst(rst),    .exception(exception_139931283803816),    .input_in(input_i2c),    .input_in_stb(input_i2c_stb),    .input_in_ack(input_i2c_ack));  main_3 main_3_139931284095848(    .clk(clk),    .rst(rst),    .exception(exception_139931284095848),    .input_in(input_switches),    .input_in_stb(input_switches_stb),    .input_in_ack(input_switches_ack));  main_4 main_4_139931280770256(    .clk(clk),    .rst(rst),    .exception(exception_139931280770256),    .input_in(input_eth_rx),    .input_in_stb(input_eth_rx_stb),    .input_in_ack(input_eth_rx_ack));  main_5 main_5_139931284093984(    .clk(clk),    .rst(rst),    .exception(exception_139931284093984),    .input_in(input_buttons),    .input_in_stb(input_buttons_stb),    .input_in_ack(input_buttons_ack));  main_6 main_6_139931280674968(    .clk(clk),    .rst(rst),    .exception(exception_139931280674968),    .output_out(output_seven_segment_annode),    .output_out_stb(output_seven_segment_annode_stb),    .output_out_ack(output_seven_segment_annode_ack));  main_7 main_7_139931282495824(    .clk(clk),    .rst(rst),    .exception(exception_139931282495824),    .output_out(output_eth_tx),    .output_out_stb(output_eth_tx_stb),    .output_out_ack(output_eth_tx_ack));  main_8 main_8_139931280736200(    .clk(clk),    .rst(rst),    .exception(exception_139931280736200),    .output_out(output_leds),    .output_out_stb(output_leds_stb),    .output_out_ack(output_leds_ack));  main_9 main_9_139931283075512(    .clk(clk),    .rst(rst),    .exception(exception_139931283075512),    .output_out(output_audio),    .output_out_stb(output_audio_stb),    .output_out_ack(output_audio_ack));  main_10 main_10_139931279485624(    .clk(clk),    .rst(rst),    .exception(exception_139931279485624),    .output_out(output_led_g),    .output_out_stb(output_led_g_stb),    .output_out_ack(output_led_g_ack));  main_11 main_11_139931283398456(    .clk(clk),    .rst(rst),    .exception(exception_139931283398456),    .output_out(output_seven_segment_cathode),    .output_out_stb(output_seven_segment_cathode_stb),    .output_out_ack(output_seven_segment_cathode_ack));  main_12 main_12_139931279088024(    .clk(clk),    .rst(rst),    .exception(exception_139931279088024),    .output_out(output_led_b),    .output_out_stb(output_led_b_stb),    .output_out_ack(output_led_b_ack));  main_13 main_13_139931282371216(    .clk(clk),    .rst(rst),    .exception(exception_139931282371216),    .output_out(output_i2c),    .output_out_stb(output_i2c_stb),    .output_out_ack(output_i2c_ack));  main_14 main_14_139931278433672(    .clk(clk),    .rst(rst),    .exception(exception_139931278433672),    .output_out(output_vga),    .output_out_stb(output_vga_stb),    .output_out_ack(output_vga_ack));  main_15 main_15_139931280813376(    .clk(clk),    .rst(rst),    .exception(exception_139931280813376),    .output_out(output_led_r),    .output_out_stb(output_led_r_stb),    .output_out_ack(output_led_r_ack));  assign exception = exception_139931283423456 || exception_139931284928272 || exception_139931283803816 || exception_139931284095848 || exception_139931280770256 || exception_139931284093984 || exception_139931280674968 || exception_139931282495824 || exception_139931280736200 || exception_139931283075512 || exception_139931279485624 || exception_139931283398456 || exception_139931279088024 || exception_139931282371216 || exception_139931278433672 || exception_139931280813376;endmodule"}
{"task_id": 1102, "completion": "reg [pARRAY_SIZE-1:0] buttonsReg0;\n  reg [pARRAY_SIZE-1:0] buttonsReg1;\n  reg [pARRAY_SIZE-1:0] buttonsReg2; \n  reg [23:0] debouncer;\n  reg [pARRAY_SIZE-1:0] buttonsDebounced;\n  reg [pARRAY_SIZE-1:0] buttonsDebouncedReg;\n  reg [pARRAY_SIZE-1:0] buttonTck;\n  integer I;\n\n  always@(posedge clk)\n  begin \n    buttonsReg0 <= buttons;\n    buttonsReg1 <= buttonsReg0;\n    buttonsReg2 <= buttonsReg1;\n    \n    if (buttonsReg2 != buttonsReg1) \n      begin \n        debouncer <= pDEBOUNCE_PERIOD/pCLKIN_PERIOD;\n      end \n    else if (debouncer != 0) \n      begin \n        debouncer <= debouncer - 1;\n      end\n    else begin\n      buttonsDebounced <= buttonsReg2;\n    end\n    \n    buttonsDebouncedReg <= buttonsDebounced;\n    \n    for(I = 0; I<pARRAY_SIZE; I = I + 1)\n    begin\n      if (pPOLARITY==0) begin \n        buttonDwTick[I] <= buttonsDebouncedReg[I] & (~buttonsDebounced[I]);\n        buttonUpTick[I] <= ~buttonsDebouncedReg[I] & buttonsDebounced[I];\n        end \n      else begin \n        buttonUpTick[I] <= buttonsDebouncedReg[I] & (~buttonsDebounced[I]);\n        buttonDwTick[I] <= ~buttonsDebouncedReg[I] & buttonsDebounced[I];\n      end \n    end \n    \n  end \n  \n  assign buttonTick   = buttonTck;\n  assign buttonState  = buttonsDebouncedReg;\n\nendmodule"}
{"task_id": 1087, "completion": "parameter point_width = 16;\n\ninput clk_i;\ninput rst_i;\n\ninput [7:0]  pixel_alpha_i;\n\ninput [point_width-1:0] x_counter_i;\ninput [point_width-1:0] y_counter_i;\ninput signed [point_width-1:0] z_i;\ninput [point_width-1:0] u_i;\ninput [point_width-1:0] v_i;\ninput [point_width-1:0] bezier_factor0_i;\ninput [point_width-1:0] bezier_factor1_i;\ninput                   bezier_inside_i;\ninput            [31:0] pixel_color_i;\ninput                   write_i;\ninput                   curve_write_i;\noutput reg              ack_o;\n\noutput reg [point_width-1:0] pixel_x_o;\noutput reg [point_width-1:0] pixel_y_o;\noutput reg signed [point_width-1:0] pixel_z_o;\noutput reg            [31:0] pixel_color_o;\noutput reg             [7:0] pixel_alpha_o;\noutput reg                   write_o;\ninput                        ack_i;\n\ninput              texture_ack_i;\ninput       [31:0] texture_data_i;\noutput      [31:2] texture_addr_o;\noutput reg  [ 3:0] texture_sel_o;\noutput reg         texture_request_o;\n\ninput                   texture_enable_i;\ninput            [31:2] tex0_base_i;\ninput [point_width-1:0] tex0_size_x_i;\ninput [point_width-1:0] tex0_size_y_i;\ninput            [ 1:0] color_depth_i;\ninput                   colorkey_enable_i;\ninput            [31:0] colorkey_i;\n\nwire             [31:0] pixel_offset;\n\nassign pixel_offset = (color_depth_i == 2'b00) ? (tex0_size_x_i*v_i + {16'h0, u_i})      :\n                      (color_depth_i == 2'b01) ? (tex0_size_x_i*v_i + {16'h0, u_i}) << 1 :\n                      (tex0_size_x_i*v_i + {16'h0, u_i})                            << 2 ;\nassign texture_addr_o = tex0_base_i + pixel_offset[31:2];\n\nreg [1:0] state;\nparameter wait_state = 2'b00, texture_read_state = 2'b01, write_pixel_state = 2'b10;\n\nwire [31:0] mem_conv_color_o;\n\nmemory_to_color color_proc(\n.color_depth_i (color_depth_i),\n.mem_i         (texture_data_i),\n.mem_lsb_i     (u_i[1:0]),\n.color_o       (mem_conv_color_o),\n.sel_o         ()\n);\n\nwire transparent_pixel = (color_depth_i == 2'b00) ? (mem_conv_color_o[7:0]  == colorkey_i[7:0])  :\n                         (color_depth_i == 2'b01) ? (mem_conv_color_o[15:0] == colorkey_i[15:0]) :\n                         (mem_conv_color_o == colorkey_i);\n\nwire [2*point_width-1:0] bezier_factor0_squared = bezier_factor0_i*bezier_factor0_i;\nwire bezier_eval = bezier_factor0_squared[2*point_width-1:point_width] > bezier_factor1_i;\nwire bezier_draw = bezier_inside_i ^ bezier_eval;\n\nalways @(posedge clk_i or posedge rst_i)\nbegin\n  if(rst_i)\n  begin\n    ack_o             <= 1'b0;\n    write_o           <= 1'b0;\n    pixel_x_o         <= 1'b0;\n    pixel_y_o         <= 1'b0;\n    pixel_z_o         <= 1'b0;\n    pixel_color_o     <= 1'b0;\n    pixel_alpha_o     <= 1'b0;\n    texture_request_o <= 1'b0;\n    texture_sel_o     <= 4'b1111;\n  end\n  else\n  begin\n    case (state)\n\n      wait_state:\n      begin\n        ack_o   <= write_i & curve_write_i & ~bezier_draw;\n\n        if(write_i & texture_enable_i & (~curve_write_i | bezier_draw))\n          texture_request_o <= 1'b1;\n        else if(write_i & (~curve_write_i | bezier_draw))\n        begin\n          pixel_x_o         <= x_counter_i;\n          pixel_y_o         <= y_counter_i;\n          pixel_z_o         <= z_i;\n          pixel_color_o     <= pixel_color_i;\n          pixel_alpha_o     <= pixel_alpha_i;\n          write_o           <= 1'b1;\n        end\n      end\n\n      texture_read_state:\n        if(texture_ack_i)\n        begin\n          pixel_x_o         <= x_counter_i;\n          pixel_y_o         <= y_counter_i;\n          pixel_z_o         <= z_i;\n          pixel_color_o     <= mem_conv_color_o;\n          pixel_alpha_o     <= pixel_alpha_i;\n          texture_request_o <= 1'b0;\n          if(colorkey_enable_i & transparent_pixel)\n            ack_o           <= 1'b1;\n          else\n            write_o         <= 1'b1;\n        end\n\n      write_pixel_state:\n      begin\n        write_o  <= 1'b0;\n        ack_o    <= ack_i;\n      end\n\n    endcase\n  end\nend\n\nalways @(posedge clk_i or posedge rst_i)\nbegin\n  if(rst_i)\n    state <= wait_state;\n  else\n    case (state)\n\n      wait_state:\n        if(write_i & texture_enable_i & (~curve_write_i | bezier_draw))\n          state <= texture_read_state;\n        else if(write_i & (~curve_write_i | bezier_draw))\n          state <= write_pixel_state;\n\n      texture_read_state:\n        if(texture_ack_i & colorkey_enable_i)\n          state <= transparent_pixel ? wait_state : write_pixel_state;\n        else if(texture_ack_i)\n          state <= write_pixel_state;\n\n      write_pixel_state:\n        if(ack_i)\n          state <= wait_state;\n\n    endcase\nend\nendmodule"}
{"task_id": 1114, "completion": "localparam PIXELS_PER_LINE = WIDTH + H_BACK_PORCH + H_SYNC + H_FRONT_PORCH;\n    localparam LINES_PER_FRAME = HEIGHT + V_BACK_PORCH + V_SYNC + V_FRONT_PORCH;\n    localparam XBITS = $clog2(PIXELS_PER_LINE);\n    localparam YBITS = $clog2(LINES_PER_FRAME);\n    reg [XBITS-1:0] x_pos;\n    wire x_max = (x_pos == (PIXELS_PER_LINE - 1));\n    reg [YBITS-1:0] y_pos;\n    wire y_max = (y_pos == (LINES_PER_FRAME - 1));\n    reg hsync;\n    assign vga_hsync = ~hsync;\n    reg vsync;\n    assign vga_vsync = ~vsync;\n    assign fb_vblank = (y_pos >= HEIGHT);\n    assign fb_hblank = (x_pos >= WIDTH);\n    always @ (posedge vga_clk or negedge reset_n) begin\n        if(~reset_n) begin\n            x_pos <= 0;\n            y_pos <= 0;\n            hsync <= 1'b0;\n            vsync <= 1'b0;\n        end else begin\n            if(x_max) begin\n                x_pos <= 0;\n                if(y_max) begin\n                    y_pos <= 0;\n                end else begin\n                    y_pos <= y_pos + 1;\n                end\n            end else begin\n                x_pos <= x_pos + 1;\n            end\n            if(x_pos == ((WIDTH + H_FRONT_PORCH) - 1)) hsync <= 1'b1;\n            else if(x_pos == ((WIDTH + H_FRONT_PORCH + H_SYNC) - 1)) hsync <= 1'b0;\n            if(y_pos == ((HEIGHT + V_FRONT_PORCH) - 1)) vsync <= 1'b1;\n            else if(y_pos == ((HEIGHT + V_FRONT_PORCH + V_SYNC) - 1)) vsync <= 1'b0;\n        end\n    end\n    assign vga_red = (x_pos < WIDTH && y_pos < HEIGHT) ? red : 8'b0;\n    assign vga_green = (x_pos < WIDTH && y_pos < HEIGHT) ? green : 8'b0;\n    assign vga_blue = (x_pos < WIDTH && y_pos < HEIGHT) ? blue : 8'b0;\nendmodule"}
{"task_id": 1095, "completion": "(* ALTERA_ATTRIBUTE = \"-name SDC_STATEMENT \\\" set_false_path -to [get_registers *altera_tse_false_path_marker:*|data_out_reg*] \\\"\" *)\n\n    (*preserve*) reg [MARKER_WIDTH - 1 : 0] data_out_reg;\n\n    assign data_out = data_out_reg;\n\n    always @(posedge clk or posedge reset) \n    begin\n       if (reset)\n       begin\n          data_out_reg <= {MARKER_WIDTH{1'b0}};\n       end\n       else\n       begin\n          data_out_reg <= data_in;\n       end\n    end\n\nendmodule"}
{"task_id": 1049, "completion": "reg cmd_ack;\n\treg busy;\n\treg al;\n\treg dout;\n\treg scl_oen;\n\treg sda_oen;\n\n\treg sSCL, sSDA;\n\treg dscl_oen;\n\treg sda_chk;\n\treg clk_en;\n\twire slave_wait;\n\treg [15:0] cnt;\n\treg [16:0] c_state;\n\t\n\talways @(posedge clk)  dscl_oen <= #1 scl_oen;\n\tassign slave_wait = dscl_oen && !sSCL;\n\n\talways @(posedge clk or negedge nReset) \n\t  if(~nReset) begin\n\t\tcnt <= #1 16'h0;\n\t\tclk_en <= #1 1'b1;\n\tend else if (rst) begin\n\t\tcnt <= #1 16'h0;\n\t\tclk_en <= #1 1'b1;\n\tend else if ( ~|cnt || !ena) begin\n\t\tcnt <= #1 clk_cnt;\n\t\tclk_en <= #1 1'b1;\n\tend else if (slave_wait) begin\n\t\tcnt <= #1 cnt;\n\t\tclk_en <= #1 1'b0;    \n\tend else begin\n\t\tcnt <= #1 cnt - 16'h1;\n\t\tclk_en <= #1 1'b0;\n\tend\n\t\n\treg dSCL, dSDA;\n\treg sta_condition;\n\treg sto_condition;\n\n\talways @(posedge clk or negedge nReset)\n\t  if (~nReset) begin\n\t\t sSCL <= #1 1'b1;\n\t\t sSDA <= #1 1'b1;\n\t\t dSCL <= #1 1'b1;\n\t\t dSDA <= #1 1'b1;\n\tend else if (rst) begin\n\t\t sSCL <= #1 1'b1;\n\t\t sSDA <= #1 1'b1;\n\t\t dSCL <= #1 1'b1;\n\t\t dSDA <= #1 1'b1;\n\tend else begin\n\t\t sSCL <= #1 scl_i;\n\t\t sSDA <= #1 sda_i;\n\t\t dSCL <= #1 sSCL;\n\t\t dSDA <= #1 sSDA;\n\tend\n\t\n\talways @(posedge clk or negedge nReset)\n\t  if (~nReset) begin\n\t\tsta_condition <= #1 1'b0;\n\t\tsto_condition <= #1 1'b0;\n\tend else if (rst) begin\n\t\tsta_condition <= #1 1'b0;\n\t\tsto_condition <= #1 1'b0;\n\tend else begin\n\t\tsta_condition <= #1 ~sSDA &  dSDA & sSCL;\n\t\tsto_condition <= #1  sSDA & ~dSDA & sSCL;\n\tend\n\t\n\talways @(posedge clk or negedge nReset)\n\t  if(!nReset) busy <= #1 1'b0;\n\t  else if (rst) busy <= #1 1'b0;\n\t  else busy <= #1 (sta_condition | busy) & ~sto_condition;\n\t\n\treg cmd_stop;\n\talways @(posedge clk or negedge nReset)\n\t  if (~nReset) cmd_stop <= #1 1'b0;\n\t  else if (rst) cmd_stop <= #1 1'b0;\n\t  else if (clk_en) cmd_stop <= #1 cmd == `I2C_CMD_STOP;\n\n\talways @(posedge clk or negedge nReset)\n\t  if (~nReset) al <= #1 1'b0;\n\t  else if (rst) al <= #1 1'b0;\n\t  else al <= #1 (sda_chk & ~sSDA & sda_oen) | (|c_state & sto_condition & ~cmd_stop);\n\t\n\talways @(posedge clk) if(sSCL & ~dSCL) dout <= #1 sSDA;\n\t\n\tparameter [16:0] idle = 17'b0_0000_0000_0000_0000;\n\tparameter [16:0] start_a = 17'b0_0000_0000_0000_0001;\n\tparameter [16:0] start_b = 17'b0_0000_0000_0000_0010;\n\tparameter [16:0] start_c = 17'b0_0000_0000_0000_0100;\n\tparameter [16:0] start_d = 17'b0_0000_0000_0000_1000;\n\tparameter [16:0] start_e = 17'b0_0000_0000_0001_0000;\n\tparameter [16:0] stop_a = 17'b0_0000_0000_0010_0000;\n\tparameter [16:0] stop_b = 17'b0_0000_0000_0100_0000;\n\tparameter [16:0] stop_c = 17'b0_0000_0000_1000_0000;\n\tparameter [16:0] stop_d = 17'b0_0000_0001_0000_0000;\n\tparameter [16:0] rd_a = 17'b0_0000_0010_0000_0000;\n\tparameter [16:0] rd_b = 17'b0_0000_0100_0000_0000;\n\tparameter [16:0] rd_c = 17'b0_0000_1000_0000_0000;\n\tparameter [16:0] rd_d = 17'b0_0001_0000_0000_0000;\n\tparameter [16:0] wr_a = 17'b0_0010_0000_0000_0000;\n\tparameter [16:0] wr_b = 17'b0_0100_0000_0000_0000;\n\tparameter [16:0] wr_c = 17'b0_1000_0000_0000_0000;\n\tparameter [16:0] wr_d = 17'b1_0000_0000_0000_0000;\n\t\n\talways @(posedge clk or negedge nReset) \n\t  if (!nReset) begin\n\t\tc_state <= #1 idle;\n\t\tcmd_ack <= #1 1'b0;\n\t\tscl_oen <= #1 1'b1;\n\t\tsda_oen <= #1 1'b1;\n\t\tsda_chk <= #1 1'b0;\n\tend else if (rst | al) begin\n\t\tc_state <= #1 idle;\n\t\tcmd_ack <= #1 1'b0;\n\t\tscl_oen <= #1 1'b1;\n\t\tsda_oen <= #1 1'b1;\n\t\tsda_chk <= #1 1'b0;\n\tend else begin\n\t\tcmd_ack <= #1 1'b0;\n\t\tif (clk_en) begin\n\t\t\tcase (c_state) \n\t\t\t\tidle: begin\n\t\t\t\t\tcase (cmd) \n\t\t\t\t\t\t`I2C_CMD_START: c_state <= #1 start_a;\n\t\t\t\t\t\t`I2C_CMD_STOP: c_state <= #1 stop_a;\n\t\t\t\t\t\t`I2C_CMD_WRITE: c_state <= #1 wr_a;\n\t\t\t\t\t\t`I2C_CMD_READ: c_state <= #1 rd_a;\n\t\t\t\t\t\tdefault: c_state <= #1 idle;\n\t\t\t\t\tendcase\n\t\t\t\t\tscl_oen <= #1 scl_oen;\n\t\t\t\t\tsda_oen <= #1 sda_oen;\n\t\t\t\t\tsda_chk <= #1 1'b0;\n\t\t\t\tend\n\t\t\t\tstart_a: begin\n\t\t\t\t\tc_state <= #1 start_b;\n\t\t\t\t\tscl_oen <= #1 scl_oen;\n\t\t\t\t\tsda_oen <= #1 1'b1;\n\t\t\t\t\tsda_chk <= #1 1'b0;\n\t\t\t\tend\n\t\t\t\tstart_b: begin\n\t\t\t\t\tc_state <= #1 start_c;\n\t\t\t\t\tscl_oen <= #1 1'b1;\n\t\t\t\t\tsda_oen <= #1 1'b1;\n\t\t\t\t\tsda_chk <= #1 1'b0;\n\t\t\t\tend\n\t\t\t\tstart_c: begin\n\t\t\t\t\tc_state <= #1 start_d;\n\t\t\t\t\tscl_oen <= #1 1'b1;\n\t\t\t\t\tsda_oen <= #1 1'b0;\n\t\t\t\t\tsda_chk <= #1 1'b0;\n\t\t\t\tend\n\t\t\t\tstart_d: begin\n\t\t\t\t\tc_state <= #1 start_e;\n\t\t\t\t\tscl_oen <= #1 1'b1;\n\t\t\t\t\tsda_oen <= #1 1'b0;\n\t\t\t\t\tsda_chk <= #1 1'b0;\n\t\t\t\tend\n\t\t\t\tstart_e: begin\n\t\t\t\t\tc_state <= #1 idle;\n\t\t\t\t\tcmd_ack <= #1 1'b1;\n\t\t\t\t\tscl_oen <= #1 1'b0;\n\t\t\t\t\tsda_oen <= #1 1'b0;\n\t\t\t\t\tsda_chk <= #1 1'b0;\n\t\t\t\tend\n\t\t\t\tstop_a: begin\n\t\t\t\t\tc_state <= #1 stop_b;\n\t\t\t\t\tscl_oen <= #1 1'b0;\n\t\t\t\t\tsda_oen <= #1 1'b0;\n\t\t\t\t\tsda_chk <= #1 1'b0;\n\t\t\t\tend\n\t\t\t\tstop_b: begin\n\t\t\t\t\tc_state <= #1 stop_c;\n\t\t\t\t\tscl_oen <= #1 1'b1;\n\t\t\t\t\tsda_oen <= #1 1'b0;\n\t\t\t\t\tsda_chk <= #1 1'b0;\n\t\t\t\tend\n\t\t\t\tstop_c: begin\n\t\t\t\t\tc_state <= #1 stop_d;\n\t\t\t\t\tscl_oen <= #1 1'b1;\n\t\t\t\t\tsda_oen <= #1 1'b0;\n\t\t\t\t\tsda_chk <= #1 1'b0;\n\t\t\t\tend\n\t\t\t\tstop_d: begin\n\t\t\t\t\tc_state <= #1 idle;\n\t\t\t\t\tcmd_ack <= #1 1'b1;\n\t\t\t\t\tscl_oen <= #1 1'b1;\n\t\t\t\t\tsda_oen <= #1 1'b1;\n\t\t\t\t\tsda_chk <= #1 1'b0;\n\t\t\t\tend\n\t\t\t\trd_a: begin\n\t\t\t\t\tc_state <= #1 rd_b;\n\t\t\t\t\tscl_oen <= #1 1'b0;\n\t\t\t\t\tsda_oen <= #1 1'b1;\n\t\t\t\t\tsda_chk <= #1 1'b0;\n\t\t\t\tend\n\t\t\t\trd_b: begin\n\t\t\t\t\tc_state <= #1 rd_c;\n\t\t\t\t\tscl_oen <= #1 1'b1;\n\t\t\t\t\tsda_oen <= #1 1'b1;\n\t\t\t\t\tsda_chk <= #1 1'b0;\n\t\t\t\tend\n\t\t\t\trd_c: begin\n\t\t\t\t\tc_state <= #1 rd_d;\n\t\t\t\t\tscl_oen <= #1 1'b1;\n\t\t\t\t\tsda_oen <= #1 1'b1;\n\t\t\t\t\tsda_chk <= #1 1'b0;\n\t\t\t\tend\n\t\t\t\trd_d: begin\n\t\t\t\t\tc_state <= #1 idle;\n\t\t\t\t\tcmd_ack <= #1 1'b1;\n\t\t\t\t\tscl_oen <= #1 1'b0;\n\t\t\t\t\tsda_oen <= #1 1'b1;\n\t\t\t\t\tsda_chk <= #1 1'b0;\n\t\t\t\tend\n\t\t\t\twr_a: begin\n\t\t\t\t\tc_state <= #1 wr_b;\n\t\t\t\t\tscl_oen <= #1 1'b0;\n\t\t\t\t\tsda_oen <= #1 din;\n\t\t\t\t\tsda_chk <= #1 1'b0;\n\t\t\t\tend\n\t\t\t\twr_b: begin\n\t\t\t\t\tc_state <= #1 wr_c;\n\t\t\t\t\tscl_oen <= #1 1'b1;\n\t\t\t\t\tsda_oen <= #1 din;\n\t\t\t\t\tsda_chk <= #1 1'b1;\n\t\t\t\tend\n\t\t\t\twr_c: begin\n\t\t\t\t\tc_state <= #1 wr_d;\n\t\t\t\t\tscl_oen <= #1 1'b1;\n\t\t\t\t\tsda_oen <= #1 din;\n\t\t\t\t\tsda_chk <= #1 1'b1;\n\t\t\t\tend\n\t\t\t\twr_d: begin\n\t\t\t\t\tc_state <= #1 idle;\n\t\t\t\t\tcmd_ack <= #1 1'b1;\n\t\t\t\t\tscl_oen <= #1 1'b0;\n\t\t\t\t\tsda_oen <= #1 din;\n\t\t\t\t\tsda_chk <= #1 1'b0;\n\t\t\t\tend\n\t\t\t\tendcase\n\t\t\tend\n\t\tend\n\n\tassign scl_o = 1'b0;\n\tassign sda_o = 1'b0;\nendmodule"}
{"task_id": 1094, "completion": "parameter xdim = 4;\n   parameter ydim = 4; \n   parameter xpos = 0;\n   parameter ypos = 0;\n   parameter warmup_packets = 100;\n   parameter measurement_packets = 1000;\n   parameter global_links_num = 2;\n   parameter local_links_num = 2;\n   input     flit_t flit_in [global_links_num-1:0];\n   output    logic [global_links_num-1:0] cntrl_out;\n   output    sim_stats_t stats;\n   input     clk, rst_n;\n   output    integer rec_count;\n   integer   expected_flit_id [local_links_num-1:0];\n   integer   head_injection_time [local_links_num-1:0];\n   integer   latency, sys_time;\n   integer   src_x, src_y;\n   integer   j, i;\n   integer   warmup_rec_count;\n   genvar ch;\n   for (ch=0; ch<local_links_num; ch++) begin:flow_control\n    always@(posedge clk) begin\n      if (!rst_n) begin\n        cntrl_out[ch] <= 0;\n      end else begin\n        if (flit_in[ch].control.valid) begin\n          if (ch < local_links_num) begin\n            cntrl_out[ch] <= 1;\n          end else begin\n            $display (\"%m: Error: Flit Channel ID is out-of-range for exit from network!\");\n            $display (\"Channel ID = %1d (router_num_pls_on_exit=%1d)\", ch, router_num_pls_on_exit);\n            $finish;\n          end\n        end else begin\n          cntrl_out[ch] <= 0;\n        end\n      end\n    end   \n   end\n   always@(posedge clk) begin\n      if (!rst_n) begin\n         rec_count=-1;\n         stats.total_latency=0;\n         stats.total_hops=0;\n         stats.max_hops=0;\n         stats.min_hops=MAXINT;\n         stats.max_latency=0;\n         stats.min_latency=MAXINT;\n         stats.measure_start=-1;\n         stats.measure_end=0;\n         stats.flit_count=0;\n         warmup_rec_count = 0;\n         src_x = 0;\n         src_y = 0;\n         for(i = 0; i < xdim; i++)\n           for(j = 0; j < ydim; j++) begin  \n              stats.flows_latencies[i][j][0] = 0;\n              stats.flows_latencies[i][j][1] = 0;\n              stats.flows_latencies[i][j][2] = 0;\n              stats.flows_latencies[i][j][3] = 32'd1000000;\n              stats.flows_latencies[i][j][4] = 0;\n           end   \n         for (j=0; j<local_links_num; j++) begin\n            expected_flit_id[j]=1;\n            head_injection_time[j]=-1;\n         end\n         for (j=0; j<=100; j++) begin\n            stats.lat_freq[j]=0;\n         end\n         sys_time = 0;\n      end else begin // if (!rst_n)\n         sys_time++;\n         for (i=0; i<local_links_num; i++) begin\n         if (flit_in[i].control.valid) begin\n            if ((flit_in[i].debug.xdest!=xpos)||(flit_in[i].debug.ydest!=ypos)) begin\n               $display (\"%m: Error: Flit arrived at wrong destination!\");\n               $finish;\n            end\n            if ((flit_in[i].debug.xdest==flit_in[i].debug.xsrc) &&\n                (flit_in[i].debug.ydest==flit_in[i].debug.ysrc)) begin\n               $display (\"%m: Error: Received flit originated from this node?\");\n               $finish;\n            end\n            if (flit_in[i].debug.flit_id != expected_flit_id[i]) begin\n               $display (\"%m: Error: Out of sequence flit received? (packet generated at %1d,%1d)\",\n                            flit_in[i].debug.xsrc, flit_in[i].debug.ysrc);\n               $display (\"-- Flit ID = %1d, Expected = %1d\", flit_in[i].debug.flit_id, expected_flit_id[i]);\n               $display (\"-- Packet ID = %1d\", flit_in[i].debug.packet_id);\n               $finish;\n            end else begin\n            end\n            expected_flit_id[i]++;\n            if (flit_in[i].debug.flit_id==1) begin\n               head_injection_time[i] = flit_in[i].debug.inject_time;\n               if ((warmup_rec_count == warmup_packets) && (stats.measure_start==-1)) stats.measure_start = sys_time;\n            end\n            if (stats.measure_start!=-1) stats.flit_count++;\n            if (flit_in[i].control.tail) begin\n               expected_flit_id[i]=1;\n               warmup_rec_count++;\n               if (stats.measure_start!=-1) begin\n                  rec_count++;\n                  stats.measure_end = sys_time;\n                  latency = sys_time - head_injection_time[i]; \n                  stats.total_latency = stats.total_latency + latency;\n                  stats.min_latency = min (stats.min_latency, latency);\n                  stats.max_latency = max (stats.max_latency, latency);\n                  src_x = flit_in[i].debug.xsrc;\n                  src_y = flit_in[i].debug.ysrc;\n                  stats.flows_latencies[src_x][src_y][0] = 1;\n                  stats.flows_latencies[src_x][src_y][1] += latency;\n                  stats.flows_latencies[src_x][src_y][2]++;\n                  stats.flows_latencies[src_x][src_y][3] = min(stats.flows_latencies[src_x][src_y][3], latency);\n                  stats.flows_latencies[src_x][src_y][4] = max(stats.flows_latencies[src_x][src_y][4], latency);\n                  stats.total_hops = stats.total_hops + flit_in[i].debug.hops;\n                  stats.min_hops = min (stats.min_hops, flit_in[i].debug.hops);\n                  stats.max_hops = max (stats.max_hops, flit_in[i].debug.hops);\n                  stats.lat_freq[min(latency, 100)]++;\n               end\n            end\n         end\n         end\n      end  \n   end\nendmodule"}
{"task_id": 1086, "completion": "reg [31:0] ee_set_reg;\n    reg [31:0] eo_set_reg;\n    reg [31:0] oe_set_reg;\n    reg [31:0] oo_set_reg;\n\n    assign ee_lru = ee_set_reg[ee_tag_adr_rd];\n    assign eo_lru = eo_set_reg[eo_tag_adr_rd];\n    assign oe_lru = oe_set_reg[oe_tag_adr_rd];\n    assign oo_lru = oo_set_reg[oo_tag_adr_rd];\n\n    wire [31:0] sel_ee;\n    wire [31:0] sel_eo;\n    wire [31:0] sel_oe;\n    wire [31:0] sel_oo;\n\n    assign sel_ee = 32'b1 << (ee_tag_adr_wr);\n    assign sel_eo = 32'b1 << (eo_tag_adr_wr);\n    assign sel_oe = 32'b1 << (oe_tag_adr_wr);\n    assign sel_oo = 32'b1 << (oo_tag_adr_wr);\n\n    always @(posedge de_clk or negedge de_rstn)\n    begin\n        if(!de_rstn) ee_set_reg <= 0;\n        else if(ee_s0_hit) ee_set_reg <= ee_set_reg | sel_ee;\n        else if(ee_s1_hit) ee_set_reg <= ee_set_reg & ~sel_ee;\n    end\n    always @(posedge de_clk or negedge de_rstn)\n    begin\n        if(!de_rstn) eo_set_reg <= 0;\n        else if(eo_s0_hit) eo_set_reg <= eo_set_reg | sel_eo;\n        else if(eo_s1_hit) eo_set_reg <= eo_set_reg & ~sel_eo;\n    end\n    always @(posedge de_clk or negedge de_rstn)\n    begin\n        if(!de_rstn) oe_set_reg <= 0;\n        else if(oe_s0_hit) oe_set_reg <= oe_set_reg | sel_oe;\n        else if(oe_s1_hit) oe_set_reg <= oe_set_reg & ~sel_oe;\n    end\n    always @(posedge de_clk or negedge de_rstn)\n    begin\n        if(!de_rstn) oo_set_reg <= 0;\n        else if(oo_s0_hit) oo_set_reg <= oo_set_reg | sel_oo;\n        else if(oo_s1_hit) oo_set_reg <= oo_set_reg & ~sel_oo;\n    end\n\nendmodule"}
{"task_id": 1103, "completion": "`ifdef OVL_ASSERT_ON\n\n      wire fire_2state_1;\n      always @(posedge clk) begin\n        if (`OVL_RESET_SIGNAL == 1'b0) begin\n        end\n        else begin\n          if (fire_2state_1) begin\n            ovl_error_t(`OVL_FIRE_2STATE,\"Antecedent does not have consequent\");\n          end\n        end\n      end\n\n      assign fire_2state_1 = ((antecedent_expr == 1'b1) && (consequent_expr == 1'b0));\n\n      `ifdef OVL_XCHECK_OFF\n      `else\n        `ifdef OVL_IMPLICIT_XCHECK_OFF\n        `else\n          reg fire_xcheck_1, fire_xcheck_2;\n          always @(posedge clk) begin\n            if (`OVL_RESET_SIGNAL == 1'b0) begin\n            end\n            else begin\n              if (fire_xcheck_1) begin\n                ovl_error_t(`OVL_FIRE_XCHECK,\"antecedent_expr contains X or Z\");\n              end\n              if (fire_xcheck_2) begin\n                ovl_error_t(`OVL_FIRE_XCHECK,\"consequent_expr contains X or Z\");\n              end\n            end\n          end\n\n          wire valid_antecedent_expr = ((antecedent_expr ^ antecedent_expr) == 1'b0);\n          wire valid_consequent_expr = ((consequent_expr ^ consequent_expr) == 1'b0);\n\n          always @ (valid_antecedent_expr or consequent_expr) begin\n            if (valid_antecedent_expr || consequent_expr) begin\n              fire_xcheck_1 = 1'b0;\n            end\n            else begin\n              fire_xcheck_1 = 1'b1;\n            end\n          end\n\n          always @ (antecedent_expr or valid_consequent_expr) begin\n            if ((antecedent_expr == 1'b0) || valid_consequent_expr) begin\n              fire_xcheck_2 = 1'b0;\n            end\n            else begin\n              fire_xcheck_2 = 1'b1;\n            end\n          end\n\n        `endif // OVL_IMPLICIT_XCHECK_OFF\n      `endif // OVL_XCHECK_OFF\n\n    `endif // OVL_ASSERT_ON\n\n    `ifdef OVL_COVER_ON\n\n      wire fire_cover_1;\n      always @ (posedge clk) begin\n        if (`OVL_RESET_SIGNAL == 1'b0) begin\n        end\n        else begin\n          if (fire_cover_1) begin\n            ovl_cover_t(\"antecedent covered\");\n          end\n        end\n      end\n\n      assign fire_cover_1 = ((OVL_COVER_BASIC_ON > 0) && (antecedent_expr == 1'b1));\n\n    `endif // OVL_COVER_ON\n  endmodule"}
{"task_id": 1120, "completion": "IBUFG clkin1_buf\n     (.O (clkin1),\n      .I (CLK_IN));\n\n    wire psdone_unused;\n    wire clkfb;\n    wire clk0;\n    wire clkfx;\n\n    DCM_SP\n    #(.CLKDV_DIVIDE          (10.000),\n      .CLKFX_DIVIDE          (20),\n      .CLKFX_MULTIPLY        (2),\n      .CLKIN_DIVIDE_BY_2     (\"FALSE\"),\n      .CLKIN_PERIOD          (10.0),\n      .CLKOUT_PHASE_SHIFT    (\"NONE\"),\n      .CLK_FEEDBACK          (\"1X\"),\n      .DESKEW_ADJUST         (\"SYSTEM_SYNCHRONOUS\"),\n      .PHASE_SHIFT           (0),\n      .STARTUP_WAIT          (\"FALSE\"))\n    dcm_sp_inst\n      (.CLKIN                 (clkin1),\n      .CLKFB                 (clkfb),\n      .CLK0                  (clk0),\n      .CLKFX                 (clkfx),\n      .PSCLK                 (1'b0),\n      .PSEN                  (1'b0),\n      .PSINCDEC              (1'b0),\n      .RST                   (1'b0),\n      .DSSEN                 (1'b0));\n\n    BUFG clkf_buf\n     (.O (clkfb),\n      .I (clk0));\n\n    BUFG clkout1_buf\n     (.O   (CLK_OUT),\n      .I   (clkfx));\n\nendmodule"}
{"task_id": 1133, "completion": "reg [WIDTH*2-1:0] dbl_last_master_ns;\n  always @(/*AS*/last_master_ns)\n    dbl_last_master_ns = {last_master_ns, last_master_ns};\n  reg [WIDTH*2-1:0] dbl_req;\n  always @(/*AS*/req) dbl_req = {req, req};\n\n  reg [WIDTH-1:0] inhibit = {WIDTH{1'b0}};\n\n  genvar i;\n  genvar j;\n  generate\n    for (i = 0; i < WIDTH; i = i + 1) begin : channel\n      wire [WIDTH-1:1] inh_group;\n      for (j = 0; j < (WIDTH-1); j = j + 1) begin : last_master\n          assign inh_group[j+1] =\n                  dbl_last_master_ns[i+j] && |dbl_req[i+WIDTH-1:i+j+1];\n      end\n      always @(/*AS*/inh_group) inhibit[i] = |inh_group;\n    end\n  endgenerate\n\n  assign grant_ns = req & ~inhibit & {WIDTH{~disable_grant}};\n\n  always @(posedge clk) grant_r <= #TCQ grant_ns;\n\n  reg [WIDTH-1:0] last_master_r;\n  localparam ONE = 1 << (WIDTH - 1);\n  assign last_master_ns = rst\n                            ? ONE[0+:WIDTH]\n                            : upd_last_master\n                                ? current_master\n                                : last_master_r;\n  always @(posedge clk) last_master_r <= #TCQ last_master_ns;\n\n`ifdef MC_SVA\n  grant_is_one_hot_zero:\n    assert property (@(posedge clk) (rst || $onehot0(grant_ns)));\n  last_master_r_is_one_hot:\n    assert property (@(posedge clk) (rst || $onehot(last_master_r)));\n`endif\n\nendmodule"}
{"task_id": 1138, "completion": "localparam  [1:0]\n      newgame = 2'b00,\n      play    = 2'b01,\n      newball = 2'b10,\n      over    = 2'b11;\n    reg [1:0] state_reg, state_next;\n    wire [9:0] pixel_x, pixel_y;\n    wire video_on, pixel_tick;\n    wire [3:0] text_on;\n    wire [2:0] text_rgb;\n    reg [2:0] rgb_reg, rgb_next;\n    wire [3:0] dig0, dig1;\n    reg [1:0] ball_reg, ball_next;\n    assign dig0 = 4'b0000;\n    assign dig1 = 4'b0000;\n    vga_sync vsync_unit\n      (.clk(clk), .reset(reset), .hsync(hsync), .vsync(vsync),\n       .video_on(video_on), .p_tick(pixel_tick),\n       .pixel_x(pixel_x), .pixel_y(pixel_y));\n    game_text game_text_unit\n      (.clk(clk),\n       .pix_x(pixel_x), .pix_y(pixel_y),\n       .dig0(dig0), .dig1(dig1), .ball(ball_reg),\n       .text_on(text_on), .text_rgb(text_rgb));\n    always @(posedge clk, posedge reset)\n       if (reset)\n          begin\n             state_reg <= newgame;\n             ball_reg <= 0;\n             rgb_reg <= 0;\n          end\n       else\n          begin\n            state_reg <= state_next;\n            ball_reg <= ball_next;\n            if (pixel_tick)\n               rgb_reg <= rgb_next;\n          end\n    always @*\n    begin\n      state_next = state_reg;\n      ball_next = ball_reg;\n      case (state_reg)\n         newgame:\n            begin\n               ball_next = 2'b11;\n               if (btn != 2'b00)\n                  begin\n                     state_next = play;\n                     ball_next = ball_reg - 1;\n                  end\n            end\n         play:\n            begin\n             if (btn == 2'b11)\n                  begin\n                     state_next = newball;\n                     ball_next = ball_reg - 2;\n                  end\n            end\n         newball:\n            if ((btn == 2'b00))\n                  begin\n                     state_next = over;\n                     ball_next = 2'b00;\n                  end\n         over:\n          state_next = newgame;\n       endcase\n    end\n    always @*\n      if (~video_on)\n         rgb_next = 3'b000;\n      else\n         if (text_on[3] ||\n               ((state_reg==newgame) && text_on[1]) ||\n               ((state_reg==over) && text_on[0]))\n            rgb_next = text_rgb;\n         else if (text_on[2])\n           rgb_next = text_rgb;\n         else\n           rgb_next = 3'b110;\n    assign rgb = rgb_reg;\nendmodule"}
{"task_id": 1128, "completion": "always @(posedge sys_clk) begin\n\t\tif(sys_rst)\n\t\t\twb_ack_o <= 1'b0;\n\t\telse begin\n\t\t\tif(wb_stb_i & wb_cyc_i & ~wb_ack_o)\n\t\t\t\twb_ack_o <= 1'b1;\n\t\t\telse\n\t\t\t\twb_ack_o <= 1'b0;\n\t\tend\n\tend\n\n\twire [31:0] wb_dat_o_prog;\n\tsoftusb_dpram #(\n\t\t.depth(pmem_width),\n\t\t.width(16),\n\t\t.initfile(initprog)\n\t) program (\n\t\t.clk(sys_clk),\n\t\t.clk2(usb_clk),\n\n\t\t.a(wb_adr_i[pmem_width+1:2]),\n\t\t.we(wb_stb_i & wb_cyc_i & ~wb_adr_i[17] & wb_we_i & ~wb_ack_o),\n\t\t.di(wb_dat_i[15:0]),\n\t\t.do(wb_dat_o_prog[15:0]),\n\n\t\t.ce2(pmem_ce),\n\t\t.a2(pmem_a),\n\t\t.we2(1'b0),\n\t\t.di2(16'hxxxx),\n\t\t.do2(pmem_d)\n\t);\n\tassign wb_dat_o_prog[31:16] = 16'd0;\n\n\twire [7:0] dmem_do0;\n\twire [7:0] dmem_do1;\n\twire [7:0] dmem_do2;\n\twire [7:0] dmem_do3;\n\twire [31:0] wb_dat_o_data;\n\n\tsoftusb_dpram #(\n\t\t.depth(dmem_width-2),\n\t\t.width(8)\n\t) dataram0 (\n\t\t.clk(sys_clk),\n\t\t.clk2(usb_clk),\n\n\t\t.a(wb_adr_i[dmem_width-1:2]),\n\t\t.we(wb_stb_i & wb_cyc_i & wb_adr_i[17] & wb_we_i & wb_sel_i[0] & ~wb_ack_o),\n\t\t.di(wb_dat_i[7:0]),\n\t\t.do(wb_dat_o_data[7:0]),\n\n\t\t.ce2(1'b1),\n\t\t.a2(dmem_a[dmem_width-1:2]),\n\t\t.we2(dmem_we & (dmem_a[1:0] == 2'd3)),\n\t\t.di2(dmem_di),\n\t\t.do2(dmem_do0)\n\t);\n\n\tsoftusb_dpram #(\n\t\t.depth(dmem_width-2),\n\t\t.width(8)\n\t) dataram1 (\n\t\t.clk(sys_clk),\n\t\t.clk2(usb_clk),\n\n\t\t.a(wb_adr_i[dmem_width-1:2]),\n\t\t.we(wb_stb_i & wb_cyc_i & wb_adr_i[17] & wb_we_i & wb_sel_i[1] & ~wb_ack_o),\n\t\t.di(wb_dat_i[15:8]),\n\t\t.do(wb_dat_o_data[15:8]),\n\n\t\t.ce2(1'b1),\n\t\t.a2(dmem_a[dmem_width-1:2]),\n\t\t.we2(dmem_we & (dmem_a[1:0] == 2'd2)),\n\t\t.di2(dmem_di),\n\t\t.do2(dmem_do1)\n\t);\n\n\tsoftusb_dpram #(\n\t\t.depth(dmem_width-2),\n\t\t.width(8)\n\t) dataram2 (\n\t\t.clk(sys_clk),\n\t\t.clk2(usb_clk),\n\n\t\t.a(wb_adr_i[dmem_width-1:2]),\n\t\t.we(wb_stb_i & wb_cyc_i & wb_adr_i[17] & wb_we_i & wb_sel_i[2] & ~wb_ack_o),\n\t\t.di(wb_dat_i[23:16]),\n\t\t.do(wb_dat_o_data[23:16]),\n\n\t\t.ce2(1'b1),\n\t\t.a2(dmem_a[dmem_width-1:2]),\n\t\t.we2(dmem_we & (dmem_a[1:0] == 2'd1)),\n\t\t.di2(dmem_di),\n\t\t.do2(dmem_do2)\n\t);\n\n\tsoftusb_dpram #(\n\t\t.depth(dmem_width-2),\n\t\t.width(8)\n\t) dataram3 (\n\t\t.clk(sys_clk),\n\t\t.clk2(usb_clk),\n\n\t\t.a(wb_adr_i[dmem_width-1:2]),\n\t\t.we(wb_stb_i & wb_cyc_i & wb_adr_i[17] & wb_we_i & wb_sel_i[3] & ~wb_ack_o),\n\t\t.di(wb_dat_i[31:24]),\n\t\t.do(wb_dat_o_data[31:24]),\n\n\t\t.ce2(1'b1),\n\t\t.a2(dmem_a[dmem_width-1:2]),\n\t\t.we2(dmem_we & (dmem_a[1:0] == 2'd0)),\n\t\t.di2(dmem_di),\n\t\t.do2(dmem_do3)\n\t);\n\n\treg [1:0] dmem_a01;\n\talways @(posedge usb_clk) dmem_a01 <= dmem_a[1:0];\n\talways @(*) begin\n\t\tcase(dmem_a01)\n\t\t\t2'd0: dmem_do = dmem_do3;\n\t\t\t2'd1: dmem_do = dmem_do2;\n\t\t\t2'd2: dmem_do = dmem_do1;\n\t\t\t2'd3: dmem_do = dmem_do0;\n\t\tendcase\n\tend\n\n\treg datasel;\n\talways @(posedge sys_clk) datasel <= wb_adr_i[17];\n\tassign wb_dat_o = datasel ? wb_dat_o_data : wb_dat_o_prog;\n\nendmodule"}
{"task_id": 1155, "completion": "input clk_in1;\n  output clk_out1;\n  input reset;\n  output locked;\nendmodule"}
{"task_id": 885, "completion": "generate\n    pcie_7x_v1_3_pcie_pipe_misc # (\n      .PIPE_PIPELINE_STAGES(PIPE_PIPELINE_STAGES)\n    )\n    pipe_misc_i (\n      .pipe_tx_rcvr_det_i(pipe_tx_rcvr_det_i),\n      .pipe_tx_reset_i(pipe_tx_reset_i),\n      .pipe_tx_rate_i(pipe_tx_rate_i),\n      .pipe_tx_deemph_i(pipe_tx_deemph_i),\n      .pipe_tx_margin_i(pipe_tx_margin_i),\n      .pipe_tx_swing_i(pipe_tx_swing_i),\n      .pipe_tx_rcvr_det_o(pipe_tx_rcvr_det_o),\n      .pipe_tx_reset_o(pipe_tx_reset_o),\n      .pipe_tx_rate_o(pipe_tx_rate_o),\n      .pipe_tx_deemph_o(pipe_tx_deemph_o),\n      .pipe_tx_margin_o(pipe_tx_margin_o),\n      .pipe_tx_swing_o(pipe_tx_swing_o),\n      .pipe_clk(pipe_clk),\n      .rst_n(rst_n)\n    );\n\n    /* \u4e0a\u8ff0\u4e3a Lane 0 \u7684\u5b9e\u4f8b\u5316 */\n\n    if (LINK_CAP_MAX_LINK_WIDTH >= 2) begin : pipe_2_lane\n      /* Lane 1 \u7684\u5b9e\u4f8b\u5316 */\n    end else begin\n      /* Lane 1 \u7684\u4fe1\u53f7\u5206\u914d */\n    end\n    if (LINK_CAP_MAX_LINK_WIDTH >= 4) begin : pipe_4_lane\n      /* Lane 2 \u548c Lane 3 \u7684\u5b9e\u4f8b\u5316 */\n    end else begin\n      /* Lane 2 \u548c Lane 3 \u7684\u4fe1\u53f7\u5206\u914d */\n    end\n    if (LINK_CAP_MAX_LINK_WIDTH >= 8) begin : pipe_8_lane\n      /* Lane 4 \u5230 Lane 7 \u7684\u5b9e\u4f8b\u5316 */\n    end else begin\n      /* Lane 4 \u5230 Lane 7 \u7684\u4fe1\u53f7\u5206\u914d */\n    end\n  endgenerate\nendmodule"}
{"task_id": 1030, "completion": "wire \\blk00000001/sig00000043 ;\n  wire \\blk00000001/sig00000042 ;\n  wire \\blk00000001/sig00000041 ;\n  wire \\blk00000001/sig00000040 ;\n  wire \\blk00000001/sig0000003f ;\n  wire \\blk00000001/sig0000003e ;\n  wire \\blk00000001/sig0000003d ;\n  wire \\blk00000001/sig0000003c ;\n  wire \\blk00000001/sig0000003b ;\n  wire \\blk00000001/sig0000003a ;\n  wire \\blk00000001/sig00000039 ;\n  wire \\blk00000001/sig00000038 ;\n  wire \\blk00000001/sig00000037 ;\n  wire \\blk00000001/sig00000036 ;\n  wire \\blk00000001/sig00000035 ;\n  wire \\blk00000001/sig00000034 ;\n  wire \\blk00000001/sig00000033 ;\n  wire \\blk00000001/sig00000032 ;\n  wire \\blk00000001/sig00000031 ;\n  wire \\blk00000001/sig00000030 ;\n  wire \\blk00000001/sig0000002f ;\n  wire \\blk00000001/sig0000002e ;\n  wire \\blk00000001/sig0000002d ;\n  wire \\blk00000001/sig0000002c ;\n  wire \\blk00000001/sig0000002b ;\n  wire \\blk00000001/sig0000002a ;\n  wire \\blk00000001/sig00000029 ;\n  wire \\blk00000001/sig00000028 ;\n  wire \\blk00000001/sig00000027 ;\n  wire \\blk00000001/sig00000026 ;\n  wire \\blk00000001/sig00000025 ;\n  wire \\blk00000001/sig00000024 ;\n  wire \\blk00000001/sig00000023 ;\n  wire \\NLW_blk00000001/blk00000004_P<34>_UNCONNECTED ;\n  wire \\NLW_blk00000001/blk00000004_P<33>_UNCONNECTED ;\n  wire \\NLW_blk00000001/blk00000004_P<32>_UNCONNECTED ;\n  wire \\NLW_blk00000001/blk00000004_P<31>_UNCONNECTED ;\n  FD #( \n    .INIT ( 1'b0 ))\n  \\blk00000001/blk00000024  ( \n    .C(clk),\n    .D(\\blk00000001/sig00000024 ),\n    .Q(p[0])\n  );\n  FD #( \n    .INIT ( 1'b0 ))\n  \\blk00000001/blk00000023  ( \n    .C(clk),\n    .D(\\blk00000001/sig0000002f ),\n    .Q(p[1])\n  );\n  FD #( \n    .INIT ( 1'b0 ))\n  \\blk00000001/blk00000022  ( \n    .C(clk),\n    .D(\\blk00000001/sig0000003a ),\n    .Q(p[2])\n  );\n  FD #( \n    .INIT ( 1'b0 ))\n  \\blk00000001/blk00000021  ( \n    .C(clk),\n    .D(\\blk00000001/sig0000003d ),\n    .Q(p[3])\n  );\n  FD #( \n    .INIT ( 1'b0 ))\n  \\blk00000001/blk00000020  ( \n    .C(clk),\n    .D(\\blk00000001/sig0000003e ),\n    .Q(p[4])\n  );\n  FD #( \n    .INIT ( 1'b0 ))\n  \\blk00000001/blk0000001f  ( \n    .C(clk),\n    .D(\\blk00000001/sig0000003f ),\n    .Q(p[5])\n  );\n  FD #( \n    .INIT ( 1'b0 ))\n  \\blk00000001/blk0000001e  ( \n    .C(clk),\n    .D(\\blk00000001/sig00000040 ),\n    .Q(p[6])\n  );\n  FD #( \n    .INIT ( 1'b0 ))\n  \\blk00000001/blk0000001d  ( \n    .C(clk),\n    .D(\\blk00000001/sig00000041 ),\n    .Q(p[7])\n  );\n  FD #( \n    .INIT ( 1'b0 ))\n  \\blk00000001/blk0000001c  ( \n    .C(clk),\n    .D(\\blk00000001/sig00000042 ),\n    .Q(p[8])\n  );\n  FD #( \n    .INIT ( 1'b0 ))\n  \\blk00000001/blk0000001b  ( \n    .C(clk),\n    .D(\\blk00000001/sig00000043 ),\n    .Q(p[9])\n  );\n  FD #( \n    .INIT ( 1'b0 ))\n  \\blk00000001/blk0000001a  ( \n    .C(clk),\n    .D(\\blk00000001/sig00000025 ),\n    .Q(p[10])\n  );\n  FD #( \n    .INIT ( 1'b0 ))\n  \\blk00000001/blk00000019  ( \n    .C(clk),\n    .D(\\blk00000001/sig00000026 ),\n    .Q(p[11])\n  );\n  FD #( \n    .INIT ( 1'b0 ))\n  \\blk00000001/blk00000018  ( \n    .C(clk),\n    .D(\\blk00000001/sig00000027 ),\n    .Q(p[12])\n  );\n  FD #( \n    .INIT ( 1'b0 ))\n  \\blk00000001/blk00000017  ( \n    .C(clk),\n    .D(\\blk00000001/sig00000028 ),\n    .Q(p[13])\n  );\n  FD #( \n    .INIT ( 1'b0 ))\n  \\blk00000001/blk00000016  ( \n    .C(clk),\n    .D(\\blk00000001/sig00000029 ),\n    .Q(p[14])\n  );\n  FD #( \n    .INIT ( 1'b0 ))\n  \\blk00000001/blk00000015  ( \n    .C(clk),\n    .D(\\blk00000001/sig0000002a ),\n    .Q(p[15])\n  );\n  FD #( \n    .INIT ( 1'b0 ))\n  \\blk00000001/blk00000014  ( \n    .C(clk),\n    .D(\\blk00000001/sig0000002b ),\n    .Q(p[16])\n  );\n  FD #( \n    .INIT ( 1'b0 ))\n  \\blk00000001/blk00000013  ( \n    .C(clk),\n    .D(\\blk00000001/sig0000002c ),\n    .Q(p[17])\n  );\n  FD #( \n    .INIT ( 1'b0 ))\n  \\blk00000001/blk00000012  ( \n    .C(clk),\n    .D(\\blk00000001/sig0000002d ),\n    .Q(p[18])\n  );\n  FD #( \n    .INIT ( 1'b0 ))\n  \\blk00000001/blk00000011  ( \n    .C(clk),\n    .D(\\blk00000001/sig0000002e ),\n    .Q(p[19])\n  );\n  FD #( \n    .INIT ( 1'b0 ))\n  \\blk00000001/blk00000010  ( \n    .C(clk),\n    .D(\\blk00000001/sig00000030 ),\n    .Q(p[20])\n  );\n  FD #( \n    .INIT ( 1'b0 ))\n  \\blk00000001/blk0000000f  ( \n    .C(clk),\n    .D(\\blk00000001/sig00000031 ),\n    .Q(p[21])\n  );\n  FD #( \n    .INIT ( 1'b0 ))\n  \\blk00000001/blk0000000e  ( \n    .C(clk),\n    .D(\\blk00000001/sig00000032 ),\n    .Q(p[22])\n  );\n  FD #( \n    .INIT ( 1'b0 ))\n  \\blk00000001/blk0000000d  ( \n    .C(clk),\n    .D(\\blk00000001/sig00000033 ),\n    .Q(p[23])\n  );\n  FD #( \n    .INIT ( 1'b0 ))\n  \\blk00000001/blk0000000c  ( \n    .C(clk),\n    .D(\\blk00000001/sig00000034 ),\n    .Q(p[24])\n  );\n  FD #( \n    .INIT ( 1'b0 ))\n  \\blk00000001/blk0000000b  ( \n    .C(clk),\n    .D(\\blk00000001/sig00000035 ),\n    .Q(p[25])\n  );\n  FD #( \n    .INIT ( 1'b0 ))\n  \\blk00000001/blk0000000a  ( \n    .C(clk),\n    .D(\\blk00000001/sig00000036 ),\n    .Q(p[26])\n  );\n  FD #( \n    .INIT ( 1'b0 ))\n  \\blk00000001/blk00000009  ( \n    .C(clk),\n    .D(\\blk00000001/sig00000037 ),\n    .Q(p[27])\n  );\n  FD #( \n    .INIT ( 1'b0 ))\n  \\blk00000001/blk00000008  ( \n    .C(clk),\n    .D(\\blk00000001/sig00000038 ),\n    .Q(p[28])\n  );\n  FD #( \n    .INIT ( 1'b0 ))\n  \\blk00000001/blk00000007  ( \n    .C(clk),\n    .D(\\blk00000001/sig00000039 ),\n    .Q(p[29])\n  );\n  FD #( \n    .INIT ( 1'b0 ))\n  \\blk00000001/blk00000006  ( \n    .C(clk),\n    .D(\\blk00000001/sig0000003b ),\n    .Q(p[30])\n  );\n  FD #( \n    .INIT ( 1'b0 ))\n  \\blk00000001/blk00000005  ( \n    .C(clk),\n    .D(\\blk00000001/sig0000003c ),\n    .Q(p[31])\n  );\n  MULT18X18S   \\blk00000001/blk00000004  ( \n    .C(clk),\n    .CE(\\blk00000001/sig00000023 ),\n    .R(\\blk00000001/sig00000022 ),\n    .A({a[15], a[15], a[15], a[14], a[13], a[12], a[11], a[10], a[9], a[8], a[7], a[6], a[5], a[4], a[3], a[2], a[1], a[0]}),\n    .B({b[15], b[15], b[15], b[14], b[13], b[12], b[11], b[10], b[9], b[8], b[7], b[6], b[5], b[4], b[3], b[2], b[1], b[0]}),\n    .P({\\blk00000001/sig0000003c , \\NLW_blk00000001/blk00000004_P<34>_UNCONNECTED , \\NLW_blk00000001/blk00000004_P<33>_UNCONNECTED , \n\\NLW_blk00000001/blk00000004_P<32>_UNCONNECTED , \\NLW_blk00000001/blk00000004_P<31>_UNCONNECTED , \\blk00000001/sig0000003b , \\blk00000001/sig00000039 \n, \\blk00000001/sig00000038 , \\blk00000001/sig00000037 , \\blk00000001/sig00000036 , \\blk00000001/sig00000035 , \\blk00000001/sig00000034 , \n\\blk00000001/sig00000033 , \\blk00000001/sig00000032 , \\blk00000001/sig00000031 , \\blk00000001/sig00000030 , \\blk00000001/sig0000002e , \n\\blk00000001/sig0000002d , \\blk00000001/sig0000002c , \\blk00000001/sig0000002b , \\blk00000001/sig0000002a , \\blk00000001/sig00000029 , \n\\blk00000001/sig00000028 , \\blk00000001/sig00000027 , \\blk00000001/sig00000026 , \\blk00000001/sig00000025 , \\blk00000001/sig00000043 , \n\\blk00000001/sig00000042 , \\blk00000001/sig00000041 , \\blk00000001/sig00000040 , \\blk00000001/sig0000003f , \\blk00000001/sig0000003e , \n\\blk00000001/sig0000003d , \\blk00000001/sig0000003a , \\blk00000001/sig0000002f , \\blk00000001/sig00000024 })\n  );\n  VCC   \\blk00000001/blk00000003  ( \n    .P(\\blk00000001/sig00000023 )\n  );\n  GND   \\blk00000001/blk00000002  ( \n    .G(\\blk00000001/sig00000022 )\n  );\n\nendmodule"}
{"task_id": 1144, "completion": "// synthesis translate_off\n\n  BLK_MEM_GEN_V6_2 #(\n    .C_ADDRA_WIDTH(10),\n    .C_ADDRB_WIDTH(10),\n    .C_ALGORITHM(1),\n    .C_AXI_ID_WIDTH(4),\n    .C_AXI_SLAVE_TYPE(0),\n    .C_AXI_TYPE(1),\n    .C_BYTE_SIZE(9),\n    .C_COMMON_CLK(0),\n    .C_DEFAULT_DATA(\"0\"),\n    .C_DISABLE_WARN_BHV_COLL(0),\n    .C_DISABLE_WARN_BHV_RANGE(0),\n    .C_FAMILY(\"spartan3\"),\n    .C_HAS_AXI_ID(0),\n    .C_HAS_ENA(0),\n    .C_HAS_ENB(0),\n    .C_HAS_INJECTERR(0),\n    .C_HAS_MEM_OUTPUT_REGS_A(0),\n    .C_HAS_MEM_OUTPUT_REGS_B(0),\n    .C_HAS_MUX_OUTPUT_REGS_A(0),\n    .C_HAS_MUX_OUTPUT_REGS_B(0),\n    .C_HAS_REGCEA(0),\n    .C_HAS_REGCEB(0),\n    .C_HAS_RSTA(0),\n    .C_HAS_RSTB(0),\n    .C_HAS_SOFTECC_INPUT_REGS_A(0),\n    .C_HAS_SOFTECC_OUTPUT_REGS_B(0),\n    .C_INIT_FILE_NAME(\"cx4_datrom.mif\"),\n    .C_INITA_VAL(\"0\"),\n    .C_INITB_VAL(\"0\"),\n    .C_INTERFACE_TYPE(0),\n    .C_LOAD_INIT_FILE(1),\n    .C_MEM_TYPE(3),\n    .C_MUX_PIPELINE_STAGES(0),\n    .C_PRIM_TYPE(1),\n    .C_READ_DEPTH_A(1024),\n    .C_READ_DEPTH_B(1024),\n    .C_READ_WIDTH_A(24),\n    .C_READ_WIDTH_B(24),\n    .C_RST_PRIORITY_A(\"CE\"),\n    .C_RST_PRIORITY_B(\"CE\"),\n    .C_RST_TYPE(\"SYNC\"),\n    .C_RSTRAM_A(0),\n    .C_RSTRAM_B(0),\n    .C_SIM_COLLISION_CHECK(\"ALL\"),\n    .C_USE_BYTE_WEA(0),\n    .C_USE_BYTE_WEB(0),\n    .C_USE_DEFAULT_DATA(0),\n    .C_USE_ECC(0),\n    .C_USE_SOFTECC(0),\n    .C_WEA_WIDTH(1),\n    .C_WEB_WIDTH(1),\n    .C_WRITE_DEPTH_A(1024),\n    .C_WRITE_DEPTH_B(1024),\n    .C_WRITE_MODE_A(\"WRITE_FIRST\"),\n    .C_WRITE_MODE_B(\"WRITE_FIRST\"),\n    .C_WRITE_WIDTH_A(24),\n    .C_WRITE_WIDTH_B(24),\n    .C_XDEVICEFAMILY(\"spartan3\")\n  )\n  inst (\n    .CLKA(clka),\n    .ADDRA(addra),\n    .DOUTA(douta),\n    .RSTA(),\n    .ENA(),\n    .REGCEA(),\n    .WEA(),\n    .DINA(),\n    .CLKB(),\n    .RSTB(),\n    .ENB(),\n    .REGCEB(),\n    .WEB(),\n    .ADDRB(),\n    .DINB(),\n    .DOUTB(),\n    .INJECTSBITERR(),\n    .INJECTDBITERR(),\n    .SBITERR(),\n    .DBITERR(),\n    .RDADDRECC(),\n    .S_ACLK(),\n    .S_ARESETN(),\n    .S_AXI_AWID(),\n    .S_AXI_AWADDR(),\n    .S_AXI_AWLEN(),\n    .S_AXI_AWSIZE(),\n    .S_AXI_AWBURST(),\n    .S_AXI_AWVALID(),\n    .S_AXI_AWREADY(),\n    .S_AXI_WDATA(),\n    .S_AXI_WSTRB(),\n    .S_AXI_WLAST(),\n    .S_AXI_WVALID(),\n    .S_AXI_WREADY(),\n    .S_AXI_BID(),\n    .S_AXI_BRESP(),\n    .S_AXI_BVALID(),\n    .S_AXI_BREADY(),\n    .S_AXI_ARID(),\n    .S_AXI_ARADDR(),\n    .S_AXI_ARLEN(),\n    .S_AXI_ARSIZE(),\n    .S_AXI_ARBURST(),\n    .S_AXI_ARVALID(),\n    .S_AXI_ARREADY(),\n    .S_AXI_RID(),\n    .S_AXI_RDATA(),\n    .S_AXI_RRESP(),\n    .S_AXI_RLAST(),\n    .S_AXI_RVALID(),\n    .S_AXI_RREADY(),\n    .S_AXI_INJECTSBITERR(),\n    .S_AXI_INJECTDBITERR(),\n    .S_AXI_SBITERR(),\n    .S_AXI_DBITERR(),\n    .S_AXI_RDADDRECC()\n  );\n\n  // synthesis translate_on\n\nendmodule"}
{"task_id": 1154, "completion": "wire [`POOL_OUT_BITWIDTH:0] adder_tree_wire [(`NEIGHBORHOOD_SIZE*2)-1-1:0];  assign pool_out = adder_tree_wire[0] / `NEIGHBORHOOD_SIZE;  genvar i;  generate  for(i=(`NEIGHBORHOOD_SIZE*2)-2; i >=1; i=i-2) begin : adder_tree    pool_add2 pool_add2_inst(      .clock(clock),      .reset(reset),      .operand_a(adder_tree_wire[i-1]),      .operand_b(adder_tree_wire[i]),      .sum(adder_tree_wire[(i/2)-1])    );  end // for  endgenerate  genvar j;  generate  for(j=0; j < `NEIGHBORHOOD_SIZE; j=j+1) begin : connect_input_to_adder_tree    assign adder_tree_wire[j+`NEIGHBORHOOD_SIZE-1] = {`POOL_TREE_PAD'd0, nh_vector[(`NN_WIDTH*j)+`NN_BITWIDTH:`NN_WIDTH*j] };  end // for  endgenerateendmodule"}
{"task_id": 1145, "completion": "// \u5185\u90e8\u4fe1\u53f7\u58f0\u660e\n    reg Q_int;\n\n    // \u89e6\u53d1\u5668\u903b\u8f91\n    always @(negedge CLK_N or negedge RESET_B) begin\n        if (!RESET_B) begin\n            Q_int <= 1'b0;\n        end else begin\n            Q_int <= D;\n        end\n    end\n\n    assign Q = Q_int;\n\nendmodule"}
{"task_id": 1113, "completion": "wire             clk_en; \n  reg     [ 31: 0] data_out; \n  wire    [ 31: 0] out_port; \n  wire    [ 31: 0] read_mux_out; \n  wire    [ 31: 0] readdata; \n  assign clk_en = 1; \n  assign read_mux_out = {32 {(address == 0)}} & data_out; \n  always @(posedge clk or negedge reset_n) \n    begin \n      if (reset_n == 0) \n          data_out <= 0; \n      else if (chipselect && ~write_n && (address == 0)) \n          data_out <= writedata[31 : 0]; \n    end \n  assign readdata = {32'b0 | read_mux_out}; \n  assign out_port = data_out; \nendmodule"}
{"task_id": 1137, "completion": "uart_tx #(\n        .DATA_WIDTH(DATA_WIDTH)\n    )\n    uart_tx_inst (\n        .clk(clk),\n        .rst(rst),\n        // axi input\n        .s_axis_tdata(s_axis_tdata),\n        .s_axis_tvalid(s_axis_tvalid),\n        .s_axis_tready(s_axis_tready),\n        // output\n        .txd(txd),\n        // status\n        .busy(tx_busy),\n        // configuration\n        .prescale(prescale)\n    );\n\n    uart_rx #(\n        .DATA_WIDTH(DATA_WIDTH)\n    )\n    uart_rx_inst (\n        .clk(clk),\n        .rst(rst),\n        // axi output\n        .m_axis_tdata(m_axis_tdata),\n        .m_axis_tvalid(m_axis_tvalid),\n        .m_axis_tready(m_axis_tready),\n        // input\n        .rxd(rxd),\n        // status\n        .busy(rx_busy),\n        .overrun_error(rx_overrun_error),\n        .frame_error(rx_frame_error),\n        // configuration\n        .prescale(prescale)\n    );\n\nendmodule"}
{"task_id": 1125, "completion": "wire almost_empty; wire almost_full; wire empty; reg [1:0] entries; reg [42:0] entry_0; reg [42:0] entry_1; wire full; reg rd_address; reg [42:0] rd_data; wire [1:0] rdwr; reg wr_address; assign rdwr = {rd, wr}; assign full = entries == 2; assign almost_full = entries >= 1; assign empty = entries == 0; assign almost_empty = entries <= 1; always @(entry_0 or entry_1 or rd_address) begin case (rd_address) 1'd0: begin rd_data = entry_0; end 1'd1: begin rd_data = entry_1; end default: begin end endcase end always @(posedge clk or negedge reset_n) begin if (reset_n == 0) begin wr_address <= 0; rd_address <= 0; entries <= 0; end else case (rdwr) 2'd1: begin if (!full) begin entries <= entries + 1; wr_address <= (wr_address == 1) ? 0 : (wr_address + 1); end end 2'd2: begin if (!empty) begin entries <= entries - 1; rd_address <= (rd_address == 1) ? 0 : (rd_address + 1); end end 2'd3: begin wr_address <= (wr_address == 1) ? 0 : (wr_address + 1); rd_address <= (rd_address == 1) ? 0 : (rd_address + 1); end default: begin end endcase end always @(posedge clk) begin if (wr & !full) begin case (wr_address) 1'd0: begin entry_0 <= wr_data; end 1'd1: begin entry_1 <= wr_data; end default: begin end endcase end endendmodule"}
{"task_id": 1149, "completion": "endmodule"}
{"task_id": 1162, "completion": "logic[16:0] arr;\n\n    always begin\n        arr[15:0] <= arr[16:1];\n        @(clk); wait(clk == 1'b1);\n    end\n\n    assign arr[16] = inp;\n    assign arr_out = arr;\n\nendmodule"}
{"task_id": 1064, "completion": "// synthesis translate_off\n\n  BLK_MEM_GEN_V7_3 #(\n    .C_ADDRA_WIDTH(8),\n    .C_ADDRB_WIDTH(8),\n    .C_ALGORITHM(1),\n    .C_AXI_ID_WIDTH(4),\n    .C_AXI_SLAVE_TYPE(0),\n    .C_AXI_TYPE(1),\n    .C_BYTE_SIZE(9),\n    .C_COMMON_CLK(0),\n    .C_DEFAULT_DATA(\"0\"),\n    .C_DISABLE_WARN_BHV_COLL(0),\n    .C_DISABLE_WARN_BHV_RANGE(0),\n    .C_ENABLE_32BIT_ADDRESS(0),\n    .C_FAMILY(\"spartan6\"),\n    .C_HAS_AXI_ID(0),\n    .C_HAS_ENA(0),\n    .C_HAS_ENB(0),\n    .C_HAS_INJECTERR(0),\n    .C_HAS_MEM_OUTPUT_REGS_A(0),\n    .C_HAS_MEM_OUTPUT_REGS_B(0),\n    .C_HAS_MUX_OUTPUT_REGS_A(0),\n    .C_HAS_MUX_OUTPUT_REGS_B(0),\n    .C_HAS_REGCEA(0),\n    .C_HAS_REGCEB(0),\n    .C_HAS_RSTA(0),\n    .C_HAS_RSTB(0),\n    .C_HAS_SOFTECC_INPUT_REGS_A(0),\n    .C_HAS_SOFTECC_OUTPUT_REGS_B(0),\n    .C_INIT_FILE(\"BlankString\"),\n    .C_INIT_FILE_NAME(\"instructionROM.mif\"),\n    .C_INITA_VAL(\"0\"),\n    .C_INITB_VAL(\"0\"),\n    .C_INTERFACE_TYPE(0),\n    .C_LOAD_INIT_FILE(1),\n    .C_MEM_TYPE(3),\n    .C_MUX_PIPELINE_STAGES(0),\n    .C_PRIM_TYPE(1),\n    .C_READ_DEPTH_A(256),\n    .C_READ_DEPTH_B(256),\n    .C_READ_WIDTH_A(32),\n    .C_READ_WIDTH_B(32),\n    .C_RST_PRIORITY_A(\"CE\"),\n    .C_RST_PRIORITY_B(\"CE\"),\n    .C_RST_TYPE(\"SYNC\"),\n    .C_RSTRAM_A(0),\n    .C_RSTRAM_B(0),\n    .C_SIM_COLLISION_CHECK(\"ALL\"),\n    .C_USE_BRAM_BLOCK(0),\n    .C_USE_BYTE_WEA(0),\n    .C_USE_BYTE_WEB(0),\n    .C_USE_DEFAULT_DATA(1),\n    .C_USE_ECC(0),\n    .C_USE_SOFTECC(0),\n    .C_WEA_WIDTH(1),\n    .C_WEB_WIDTH(1),\n    .C_WRITE_DEPTH_A(256),\n    .C_WRITE_DEPTH_B(256),\n    .C_WRITE_MODE_A(\"WRITE_FIRST\"),\n    .C_WRITE_MODE_B(\"WRITE_FIRST\"),\n    .C_WRITE_WIDTH_A(32),\n    .C_WRITE_WIDTH_B(32),\n    .C_XDEVICEFAMILY(\"spartan6\")\n  )\n  inst (\n    .CLKA(clka),\n    .ADDRA(addra),\n    .DOUTA(douta),\n    .RSTA(),\n    .ENA(),\n    .REGCEA(),\n    .WEA(),\n    .DINA(),\n    .CLKB(),\n    .RSTB(),\n    .ENB(),\n    .REGCEB(),\n    .WEB(),\n    .ADDRB(),\n    .DINB(),\n    .DOUTB(),\n    .INJECTSBITERR(),\n    .INJECTDBITERR(),\n    .SBITERR(),\n    .DBITERR(),\n    .RDADDRECC(),\n    .S_ACLK(),\n    .S_ARESETN(),\n    .S_AXI_AWID(),\n    .S_AXI_AWADDR(),\n    .S_AXI_AWLEN(),\n    .S_AXI_AWSIZE(),\n    .S_AXI_AWBURST(),\n    .S_AXI_AWVALID(),\n    .S_AXI_AWREADY(),\n    .S_AXI_WDATA(),\n    .S_AXI_WSTRB(),\n    .S_AXI_WLAST(),\n    .S_AXI_WVALID(),\n    .S_AXI_WREADY(),\n    .S_AXI_BID(),\n    .S_AXI_BRESP(),\n    .S_AXI_BVALID(),\n    .S_AXI_BREADY(),\n    .S_AXI_ARID(),\n    .S_AXI_ARADDR(),\n    .S_AXI_ARLEN(),\n    .S_AXI_ARSIZE(),\n    .S_AXI_ARBURST(),\n    .S_AXI_ARVALID(),\n    .S_AXI_ARREADY(),\n    .S_AXI_RID(),\n    .S_AXI_RDATA(),\n    .S_AXI_RRESP(),\n    .S_AXI_RLAST(),\n    .S_AXI_RVALID(),\n    .S_AXI_RREADY(),\n    .S_AXI_INJECTSBITERR(),\n    .S_AXI_INJECTDBITERR(),\n    .S_AXI_SBITERR(),\n    .S_AXI_DBITERR(),\n    .S_AXI_RDADDRECC()\n  );\n\n  // synthesis translate_on\n\nendmodule"}
{"task_id": 1159, "completion": "reg load;\n    reg next_point;\n\n    /* Interpolators */\n    tmu2_geninterp18 i_tx(\n        .sys_clk(sys_clk),\n        .load(load),\n        .next_point(next_point),\n        .init(tsx),\n        .positive(diff_x_positive),\n        .q(diff_x_q),\n        .r(diff_x_r),\n        .divisor({6'd0, dst_squarew}),\n        .o(tx)\n    );\n    tmu2_geninterp18 i_ty(\n        .sys_clk(sys_clk),\n        .load(load),\n        .next_point(next_point),\n        .init(tsy),\n        .positive(diff_y_positive),\n        .q(diff_y_q),\n        .r(diff_y_r),\n        .divisor({6'd0, dst_squarew}),\n        .o(ty)\n    );\n\n    always @(posedge sys_clk) begin\n        if(load) begin\n            dx <= x;\n            dy <= y;\n        end else if(next_point)\n            dx <= dx + 12'd1;\n    end\n\n    /* Controller */\n    reg [10:0] remaining_points;\n    always @(posedge sys_clk) begin\n        if(load)\n            remaining_points <= dst_squarew - 11'd1;\n        else if(next_point)\n            remaining_points <= remaining_points - 11'd1;\n    end\n    wire last_point = remaining_points == 11'd0;\n\n    reg state;\n    reg next_state;\n\n    parameter IDLE\t= 1'b0;\n    parameter BUSY\t= 1'b1;\n\n    always @(posedge sys_clk) begin\n        if(sys_rst)\n            state <= IDLE;\n        else\n            state <= next_state;\n    end\n\n    assign busy = state;\n    assign pipe_ack_o = ~state;\n    assign pipe_stb_o = state;\n\n    always @(*) begin\n        next_state = state;\n        load = 1'b0;\n        next_point = 1'b0;\n\n        case(state)\n            IDLE: begin\n                if(pipe_stb_i) begin\n                    load = 1'b1;\n                    next_state = BUSY;\n                end\n            end\n            BUSY: begin\n                if(pipe_ack_i) begin\n                    if(last_point)\n                        next_state = IDLE;\n                    else\n                        next_point = 1'b1;\n                end\n            end\n        endcase\n    end\n\nendmodule"}
{"task_id": 1147, "completion": "endmodule"}
{"task_id": 1150, "completion": "// \u8868\u8fbe\u5f0f\u7c7b\u578b\n    typedef enum reg [1:0] {\n        BOOL,\n        NAT,\n        INVALID\n    } expr_type;\n\n    expr_type current_type;\n\n    always @(*) begin\n        case (expr_in)\n            // \u5e03\u5c14\u503c\u7684\u7c7b\u578b\n            tru:    current_type = BOOL;\n            fls:    current_type = BOOL;\n            // \u81ea\u7136\u6570\u7684\u7c7b\u578b\n            zro:    current_type = NAT;\n            // \u9012\u589e\n            scc:    current_type = NAT;\n            // \u9012\u51cf\n            prd:    current_type = NAT;\n            // \u5224\u65ad\u662f\u5426\u4e3a\u96f6\n            iszero: current_type = BOOL;\n            default: current_type = INVALID;\n        endcase\n    end\n\n    assign type_out = current_type;\n\nendmodule"}
{"task_id": 1152, "completion": "wire             clk_en;  reg     [  7: 0] data_out;  wire    [  7: 0] read_mux_out;  assign clk_en = 1;  assign read_mux_out = {8 {(address == 0)}} & data_out;  always @(posedge clk or negedge reset_n)  begin    if (reset_n == 0)        data_out <= 0;    else if (chipselect && ~write_n && (address == 0))        data_out <= writedata[7 : 0];  end  assign readdata = {32'b0 | read_mux_out};  assign out_port = data_out;endmodule"}
{"task_id": 1161, "completion": "wire                  aclk;\n    wire                  aclken;\n    wire                  a_tvalid;\n    wire [63:0]           a_tdata;\n    wire                  b_tvalid;\n    wire [63:0]           b_tdata;\n    wire                  r_tvalid;\n    wire [63:0]           r_tdata;\n    reg  [din0_WIDTH-1:0] din0_buf1;\n    reg  [din1_WIDTH-1:0] din1_buf1;\n\n    feedforward_ap_ddiv_29_no_dsp_64 feedforward_ap_ddiv_29_no_dsp_64_u (\n        .aclk                 ( aclk ),\n        .aclken               ( aclken ),\n        .s_axis_a_tvalid      ( a_tvalid ),\n        .s_axis_a_tdata       ( a_tdata ),\n        .s_axis_b_tvalid      ( b_tvalid ),\n        .s_axis_b_tdata       ( b_tdata ),\n        .m_axis_result_tvalid ( r_tvalid ),\n        .m_axis_result_tdata  ( r_tdata )\n    );\n\n    assign aclk     = clk;\n    assign aclken   = ce;\n    assign a_tvalid = 1'b1;\n    assign a_tdata  = din0_buf1==='bx ? 'b0 : din0_buf1;\n    assign b_tvalid = 1'b1;\n    assign b_tdata  = din1_buf1==='bx ? 'b0 : din1_buf1;\n    assign dout     = r_tdata;\n\n    always @(posedge clk) begin\n        if (ce) begin\n            din0_buf1 <= din0;\n            din1_buf1 <= din1;\n        end\n    end\n\nendmodule"}
{"task_id": 1157, "completion": "// \u5b9a\u4e49\u603b\u6620\u5c04\u7c7b\u578b\u548c\u76f8\u5173\u51fd\u6570\n    typedef function [A] \n    total_map; \n\n    function total_map t_empty(A v); \n        return fun (key) => v;\n    endfunction; \n\n    function total_map t_update(total_map m, string x, A v); \n        return fun (key) => if eqb_string x key then v else m(key);\n    endfunction; \n\n    endmodule"}
{"task_id": 1174, "completion": "wire aclk;    wire aclken;    wire a_tvalid;    wire [31:0] a_tdata;    wire b_tvalid;    wire [31:0] b_tdata;    wire r_tvalid;    wire [31:0] r_tdata;    reg [din0_WIDTH-1:0] din0_buf1;    reg [din1_WIDTH-1:0] din1_buf1;    convolve_kernel_ap_fadd_3_full_dsp_32 convolve_kernel_ap_fadd_3_full_dsp_32_u (        .aclk ( aclk ),        .aclken ( aclken ),        .s_axis_a_tvalid ( a_tvalid ),        .s_axis_a_tdata ( a_tdata ),        .s_axis_b_tvalid ( b_tvalid ),        .s_axis_b_tdata ( b_tdata ),        .m_axis_result_tvalid ( r_tvalid ),        .m_axis_result_tdata ( r_tdata )    );    assign aclk = clk;    assign aclken = ce;    assign a_tvalid = 1'b1;    assign a_tdata = din0_buf1;    assign b_tvalid = 1'b1;    assign b_tdata = din1_buf1;    assign dout = r_tdata;    always @(posedge clk) begin        if (ce) begin            din0_buf1 <= din0;            din1_buf1 <= din1;        end    endendmodule"}
{"task_id": 1179, "completion": "assign r = (addr == 4'b0000) ? 1'b1 : 1'b0;\n    assign s = (addr == 4'b0001) ? 1'b1 : 1'b0;\n    assign t = (addr == 4'b0010) ? 1'b1 : 1'b0;\n    assign x = (addr == 4'b0011) ? 1'b1 : 1'b0;\n    assign y = (addr == 4'b0100) ? 1'b1 : 1'b0;\n    assign z = (addr == 4'b0101) ? 1'b1 : 1'b0;\nendmodule"}
{"task_id": 1158, "completion": "reg              enable_action_strobe;\n  reg     [1:0] ir;\n  reg     [37:0] jdo;\n  reg              jxuir;\n  reg              sync2_udr;\n  reg              sync2_uir;\n  wire             sync_udr;\n  wire             sync_uir;\n  wire             take_action_ocimem_a;\n  wire             take_no_action_ocimem_a;\n  wire             take_action_ocimem_b;\n  wire             take_action_tracemem_a;\n  wire             take_no_action_tracemem_a;\n  wire             take_action_tracemem_b;\n  wire             take_action_break_a;\n  wire             take_no_action_break_a;\n  wire             take_action_break_b;\n  wire             take_no_action_break_b;\n  wire             take_action_break_c;\n  wire             take_no_action_break_c;\n  wire             take_action_tracectrl;\n  reg              update_jdo_strobe;\n  assign sync_udr = vs_udr;\n  assign sync_uir = vs_uir;\n  always @(posedge clk) begin\n    sync2_udr <= sync_udr;\n    update_jdo_strobe <= sync_udr & ~sync2_udr;\n    enable_action_strobe <= update_jdo_strobe;\n    sync2_uir <= sync_uir;\n    jxuir <= sync_uir & ~sync2_uir;\n  end\n  assign take_action_ocimem_a = enable_action_strobe && (ir == 2'b00) && ~jdo[35] && jdo[34];\n  assign take_no_action_ocimem_a = enable_action_strobe && (ir == 2'b00) && ~jdo[35] && ~jdo[34];\n  assign take_action_ocimem_b = enable_action_strobe && (ir == 2'b00) && jdo[35];\n  assign take_action_tracemem_a = enable_action_strobe && (ir == 2'b01) && ~jdo[37] && jdo[36];\n  assign take_no_action_tracemem_a = enable_action_strobe && (ir == 2'b01) && ~jdo[37] && ~jdo[36];\n  assign take_action_tracemem_b = enable_action_strobe && (ir == 2'b01) && jdo[37];\n  assign take_action_break_a = enable_action_strobe && (ir == 2'b10) && ~jdo[36] && jdo[37];\n  assign take_no_action_break_a = enable_action_strobe && (ir == 2'b10) && ~jdo[36] && ~jdo[37];\n  assign take_action_break_b = enable_action_strobe && (ir == 2'b10) && jdo[36] && ~jdo[35] && jdo[37];\n  assign take_no_action_break_b = enable_action_strobe && (ir == 2'b10) && jdo[36] && ~jdo[35] && ~jdo[37];\n  assign take_action_break_c = enable_action_strobe && (ir == 2'b10) && jdo[36] && jdo[35] && jdo[37];\n  assign take_no_action_break_c = enable_action_strobe && (ir == 2'b10) && jdo[36] && jdo[35] && ~jdo[37];\n  assign take_action_tracectrl = enable_action_strobe && (ir == 2'b11) && jdo[15];\n  always @(posedge clk) begin\n    if (jxuir)\n        ir <= ir_in;\n    if (update_jdo_strobe)\n        jdo <= sr;\n  end\nendmodule"}
{"task_id": 1131, "completion": "reg [WORDS-1:0] waddr_dec;\nalways @(*) begin\n\twaddr_dec = 0;\n\twaddr_dec[waddr] = 1'b1;\nend\n\n//////////////////////////////////////\n// RAM address pointer\n//////////////////////////////////////\n\treg rst_ptr;\n\treg [DATA_WIDTH-1:0] addr_ptr,last_addr_ptr,last2_addr_ptr;\n\treg ptr_max;\n\n\talways @(posedge clk) begin\n\t\tif (rst_ptr) begin\n\t\t\tptr_max <= 1'b0;\n\t\t\taddr_ptr <= 0;\n\t\tend\n\t\telse begin\n\t\t\tif (addr_ptr == {{DATA_WIDTH-1{1'b1}},1'b0})\n\t\t\t\tptr_max <= 1'b1;\n\t\t\taddr_ptr <= addr_ptr + 1'b1;\n\t\tend\n\tend\n\n\talways @(posedge clk) begin\n\t\tlast_addr_ptr <= addr_ptr;\n\t\tlast2_addr_ptr <= last_addr_ptr;\n\tend\n\n//////////////////////////////////////\n// storage table\n//////////////////////////////////////\n\twire [DATA_WIDTH-1:0] ram_raddr, ram_waddr;\n\treg ram_we;\n\twire [WORDS-1:0] ram_data, ram_match_lines;\n\n\tram_block storage (\n\t\t.clk(clk),\n\t\t.data(ram_data),\n\t\t.rdaddress(ram_raddr),\n\t\t.wraddress(ram_waddr),\n\t\t.wren(ram_we),\n\t\t.q(ram_match_lines)\n\t);\n\n\tdefparam storage .DAT_WIDTH = WORDS;\n\tdefparam storage .ADDR_WIDTH = DATA_WIDTH;\n\n\treg ram_addr_select, zero_ram_data;\n\t\n\tassign ram_raddr = ram_addr_select ? addr_ptr : lookup_data;\n\tassign ram_waddr = zero_ram_data ? addr_ptr : last2_addr_ptr;\n\tassign ram_data = (~{WORDS{zero_ram_data}}) &\n\t\t\t(waddr_dec | ram_match_lines);\n\tassign match_lines = ram_match_lines;\n\n//////////////////////////////////////\n// decide to write at this data \n//   location or not, with dont care\n//////////////////////////////////////\nreg write_here;\nreg [DATA_WIDTH-1:0] bit_match;\n\n\talways @(posedge clk) begin\n\t\tbit_match <= ~wcare | ~(wdata ^ addr_ptr);\n\t\twrite_here <= &bit_match;\n\tend\n\n//////////////////////////////////////\n// control\n//////////////////////////////////////\nparameter INIT = 0, WIPE = 1, READY = 2, WRITE_A = 3,\n\t\tWRITE_B = 4, WRITE_C = 5, WRITE_D = 6;\n\nreg [3:0] state,next_state;\n\n\talways @(*) begin\n\t\trst_ptr = 1'b0;\n\t\tram_we = 1'b0;\n\t\tram_addr_select = 1'b1;\n\t\tnext_state = state;\n\t\tready = 1'b0;\n\t\tzero_ram_data = 1'b0;\n\n\t\tcase (state)\n\t\t\tINIT : begin\n\t\t\t\trst_ptr = 1'b1;\n\t\t\t\tnext_state = WIPE;\n\t\t\tend\n\t\t\tWIPE : begin\n\t\t\t\tram_we = 1'b1;\n\t\t\t\tzero_ram_data = 1'b1;\n\t\t\t\tif (ptr_max) begin\n\t\t\t\t\tnext_state = READY;\n\t\t\t\t\trst_ptr = 1'b1;\n\t\t\t\tend\n\t\t\tend\n\t\t\tREADY : begin\n\t\t\t\tready = 1'b1;\n\t\t\t\tram_addr_select = 1'b0;\n\t\t\t\trst_ptr = 1'b1;\n\t\t\t\tif (start_write) begin\n\t\t\t\t\tnext_state = WRITE_A;\n\t\t\t\t\t\rst_ptr = 1'b0;\n\t\t\t\tend\n\t\t\tend\n\t\t\tWRITE_A : begin\n\t\t\t\tnext_state = WRITE_B;\n\t\t\tend\n\t\t\tWRITE_B : begin\n\t\t\t\tram_we = write_here;\n\t\t\t\tif (ptr_max) begin\n\t\t\t\t\tnext_state = WRITE_C;\n\t\t\t\tend\n\t\t\tend\n\t\t\tWRITE_C : begin\n\t\t\t\tram_we = write_here;\n\t\t\t\tnext_state = WRITE_D;\n\t\t\tend\n\t\t\tWRITE_D : begin\n\t\t\t\tram_we = write_here;\n\t\t\t\tnext_state = READY;\n\t\t\t\t\trst_ptr = 1'b1;\n\t\t\tend\n\t\tendcase\n\tend\n\n\talways @(posedge clk) begin\n\t\tif (rst) state <= INIT;\n\t\telse state <= next_state;\n\tend\n\nendmodule"}
{"task_id": 1164, "completion": "_dual_port_sram memory_0 (                .wclk           (wclk),                .wen            (wen),                .waddr          (waddr),                .data_in        (d_in),                .rclk           (rclk),                .ren            (ren),                .raddr          (raddr),                .wenb          (wenb),                .d_out          (d_out) );    endmodule"}
{"task_id": 1153, "completion": "BLK_MEM_GEN_V7_3 #(\n    .C_ADDRA_WIDTH(11),\n    .C_ADDRB_WIDTH(9),\n    .C_ALGORITHM(1),\n    .C_AXI_ID_WIDTH(4),\n    .C_AXI_SLAVE_TYPE(0),\n    .C_AXI_TYPE(1),\n    .C_BYTE_SIZE(9),\n    .C_COMMON_CLK(1),\n    .C_DEFAULT_DATA(\"0\"),\n    .C_DISABLE_WARN_BHV_COLL(0),\n    .C_DISABLE_WARN_BHV_RANGE(0),\n    .C_ENABLE_32BIT_ADDRESS(0),\n    .C_FAMILY(\"spartan3\"),\n    .C_HAS_AXI_ID(0),\n    .C_HAS_ENA(0),\n    .C_HAS_ENB(0),\n    .C_HAS_INJECTERR(0),\n    .C_HAS_MEM_OUTPUT_REGS_A(0),\n    .C_HAS_MEM_OUTPUT_REGS_B(0),\n    .C_HAS_MUX_OUTPUT_REGS_A(0),\n    .C_HAS_MUX_OUTPUT_REGS_B(0),\n    .C_HAS_REGCEA(0),\n    .C_HAS_REGCEB(0),\n    .C_HAS_RSTA(0),\n    .C_HAS_RSTB(0),\n    .C_HAS_SOFTECC_INPUT_REGS_A(0),\n    .C_HAS_SOFTECC_OUTPUT_REGS_B(0),\n    .C_INIT_FILE(\"BlankString\"),\n    .C_INIT_FILE_NAME(\"no_coe_file_loaded\"),\n    .C_INITA_VAL(\"0\"),\n    .C_INITB_VAL(\"0\"),\n    .C_INTERFACE_TYPE(0),\n    .C_LOAD_INIT_FILE(0),\n    .C_MEM_TYPE(1),\n    .C_MUX_PIPELINE_STAGES(0),\n    .C_PRIM_TYPE(1),\n    .C_READ_DEPTH_A(2048),\n    .C_READ_DEPTH_B(512),\n    .C_READ_WIDTH_A(8),\n    .C_READ_WIDTH_B(32),\n    .C_RST_PRIORITY_A(\"CE\"),\n    .C_RST_PRIORITY_B(\"CE\"),\n    .C_RST_TYPE(\"SYNC\"),\n    .C_RSTRAM_A(0),\n    .C_RSTRAM_B(0),\n    .C_SIM_COLLISION_CHECK(\"ALL\"),\n    .C_USE_BRAM_BLOCK(0),\n    .C_USE_BYTE_WEA(0),\n    .C_USE_BYTE_WEB(0),\n    .C_USE_DEFAULT_DATA(0),\n    .C_USE_ECC(0),\n    .C_USE_SOFTECC(0),\n    .C_WEA_WIDTH(1),\n    .C_WEB_WIDTH(1),\n    .C_WRITE_DEPTH_A(2048),\n    .C_WRITE_DEPTH_B(512),\n    .C_WRITE_MODE_A(\"WRITE_FIRST\"),\n    .C_WRITE_MODE_B(\"WRITE_FIRST\"),\n    .C_WRITE_WIDTH_A(8),\n    .C_WRITE_WIDTH_B(32),\n    .C_XDEVICEFAMILY(\"spartan3\")\n  )\n  inst (\n    .CLKA(clka),\n    .WEA(wea),\n    .ADDRA(addra),\n    .DINA(dina),\n    .CLKB(clkb),\n    .ADDRB(addrb),\n    .DOUTB(doutb),\n    .RSTA(),\n    .ENA(),\n    .REGCEA(),\n    .DOUTA(),\n    .RSTB(),\n    .ENB(),\n    .REGCEB(),\n    .WEB(),\n    .DINB(),\n    .INJECTSBITERR(),\n    .INJECTDBITERR(),\n    .SBITERR(),\n    .DBITERR(),\n    .RDADDRECC(),\n    .S_ACLK(),\n    .S_ARESETN(),\n    .S_AXI_AWID(),\n    .S_AXI_AWADDR(),\n    .S_AXI_AWLEN(),\n    .S_AXI_AWSIZE(),\n    .S_AXI_AWBURST(),\n    .S_AXI_AWVALID(),\n    .S_AXI_AWREADY(),\n    .S_AXI_WDATA(),\n    .S_AXI_WSTRB(),\n    .S_AXI_WLAST(),\n    .S_AXI_WVALID(),\n    .S_AXI_WREADY(),\n    .S_AXI_BID(),\n    .S_AXI_BRESP(),\n    .S_AXI_BVALID(),\n    .S_AXI_BREADY(),\n    .S_AXI_ARID(),\n    .S_AXI_ARADDR(),\n    .S_AXI_ARLEN(),\n    .S_AXI_ARSIZE(),\n    .S_AXI_ARBURST(),\n    .S_AXI_ARVALID(),\n    .S_AXI_ARREADY(),\n    .S_AXI_RID(),\n    .S_AXI_RDATA(),\n    .S_AXI_RRESP(),\n    .S_AXI_RLAST(),\n    .S_AXI_RVALID(),\n    .S_AXI_RREADY(),\n    .S_AXI_INJECTSBITERR(),\n    .S_AXI_INJECTDBITERR(),\n    .S_AXI_SBITERR(),\n    .S_AXI_DBITERR(),\n    .S_AXI_RDADDRECC()\n  );\n\nendmodule"}
{"task_id": 1185, "completion": "xlslice #(\n    .DIN_WIDTH(40),\n    .DIN_FROM(32),\n    .DIN_TO(17)\n  ) inst (\n    .Din(Din),\n    .Dout(Dout)\n  );\nendmodule"}
{"task_id": 1124, "completion": "parameter num_ports = 32;\n   parameter num_priorities = 1;\n   parameter encode_state = 1;\n   localparam state_width = clogb(num_ports);\n   parameter reset_type = `RESET_TYPE_ASYNC;\n   input clk;\n   input reset;\n   input active;\n   input [0:num_priorities*num_ports-1] req_pr;\n   output [0:num_priorities*num_ports-1] gnt_pr;\n   wire [0:num_priorities*num_ports-1] gnt_pr;\n   output [0:num_ports-1] gnt;\n   wire [0:num_ports-1] gnt;\n   input update;\n   wire [0:num_priorities*num_ports-1] gnt_intm_pr;\n   wire [0:num_ports-1] prio_port;\n   genvar prio;\n   generate\n      for(prio = 0; prio < num_priorities; prio = prio + 1)\n      begin:prios\n         wire [0:num_ports-1] req;\n         assign req = req_pr[prio*num_ports:(prio+1)*num_ports-1];\n         wire [0:num_ports-1] gnt;\n         c_prefix_arbiter_base\n           #(.num_ports(num_ports))\n         gnt_ab\n           (.prio_port(prio_port),\n            .req(req),\n            .gnt(gnt));\n         assign gnt_intm_pr[prio*num_ports:(prio+1)*num_ports-1] = gnt;\n      end\n      if(encode_state)\n      begin\n         wire [0:state_width-1] next_state;\n         c_encode\n           #(.num_ports(num_ports),\n             .offset(1))\n         next_state_enc\n           (.data_in(gnt),\n            .data_out(next_state));\n         wire [0:state_width-1] state_s, state_q;\n         assign state_s = update ? next_state : state_q;\n         c_dff\n           #(.width(state_width),\n             .reset_type(reset_type))\n         stateq\n           (.clk(clk),\n            .reset(reset),\n            .active(active),\n            .d(state_s),\n            .q(state_q));\n         c_decode\n           #(.num_ports(num_ports))\n         prio_port_dec\n           (.data_in(state_q),\n            .data_out(prio_port));\n      end\n      else\n      begin\n         wire [0:num_ports-1] next_prio;\n         assign next_prio = {gnt[num_ports-1], gnt[0:num_ports-2]};\n         wire [0:num_ports-1] prio_s, prio_q;\n         assign prio_s = update ? next_prio : prio_q;\n         c_dff\n           #(.width(num_ports),\n             .reset_value({1'b1, {(num_ports-1){1'b0}}}),\n             .reset_type(reset_type))\n         prioq\n           (.clk(clk),\n            .reset(reset),\n            .active(active),\n            .d(prio_s),\n            .q(prio_q));\n         assign prio_port = prio_q;\n      end\n      if(num_priorities == 1)\n      begin\n         assign gnt_pr = gnt_intm_pr;\n         assign gnt = gnt_intm_pr;\n      end\n      else if(num_priorities > 1)\n      begin\n         wire [0:num_priorities-1] any_req_pr;\n         c_reduce_bits\n           #(.num_ports(num_priorities),\n             .width(num_ports),\n             .op(`BINARY_OP_OR))\n         any_req_pr_rb\n           (.data_in(req_pr),\n            .data_out(any_req_pr));\n         wire [0:num_priorities-1] any_req_mod_pr;\n         assign any_req_mod_pr = {any_req_pr[0:num_priorities-2], 1'b1};\n         wire [0:num_priorities-1] sel_pr;\n         c_lod\n           #(.width(num_priorities))\n         sel_pr_lod\n           (.data_in(any_req_mod_pr),\n            .data_out(sel_pr));\n         c_gate_bits\n           #(.num_ports(num_priorities),\n             .width(num_ports),\n             .op(`BINARY_OP_AND))\n         gnt_pr_gb\n           (.select(sel_pr),\n            .data_in(gnt_intm_pr),\n            .data_out(gnt_pr));\n         c_select_1ofn\n           #(.num_ports(num_priorities),\n             .width(num_ports))\n         gnt_sel\n           (.select(sel_pr),\n            .data_in(gnt_intm_pr),\n            .data_out(gnt));\n      end\n   endgenerate\nendmodule"}
{"task_id": 1195, "completion": "`define DLY #1\n\n    parameter CHANNEL_BOND_LOAD_CODE = 6'b100111;\n\n    input   [5:0]   RX_STATUS;\n    output          CHANNEL_BOND_LOAD;\n\n    input           USER_CLK;\n\n    reg             CHANNEL_BOND_LOAD;\n\n    always @(posedge USER_CLK)\n        CHANNEL_BOND_LOAD <= (RX_STATUS == CHANNEL_BOND_LOAD_CODE);\n\nendmodule"}
{"task_id": 1186, "completion": "generate\n        genvar binary_pos, one_hot_pos;\n        wire [(NO_OF_MODES*LOG2_NO_OF_MODES)-1:0] binary_values;\n        wire [(NO_OF_MODES*LOG2_NO_OF_MODES)-1:0] binary_values_by_bit;\n        for(one_hot_pos=0; one_hot_pos<NO_OF_MODES; one_hot_pos=one_hot_pos+1) begin : to_binary_one_hot_pos\n           assign binary_values[(one_hot_pos*LOG2_NO_OF_MODES)+(LOG2_NO_OF_MODES-1):(one_hot_pos*LOG2_NO_OF_MODES)] = (one_hot[one_hot_pos]) ? one_hot_pos + 1 : 0;\n        end\n        for(binary_pos=0; binary_pos<LOG2_NO_OF_MODES; binary_pos=binary_pos+1) begin : to_binary_binary_pos\n            for(one_hot_pos=0; one_hot_pos<NO_OF_MODES; one_hot_pos=one_hot_pos+1) begin : to_binary_one_hot_pos\n                assign binary_values_by_bit[(binary_pos*NO_OF_MODES)+one_hot_pos] = binary_values[(one_hot_pos*LOG2_NO_OF_MODES)+binary_pos];\n            end\n            assign binary[binary_pos] = |binary_values_by_bit[(binary_pos*NO_OF_MODES)+NO_OF_MODES-1:binary_pos*NO_OF_MODES];\n        end\n    endgenerate\nendmodule"}
{"task_id": 1109, "completion": "`define DLY #1 wire [15:0] open_i; wire [0:3] TX1N_OUT_unused; wire [0:3] TX1P_OUT_unused; wire [0:3] RX1N_IN_unused; wire [0:3] RX1P_IN_unused; wire [3:0] ch_bond_done_i_unused; wire [7:0] rx_char_is_comma_i_unused; wire [3:0] rx_buf_err_i_unused; wire [7:0] rx_char_is_k_i_unused; wire [63:0] rx_data_i_unused; wire [7:0] rx_disp_err_i_unused; wire [7:0] rx_not_in_table_i_unused; wire [3:0] rx_realign_i_unused; wire [3:0] tx_buf_err_i_unused; wire [3:0] ch_bond_done_i; wire channel_up_i; wire en_chan_sync_i; wire [3:0] ena_comma_align_i; wire [0:3] gen_a_i; wire gen_cc_i; wire gen_ecp_i; wire [0:7] gen_k_i; wire [0:3] gen_pad_i; wire [0:7] gen_r_i; wire gen_scp_i; wire [0:7] gen_v_i; wire [0:7] got_a_i; wire [0:3] got_v_i; wire [0:3] hard_error_i; wire [0:3] lane_up_i; wire [0:3] raw_tx_out_clk_i; wire [0:3] reset_lanes_i; wire [3:0] rx_buf_err_i; wire [7:0] rx_char_is_comma_i; wire [7:0] rx_char_is_k_i; wire [11:0] rx_clk_cor_cnt_i; wire [63:0] rx_data_i; wire [7:0] rx_disp_err_i; wire [0:3] rx_ecp_i; wire [7:0] rx_not_in_table_i; wire [0:3] rx_pad_i; wire [0:63] rx_pe_data_i; wire [0:3] rx_pe_data_v_i; wire [3:0] rx_polarity_i; wire [3:0] rx_realign_i; wire [3:0] rx_reset_i; wire [0:3] rx_scp_i; wire [0:3] soft_error_i; wire start_rx_i; wire tied_to_ground_i; wire [47:0] tied_to_ground_vec_i; wire tied_to_vcc_i; wire [3:0] tx_buf_err_i; wire [7:0] tx_char_is_k_i; wire [63:0] tx_data_i; wire [0:1] tx_lock_i; wire [0:63] tx_pe_data_i; wire [0:3] tx_pe_data_v_i; wire [3:0] tx_reset_i; reg [0:3] ch_bond_load_pulse_i; reg [0:3] ch_bond_done_dly_i; wire reset_lism_i; wire reset_done_i; assign tied_to_ground_vec_i = 64'd0; assign tied_to_ground_i = 1'b0; assign tied_to_vcc_i = 1'b1; assign CHANNEL_UP = channel_up_i; assign TX_OUT_CLK = raw_tx_out_clk_i[0]; assign TX_LOCK = &tx_lock_i; assign LANE_UP[0] = lane_up_i[0]; aur1_AURORA_LANE aurora_lane_0_i ( .RESETDONE(reset_done_i), //Fix for CR519148 .RESET_LISM(reset_lism_i), //Fix for CR469729 .RX_DATA(rx_data_i[15:0]), .RX_NOT_IN_TABLE(rx_not_in_table_i[1:0]), .RX_DISP_ERR(rx_disp_err_i[1:0]), .RX_CHAR_IS_K(rx_char_is_k_i[1:0]), .RX_CHAR_IS_COMMA(rx_char_is_comma_i[1:0]), .RX_STATUS(tied_to_ground_vec_i[5:0]), .TX_BUF_ERR(tx_buf_err_i[0]), .RX_BUF_ERR(rx_buf_err_i[0]), .RX_REALIGN(rx_realign_i[0]), .RX_POLARITY(rx_polarity_i[0]), .RX_RESET(rx_reset_i[0]), .TX_CHAR_IS_K(tx_char_is_k_i[1:0]), .TX_DATA(tx_data_i[15:0]), .TX_RESET(tx_reset_i[0]), .ENA_COMMA_ALIGN(ena_comma_align_i[0]), .GEN_SCP(gen_scp_i), .GEN_ECP(tied_to_ground_i), .GEN_PAD(gen_pad_i[0]), .TX_PE_DATA(tx_pe_data_i[0:15]), .TX_PE_DATA_V(tx_pe_data_v_i[0]), .GEN_CC(gen_cc_i), .RX_PAD(rx_pad_i[0]), .RX_PE_DATA(rx_pe_data_i[0:15]), .RX_PE_DATA_V(rx_pe_data_v_i[0]), .RX_SCP(rx_scp_i[0]), .RX_ECP(rx_ecp_i[0]), .GEN_A(gen_a_i[0]), .GEN_K(gen_k_i[0:1]), .GEN_R(gen_r_i[0:1]), .GEN_V(gen_v_i[0:1]), .LANE_UP(lane_up_i[0]), .SOFT_ERROR(soft_error_i[0]), .HARD_ERROR(hard_error_i[0]), .CHANNEL_BOND_LOAD(), .GOT_A(got_a_i[0:1]), .GOT_V(got_v_i[0]), .USER_CLK(USER_CLK), .RESET(reset_lanes_i[0]) ); assign LANE_UP[1] = lane_up_i[1]; aur1_AURORA_LANE aurora_lane_1_i ( .RESETDONE(reset_done_i), .RESET_LISM(reset_lism_i), .RX_DATA(rx_data_i[31:16]), .RX_NOT_IN_TABLE(rx_not_in_table_i[3:2]), .RX_DISP_ERR(rx_disp_err_i[3:2]), .RX_CHAR_IS_K(rx_char_is_k_i[3:2]), .RX_CHAR_IS_COMMA(rx_char_is_comma_i[3:2]), .RX_STATUS(tied_to_ground_vec_i[5:0]), .TX_BUF_ERR(tx_buf_err_i[1]), .RX_BUF_ERR(rx_buf_err_i[1]), .RX_REALIGN(rx_realign_i[1]), .RX_POLARITY(rx_polarity_i[1]), .RX_RESET(rx_reset_i[1]), .TX_CHAR_IS_K(tx_char_is_k_i[3:2]), .TX_DATA(tx_data_i[31:16]), .TX_RESET(tx_reset_i[1]), .ENA_COMMA_ALIGN(ena_comma_align_i[1]), .GEN_SCP(tied_to_ground_i), .GEN_ECP(tied_to_ground_i), .GEN_PAD(gen_pad_i[1]), .TX_PE_DATA(tx_pe_data_i[16:31]), .TX_PE_DATA_V(tx_pe_data_v_i[1]), .GEN_CC(gen_cc_i), .RX_PAD(rx_pad_i[1]), .RX_PE_DATA(rx_pe_data_i[16:31]), .RX_PE_DATA_V(rx_pe_data_v_i[1]), .RX_SCP(rx_scp_i[1]), .RX_ECP(rx_ecp_i[1]), .GEN_A(gen_a_i[1]), .GEN_K(gen_k_i[2:3]), .GEN_R(gen_r_i[2:3]), .GEN_V(gen_v_i[2:3]), .LANE_UP(lane_up_i[1]), .SOFT_ERROR(soft_error_i[1]), .HARD_ERROR(hard_error_i[1]), .CHANNEL_BOND_LOAD(), .GOT_A(got_a_i[2:3]), .GOT_V(got_v_i[1]), .USER_CLK(USER_CLK), .RESET(reset_lanes_i[1]) ); assign LANE_UP[2] = lane_up_i[2]; aur1_AURORA_LANE aurora_lane_2_i ( .RESETDONE(reset_done_i), .RESET_LISM(reset_lism_i), .RX_DATA(rx_data_i[47:32]), .RX_NOT_IN_TABLE(rx_not_in_table_i[5:4]), .RX_DISP_ERR(rx_disp_err_i[5:4]), .RX_CHAR_IS_K(rx_char_is_k_i[5:4]), .RX_CHAR_IS_COMMA(rx_char_is_comma_i[5:4]), .RX_STATUS(tied_to_ground_vec_i[5:0]), .TX_BUF_ERR(tx_buf_err_i[2]), .RX_BUF_ERR(rx_buf_err_i[2]), .RX_REALIGN(rx_realign_i[2]), .RX_POLARITY(rx_polarity_i[2]), .RX_RESET(rx_reset_i[2]), .TX_CHAR_IS_K(tx_char_is_k_i[5:4]), .TX_DATA(tx_data_i[47:32]), .TX_RESET(tx_reset_i[2]), .ENA_COMMA_ALIGN(ena_comma_align_i[2]), .GEN_SCP(tied_to_ground_i), .GEN_ECP(tied_to_ground_i), .GEN_PAD(gen_pad_i[2]), .TX_PE_DATA(tx_pe_data_i[32:47]), .TX_PE_DATA_V(tx_pe_data_v_i[2]), .GEN_CC(gen_cc_i), .RX_PAD(rx_pad_i[2]), .RX_PE_DATA(rx_pe_data_i[32:47]), .RX_PE_DATA_V(rx_pe_data_v_i[2]), .RX_SCP(rx_scp_i[2]), .RX_ECP(rx_ecp_i[2]), .GEN_A(gen_a_i[2]), .GEN_K(gen_k_i[4:5]), .GEN_R(gen_r_i[4:5]), .GEN_V(gen_v_i[4:5]), .LANE_UP(lane_up_i[2]), .SOFT_ERROR(soft_error_i[2]), .HARD_ERROR(hard_error_i[2]), .CHANNEL_BOND_LOAD(), .GOT_A(got_a_i[4:5]), .GOT_V(got_v_i[2]), .USER_CLK(USER_CLK), .RESET(reset_lanes_i[2]) ); assign LANE_UP[3] = lane_up_i[3]; aur1_AURORA_LANE aurora_lane_3_i ( .RESETDONE(reset_done_i), .RESET_LISM(reset_lism_i), .RX_DATA(rx_data_i[63:48]), .RX_NOT_IN_TABLE(rx_not_in_table_i[7:6]), .RX_DISP_ERR(rx_disp_err_i[7:6]), .RX_CHAR_IS_K(rx_char_is_k_i[7:6]), .RX_CHAR_IS_COMMA(rx_char_is_comma_i[7:6]), .RX_STATUS(tied_to_ground_vec_i[5:0]), .TX_BUF_ERR(tx_buf_err_i[3]), .RX_BUF_ERR(rx_buf_err_i[3]), .RX_REALIGN(rx_realign_i[3]), .RX_POLARITY(rx_polarity_i[3]), .RX_RESET(rx_reset_i[3]), .TX_CHAR_IS_K(tx_char_is_k_i[7:6]), .TX_DATA(tx_data_i[63:48]), .TX_RESET(tx_reset_i[3]), .ENA_COMMA_ALIGN(ena_comma_align_i[3]), .GEN_SCP(tied_to_ground_i), .GEN_ECP(gen_ecp_i), .GEN_PAD(gen_pad_i[3]), .TX_PE_DATA(tx_pe_data_i[48:63]), .TX_PE_DATA_V(tx_pe_data_v_i[3]), .GEN_CC(gen_cc_i), .RX_PAD(rx_pad_i[3]), .RX_PE_DATA(rx_pe_data_i[48:63]), .RX_PE_DATA_V(rx_pe_data_v_i[3]), .RX_SCP(rx_scp_i[3]), .RX_ECP(rx_ecp_i[3]), .GEN_A(gen_a_i[3]), .GEN_K(gen_k_i[6:7]), .GEN_R(gen_r_i[6:7]), .GEN_V(gen_v_i[6:7]), .LANE_UP(lane_up_i[3]), .SOFT_ERROR(soft_error_i[3]), .HARD_ERROR(hard_error_i[3]), .CHANNEL_BOND_LOAD(), .GOT_A(got_a_i[6:7]), .GOT_V(got_v_i[3]), .USER_CLK(USER_CLK), .RESET(reset_lanes_i[3]) ); aur1_GTP_WRAPPER # ( .SIM_GTPRESET_SPEEDUP(SIM_GTPRESET_SPEEDUP) ) gtp_wrapper_i ( .RESETDONE(reset_done_i), .RESET_LISM(reset_lism_i), .RXPOLARITY_IN(rx_polarity_i[0]), .RXPOLARITY_IN_LANE1(rx_polarity_i[1]), .RXPOLARITY_IN_LANE2(rx_polarity_i[2]), .RXPOLARITY_IN_LANE3(rx_polarity_i[3]), .RXRESET_IN(rx_reset_i[0]), .RXRESET_IN_LANE1(rx_reset_i[1]), .RXRESET_IN_LANE2(rx_reset_i[2]), .RXRESET_IN_LANE3(rx_reset_i[3]), .TXCHARISK_IN(tx_char_is_k_i[1:0]), .TXCHARISK_IN_LANE1(tx_char_is_k_i[3:2]), .TXCHARISK_IN_LANE2(tx_char_is_k_i[5:4]), .TXCHARISK_IN_LANE3(tx_char_is_k_i[7:6]), .TXDATA_IN(tx_data_i[15:0]), .TXDATA_IN_LANE1(tx_data_i[31:16]), .TXDATA_IN_LANE2(tx_data_i[47:32]), .TXDATA_IN_LANE3(tx_data_i[63:48]), .TXRESET_IN(tx_reset_i[0]), .TXRESET_IN_LANE1(tx_reset_i[1]), .TXRESET_IN_LANE2(tx_reset_i[2]), .TXRESET_IN_LANE3(tx_reset_i[3]), .RXDATA_OUT(rx_data_i[15:0]), .RXDATA_OUT_LANE1(rx_data_i[31:16]), .RXDATA_OUT_LANE2(rx_data_i[47:32]), .RXDATA_OUT_LANE3(rx_data_i[63:48]), .RXNOTINTABLE_OUT(rx_not_in_table_i[1:0]), .RXNOTINTABLE_OUT_LANE1(rx_not_in_table_i[3:2]), .RXNOTINTABLE_OUT_LANE2(rx_not_in_table_i[5:4]), .RXNOTINTABLE_OUT_LANE3(rx_not_in_table_i[7:6]), .RXDISPERR_OUT(rx_disp_err_i[1:0]), .RXDISPERR_OUT_LANE1(rx_disp_err_i[3:2]), .RXDISPERR_OUT_LANE2(rx_disp_err_i[5:4]), .RXDISPERR_OUT_LANE3(rx_disp_err_i[7:6]), .RXCHARISK_OUT(rx_char_is_k_i[1:0]), .RXCHARISK_OUT_LANE1(rx_char_is_k_i[3:2]), .RXCHARISK_OUT_LANE2(rx_char_is_k_i[5:4]), .RXCHARISK_OUT_LANE3(rx_char_is_k_i[7:6]), .RXCHARISCOMMA_OUT(rx_char_is_comma_i[1:0]), .RXCHARISCOMMA_OUT_LANE1(rx_char_is_comma_i[3:2]), .RXCHARISCOMMA_OUT_LANE2(rx_char_is_comma_i[5:4]), .RXCHARISCOMMA_OUT_LANE3(rx_char_is_comma_i[7:6]), .RXREALIGN_OUT(rx_realign_i[0]), .RXREALIGN_OUT_LANE1(rx_realign_i[1]), .RXREALIGN_OUT_LANE2(rx_realign_i[2]), .RXREALIGN_OUT_LANE3(rx_realign_i[3]), .RXBUFERR_OUT(rx_buf_err_i[0]), .RXBUFERR_OUT_LANE1(rx_buf_err_i[1]), .RXBUFERR_OUT_LANE2(rx_buf_err_i[2]), .RXBUFERR_OUT_LANE3(rx_buf_err_i[3]), .TXBUFERR_OUT(tx_buf_err_i[0]), .TXBUFERR_OUT_LANE1(tx_buf_err_i[1]), .TXBUFERR_OUT_LANE2(tx_buf_err_i[2]), .TXBUFERR_OUT_LANE3(tx_buf_err_i[3]), .ENMCOMMAALIGN_IN(ena_comma_align_i[0]), .ENMCOMMAALIGN_IN_LANE1(ena_comma_align_i[1]), .ENMCOMMAALIGN_IN_LANE2(ena_comma_align_i[2]), .ENMCOMMAALIGN_IN_LANE3(ena_comma_align_i[3]), .ENPCOMMAALIGN_IN(ena_comma_align_i[0]), .ENPCOMMAALIGN_IN_LANE1(ena_comma_align_i[1]), .ENPCOMMAALIGN_IN_LANE2(ena_comma_align_i[2]), .ENPCOMMAALIGN_IN_LANE3(ena_comma_align_i[3]), .RXRECCLK1_OUT(), .RXRECCLK1_OUT_LANE1(), .RXRECCLK1_OUT_LANE2(), .RXRECCLK1_OUT_LANE3(), .RXRECCLK2_OUT(), .RXRECCLK2_OUT_LANE1(), .RXRECCLK2_OUT_LANE2(), .RXRECCLK2_OUT_LANE3(), .ENCHANSYNC_IN(tied_to_vcc_i), .ENCHANSYNC_IN_LANE1(en_chan_sync_i), .ENCHANSYNC_IN_LANE2(tied_to_vcc_i), .ENCHANSYNC_IN_LANE3(tied_to_vcc_i), .CHBONDDONE_OUT(ch_bond_done_i[0]), .CHBONDDONE_OUT_LANE1(ch_bond_done_i[1]), .CHBONDDONE_OUT_LANE2(ch_bond_done_i[2]), .CHBONDDONE_OUT_LANE3(ch_bond_done_i[3]), .RX1N_IN(RXN[0]), .RX1N_IN_LANE1(RXN[1]), .RX1N_IN_LANE2(RXN[2]), .RX1N_IN_LANE3(RXN[3]), .RX1P_IN(RXP[0]), .RX1P_IN_LANE1(RXP[1]), .RX1P_IN_LANE2(RXP[2]), .RX1P_IN_LANE3(RXP[3]), .TX1N_OUT(TXN[0]), .TX1N_OUT_LANE1(TXN[1]), .TX1N_OUT_LANE2(TXN[2]), .TX1N_OUT_LANE3(TXN[3]), .TX1P_OUT(TXP[0]), .TX1P_OUT_LANE1(TXP[1]), .TX1P_OUT_LANE2(TXP[2]), .TX1P_OUT_LANE3(TXP[3]), .RXUSRCLK_IN(SYNC_CLK), .RXUSRCLK2_IN(USER_CLK), .TXUSRCLK_IN(SYNC_CLK), .TXUSRCLK2_IN(USER_CLK), .REFCLK(GTPD7), .TXOUTCLK1_OUT(raw_tx_out_clk_i[0]), .TXOUTCLK2_OUT(), .TXOUTCLK1_OUT_LANE1(raw_tx_out_clk_i[1]), .TXOUTCLK2_OUT_LANE1(), .TXOUTCLK1_OUT_LANE2(raw_tx_out_clk_i[2]), .TXOUTCLK2_OUT_LANE2(), .TXOUTCLK1_OUT_LANE3(raw_tx_out_clk_i[3]), .TXOUTCLK2_OUT_LANE3(), .PLLLKDET_OUT(tx_lock_i[0]), .PLLLKDET_OUT_LANE1(tx_lock_i[1]), .REFCLKOUT_OUT(), .REFCLKOUT_OUT_LANE1(), .GTPRESET_IN(GT_RESET), .LOOPBACK_IN(LOOPBACK), .TXDIFF(TXDIFF), .TXPREEMP(TXPREEMP), .POWERDOWN_IN(POWER_DOWN) ); always @(posedge USER_CLK) if (RESET) ch_bond_done_dly_i <= 2'b0; else if (en_chan_sync_i) ch_bond_done_dly_i <= ch_bond_done_i; else ch_bond_done_dly_i <= 2'b0; always @(posedge USER_CLK) if (RESET) ch_bond_load_pulse_i <= 2'b0; else if(en_chan_sync_i) ch_bond_load_pulse_i <= ch_bond_done_i & ~ch_bond_done_dly_i; else ch_bond_load_pulse_i <= 2'b00; aur1_GLOBAL_LOGIC global_logic_i ( .CH_BOND_DONE(ch_bond_done_i), .EN_CHAN_SYNC(en_chan_sync_i), .LANE_UP(lane_up_i), .SOFT_ERROR(soft_error_i), .HARD_ERROR(hard_error_i), .CHANNEL_BOND_LOAD(ch_bond_load_pulse_i), .GOT_A(got_a_i), .GOT_V(got_v_i), .GEN_A(gen_a_i), .GEN_K(gen_k_i), .GEN_R(gen_r_i), .GEN_V(gen_v_i), .RESET_LANES(reset_lanes_i), .USER_CLK(USER_CLK), .RESET(RESET), .POWER_DOWN(POWER_DOWN), .CHANNEL_UP(channel_up_i), .START_RX(start_rx_i), .CHANNEL_SOFT_ERROR(SOFT_ERROR), .CHANNEL_HARD_ERROR(HARD_ERROR) ); aur1_TX_STREAM tx_stream_i ( .TX_D(TX_D), .TX_SRC_RDY_N(TX_SRC_RDY_N), .TX_DST_RDY_N(TX_DST_RDY_N), .CHANNEL_UP(channel_up_i), .DO_CC(DO_CC), .WARN_CC(WARN_CC), .GEN_SCP(gen_scp_i), .GEN_ECP(gen_ecp_i), .TX_PE_DATA_V(tx_pe_data_v_i), .GEN_PAD(gen_pad_i), .TX_PE_DATA(tx_pe_data_i), .GEN_CC(gen_cc_i), .USER_CLK(USER_CLK) ); aur1_RX_STREAM rx_stream_i ( .RX_D(RX_D), .RX_SRC_RDY_N(RX_SRC_RDY_N), .START_RX(start_rx_i), .RX_PAD(rx_pad_i), .RX_PE_DATA(rx_pe_data_i), .RX_PE_DATA_V(rx_pe_data_v_i), .RX_SCP(rx_scp_i), .RX_ECP(rx_ecp_i), .USER_CLK(USER_CLK) );endmodule"}
{"task_id": 1165, "completion": "localparam TRN_IDLE = 1'b0; localparam MASTER_NONE = 4'b0000; wire [3:0] masterAddrInProg; reg [3:0] masterDataInProg; reg addrPhMasterHREADY; wire addrPhMasterDataPhComplete; reg preHTRANS; always @ ( posedge HCLK or negedge HRESETN ) begin if ( !HRESETN ) masterDataInProg <= MASTER_NONE; else if ( HREADY_S ) masterDataInProg <= masterAddrInProg; end COREAHBLITE_SLAVEARBITER slave_arbiter ( .HCLK(HCLK), .HRESETN(HRESETN), .MADDRSEL(MADDRSEL), .ADDRPHEND(HREADY_S), .M0GATEDHMASTLOCK(M0GATEDHMASTLOCK), .M1GATEDHMASTLOCK(M1GATEDHMASTLOCK), .M2GATEDHMASTLOCK(M2GATEDHMASTLOCK), .M3GATEDHMASTLOCK(M3GATEDHMASTLOCK), .MASTERADDRINPROG(masterAddrInProg) ); always @ ( * ) begin casez ( masterAddrInProg ) 4'b???1: begin HSEL = 1'b1; preHTRANS = M0GATEDHTRANS; HSIZE = M0GATEDHSIZE; HWRITE = M0GATEDHWRITE; HADDR = M0GATEDHADDR; HMASTLOCK = M0GATEDHMASTLOCK; addrPhMasterHREADY = MPREVDATASLAVEREADY[0]; end 4'b??1?: begin HSEL = 1'b1; preHTRANS = M1GATEDHTRANS; HSIZE = M1GATEDHSIZE; HWRITE = M1GATEDHWRITE; HADDR = M1GATEDHADDR; HMASTLOCK = M1GATEDHMASTLOCK; addrPhMasterHREADY = MPREVDATASLAVEREADY[1]; end 4'b?1??: begin HSEL = 1'b1; preHTRANS = M2GATEDHTRANS; HSIZE = M2GATEDHSIZE; HWRITE = M2GATEDHWRITE; HADDR = M2GATEDHADDR; HMASTLOCK = M2GATEDHMASTLOCK; addrPhMasterHREADY = MPREVDATASLAVEREADY[1]; end 4'b1???: begin HSEL = 1'b1; preHTRANS = M3GATEDHTRANS; HSIZE = M3GATEDHSIZE; HWRITE = M3GATEDHWRITE; HADDR = M3GATEDHADDR; HMASTLOCK = M3GATEDHMASTLOCK; addrPhMasterHREADY = MPREVDATASLAVEREADY[1]; end default: begin HSEL = 1'b0; preHTRANS = TRN_IDLE; HSIZE = 2'b00; HWRITE = 1'b0; HADDR = 32'h0; HMASTLOCK = 1'b0; addrPhMasterHREADY = 1'b1; end endcase end assign addrPhMasterDataPhComplete = |(masterAddrInProg & MDATASEL); assign HTRANS = preHTRANS && (addrPhMasterHREADY || addrPhMasterDataPhComplete); assign HREADY_S = HREADYOUT; always @ ( * ) begin casez ( masterDataInProg ) 4'b???1: begin HWDATA = HWDATA_M0; end 4'b??1?: begin HWDATA = HWDATA_M1; end 4'b?1??: begin HWDATA = HWDATA_M2; end 4'b1???: begin HWDATA = HWDATA_M3; end default: begin HWDATA = 32'h0; end endcase end always @ ( * ) begin MHRESP = 2'b00; casez ( masterDataInProg ) 4'b???1: begin MHRESP[0] = HRESP; end 4'b??1?: begin MHRESP[1] = HRESP; end 4'b?1??: begin MHRESP[2] = HRESP; end 4'b1???: begin MHRESP[3] = HRESP; end default: begin MHRESP = 2'b00; end endcase end always @ ( * ) begin if ( MADDRSEL[0] && !masterAddrInProg[0] ) MADDRREADY[0] = 1'b0; else if ( MADDRSEL[0] && masterAddrInProg[0] ) MADDRREADY[0] = HREADYOUT; else MADDRREADY[0] = 1'b1; end always @ ( * ) begin if ( MADDRSEL[1] && !masterAddrInProg[1] ) MADDRREADY[1] = 1'b0; else if ( MADDRSEL[1] && masterAddrInProg[1] ) MADDRREADY[1] = HREADYOUT; else MADDRREADY[1] = 1'b1; end always @ ( * ) begin if ( MADDRSEL[2] && !masterAddrInProg[2] ) MADDRREADY[2] = 1'b0; else if ( MADDRSEL[2] && masterAddrInProg[2] ) MADDRREADY[2] = HREADYOUT; else MADDRREADY[2] = 1'b1; end always @ ( * ) begin if ( MADDRSEL[3] && !masterAddrInProg[3] ) MADDRREADY[3] = 1'b0; else if ( MADDRSEL[3] && masterAddrInProg[3] ) MADDRREADY[3] = HREADYOUT; else MADDRREADY[3] = 1'b1; end always @ ( * ) begin if ( MDATASEL[0] && !masterDataInProg[0] ) MDATAREADY[0] = 1'b0; else if ( MDATASEL[0] && masterDataInProg[0] ) MDATAREADY[0] = HREADYOUT; else MDATAREADY[0] = 1'b1; end always @ ( * ) begin if ( MDATASEL[1] && !masterDataInProg[1] ) MDATAREADY[1] = 1'b0; else if ( MDATASEL[1] && masterDataInProg[1] ) MDATAREADY[1] = HREADYOUT; else MDATAREADY[1] = 1'b1; end always @ ( * ) begin if ( MDATASEL[2] && !masterDataInProg[2] ) MDATAREADY[2] = 1'b0; else if ( MDATASEL[2] && masterDataInProg[2] ) MDATAREADY[2] = HREADYOUT; else MDATAREADY[2] = 1'b1; end always @ ( * ) begin if ( MDATASEL[3] && !masterDataInProg[3] ) MDATAREADY[3] = 1'b0; else if ( MDATASEL[3] && masterDataInProg[3] ) MDATAREADY[3] = HREADYOUT; else MDATAREADY[3] = 1'b1; end endmodule"}
{"task_id": 1170, "completion": "reg [7:0] obc1_regs [7:0];\n\n  wire [6:0] oam_number = obc1_regs[6][6:0];\n\n  wire obc_bank = obc1_regs[5][0];\n\n  wire low_en = enable & ((addr_in & 13'h1a00) == 13'h1800);\n  wire high_en = enable & ((addr_in & 13'h1a00) == 13'h1a00);\n  wire reg_en = enable & ((addr_in & 13'h1ff8) == 13'h1ff0);\n\n  wire [2:0] obc_reg = addr_in[2:0];\n\n  wire oam_low_we  = enable & (reg_we_rising) & (((addr_in & 13'h1ffc) == 13'h1ff0) | low_en);\n  wire oam_high_we = enable & (reg_we_rising) & (addr_in == 13'h1ff4);\n  wire snes_high_we = enable & (reg_we_rising) & high_en;\n\n  wire [9:0] oam_low_addr = (~reg_en) ? addr_in[9:0] : {~obc_bank, oam_number, addr_in[1:0]};\n  wire [7:0] oam_high_addr = (~reg_en) ? addr_in[5:0] : {~obc_bank, oam_number};\n\n  wire [7:0] low_douta;\n  wire [7:0] high_doutb;\n\n  `ifdef MK2\n  obc_lower oam_low (\n    .clka(clk), // input clka\n    .wea(oam_low_we), // input [0 : 0] wea\n    .addra(oam_low_addr), // input [9 : 0] addra\n    .dina(data_in), // input [7 : 0] dina\n    .douta(low_douta) // output [7 : 0] douta\n  );\n\n  obc_upper oam_high (\n    .clka(clk), // input clka\n    .wea(oam_high_we), // input [0 : 0] wea\n    .addra(oam_high_addr), // input [7 : 0] addra\n    .dina(data_in[1:0]), // input [1 : 0] dina\n    .douta(douta), // unused\n    .clkb(clk), // input clkb\n    .web(snes_high_we), // input [0 : 0] web\n    .addrb(addr_in[5:0]), // input [5 : 0] addrb\n    .dinb(data_in),\n    .doutb(high_doutb) // output [7 : 0] doutb\n  );\n  `endif\n  `ifdef MK3\n  obc_lower oam_low (\n    .clock(clk), // input clka\n    .wren(oam_low_we), // input [0 : 0] wea\n    .address(oam_low_addr), // input [9 : 0] addra\n    .data(data_in), // input [7 : 0] dina\n    .q(low_douta) // output [7 : 0] douta\n  );\n\n  obc_upper oam_high (\n    .clock(clk), // input clka\n    .wren_a(oam_high_we), // input [0 : 0] wea\n    .address_a(oam_high_addr), // input [7 : 0] addra\n    .data_a(data_in[1:0]), // input [1 : 0] dina\n    .q_a(douta), // unused\n    .wren_b(snes_high_we), // input [0 : 0] web\n    .address_b(addr_in[5:0]), // input [5 : 0] addrb\n    .data_b(data_in),\n    .q_b(high_doutb) // output [7 : 0] doutb\n  );\n  `endif\n  assign data_out = reg_en ? obc1_regs[addr_in[2:0]]\n                    : low_en ? low_douta\n                    : high_en ? high_doutb\n                    : 8'h77;\n\n  always @(posedge clk) begin\n    if(reg_en & reg_we_rising) begin\n      obc1_regs[obc_reg] <= data_in;\n    end\n  end\n\nendmodule"}
{"task_id": 980, "completion": "parameter         C_FAMILY         = \"virtex7\";    parameter         C_I2C_SLAVE_ADDR = \"1110110\";    parameter integer C_TFT_INTERFACE  = 1;    parameter integer C_IOREG_STYLE    = 1;    parameter integer C_EN_I2C_INTF    = 1;    input             TFT_Clk;    input             TFT_Rst;    input             TFT_Rst_8s;    input             Bus2IP_Rst;    input             Bus2IP_Clk;    input             HSYNC;                          input             VSYNC;                          input             DE;     input    [5:0]    RED;    input    [5:0]    GREEN;    input    [5:0]    BLUE;    output            TFT_HSYNC;    output            TFT_VSYNC;    output            TFT_DE;    output            TFT_VGA_CLK;    output   [5:0]    TFT_VGA_R;    output   [5:0]    TFT_VGA_G;    output   [5:0]    TFT_VGA_B;    output            TFT_DVI_CLK_P;    output            TFT_DVI_CLK_N;    output   [11:0]   TFT_DVI_DATA;    output            I2C_done;    input             TFT_IIC_SCL_I;    output            TFT_IIC_SCL_O;    output            TFT_IIC_SCL_T;    input             TFT_IIC_SDA_I;    output            TFT_IIC_SDA_O;    output            TFT_IIC_SDA_T;    output            IIC_xfer_done;    input             TFT_iic_xfer;    input  [0:7]      TFT_iic_reg_addr;    input  [0:7]      TFT_iic_reg_data;    FDS FDS_HSYNC (.Q(TFT_HSYNC), .C(~TFT_Clk), .S(TFT_Rst), .D(HSYNC));    FDS FDS_VSYNC (.Q(TFT_VSYNC), .C(~TFT_Clk), .S(TFT_Rst), .D(VSYNC));    FDR FDR_DE    (.Q(TFT_DE),    .C(~TFT_Clk), .R(TFT_Rst), .D(DE));    generate    if (C_TFT_INTERFACE == 1) // Selects DVI interface    begin : gen_dvi_if        wire        tft_iic_sda_t_i;        wire        tft_iic_scl_t_i;        wire [11:0] dvi_data_a;        wire [11:0] dvi_data_b;        genvar i;        assign dvi_data_a[0]  = GREEN[2];        assign dvi_data_a[1]  = GREEN[3];        assign dvi_data_a[2]  = GREEN[4];        assign dvi_data_a[3]  = GREEN[5];        assign dvi_data_a[4]  = 1'b0;        assign dvi_data_a[5]  = 1'b0;        assign dvi_data_a[6]  = RED[0];        assign dvi_data_a[7]  = RED[1];        assign dvi_data_a[8]  = RED[2];        assign dvi_data_a[9]  = RED[3];        assign dvi_data_a[10] = RED[4];        assign dvi_data_a[11] = RED[5];        assign dvi_data_b[0]  = 1'b0;        assign dvi_data_b[1]  = 1'b0;        assign dvi_data_b[2]  = BLUE[0];        assign dvi_data_b[3]  = BLUE[1];        assign dvi_data_b[4]  = BLUE[2];        assign dvi_data_b[5]  = BLUE[3];        assign dvi_data_b[6]  = BLUE[4];        assign dvi_data_b[7]  = BLUE[5];        assign dvi_data_b[8]  = 1'b0;        assign dvi_data_b[9]  = 1'b0;        assign dvi_data_b[10] = GREEN[0];        assign dvi_data_b[11] = GREEN[1];        if (C_IOREG_STYLE == 0)            begin : gen_7s                ODDR TFT_CLKP_ODDR (.Q(TFT_DVI_CLK_P), .C(TFT_Clk), .CE(1'b1), .R(TFT_Rst), .D1(1'b1), .D2(1'b0), .S(1'b0));                ODDR TFT_CLKN_ODDR (.Q(TFT_DVI_CLK_N), .C(TFT_Clk), .CE(1'b1), .R(TFT_Rst), .D1(1'b0), .D2(1'b1), .S(1'b0));                for (i=0;i<12;i=i+1) begin : replicate_tft_dvi_data                    ODDR ODDR_TFT_DATA (.Q(TFT_DVI_DATA[i]), .C(TFT_Clk), .CE(1'b1), .R(~DE|TFT_Rst), .D2(dvi_data_b[i]), .D1(dvi_data_a[i]), .S(1'b0));                end            end    else            begin : gen_8s                 OSERDESE3                 #(         .DATA_WIDTH (4),         .INIT (0),         .IS_CLKDIV_INVERTED (0),         .IS_CLK_INVERTED (0),         .ODDR_MODE (\"TRUE\"),         .IS_RST_INVERTED (0),         .OSERDES_D_BYPASS (\"TRUE\"),         .OSERDES_T_BYPASS (\"TRUE\"))                  TFT_CLKP_OSERDESE3 (                   .CLK (TFT_Clk),                   .CLKDIV (TFT_Clk),                   .D (8'b00000011),                   .OQ (TFT_DVI_CLK_P),                   .RST (TFT_Rst_8s),                   .T (1'b0),                   .T_OUT ());             OSERDESE3                 #(         .DATA_WIDTH (4),         .INIT (0),         .IS_CLKDIV_INVERTED (0),         .IS_CLK_INVERTED (0),         .ODDR_MODE (\"TRUE\"),         .IS_RST_INVERTED (0),         .OSERDES_D_BYPASS (\"TRUE\"),         .OSERDES_T_BYPASS (\"TRUE\"))                  TFT_CLKN_OSERDESE3 (                   .CLK (TFT_Clk),                   .CLKDIV (TFT_Clk),                   .D (8'b00110000),                   .OQ (TFT_DVI_CLK_N),                   .RST (TFT_Rst_8s),                   .T (1'b0),                   .T_OUT ());                for (i=0;i<12;i=i+1) begin : replicate_tft_dvi_data                    OSERDESE3                 #(         .DATA_WIDTH (4),         .INIT (0),         .IS_CLKDIV_INVERTED (0),         .IS_CLK_INVERTED (0),         .ODDR_MODE (\"TRUE\"),         .IS_RST_INVERTED (0),         .OSERDES_D_BYPASS (\"TRUE\"),         .OSERDES_T_BYPASS (\"TRUE\"))                  TFT_DATA_OSERDESE3 (                   .CLK (~TFT_Clk),                   .CLKDIV (~TFT_Clk),                   .D ({2'b00,dvi_data_a[i],dvi_data_a[i],2'b00,dvi_data_b[i],dvi_data_b[i]}),                   .OQ (TFT_DVI_DATA[i]),                   .RST (TFT_Rst),                   .T (1'b0),                   .T_OUT ());               end            end            assign TFT_VGA_CLK = 1'b0;            assign TFT_VGA_R   = 6'b0;            assign TFT_VGA_G   = 6'b0;            assign TFT_VGA_B   = 6'b0;            if (C_EN_I2C_INTF == 1)            begin : EN_I2C                axi_tft_v2_0_iic_init                 # (.C_I2C_SLAVE_ADDR(C_I2C_SLAVE_ADDR))                  iic_init                    (                      .Clk              (Bus2IP_Clk),                      .Reset_n          (~Bus2IP_Rst),                      .SDA              (tft_iic_sda_t_i),                      .SCL              (tft_iic_scl_t_i),                      .Done             (I2C_done),                      .IIC_xfer_done    (IIC_xfer_done),                      .TFT_iic_xfer     (TFT_iic_xfer),                      .TFT_iic_reg_addr (TFT_iic_reg_addr),                      .TFT_iic_reg_data (TFT_iic_reg_data)                     );                              assign TFT_IIC_SCL_O = 1'b0;                assign TFT_IIC_SDA_O = 1'b0;                assign TFT_IIC_SDA_T = tft_iic_sda_t_i ;                assign TFT_IIC_SCL_T = tft_iic_scl_t_i ;            end else            begin : DIS_I2C                assign I2C_done       = 1'b1;                assign IIC_xfer_done  = 1'b0;                assign TFT_IIC_SCL_O  = 1'b0;                assign TFT_IIC_SDA_O  = 1'b0;                assign TFT_IIC_SDA_T  = 1'b1;                assign TFT_IIC_SCL_T  = 1'b1;            end        end // End DVI Interface     else  // Selects VGA Interface        begin : gen_vga_if          if (C_IOREG_STYLE == 0)            begin : gen_7s                ODDR TFT_CLK_ODDR   (.Q(TFT_VGA_CLK), .C(TFT_Clk), .CE(1'b1), .R(TFT_Rst), .D1(1'b0), .D2(1'b1), .S(1'b0));            end          else            begin : gen_8s             OSERDESE3                 #(         .DATA_WIDTH (4),         .INIT (0),         .IS_CLKDIV_INVERTED (0),         .IS_CLK_INVERTED (0),         .ODDR_MODE (\"TRUE\"),         .IS_RST_INVERTED (0),         .OSERDES_D_BYPASS (\"TRUE\"),         .OSERDES_T_BYPASS (\"TRUE\"))                  TFT_CLK_OSERDESE3 (                   .CLK (TFT_Clk),                   .CLKDIV (TFT_Clk),                   .D (8'b00110000),                   .OQ (TFT_VGA_CLK),                   .RST (TFT_Rst_8s),                   .T (1'b0),                   .T_OUT ());            end          FDR FDR_R0 (.Q(TFT_VGA_R[0]), .C(~TFT_Clk), .R(TFT_Rst), .D(RED[0]));          FDR FDR_R1 (.Q(TFT_VGA_R[1]), .C(~TFT_Clk), .R(TFT_Rst), .D(RED[1]));          FDR FDR_R2 (.Q(TFT_VGA_R[2]), .C(~TFT_Clk), .R(TFT_Rst), .D(RED[2]));          FDR FDR_R3 (.Q(TFT_VGA_R[3]), .C(~TFT_Clk), .R(TFT_Rst), .D(RED[3]));          FDR FDR_R4 (.Q(TFT_VGA_R[4]), .C(~TFT_Clk), .R(TFT_Rst), .D(RED[4]));          FDR FDR_R5 (.Q(TFT_VGA_R[5]), .C(~TFT_Clk), .R(TFT_Rst), .D(RED[5]));          FDR FDR_G0 (.Q(TFT_VGA_G[0]), .C(~TFT_Clk), .R(TFT_Rst), .D(GREEN[0]));          FDR FDR_G1 (.Q(TFT_VGA_G[1]), .C(~TFT_Clk), .R(TFT_Rst), .D(GREEN[1]));          FDR FDR_G2 (.Q(TFT_VGA_G[2]), .C(~TFT_Clk), .R(TFT_Rst), .D(GREEN[2]));          FDR FDR_G3 (.Q(TFT_VGA_G[3]), .C(~TFT_Clk), .R(TFT_Rst), .D(GREEN[3]));          FDR FDR_G4 (.Q(TFT_VGA_G[4]), .C(~TFT_Clk), .R(TFT_Rst), .D(GREEN[4]));          FDR FDR_G5 (.Q(TFT_VGA_G[5]), .C(~TFT_Clk), .R(TFT_Rst), .D(GREEN[5]));          FDR FDR_B0 (.Q(TFT_VGA_B[0]), .C(~TFT_Clk), .R(TFT_Rst), .D(BLUE[0]));          FDR FDR_B1 (.Q(TFT_VGA_B[1]), .C(~TFT_Clk), .R(TFT_Rst), .D(BLUE[1]));          FDR FDR_B2 (.Q(TFT_VGA_B[2]), .C(~TFT_Clk), .R(TFT_Rst), .D(BLUE[2]));          FDR FDR_B3 (.Q(TFT_VGA_B[3]), .C(~TFT_Clk), .R(TFT_Rst), .D(BLUE[3]));          FDR FDR_B4 (.Q(TFT_VGA_B[4]), .C(~TFT_Clk), .R(TFT_Rst), .D(BLUE[4]));          FDR FDR_B5 (.Q(TFT_VGA_B[5]), .C(~TFT_Clk), .R(TFT_Rst), .D(BLUE[5]));          assign TFT_DVI_CLK_P  = 1'b0;           assign TFT_DVI_CLK_N  = 1'b0;          assign TFT_DVI_DATA   = 12'b0;          assign I2C_done       = 1'b1;          assign IIC_xfer_done  = 1'b0;          assign TFT_IIC_SCL_O  = 1'b0;          assign TFT_IIC_SDA_O  = 1'b0;          assign TFT_IIC_SDA_T  = 1'b1;          assign TFT_IIC_SCL_T  = 1'b1;        end // End VGA Interface    endgenerate    endmodule"}
{"task_id": 1189, "completion": "reg ctrl_ena;\n    reg ctrl_ext;\n    reg ctrl_loop;\n    reg ctrl_start;\n\n    wire start;\n    wire enable;\n    wire ena_loop;\n    wire ena_ext;\n    wire set_start;\n\n    wire running;\n\n    reg [15:0]period;\n    reg [15:0]loopcnt;\n\n    wire [7:0]seq_address;\n    wire [15:0]seq_command;\n\n    always @(posedge csi_clock_clk or posedge csi_clock_reset)\n    begin\n        if (csi_clock_reset)\n        begin\n            { ctrl_ena, ctrl_loop, ctrl_ext, ctrl_start } <= 4'b0000;\n            period   <= 0;\n        end\n        else if (avs_ctrl_write)\n        begin\n            case (avs_ctrl_address)\n                0: { ctrl_ena, ctrl_loop, ctrl_ext, ctrl_start }\n                        <= { avs_ctrl_writedata[7], avs_ctrl_writedata[2:0] };\n                1: period   <= avs_ctrl_writedata[15:0];\n            endcase\n        end\n        else if (clkena) ctrl_start <= 0;\n    end\n\n    assign avs_ctrl_readdata =\n        avs_ctrl_address ? { 16'd0, period } : { 31'd0, running };\n\n    assign enable    = ctrl_ena;\n    assign ena_ext   = ctrl_ext;\n    assign ena_loop  = ctrl_loop;\n    assign set_start = ctrl_start;\n    wire trig_loop = loopcnt == 0;\n    always @(posedge csi_clock_clk or posedge csi_clock_reset)\n    begin\n        if (csi_clock_reset) loopcnt <= 0;\n        else if (clkena)\n        begin\n            if (ena_loop)\n            begin\n                if (trig_loop) loopcnt <= period; else loopcnt <= loopcnt - 1;\n            end\n            else loopcnt <= 0;\n        end\n    end\n\n    assign start = set_start || (ena_loop && trig_loop) || (ena_ext && trigger);\n\n    pg_ram ram\n    (\n        .clock     (csi_clock_clk),\n        .wren      (avs_data_write),\n        .wraddress (avs_data_address),\n        .byteena_a (avs_data_byteenable),\n        .data      (avs_data_writedata),\n        .rdaddress (seq_address),\n        .q (seq_command)\n    );\n\n    pg_sequencer pg\n    (\n        .clk(csi_clock_clk),\n        .sync(clkena),\n        .reset(csi_clock_reset),\n        .enable(enable),\n        .start(start),\n        .running(running),\n        .pgout(pgout),\n        .ip(seq_address),\n        .cmd(seq_command)\n    );\n\nendmodule"}
{"task_id": 1203, "completion": "// Multiplexer logic here\n\nendmodule"}
{"task_id": 1213, "completion": "reg [1:0] buffer;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            buffer <= 2'd0;\n        end else begin\n            buffer <= ip;\n        end\n    end\n\n    assign op = buffer;\nendmodule"}
{"task_id": 790, "completion": "wire  Net_65;\n          wire  Net_64;\n          wire  Net_37;\n          wire  Net_63;\n          wire  Net_15;\n          wire  Net_14;\n          wire  Net_53;\n          wire  Net_60;\n          wire  Net_55;\n\n    cy_m0s8_ble_v1_0 cy_m0s8_ble (\n        .interrupt(Net_15),\n        .rf_ext_pa_en(Net_63));\n\n\n    cy_isr_v1_0\n        #(.int_type(2'b10))\n        bless_isr\n         (.int_signal(Net_15));\n\n\n    cy_clock_v1_0\n        #(.id(\"83af9cd5-09a4-48a2-88b9-37aaa4f44cd3/5ae6fa4d-f41a-4a35-8821-7ce70389cb0c\"),\n          .source_clock_id(\"9A908CA6-5BB3-4db0-B098-959E5D90882B\"),\n          .divisor(0),\n          .period(\"0\"),\n          .is_direct(1),\n          .is_digital(0))\n        LFCLK\n         (.clock_out(Net_53));\n\n\n    assign clk = Net_53 | Net_55;\n\n    assign Net_55 = 1'h0;\n\nendmodule"}
{"task_id": 1215, "completion": "output X   ;\n    input  A1_N;\n    input  A2_N;\n    input  B1  ;\n    input  B2  ;\n    input  VPWR;\n    input  VGND;\n    input  VPB ;\n    input  VNB ;\n\n    wire nand0_out        ;\n    wire or0_out          ;\n    wire and0_out_X       ;\n    wire pwrgood_pp0_out_X;\n\n    nand                                 nand0       (nand0_out        , A2_N, A1_N            );\n    or                                   or0         (or0_out          , B2, B1                );\n    and                                  and0        (and0_out_X       , nand0_out, or0_out    );\n    sky130_fd_sc_hdll__udp_pwrgood_pp$PG pwrgood_pp0 (pwrgood_pp0_out_X, and0_out_X, VPWR, VGND);\n    buf                                  buf0        (X                , pwrgood_pp0_out_X     );\n\nendmodule"}
{"task_id": 1196, "completion": "always @(*)\nbegin\n  case (CONF)\n    4'd0: begin\n      mO_tvalid =  1'b0     ;\n      mO_tdata  = 32'd0     ;\n      s1_tready =  1'b0     ;\n      s2_tready =  1'b0     ;\n      s3_tready =  1'b0     ;\n      s4_tready =  1'b0     ;\n      s5_tready =  1'b0     ;\n    end\n\n    4'd1: begin\n      mO_tvalid = s1_tvalid ;\n      mO_tdata  = s1_tdata  ;\n      s1_tready = mO_tready ;\n      s2_tready = 1'b0      ;\n      s3_tready = 1'b0      ;\n      s4_tready = 1'b0      ;\n      s5_tready = 1'b0      ;\n    end\n\n    4'd2: begin\n      mO_tvalid = s2_tvalid ;\n      mO_tdata  = s2_tdata  ;\n      s1_tready = 1'b0      ;\n      s2_tready = mO_tready ;\n      s3_tready = 1'b0      ;\n      s4_tready = 1'b0      ;\n      s5_tready = 1'b0      ;\n    end\n\n    4'd3: begin\n      mO_tvalid = s3_tvalid ;\n      mO_tdata  = s3_tdata  ;\n      s1_tready = 1'b0      ;\n      s2_tready = 1'b0      ;\n      s3_tready = mO_tready ;\n      s4_tready = 1'b0      ;\n      s5_tready = 1'b0      ;\n    end\n\n    4'd4: begin\n      mO_tvalid = s4_tvalid ;\n      mO_tdata  = s4_tdata  ;\n      s1_tready = 1'b0      ;\n      s2_tready = 1'b0      ;\n      s3_tready = 1'b0      ;\n      s4_tready = mO_tready ;\n      s5_tready = 1'b0      ;\n    end\n\n    4'd5: begin\n      mO_tvalid = s5_tvalid ;\n      mO_tdata  = s5_tdata  ;\n      s1_tready = 1'b0      ;\n      s2_tready = 1'b0      ;\n      s3_tready = 1'b0      ;\n      s4_tready = 1'b0      ;\n      s5_tready = mO_tready ;\n    end\n\n    default: begin\n      mO_tvalid =  1'b0     ;\n      mO_tdata  = 32'd0     ;\n      s1_tready =  1'b0     ;\n      s2_tready =  1'b0     ;\n      s3_tready =  1'b0     ;\n      s4_tready =  1'b0     ;\n      s5_tready =  1'b0     ;\n    end\n  endcase\nend\n\nendmodule"}
{"task_id": 1218, "completion": "reg [DATA_WIDTH-1:0] mem [(1<<ADDR_WIDTH)-1:0];\n\n    always @(posedge clk_a) begin\n        if (wce_a) begin\n            mem[wa_a] <= wd_a;\n        end\n    end\n\n    assign rq_a = (rce_a) ? mem[ra_a] : {DATA_WIDTH{1'b0}};\n\n    always @(posedge clk_b) begin\n        if (wce_b) begin\n            mem[wa_b] <= wd_b;\n        end\n    end\n\n    assign rq_b = (rce_b) ? mem[ra_b] : {DATA_WIDTH{1'b0}};\nendmodule"}
{"task_id": 1035, "completion": "localparam  IDLE                      = 4'h0;\nlocalparam  PROCESS_STEP              = 4'h1;\nlocalparam  PROCESS_SLEEP             = 4'h2;\nlocalparam  PROCESS_SHOOT_THROUGH     = 4'h3;\nlocalparam  PREPARE_MICRO_STEP        = 4'h4;\nlocalparam  PROCESS_MICRO_STEP        = 4'h5;\nlocalparam  FINISHED                  = 4'h6;\nlocalparam  FULL_STEP                 = 4'h0;\nlocalparam  HALF_STEP                 = 4'h1;\nlocalparam  MICRO_STEP                = 4'h2;\nlocalparam  UNDEFINED_STEP            = 4'h3;\nlocalparam  MAX_FULL_STEP_SIZE        = 4;\nlocalparam  MAX_HALF_STEP_SIZE        = 8;\nlocalparam  MAX_MICRO_STEP_SIZE       = 8;\nlocalparam  FULL_STEP_INC             = 32'h00000200;\nlocalparam  HALF_STEP_INC             = 32'h00000100;\nlocalparam  MICRO_STEP_INC            = 32'h00000010;\n\nreg     [3:0]         state         = IDLE;\n\nreg     [7:0]         step_pos;\nwire    [31:0]        in_full_steps;\nwire    [31:0]        in_half_steps;\nwire    [7:0]         full_step_pos;\nwire    [7:0]         half_step_pos;\n\nwire    [3:0]         full_step_path[3:0];\nwire    [3:0]         half_step_path[7:0];\n\nreg                   continuous;\nreg                   direction;\nreg     [31:0]        max_step_count;\nreg     [31:0]        step_count;\nwire    [31:0]        steps_left;\n\nreg     [31:0]        run_period;\nreg     [31:0]        step_delay;\nreg     [3:0]         step_type     = UNDEFINED_STEP;\n\nreg     [31:0]        shoot_through_period;\nreg     [31:0]        shoot_through_count;\n\nwire    [31:0]        step_inc_map  [3:0];\nwire    [31:0]        max_pos_map   [3:0];\n\nreg     [3:0]         hbridge_map;\nreg                   move_strobe;\nreg     [31:0]        current_position;\n\nreg     [31:0]        accelleration;\nreg     [31:0]        current_period;\nreg     [31:0]        walk_period;\nreg     [31:0]        prev_step_count;\nwire                  step_change;\nreg     [31:0]        velocity;\n\nwire    [3:0]         micro_hbridge_map;\nwire                  micro_busy;\nwire    [31:0]        micro_position;\nwire    [31:0]        micro_step_count;\nwire    [7:0]         micro_step_pos;\nwire                  micro_move_strobe;\n\nbipolar_micro_stepper #(\n  `ifdef SIM\n  .CLOCK_DIV          (1                        )\n  `else\n  .CLOCK_DIV          (4                        )\n  `endif\n)bms(\n  .clk                (clk                      ),\n  .rst                (rst                      ),\n  .i_go               (i_go && i_micro_step     ),\n  .o_busy             (micro_busy               ),\n  .i_stop             (i_stop                   ),\n  .i_micro_step_hold  (i_micro_step_hold        ),\n  .i_current_position (current_position         ),\n  .o_current_position (micro_position           ),\n  .i_step_pos         (step_pos                 ),\n  .o_step_pos         (micro_step_pos           ),\n  .o_step_count       (micro_step_count         ),\n  .o_move_strobe      (micro_move_strobe        ),\n  .i_continuous       (i_continuous             ),\n  .i_direction        (i_direction              ),\n  .i_steps            (i_steps                  ),\n  .i_current_period   (current_period           ),\n  .o_hbridge0_l       (micro_hbridge_map[3]     ),\n  .o_hbridge0_r       (micro_hbridge_map[2]     ),\n  .o_hbridge1_l       (micro_hbridge_map[1]     ),\n  .o_hbridge1_r       (micro_hbridge_map[0]     )\n);\n\nassign full_step_path[0]          = 4'b1010;\nassign full_step_path[1]          = 4'b0110;\nassign full_step_path[2]          = 4'b0101;\nassign full_step_path[3]          = 4'b1001;\n\nassign half_step_path[0]          = 4'b1000;\nassign half_step_path[1]          = 4'b1010;\nassign half_step_path[2]          = 4'b0010;\nassign half_step_path[3]          = 4'b0110;\nassign half_step_path[4]          = 4'b0100;\nassign half_step_path[5]          = 4'b0101;\nassign half_step_path[6]          = 4'b0001;\nassign half_step_path[7]          = 4'b1001;\n\nassign step_inc_map[0]            = FULL_STEP_INC;\nassign step_inc_map[1]            = HALF_STEP_INC;\nassign step_inc_map[2]            = MICRO_STEP_INC;\nassign step_inc_map[3]            = 32'h0;\n\nassign max_pos_map[0]             = MAX_FULL_STEP_SIZE - 1;\nassign max_pos_map[1]             = MAX_HALF_STEP_SIZE - 1;\nassign max_pos_map[2]             = MAX_HALF_STEP_SIZE - 1;\nassign max_pos_map[3]             = 32'h0;\n\nassign o_busy                     = (state != IDLE);\n\nassign o_hbridge0_l               = (step_type == MICRO_STEP) ? micro_hbridge_map[3] : hbridge_map[3];\nassign o_hbridge0_r               = (step_type == MICRO_STEP) ? micro_hbridge_map[2] : hbridge_map[2];\nassign o_hbridge1_l               = (step_type == MICRO_STEP) ? micro_hbridge_map[1] : hbridge_map[1];\nassign o_hbridge1_r               = (step_type == MICRO_STEP) ? micro_hbridge_map[0] : hbridge_map[0];\n\nassign in_full_steps              =  {9'h0, i_steps[31:9]};\nassign in_half_steps              =  {8'h0, i_steps[31:8]};\n\nassign step_change                = (i_micro_step) ?\n                                      (prev_step_count != micro_step_count) :\n                                      (prev_step_count != step_count);\nassign steps_left                 = (i_micro_step) ?\n                                      (max_step_count - micro_step_count) :\n                                      (max_step_count - step_count);\nassign o_move_strobe              = i_micro_step ? micro_move_strobe : move_strobe;\n\nalways @ (posedge clk) begin\n  if (rst) begin\n    state                     <=  IDLE;\n    hbridge_map               <=  4'b0000;\n\n    step_type                 <=  UNDEFINED_STEP;\n    continuous                <=  0;\n    direction                 <=  0;\n    max_step_count            <=  0;\n    step_count                <=  0;\n    o_err_bad_step            <=  0;\n\n    step_delay                <=  0;\n\n    step_pos                  <=  0;\n\n    shoot_through_period      <=  0;\n    shoot_through_count       <=  0;\n\n    current_position          <=  0;\n    move_strobe               <=  0;\n  end\n  else begin\n    move_strobe               <=  0;\n    case (state)\n      IDLE: begin\n        continuous            <=  0;\n        step_count            <=  0;\n        max_step_count        <=  0;\n\n        step_delay            <=  0;\n        o_err_bad_step        <=  0;\n        direction             <=  0;\n\n        if (i_go) begin\n          if (i_full_step) begin\n            step_type         <=  FULL_STEP;\n            state             <=  PROCESS_STEP;\n            max_step_count    <=  in_full_steps;\n          end\n          else if (i_half_step) begin\n            step_type         <=  HALF_STEP;\n            state             <=  PROCESS_STEP;\n            max_step_count    <=  in_half_steps;\n          end\n          else if (i_micro_step) begin\n            step_type         <=  MICRO_STEP;\n            state             <=  FINISHED;\n            max_step_count    <=  in_half_steps;\n          end\n          else begin\n            step_type         <=  UNDEFINED_STEP;\n            o_err_bad_step    <=  1;\n            state             <=  FINISHED;\n          end\n          if (i_continuous) begin\n            continuous        <=  1;\n          end\n          shoot_through_period<=  i_shoot_through_period;\n          direction           <=  i_direction;\n        end\n      end\n      PROCESS_STEP: begin\n        if (i_stop || (step_count >= max_step_count)) begin\n          state               <=  FINISHED;\n        end\n        else begin\n          step_delay          <=  0;\n          case (step_type)\n            FULL_STEP: begin\n              if (step_count < max_step_count) begin\n                hbridge_map   <=  full_step_path[step_pos];\n                state         <=  PROCESS_SLEEP;\n              end\n              else begin\n                state         <=  FINISHED;\n              end\n            end\n            HALF_STEP: begin\n              if (step_count < max_step_count) begin\n                hbridge_map   <=  half_step_path[step_pos];\n                state         <=  PROCESS_SLEEP;\n              end\n              else begin\n                state         <=  FINISHED;\n              end\n            end\n            default: begin\n              o_err_bad_step  <=  1;\n              state           <=  FINISHED;\n            end\n          endcase\n        end\n      end\n      PROCESS_SLEEP: begin\n        if (step_delay < current_period) begin\n          step_delay          <=  step_delay + 1;\n        end\n        else begin\n          if (!continuous) begin\n            step_count        <=  step_count + 1;\n          end\n          move_strobe         <=  1;\n          if (direction) begin\n            if (step_pos >= max_pos_map[step_type]) begin\n              step_pos        <=  0;\n            end\n            else begin\n              step_pos        <=  step_pos + 1;\n            end\n          end\n          else begin\n            if (step_pos == 0) begin\n              step_pos        <=  max_pos_map[step_type];\n            end\n            else begin\n              step_pos        <=  step_pos - 1;\n            end\n          end\n\n          if (shoot_through_period > 0) begin\n            shoot_through_count   <=  0;\n            state                 <=  PROCESS_SHOOT_THROUGH;\n          end\n          else begin\n            state                 <=  PROCESS_STEP;\n          end\n        end\n      end\n      PROCESS_SHOOT_THROUGH: begin\n        if (shoot_through_count < shoot_through_period) begin\n          shoot_through_count     <=  shoot_through_count + 1;\n          hbridge_map             <=  4'b0000;\n        end\n        else begin\n          state                   <=  PROCESS_STEP;\n        end\n      end\n      FINISHED: begin\n        hbridge_map               <=  4'b0000;\n        if (!i_go && !micro_busy) begin\n          if (step_type == MICRO_STEP) begin\n            current_position      <=  micro_position;\n          end\n          state                   <=  IDLE;\n        end\n      end\n      default: begin\n        state                     <=  FINISHED;\n      end\n    endcase\n    if (i_stop) begin\n      state                       <=  IDLE;\n    end\n  end\nend\n\nalways @ (posedge clk) begin\n  if (rst) begin\n    accelleration         <=  0;\n    current_period        <=  0;\n    velocity              <=  0;\n    prev_step_count       <=  0;\n    run_period            <=  0;\n    walk_period           <=  0;\n  end\n  else begin\n    if (i_go) begin\n      accelleration       <=  i_step_accelleration;\n      if (i_full_step) begin\n        run_period        <=  i_step_run_period   << 1;\n        walk_period       <=  i_step_walk_period  << 1;\n        current_period      <=  i_step_walk_period << 1;\n      end\n      else begin\n        run_period        <=  i_step_run_period;\n        walk_period       <=  i_step_walk_period;\n        current_period    <=  i_step_walk_period;\n      end\n    end\n\n    if (step_change) begin\n      if ((velocity < steps_left) && (current_period > run_period)) begin\n        velocity            <= velocity + 1;\n        if ((current_period - accelleration) < run_period) begin\n          current_period    <= run_period;\n        end\n        else begin\n          if (velocity + 1 < steps_left) begin\n            current_period <= current_period - accelleration;\n          end\n        end\n      end\n      else if ((velocity >= steps_left) && (velocity > 0))begin\n        velocity            <=  velocity - 1;\n        if ((current_period + accelleration) > walk_period) begin\n          current_period    <=  walk_period;\n        end\n        else begin\n          current_period    <=  current_period + accelleration;\n        end\n      end\n    end\n\n    if (i_micro_step) begin\n      prev_step_count       <=  micro_step_count;\n    end\n    else begin\n      prev_step_count       <=  step_count;\n    end\n  end\nend\n\nendmodule"}
{"task_id": 1214, "completion": "input [0:127] dataOut_in;\n    input [0:15] wbyteen_in;\n    input regwren_in;\n    input [0:4] rwraddrd_in;\n    input reginmuxop_in;\n    input [0:127] aluOut_in;\n    input [0:31] instruction_in;\n    input clk, reset;\n\n    output [0:127] dataOut_out;\n    output [0:15] wbyteen_out;\n    output regwren_out;\n    output [0:15] rwraddrd_out;\n    output reginmuxop_out;\n    output [0:127] aluOut_out;\n    output [0:31] instruction_out;\n\n    reg [0:127] dataOut_out;\n    reg [0:15] wbyteen_out;\n    reg regwren_out;\n    reg [0:4] rwraddrd_out;\n    reg reginmuxop_out;\n    reg [0:127] aluOut_out;\n    reg [0:31] instruction_out;\n\n    always @ (posedge clk)\n        begin\n        if (reset == 1'b1)\n            begin\n            dataOut_out<=128'b0;\n            wbyteen_out<=16'b0;\n            regwren_out<=1'b0;\n            rwraddrd_out<=5'b0;\n            reginmuxop_out<=1'b0;\n            aluOut_out<=128'b0;\n            instruction_out<=32'b0;\n            end\n        else\n            begin\n            dataOut_out<=dataOut_in;\n            wbyteen_out<=wbyteen_in;\n            regwren_out<=regwren_in;\n            rwraddrd_out<=rwraddrd_in;\n            reginmuxop_out<=reginmuxop_in;\n            aluOut_out<=aluOut_in;\n            instruction_out<=instruction_in;\n            end\n        end\n\nendmodule"}
{"task_id": 1217, "completion": "input\t aclr;\n    input\t clock;\n    input\t[5:0] data;\n    input\t rdreq;\n    input\t wrreq;\n    output\t almost_empty;\n    output\t almost_full;\n    output\t[5:0] q;\n\n    wire  sub_wire0;\n    wire  sub_wire1;\n    wire [5:0] sub_wire2;\n    wire  almost_empty = sub_wire0;\n    wire  almost_full = sub_wire1;\n    wire [5:0] q = sub_wire2[5:0];\n\n    scfifo scfifo_component (\n                .aclr (aclr),\n                .clock (clock),\n                .data (data),\n                .rdreq (rdreq),\n                .wrreq (wrreq),\n                .almost_empty (sub_wire0),\n                .almost_full (sub_wire1),\n                .q (sub_wire2),\n                .empty (),\n                .full (),\n                .sclr (),\n                .usedw ());\n    defparam\n        scfifo_component.add_ram_output_register = \"ON\",\n        scfifo_component.almost_empty_value = 2,\n        scfifo_component.almost_full_value = 254,\n        scfifo_component.intended_device_family = \"Cyclone V\",\n        scfifo_component.lpm_numwords = 256,\n        scfifo_component.lpm_showahead = \"OFF\",\n        scfifo_component.lpm_type = \"scfifo\",\n        scfifo_component.lpm_width = 6,\n        scfifo_component.lpm_widthu = 8,\n        scfifo_component.overflow_checking = \"ON\",\n        scfifo_component.underflow_checking = \"ON\",\n        scfifo_component.use_eab = \"ON\";\n\nendmodule"}
{"task_id": 1222, "completion": "wire trdemu_on = vg_rdwr_fclk && fdd_mask[vg_a] && dos && romnram;\n\n    always @(posedge fclk, negedge rst_n)\n    if( !rst_n )\n    begin\n        dos = 1'b1;\n    end\n    else\n    begin\n        if( !cpm_n )\n            dos <= 1'b1;\n        else if( dos_turn_off )\n            dos <= 1'b0;\n        else if( dos_turn_on )\n            dos <= 1'b1;\n    end\n\n    always @(posedge fclk, negedge rst_n)\n    if( !rst_n )\n        in_trdemu <= 1'b0;\n    else if( clr_nmi )\n        in_trdemu <= 1'b0;\n    else if( trdemu_on )\n        in_trdemu <= 1'b1;\n\n    always @(posedge fclk, negedge rst_n)\n    if( !rst_n )\n        trdemu_wr_disable <= 1'b0;\n    else if( zpos && !m1_n )\n        trdemu_wr_disable <= 1'b0;\n    else if( trdemu_on )\n        trdemu_wr_disable <= 1'b1;\n\nendmodule"}
{"task_id": 1208, "completion": "parameter  [1:0]  pri_sel = 2'd0;\n\n    input  [7:0] valid;\n    input  [1:0] pri0, pri1, pri2, pri3;\n    input  [1:0] pri4, pri5, pri6, pri7;\n    output  [1:0] pri_out;\n\n    wire  [3:0] pri0_out, pri1_out, pri2_out, pri3_out;\n    wire  [3:0] pri4_out, pri5_out, pri6_out, pri7_out;\n    wire  [3:0] pri_out_tmp;\n    reg  [1:0] pri_out0, pri_out1;\n    wire  [1:0] pri_out;\n\n    wb_conmax_pri_dec #(pri_sel) pd0(\n            .valid(     valid[0]    ),\n            .pri_in(   pri0       ),\n            .pri_out(  pri0_out   )\n            );\n\n    wb_conmax_pri_dec #(pri_sel) pd1(\n            .valid(     valid[1]    ),\n            .pri_in(   pri1       ),\n            .pri_out(  pri1_out   )\n            );\n\n    wb_conmax_pri_dec #(pri_sel) pd2(\n            .valid(     valid[2]    ),\n            .pri_in(   pri2       ),\n            .pri_out(  pri2_out   )\n            );\n\n    wb_conmax_pri_dec #(pri_sel) pd3(\n            .valid(     valid[3]    ),\n            .pri_in(   pri3       ),\n            .pri_out(  pri3_out   )\n            );\n\n    wb_conmax_pri_dec #(pri_sel) pd4(\n            .valid(     valid[4]    ),\n            .pri_in(   pri4       ),\n            .pri_out(  pri4_out   )\n            );\n\n    wb_conmax_pri_dec #(pri_sel) pd5(\n            .valid(     valid[5]    ),\n            .pri_in(   pri5       ),\n            .pri_out(  pri5_out   )\n            );\n\n    wb_conmax_pri_dec #(pri_sel) pd6(\n            .valid(     valid[6]    ),\n            .pri_in(   pri6       ),\n            .pri_out(  pri6_out   )\n            );\n\n    wb_conmax_pri_dec #(pri_sel) pd7(\n            .valid(     valid[7]    ),\n            .pri_in(   pri7       ),\n            .pri_out(  pri7_out   )\n            );\n\n    assign pri_out_tmp =    pri0_out | pri1_out | pri2_out | pri3_out |\n                pri4_out | pri5_out | pri6_out | pri7_out;\n\n    always @(pri_out_tmp)\n    \tif(pri_out_tmp[3])  pri_out1 = 2'h3;\n    \telse\n    \tif(pri_out_tmp[2])  pri_out1 = 2'h2;\n    \telse\n    \tif(pri_out_tmp[1])  pri_out1 = 2'h1;\n    \telse          pri_out1 = 2'h0;\n\n    always @(pri_out_tmp)\n    \tif(pri_out_tmp[1])  pri_out0 = 2'h1;\n    \telse          pri_out0 = 2'h0;\n\n    assign pri_out = (pri_sel==2'd0) ? 2'h0 : ( (pri_sel==2'd1) ? pri_out0 : pri_out1 );\n\nendmodule"}
{"task_id": 1198, "completion": "reg [1:0] state;\n    parameter wait_state = 2'b00, z_read_state = 2'b01, write_pixel_state = 2'b10;\n    wire [31:0] pixel_offset = (target_size_x_i*cuvz_pixel_y_i + {16'h0, cuvz_pixel_x_i}) << 1;\n    assign z_addr_o = zbuffer_base_i + pixel_offset[31:2];\n    wire [31:0] z_value_at_target32;\n    wire signed [point_width-1:0] z_value_at_target = z_value_at_target32[point_width-1:0];\n    memory_to_color memory_proc(\n        .color_depth_i (2'b01),\n        .mem_i         (z_data_i),\n        .mem_lsb_i     (cuvz_pixel_x_i[1:0]),\n        .color_o       (z_value_at_target32),\n        .sel_o         ()\n    );\n    always @(posedge clk_i or posedge rst_i)\n    if(rst_i) begin\n        u_o <= 1'b0;\n        v_o <= 1'b0;\n        bezier_factor0_o <= 1'b0;\n        bezier_factor1_o <= 1'b0;\n        pixel_x_o <= 1'b0;\n        pixel_y_o <= 1'b0;\n        pixel_z_o <= 1'b0;\n        color_o <= 1'b0;\n        a_o <= 1'b0;\n        z_sel_o <= 4'b1111;\n    end else begin\n        if(raster_write_i) begin\n            u_o <= raster_u_i;\n            v_o <= raster_v_i;\n            a_o <= 8'hff;\n            color_o <= flat_color_i;\n            pixel_x_o <= raster_pixel_x_i;\n            pixel_y_o <= raster_pixel_y_i;\n            pixel_z_o <= 1'b0;\n        end else if(cuvz_write_i) begin\n            u_o <= cuvz_u_i;\n            v_o <= cuvz_v_i;\n            a_o <= cuvz_a_i;\n            color_o <= cuvz_color_i;\n            pixel_x_o <= cuvz_pixel_x_i;\n            pixel_y_o <= cuvz_pixel_y_i;\n            pixel_z_o <= cuvz_pixel_z_i;\n            bezier_factor0_o <= bezier_factor0_i;\n            bezier_factor1_o <= bezier_factor1_i;\n        end\n    end\n    wire fail_z_check = z_value_at_target > cuvz_pixel_z_i;\n    wire outside_target = raster_write_i ? (raster_pixel_x_i >= target_size_x_i) | (raster_pixel_y_i >= target_size_y_i) : (cuvz_pixel_x_i >= target_size_x_i) | (cuvz_pixel_y_i >= target_size_y_i);\n    wire outside_clip = raster_write_i ? (raster_pixel_x_i < clip_pixel0_x_i) | (raster_pixel_y_i < clip_pixel0_y_i) | (raster_pixel_x_i >= clip_pixel1_x_i) | (raster_pixel_y_i >= clip_pixel1_y_i) : (cuvz_pixel_x_i < clip_pixel0_x_i) | (cuvz_pixel_y_i < clip_pixel0_y_i) | (cuvz_pixel_x_i >= clip_pixel1_x_i) | (cuvz_pixel_y_i >= clip_pixel1_y_i);\n    wire discard_pixel = outside_target | (clipping_enable_i & outside_clip);\n    wire write_i = raster_write_i | cuvz_write_i;\n    always @(posedge clk_i or posedge rst_i)\n    if(rst_i) begin\n        ack_o <= 1'b0;\n        write_o <= 1'b0;\n        z_request_o <= 1'b0;\n        z_sel_o <= 4'b1111;\n    end else begin\n        case (state)\n            wait_state: begin\n                if(write_i)\n                    ack_o <= discard_pixel;\n                else\n                    ack_o <= 1'b0;\n\n                if(write_i & zbuffer_enable_i)\n                    z_request_o <= ~discard_pixel;\n                else if(write_i)\n                    write_o <= ~discard_pixel;\n            end\n            z_read_state:\n                if(z_ack_i) begin\n                    write_o <= ~fail_z_check;\n                    ack_o <= fail_z_check;\n                    z_request_o <= 1'b0;\n                end else\n                    z_request_o <= ~wbm_busy_i | z_request_o;\n            write_pixel_state: begin\n                write_o <= 1'b0;\n                if(ack_i)\n                    ack_o <= 1'b1;\n            end\n        endcase\n    end\n    always @(posedge clk_i or posedge rst_i)\n    if(rst_i)\n        state <= wait_state;\n    else\n        case (state)\n            wait_state:\n                if(write_i & ~discard_pixel) begin\n                    if(zbuffer_enable_i)\n                        state <= z_read_state;\n                    else \n                        state <= write_pixel_state;\n                end\n            z_read_state:\n                if(z_ack_i)\n                    state <= fail_z_check ? wait_state : write_pixel_state;\n            write_pixel_state:\n                if(ack_i)\n                    state <= wait_state;\n        endcase\nendmodule"}
{"task_id": 1006, "completion": "wire GND_1;\n  wire VCC_1;\n  wire [7:0] axi_gpio_0_GPIO_TRI_O;\n  wire [14:0] processing_system7_0_DDR_ADDR;\n  wire [2:0] processing_system7_0_DDR_BA;\n  wire processing_system7_0_DDR_CAS_N;\n  wire processing_system7_0_DDR_CKE;\n  wire processing_system7_0_DDR_CK_N;\n  wire processing_system7_0_DDR_CK_P;\n  wire processing_system7_0_DDR_CS_N;\n  wire [3:0] processing_system7_0_DDR_DM;\n  wire [31:0] processing_system7_0_DDR_DQ;\n  wire [3:0] processing_system7_0_DDR_DQS_N;\n  wire [3:0] processing_system7_0_DDR_DQS_P;\n  wire processing_system7_0_DDR_ODT;\n  wire processing_system7_0_DDR_RAS_N;\n  wire processing_system7_0_DDR_RESET_N;\n  wire processing_system7_0_DDR_WE_N;\n  wire processing_system7_0_FCLK_CLK0;\n  wire processing_system7_0_FCLK_RESET0_N;\n  wire processing_system7_0_FIXED_IO_DDR_VRN;\n  wire processing_system7_0_FIXED_IO_DDR_VRP;\n  wire [53:0] processing_system7_0_FIXED_IO_MIO;\n  wire processing_system7_0_FIXED_IO_PS_CLK;\n  wire processing_system7_0_FIXED_IO_PS_PORB;\n  wire processing_system7_0_FIXED_IO_PS_SRSTB;\n  wire [31:0] processing_system7_0_M_AXI_GP0_ARADDR;\n  wire [1:0] processing_system7_0_M_AXI_GP0_ARBURST;\n  wire [3:0] processing_system7_0_M_AXI_GP0_ARCACHE;\n  wire [11:0] processing_system7_0_M_AXI_GP0_ARID;\n  wire [3:0] processing_system7_0_M_AXI_GP0_ARLEN;\n  wire [1:0] processing_system7_0_M_AXI_GP0_ARLOCK;\n  wire [2:0] processing_system7_0_M_AXI_GP0_ARPROT;\n  wire [3:0] processing_system7_0_M_AXI_GP0_ARQOS;\n  wire processing_system7_0_M_AXI_GP0_ARREADY;\n  wire [2:0] processing_system7_0_M_AXI_GP0_ARSIZE;\n  wire processing_system7_0_M_AXI_GP0_ARVALID;\n  wire [31:0] processing_system7_0_M_AXI_GP0_AWADDR;\n  wire [1:0] processing_system7_0_M_AXI_GP0_AWBURST;\n  wire [3:0] processing_system7_0_M_AXI_GP0_AWCACHE;\n  wire [11:0] processing_system7_0_M_AXI_GP0_AWID;\n  wire [3:0] processing_system7_0_M_AXI_GP0_AWLEN;\n  wire [1:0] processing_system7_0_M_AXI_GP0_AWLOCK;\n  wire [2:0] processing_system7_0_M_AXI_GP0_AWPROT;\n  wire [3:0] processing_system7_0_M_AXI_GP0_AWQOS;\n  wire processing_system7_0_M_AXI_GP0_AWREADY;\n  wire [2:0] processing_system7_0_M_AXI_GP0_AWSIZE;\n  wire processing_system7_0_M_AXI_GP0_AWVALID;\n  wire [11:0] processing_system7_0_M_AXI_GP0_BID;\n  wire processing_system7_0_M_AXI_GP0_BREADY;\n  wire [1:0] processing_system7_0_M_AXI_GP0_BRESP;\n  wire processing_system7_0_M_AXI_GP0_BVALID;\n  wire [31:0] processing_system7_0_M_AXI_GP0_RDATA;\n  wire [11:0] processing_system7_0_M_AXI_GP0_RID;\n  wire processing_system7_0_M_AXI_GP0_RLAST;\n  wire processing_system7_0_M_AXI_GP0_RREADY;\n  wire [1:0] processing_system7_0_M_AXI_GP0_RRESP;\n  wire processing_system7_0_M_AXI_GP0_RVALID;\n  wire [31:0] processing_system7_0_M_AXI_GP0_WDATA;\n  wire [11:0] processing_system7_0_M_AXI_GP0_WID;\n  wire processing_system7_0_M_AXI_GP0_WLAST;\n  wire processing_system7_0_M_AXI_GP0_WREADY;\n  wire [3:0] processing_system7_0_M_AXI_GP0_WSTRB;\n  wire processing_system7_0_M_AXI_GP0_WVALID;\n  wire [8:0] processing_system7_0_axi_periph_M00_AXI_ARADDR;\n  wire processing_system7_0_axi_periph_M00_AXI_ARREADY;\n  wire processing_system7_0_axi_periph_M00_AXI_ARVALID;\n  wire [8:0] processing_system7_0_axi_periph_M00_AXI_AWADDR;\n  wire processing_system7_0_axi_periph_M00_AXI_AWREADY;\n  wire processing_system7_0_axi_periph_M00_AXI_AWVALID;\n  wire processing_system7_0_axi_periph_M00_AXI_BREADY;\n  wire [1:0] processing_system7_0_axi_periph_M00_AXI_BRESP;\n  wire processing_system7_0_axi_periph_M00_AXI_BVALID;\n  wire [31:0] processing_system7_0_axi_periph_M00_AXI_RDATA;\n  wire processing_system7_0_axi_periph_M00_AXI_RREADY;\n  wire [1:0] processing_system7_0_axi_periph_M00_AXI_RRESP;\n  wire processing_system7_0_axi_periph_M00_AXI_RVALID;\n  wire [31:0] processing_system7_0_axi_periph_M00_AXI_WDATA;\n  wire processing_system7_0_axi_periph_M00_AXI_WREADY;\n  wire [3:0] processing_system7_0_axi_periph_M00_AXI_WSTRB;\n  wire processing_system7_0_axi_periph_M00_AXI_WVALID;\n  wire [0:0] rst_processing_system7_0_100M_interconnect_aresetn;\n  wire [0:0] rst_processing_system7_0_100M_peripheral_aresetn;\n\n  assign LEDs_8Bits_tri_o[7:0] = axi_gpio_0_GPIO_TRI_O;\n  GND GND\n       (.G(GND_1));\n  VCC VCC\n       (.P(VCC_1));\n  design_gpio_led_axi_gpio_0_0 axi_gpio_0\n       (.gpio_io_o(axi_gpio_0_GPIO_TRI_O),\n        .s_axi_aclk(processing_system7_0_FCLK_CLK0),\n        .s_axi_araddr(processing_system7_0_axi_periph_M00_AXI_ARADDR),\n        .s_axi_aresetn(rst_processing_system7_0_100M_peripheral_aresetn),\n        .s_axi_arready(processing_system7_0_axi_periph_M00_AXI_ARREADY),\n        .s_axi_arvalid(processing_system7_0_axi_periph_M00_AXI_ARVALID),\n        .s_axi_awaddr(processing_system7_0_axi_periph_M00_AXI_AWADDR),\n        .s_axi_awready(processing_system7_0_axi_periph_M00_AXI_AWREADY),\n        .s_axi_awvalid(processing_system7_0_axi_periph_M00_AXI_AWVALID),\n        .s_axi_bready(processing_system7_0_axi_periph_M00_AXI_BREADY),\n        .s_axi_bresp(processing_system7_0_axi_periph_M00_AXI_BRESP),\n        .s_axi_bvalid(processing_system7_0_axi_periph_M00_AXI_BVALID),\n        .s_axi_rdata(processing_system7_0_axi_periph_M00_AXI_RDATA),\n        .s_axi_rready(processing_system7_0_axi_periph_M00_AXI_RREADY),\n        .s_axi_rresp(processing_system7_0_axi_periph_M00_AXI_RRESP),\n        .s_axi_rvalid(processing_system7_0_axi_periph_M00_AXI_RVALID),\n        .s_axi_wdata(processing_system7_0_axi_periph_M00_AXI_WDATA),\n        .s_axi_wready(processing_system7_0_axi_periph_M00_AXI_WREADY),\n        .s_axi_wstrb(processing_system7_0_axi_periph_M00_AXI_WSTRB),\n        .s_axi_wvalid(processing_system7_0_axi_periph_M00_AXI_WVALID));\n  design_gpio_led_processing_system7_0_0 processing_system7_0\n       (.DDR_Addr(DDR_addr[14:0]),\n        .DDR_BankAddr(DDR_ba[2:0]),\n        .DDR_CAS_n(DDR_cas_n),\n        .DDR_CKE(DDR_cke),\n        .DDR_CS_n(DDR_cs_n),\n        .DDR_Clk(DDR_ck_p),\n        .DDR_Clk_n(DDR_ck_n),\n        .DDR_DM(DDR_dm[3:0]),\n        .DDR_DQ(DDR_dq[31:0]),\n        .DDR_DQS(DDR_dqs_p[3:0]),\n        .DDR_DQS_n(DDR_dqs_n[3:0]),\n        .DDR_DRSTB(DDR_reset_n),\n        .DDR_ODT(DDR_odt),\n        .DDR_RAS_n(DDR_ras_n),\n        .DDR_VRN(FIXED_IO_ddr_vrn),\n        .DDR_VRP(FIXED_IO_ddr_vrp),\n        .DDR_WEB(DDR_we_n),\n        .FCLK_CLK0(processing_system7_0_FCLK_CLK0),\n        .FCLK_RESET0_N(processing_system7_0_FCLK_RESET0_N),\n        .MIO(FIXED_IO_mio[53:0]),\n        .M_AXI_GP0_ACLK(processing_system7_0_FCLK_CLK0),\n        .M_AXI_GP0_ARADDR(processing_system7_0_M_AXI_GP0_ARADDR),\n        .M_AXI_GP0_ARBURST(processing_system7_0_M_AXI_GP0_ARBURST),\n        .M_AXI_GP0_ARCACHE(processing_system7_0_M_AXI_GP0_ARCACHE),\n        .M_AXI_GP0_ARID(processing_system7_0_M_AXI_GP0_ARID),\n        .M_AXI_GP0_ARLEN(processing_system7_0_M_AXI_GP0_ARLEN),\n        .M_AXI_GP0_ARLOCK(processing_system7_0_M_AXI_GP0_ARLOCK),\n        .M_AXI_GP0_ARPROT(processing_system7_0_M_AXI_GP0_ARPROT),\n        .M_AXI_GP0_ARQOS(processing_system7_0_M_AXI_GP0_ARQOS),\n        .M_AXI_GP0_ARREADY(processing_system7_0_M_AXI_GP0_ARREADY),\n        .M_AXI_GP0_ARSIZE(processing_system7_0_M_AXI_GP0_ARSIZE),\n        .M_AXI_GP0_ARVALID(processing_system7_0_M_AXI_GP0_ARVALID),\n        .M_AXI_GP0_AWADDR(processing_system7_0_M_AXI_GP0_AWADDR),\n        .M_AXI_GP0_AWBURST(processing_system7_0_M_AXI_GP0_AWBURST),\n        .M_AXI_GP0_AWCACHE(processing_system7_0_M_AXI_GP0_AWCACHE),\n        .M_AXI_GP0_AWID(processing_system7_0_M_AXI_GP0_AWID),\n        .M_AXI_GP0_AWLEN(processing_system7_0_M_AXI_GP0_AWLEN),\n        .M_AXI_GP0_AWLOCK(processing_system7_0_M_AXI_GP0_AWLOCK),\n        .M_AXI_GP0_AWPROT(processing_system7_0_M_AXI_GP0_AWPROT),\n        .M_AXI_GP0_AWQOS(processing_system7_0_M_AXI_GP0_AWQOS),\n        .M_AXI_GP0_AWREADY(processing_system7_0_M_AXI_GP0_AWREADY),\n        .M_AXI_GP0_AWSIZE(processing_system7_0_M_AXI_GP0_AWSIZE),\n        .M_AXI_GP0_AWVALID(processing_system7_0_M_AXI_GP0_AWVALID),\n        .M_AXI_GP0_BID(processing_system7_0_M_AXI_GP0_BID),\n        .M_AXI_GP0_BREADY(processing_system7_0_M_AXI_GP0_BREADY),\n        .M_AXI_GP0_BRESP(processing_system7_0_M_AXI_GP0_BRESP),\n        .M_AXI_GP0_BVALID(processing_system7_0_M_AXI_GP0_BVALID),\n        .M_AXI_GP0_RDATA(processing_system7_0_M_AXI_GP0_RDATA),\n        .M_AXI_GP0_RID(processing_system7_0_M_AXI_GP0_RID),\n        .M_AXI_GP0_RLAST(processing_system7_0_M_AXI_GP0_RLAST),\n        .M_AXI_GP0_RREADY(processing_system7_0_M_AXI_GP0_RREADY),\n        .M_AXI_GP0_RRESP(processing_system7_0_M_AXI_GP0_RRESP),\n        .M_AXI_GP0_RVALID(processing_system7_0_M_AXI_GP0_RVALID),\n        .M_AXI_GP0_WDATA(processing_system7_0_M_AXI_GP0_WDATA),\n        .M_AXI_GP0_WID(processing_system7_0_M_AXI_GP0_WID),\n        .M_AXI_GP0_WLAST(processing_system7_0_M_AXI_GP0_WLAST),\n        .M_AXI_GP0_WREADY(processing_system7_0_M_AXI_GP0_WREADY),\n        .M_AXI_GP0_WSTRB(processing_system7_0_M_AXI_GP0_WSTRB),\n        .M_AXI_GP0_WVALID(processing_system7_0_M_AXI_GP0_WVALID),\n        .PS_CLK(FIXED_IO_ps_clk),\n        .PS_PORB(FIXED_IO_ps_porb),\n        .PS_SRSTB(FIXED_IO_ps_srstb),\n        .USB0_VBUS_PWRFAULT(GND_1));\n  design_gpio_led_processing_system7_0_axi_periph_1 processing_system7_0_axi_periph\n       (.ACLK(processing_system7_0_FCLK_CLK0),\n        .ARESETN(rst_processing_system7_0_100M_interconnect_aresetn),\n        .M00_ACLK(processing_system7_0_FCLK_CLK0),\n        .M00_ARESETN(rst_processing_system7_0_100M_peripheral_aresetn),\n        .M00_AXI_araddr(processing_system7_0_axi_periph_M00_AXI_ARADDR),\n        .M00_AXI_arready(processing_system7_0_axi_periph_M00_AXI_ARREADY),\n        .M00_AXI_arvalid(processing_system7_0_axi_periph_M00_AXI_ARVALID),\n        .M00_AXI_awaddr(processing_system7_0_axi_periph_M00_AXI_AWADDR),\n        .M00_AXI_awready(processing_system7_0_axi_periph_M00_AXI_AWREADY),\n        .M00_AXI_awvalid(processing_system7_0_axi_periph_M00_AXI_AWVALID),\n        .M00_AXI_bready(processing_system7_0_axi_periph_M00_AXI_BREADY),\n        .M00_AXI_bresp(processing_system7_0_axi_periph_M00_AXI_BRESP),\n        .M00_AXI_bvalid(processing_system7_0_axi_periph_M00_AXI_BVALID),\n        .M00_AXI_rdata(processing_system7_0_axi_periph_M00_AXI_RDATA),\n        .M00_AXI_rready(processing_system7_0_axi_periph_M00_AXI_RREADY),\n        .M00_AXI_rresp(processing_system7_0_axi_periph_M00_AXI_RRESP),\n        .M00_AXI_rvalid(processing_system7_0_axi_periph_M00_AXI_RVALID),\n        .M00_AXI_wdata(processing_system7_0_axi_periph_M00_AXI_WDATA),\n        .M00_AXI_wready(processing_system7_0_axi_periph_M00_AXI_WREADY),\n        .M00_AXI_wstrb(processing_system7_0_axi_periph_M00_AXI_WSTRB),\n        .M00_AXI_wvalid(processing_system7_0_axi_periph_M00_AXI_WVALID));\n  design_gpio_led_rst_processing_system7_0_100M_1 rst_processing_system7_0_100M\n       (.aux_reset_in(VCC_1),\n        .dcm_locked(VCC_1),\n        .ext_reset_in(processing_system7_0_FCLK_RESET0_N),\n        .interconnect_aresetn(rst_processing_system7_0_100M_interconnect_aresetn),\n        .mb_debug_sys_rst(GND_1),\n        .peripheral_aresetn(rst_processing_system7_0_100M_peripheral_aresetn),\n        .slowest_sync_clk(processing_system7_0_FCLK_CLK0));\nendmodule"}
{"task_id": 1141, "completion": "wire [D-1:0] ddly_m; wire [D-1:0] ddly_s; wire [D-1:0] busys; wire [D-1:0] busym; wire [D-1:0] rx_data_in; wire [D-1:0] rx_data_in_fix; wire [D-1:0] cascade; wire [D-1:0] pd_edge; reg [8:0] counter; reg [3:0] state; reg cal_data_sint; wire [D-1:0] busy_data; reg busy_data_d; wire cal_data_slave; reg enable; reg cal_data_master; reg rst_data; reg inc_data_int; wire inc_data; reg [D-1:0] ce_data; reg valid_data_d; reg incdec_data_d; wire [(8*D)-1:0] mdataout; reg [4:0] pdcounter; wire [D-1:0] valid_data; wire [D-1:0] incdec_data; reg [D-1:0] mux; reg ce_data_inta; reg flag; wire [D:0] incdec_data_or; wire [D-1:0] incdec_data_im; wire [D:0] valid_data_or; wire [D-1:0] valid_data_im; wire [D:0] busy_data_or; wire [D-1:0] all_ce; parameter SIM_TAP_DELAY = 49; parameter [D-1:0] RX_SWAP_MASK = 16'h0000; assign cal_data_slave = cal_data_sint; assign debug = {mux, cal_data_master, rst_data, cal_data_slave, busy_data_d, inc_data, ce_data, valid_data_d, incdec_data_d}; genvar i; genvar j; always @ (posedge gclk or posedge reset) begin if (reset == 1'b1) begin state <= 0; cal_data_master <= 1'b0; cal_data_sint <= 1'b0; counter <= 9'b000000000; enable <= 1'b0; mux <= 16'h0001; end else begin counter <= counter + 9'b000000001; if (counter[8] == 1'b1) begin counter <= 9'b000000000; end if (counter[5] == 1'b1) begin enable <= 1'b1; end if (state == 0 && enable == 1'b1) begin cal_data_master <= 1'b0; cal_data_sint <= 1'b0; rst_data <= 1'b0; if (busy_data_d == 1'b0) begin state <= 1; end end else if (state == 1) begin cal_data_master <= 1'b1; cal_data_sint <= 1'b1; if (busy_data_d == 1'b1) begin state <= 2; end end else if (state == 2) begin cal_data_master <= 1'b0; cal_data_sint <= 1'b0; if (busy_data_d == 1'b0) begin rst_data <= 1'b1; state <= 3; end end else if (state == 3) begin rst_data <= 1'b0; if (busy_data_d == 1'b0) begin state <= 4; end end else if (state == 4) begin if (counter[8] == 1'b1) begin state <= 5; end end else if (state == 5) begin if (busy_data_d == 1'b0) begin cal_data_sint <= 1'b1; state <= 6; if (D != 1) begin mux <= {mux[D-2:0], mux[D-1]}; end end end else if (state == 6) begin if (busy_data_d == 1'b1) begin cal_data_sint <= 1'b0; state <= 7; end end else if (state == 7) begin cal_data_sint <= 1'b0; if (busy_data_d == 1'b0) begin state <= 4; end end end end always @ (posedge gclk or posedge reset) begin if (reset == 1'b1) begin pdcounter <= 5'h10; ce_data_inta <= 1'b0; flag <= 1'b0; end else begin busy_data_d <= busy_data_or[D]; if (use_phase_detector == 1'b1 && USE_PD == \"TRUE\") begin incdec_data_d <= incdec_data_or[D]; valid_data_d <= valid_data_or[D]; if (ce_data_inta == 1'b1) begin ce_data = mux; end else begin ce_data = mux ^ mux; end if (state == 7) begin flag <= 1'b0; end else if (state != 4 || busy_data_d == 1'b1) begin pdcounter <= 5'b10000; ce_data_inta <= 1'b0; end else if (pdcounter == 5'b11111 && flag == 1'b0) begin ce_data_inta <= 1'b1; inc_data_int <= 1'b1; pdcounter <= 5'b10000; flag <= 1'b1; end else if (pdcounter == 5'b00000 && flag == 1'b0) begin ce_data_inta <= 1'b1; inc_data_int <= 1'b0; pdcounter <= 5'b10000; flag <= 1'b1; end else if (valid_data_d == 1'b1) begin ce_data_inta <= 1'b0; if (incdec_data_d == 1'b1 && pdcounter != 5'b11111) begin pdcounter <= pdcounter + 5'b00001; end else if (incdec_data_d == 1'b0 && pdcounter != 5'b00000) begin pdcounter <= pdcounter + 5'b11111; end end else begin ce_data_inta <= 1'b0; end end else begin ce_data = all_ce; inc_data_int = debug_in[1]; end end end assign inc_data = inc_data_int; assign incdec_data_or[0] = 1'b0; assign valid_data_or[0] = 1'b0; assign busy_data_or[0] = 1'b0; generate for (i = 0 ; i <= (D-1) ; i = i+1) begin : loop0 assign incdec_data_im[i] = incdec_data[i] & mux[i]; assign incdec_data_or[i+1] = incdec_data_im[i] | incdec_data_or[i]; assign valid_data_im[i] = valid_data[i] & mux[i]; assign valid_data_or[i+1] = valid_data_im[i] | valid_data_or[i]; assign busy_data_or[i+1] = busy_data[i] | busy_data_or[i]; assign all_ce[i] = debug_in[0]; assign rx_data_in_fix[i] = rx_data_in[i] ^ RX_SWAP_MASK[i]; IBUF data_in (.I(datain[i]), .O(rx_data_in[i])); if (USE_PD == \"TRUE\" || S > 4) begin assign busy_data[i] = busys[i]; IODELAY2 #( .DATA_RATE(\"SDR\"), .IDELAY_VALUE(0), .IDELAY2_VALUE(0), .IDELAY_MODE(\"NORMAL\"), .ODELAY_VALUE(0), .IDELAY_TYPE(\"DIFF_PHASE_DETECTOR\"), .COUNTER_WRAPAROUND(\"WRAPAROUND\"), .DELAY_SRC(\"IDATAIN\"), .SERDES_MODE(\"MASTER\"), .SIM_TAPDELAY_VALUE(SIM_TAP_DELAY)) iodelay_m ( .IDATAIN(rx_data_in_fix[i]), .TOUT(), .DOUT(), .T(1'b1), .ODATAIN(1'b0), .DATAOUT(ddly_m[i]), .DATAOUT2(), .IOCLK0(rxioclk), .IOCLK1(1'b0), .CLK(gclk), .CAL(cal_data_master), .INC(inc_data), .CE(ce_data[i]), .RST(rst_data), .BUSY()); IODELAY2 #( .DATA_RATE(\"SDR\"), .IDELAY_VALUE(0), .IDELAY2_VALUE(0), .IDELAY_MODE(\"NORMAL\"), .ODELAY_VALUE(0), .IDELAY_TYPE(\"DIFF_PHASE_DETECTOR\"), .COUNTER_WRAPAROUND(\"WRAPAROUND\"), .DELAY_SRC(\"IDATAIN\"), .SERDES_MODE(\"SLAVE\"), .SIM_TAPDELAY_VALUE(SIM_TAP_DELAY)) iodelay_s ( .IDATAIN(rx_data_in_fix[i]), .TOUT(), .DOUT(), .T(1'b1), .ODATAIN(1'b0), .DATAOUT(ddly_s[i]), .DATAOUT2(), .IOCLK0(rxioclk), .IOCLK1(1'b0), .CLK(gclk), .CAL(cal_data_slave), .INC(inc_data), .CE(ce_data[i]), .RST(rst_data), .BUSY(busys[i])); ISERDES2 #( .DATA_WIDTH(S), .DATA_RATE(\"SDR\"), .BITSLIP_ENABLE(\"TRUE\"), .SERDES_MODE(\"MASTER\"), .INTERFACE_TYPE(\"RETIMED\")) iserdes_m ( .D(ddly_m[i]), .CE0(1'b1), .CLK0(rxioclk), .CLK1(1'b0), .IOCE(rxserdesstrobe), .RST(reset), .CLKDIV(gclk), .SHIFTIN(pd_edge[i]), .BITSLIP(bitslip), .FABRICOUT(), .Q4(mdataout[(8*i)+7]), .Q3(mdataout[(8*i)+6]), .Q2(mdataout[(8*i)+5]), .Q1(mdataout[(8*i)+4]), .DFB(), .CFB0(), .CFB1(), .VALID(valid_data[i]), .INCDEC(incdec_data[i]), .SHIFTOUT(cascade[i])); ISERDES2 #( .DATA_WIDTH(S), .DATA_RATE(\"SDR\"), .BITSLIP_ENABLE(\"TRUE\"), .SERDES_MODE(\"SLAVE\"), .INTERFACE_TYPE(\"RETIMED\")) iserdes_s ( .D(ddly_s[i]), .CE0(1'b1), .CLK0(rxioclk), .CLK1(1'b0), .IOCE(rxserdesstrobe), .RST(reset), .CLKDIV(gclk), .SHIFTIN(cascade[i]), .BITSLIP(bitslip), .FABRICOUT(), .Q4(mdataout[(8*i)+3]), .Q3(mdataout[(8*i)+2]), .Q2(mdataout[(8*i)+1]), .Q1(mdataout[(8*i)+0]), .DFB(), .CFB0(), .CFB1(), .VALID(), .INCDEC(), .SHIFTOUT(pd_edge[i])); end if (USE_PD != \"TRUE\" && S < 5) begin assign busy_data[i] = busym[i]; IODELAY2 #( .DATA_RATE(\"SDR\"), .IDELAY_VALUE(0), .IDELAY2_VALUE(0), .IDELAY_MODE(\"NORMAL\"), .ODELAY_VALUE(0), .IDELAY_TYPE(\"VARIABLE_FROM_HALF_MAX\"), .COUNTER_WRAPAROUND(\"WRAPAROUND\"), .DELAY_SRC(\"IDATAIN\"), .SERDES_MODE(\"MASTER\"), .SIM_TAPDELAY_VALUE(SIM_TAP_DELAY)) iodelay_m ( .IDATAIN(rx_data_in_fix[i]), .TOUT(), .DOUT(), .T(1'b1), .ODATAIN(1'b0), .DATAOUT(ddly_m[i]), .DATAOUT2(), .IOCLK0(rxioclk), .IOCLK1(1'b0), .CLK(gclk), .CAL(cal_data_master), .INC(1'b0), .CE(1'b0), .RST(rst_data), .BUSY(busym[i])); ISERDES2 #( .DATA_WIDTH(S), .DATA_RATE(\"SDR\"), .BITSLIP_ENABLE(\"TRUE\"), .SERDES_MODE(\"MASTER\"), .INTERFACE_TYPE(\"RETIMED\")) iserdes_m ( .D(ddly_m[i]), .CE0(1'b1), .CLK0(rxioclk), .CLK1(1'b0), .IOCE(rxserdesstrobe), .RST(reset), .CLKDIV(gclk), .SHIFTIN(1'b0), .BITSLIP(bitslip), .FABRICOUT(), .Q4(mdataout[(8*i)+7]), .Q3(mdataout[(8*i)+6]), .Q2(mdataout[(8*i)+5]), .Q1(mdataout[(8*i)+4]), .DFB(), .CFB0(), .CFB1(), .VALID(), .INCDEC(), .SHIFTOUT()); end for (j = 7 ; j >= (8-S) ; j = j-1) begin : loop2 assign data_out[((D*(j+S-8))+i)] = mdataout[(8*i)+j]; end end endgenerate endmodule"}
{"task_id": 1229, "completion": "wire             clk_en; wire    [  7: 0] data_in; wire    [  7: 0] read_mux_out; reg     [ 31: 0] readdata;  assign clk_en = 1;  assign read_mux_out = {8 {(address == 0)}} & data_in;  always @(posedge clk or negedge reset_n) begin if (reset_n == 0) readdata <= 0; else if (clk_en) readdata <= {32'b0 | read_mux_out}; end  assign data_in = in_port; endmodule"}
{"task_id": 1201, "completion": "parameter ADDR_MUX_START = 28;\n\n    always @ *\n    begin\n\n       out0_addr_o = 32'h00000000;\n       out0_data_o = 32'h00000000;\n       out0_sel_o = 4'b0000;\n       out0_we_o = 1'b0;\n       out0_stb_o = 1'b0;\n       out0_cyc_o = 1'b0;\n       out0_cti_o = 3'b0;\n       out1_addr_o = 32'h00000000;\n       out1_data_o = 32'h00000000;\n       out1_sel_o = 4'b0000;\n       out1_we_o = 1'b0;\n       out1_stb_o = 1'b0;\n       out1_cyc_o = 1'b0;\n       out1_cti_o = 3'b0;\n       out2_addr_o = 32'h00000000;\n       out2_data_o = 32'h00000000;\n       out2_sel_o = 4'b0000;\n       out2_we_o = 1'b0;\n       out2_stb_o = 1'b0;\n       out2_cyc_o = 1'b0;\n       out2_cti_o = 3'b0;\n\n       case (mem_addr_i[ADDR_MUX_START+2-1:ADDR_MUX_START])\n\n       2'd0:\n       begin\n           out0_addr_o = mem_addr_i;\n           out0_data_o = mem_data_i;\n           out0_sel_o = mem_sel_i;\n           out0_we_o = mem_we_i;\n           out0_stb_o = mem_stb_i;\n           out0_cyc_o = mem_cyc_i;\n           out0_cti_o = mem_cti_i;\n       end\n       2'd1:\n       begin\n           out1_addr_o = mem_addr_i;\n           out1_data_o = mem_data_i;\n           out1_sel_o = mem_sel_i;\n           out1_we_o = mem_we_i;\n           out1_stb_o = mem_stb_i;\n           out1_cyc_o = mem_cyc_i;\n           out1_cti_o = mem_cti_i;\n       end\n       2'd2:\n       begin\n           out2_addr_o = mem_addr_i;\n           out2_data_o = mem_data_i;\n           out2_sel_o = mem_sel_i;\n           out2_we_o = mem_we_i;\n           out2_stb_o = mem_stb_i;\n           out2_cyc_o = mem_cyc_i;\n           out2_cti_o = mem_cti_i;\n       end\n\n       default :\n          ;      \n       endcase\n    end\n\n    always @ *\n    begin\n       case (mem_addr_i[ADDR_MUX_START+2-1:ADDR_MUX_START])\n\n        2'd0:\n        begin\n           mem_data_o = out0_data_i;\n           mem_stall_o = out0_stall_i;\n           mem_ack_o = out0_ack_i;\n        end\n        2'd1:\n        begin\n           mem_data_o = out1_data_i;\n           mem_stall_o = out1_stall_i;\n           mem_ack_o = out1_ack_i;\n        end\n        2'd2:\n        begin\n           mem_data_o = out2_data_i;\n           mem_stall_o = out2_stall_i;\n           mem_ack_o = out2_ack_i;\n        end\n\n       default :\n       begin\n           mem_data_o = 32'h00000000;\n           mem_stall_o = 1'b0;\n           mem_ack_o = 1'b0;\n       end\n       endcase\n    end\n\nendmodule"}
{"task_id": 1231, "completion": "xlslice #(\n    .DIN_WIDTH(32),\n    .DIN_FROM(29),\n    .DIN_TO(6)\n  ) inst (\n    .Din(Din),\n    .Dout(Dout)\n  );\nendmodule"}
{"task_id": 1204, "completion": "BLK_MEM_GEN_V7_3 #(\n    .C_ADDRA_WIDTH(10),\n    .C_ADDRB_WIDTH(10),\n    .C_ALGORITHM(1),\n    .C_AXI_ID_WIDTH(4),\n    .C_AXI_SLAVE_TYPE(0),\n    .C_AXI_TYPE(1),\n    .C_BYTE_SIZE(9),\n    .C_COMMON_CLK(0),\n    .C_DEFAULT_DATA(\"0\"),\n    .C_DISABLE_WARN_BHV_COLL(0),\n    .C_DISABLE_WARN_BHV_RANGE(0),\n    .C_ENABLE_32BIT_ADDRESS(0),\n    .C_FAMILY(\"kintex7\"),\n    .C_HAS_AXI_ID(0),\n    .C_HAS_ENA(0),\n    .C_HAS_ENB(0),\n    .C_HAS_INJECTERR(0),\n    .C_HAS_MEM_OUTPUT_REGS_A(0),\n    .C_HAS_MEM_OUTPUT_REGS_B(0),\n    .C_HAS_MUX_OUTPUT_REGS_A(0),\n    .C_HAS_MUX_OUTPUT_REGS_B(0),\n    .C_HAS_REGCEA(0),\n    .C_HAS_REGCEB(0),\n    .C_HAS_RSTA(0),\n    .C_HAS_RSTB(0),\n    .C_HAS_SOFTECC_INPUT_REGS_A(0),\n    .C_HAS_SOFTECC_OUTPUT_REGS_B(0),\n    .C_INIT_FILE(\"BlankString\"),\n    .C_INIT_FILE_NAME(\"no_coe_file_loaded\"),\n    .C_INITA_VAL(\"0\"),\n    .C_INITB_VAL(\"0\"),\n    .C_INTERFACE_TYPE(0),\n    .C_LOAD_INIT_FILE(0),\n    .C_MEM_TYPE(0),\n    .C_MUX_PIPELINE_STAGES(0),\n    .C_PRIM_TYPE(1),\n    .C_READ_DEPTH_A(1024),\n    .C_READ_DEPTH_B(1024),\n    .C_READ_WIDTH_A(32),\n    .C_READ_WIDTH_B(32),\n    .C_RST_PRIORITY_A(\"CE\"),\n    .C_RST_PRIORITY_B(\"CE\"),\n    .C_RST_TYPE(\"SYNC\"),\n    .C_RSTRAM_A(0),\n    .C_RSTRAM_B(0),\n    .C_SIM_COLLISION_CHECK(\"ALL\"),\n    .C_USE_BRAM_BLOCK(0),\n    .C_USE_BYTE_WEA(0),\n    .C_USE_BYTE_WEB(0),\n    .C_USE_DEFAULT_DATA(0),\n    .C_USE_ECC(0),\n    .C_USE_SOFTECC(0),\n    .C_WEA_WIDTH(1),\n    .C_WEB_WIDTH(1),\n    .C_WRITE_DEPTH_A(1024),\n    .C_WRITE_DEPTH_B(1024),\n    .C_WRITE_MODE_A(\"WRITE_FIRST\"),\n    .C_WRITE_MODE_B(\"WRITE_FIRST\"),\n    .C_WRITE_WIDTH_A(32),\n    .C_WRITE_WIDTH_B(32),\n    .C_XDEVICEFAMILY(\"kintex7\")\n  )\n  inst (\n    .CLKA(clka),\n    .WEA(wea),\n    .ADDRA(addra),\n    .DINA(dina),\n    .DOUTA(douta),\n    .RSTA(),\n    .ENA(),\n    .REGCEA(),\n    .CLKB(),\n    .RSTB(),\n    .ENB(),\n    .REGCEB(),\n    .WEB(),\n    .ADDRB(),\n    .DINB(),\n    .DOUTB(),\n    .INJECTSBITERR(),\n    .INJECTDBITERR(),\n    .SBITERR(),\n    .DBITERR(),\n    .RDADDRECC(),\n    .S_ACLK(),\n    .S_ARESETN(),\n    .S_AXI_AWID(),\n    .S_AXI_AWADDR(),\n    .S_AXI_AWLEN(),\n    .S_AXI_AWSIZE(),\n    .S_AXI_AWBURST(),\n    .S_AXI_AWVALID(),\n    .S_AXI_AWREADY(),\n    .S_AXI_WDATA(),\n    .S_AXI_WSTRB(),\n    .S_AXI_WLAST(),\n    .S_AXI_WVALID(),\n    .S_AXI_WREADY(),\n    .S_AXI_BID(),\n    .S_AXI_BRESP(),\n    .S_AXI_BVALID(),\n    .S_AXI_BREADY(),\n    .S_AXI_ARID(),\n    .S_AXI_ARADDR(),\n    .S_AXI_ARLEN(),\n    .S_AXI_ARSIZE(),\n    .S_AXI_ARBURST(),\n    .S_AXI_ARVALID(),\n    .S_AXI_ARREADY(),\n    .S_AXI_RID(),\n    .S_AXI_RDATA(),\n    .S_AXI_RRESP(),\n    .S_AXI_RLAST(),\n    .S_AXI_RVALID(),\n    .S_AXI_RREADY(),\n    .S_AXI_INJECTSBITERR(),\n    .S_AXI_INJECTDBITERR(),\n    .S_AXI_SBITERR(),\n    .S_AXI_DBITERR(),\n    .S_AXI_RDADDRECC()\n  );\n\nendmodule"}
{"task_id": 1163, "completion": "localparam MODULE_NAME = \"DSP_M_DATA\";\n  localparam in_delay = 0;\n  localparam out_delay = 0;\n  localparam inclk_delay = 0;\n  localparam outclk_delay = 0;\n\n  localparam MREG_0 = 1;\n  localparam MREG_1 = 0;\n\n  reg trig_attr = 1'b0;\n  reg attr_err = 1'b0;\n  tri0 glblGSR = glbl.GSR;\n\n  wire [44:0] U_DATA_out;\n  wire [44:0] V_DATA_out;\n\n  reg [44:0] U_DATA_reg = 45'h100000000000;\n  reg [44:0] V_DATA_reg = 45'h100000000000;\n  wire CLK_mreg;\n\n  assign U_DATA = U_DATA_out;\n  assign V_DATA = V_DATA_out;\n\n  assign U_DATA_out = (MREG_BIN == MREG_1) ? U_DATA_reg : U;\n  assign V_DATA_out = (MREG_BIN == MREG_1) ? V_DATA_reg : V;\n\n  always @(posedge CLK_mreg) begin\n      if (RSTM_in || glblGSR) begin\n          U_DATA_reg <= 45'h100000000000;\n          V_DATA_reg <= 45'h100000000000;\n      end else if (CEM_in) begin\n          U_DATA_reg <= U;\n          V_DATA_reg <= V;\n      end\n  end\n\n  specify\n    (CLK => U_DATA[0]) = (0:0:0, 0:0:0);\n    (CLK => V_DATA[0]) = (0:0:0, 0:0:0);\n    // \u7701\u7565\u5176\u4ed6\u540c\u7c7b\u65f6\u95f4\u7ea6\u675f\n  endspecify\nendmodule"}
{"task_id": 1191, "completion": "axi_register_slice_v2_1_axi_register_slice #(\n    .C_FAMILY(\"zynq\"),\n    .C_AXI_PROTOCOL(1),\n    .C_AXI_ID_WIDTH(1),\n    .C_AXI_ADDR_WIDTH(32),\n    .C_AXI_DATA_WIDTH(64),\n    .C_AXI_SUPPORTS_USER_SIGNALS(0),\n    .C_AXI_AWUSER_WIDTH(1),\n    .C_AXI_ARUSER_WIDTH(1),\n    .C_AXI_WUSER_WIDTH(1),\n    .C_AXI_RUSER_WIDTH(1),\n    .C_AXI_BUSER_WIDTH(1),\n    .C_REG_CONFIG_AW(7),\n    .C_REG_CONFIG_W(1),\n    .C_REG_CONFIG_B(7),\n    .C_REG_CONFIG_AR(7),\n    .C_REG_CONFIG_R(1)\n  ) inst (\n    .aclk(aclk),\n    .aresetn(aresetn),\n    .s_axi_awid(s_axi_awid),\n    .s_axi_awaddr(s_axi_awaddr),\n    .s_axi_awlen(s_axi_awlen),\n    .s_axi_awsize(s_axi_awsize),\n    .s_axi_awburst(s_axi_awburst),\n    .s_axi_awlock(s_axi_awlock),\n    .s_axi_awcache(s_axi_awcache),\n    .s_axi_awprot(s_axi_awprot),\n    .s_axi_awregion(4'H0),\n    .s_axi_awqos(s_axi_awqos),\n    .s_axi_awuser(1'H0),\n    .s_axi_awvalid(s_axi_awvalid),\n    .s_axi_awready(s_axi_awready),\n    .s_axi_wid(s_axi_wid),\n    .s_axi_wdata(s_axi_wdata),\n    .s_axi_wstrb(s_axi_wstrb),\n    .s_axi_wlast(s_axi_wlast),\n    .s_axi_wuser(1'H0),\n    .s_axi_wvalid(s_axi_wvalid),\n    .s_axi_wready(s_axi_wready),\n    .s_axi_bid(s_axi_bid),\n    .s_axi_bresp(s_axi_bresp),\n    .s_axi_buser(),\n    .s_axi_bvalid(s_axi_bvalid),\n    .s_axi_bready(s_axi_bready),\n    .s_axi_arid(s_axi_arid),\n    .s_axi_araddr(s_axi_araddr),\n    .s_axi_arlen(s_axi_arlen),\n    .s_axi_arsize(s_axi_arsize),\n    .s_axi_arburst(s_axi_arburst),\n    .s_axi_arlock(s_axi_arlock),\n    .s_axi_arcache(s_axi_arcache),\n    .s_axi_arprot(s_axi_arprot),\n    .s_axi_arregion(4'H0),\n    .s_axi_arqos(s_axi_arqos),\n    .s_axi_aruser(1'H0),\n    .s_axi_arvalid(s_axi_arvalid),\n    .s_axi_arready(s_axi_arready),\n    .s_axi_rid(s_axi_rid),\n    .s_axi_rdata(s_axi_rdata),\n    .s_axi_rresp(s_axi_rresp),\n    .s_axi_rlast(s_axi_rlast),\n    .s_axi_ruser(),\n    .s_axi_rvalid(s_axi_rvalid),\n    .s_axi_rready(s_axi_rready),\n    .m_axi_awid(m_axi_awid),\n    .m_axi_awaddr(m_axi_awaddr),\n    .m_axi_awlen(m_axi_awlen),\n    .m_axi_awsize(m_axi_awsize),\n    .m_axi_awburst(m_axi_awburst),\n    .m_axi_awlock(m_axi_awlock),\n    .m_axi_awcache(m_axi_awcache),\n    .m_axi_awprot(m_axi_awprot),\n    .m_axi_awregion(),\n    .m_axi_awqos(m_axi_awqos),\n    .m_axi_awuser(),\n    .m_axi_awvalid(m_axi_awvalid),\n    .m_axi_awready(m_axi_awready),\n    .m_axi_wid(m_axi_wid),\n    .m_axi_wdata(m_axi_wdata),\n    .m_axi_wstrb(m_axi_wstrb),\n    .m_axi_wlast(m_axi_wlast),\n    .m_axi_wuser(),\n    .m_axi_wvalid(m_axi_wvalid),\n    .m_axi_wready(m_axi_wready),\n    .m_axi_bid(m_axi_bid),\n    .m_axi_bresp(m_axi_bresp),\n    .m_axi_buser(1'H0),\n    .m_axi_bvalid(m_axi_bvalid),\n    .m_axi_bready(m_axi_bready),\n    .m_axi_arid(m_axi_arid),\n    .m_axi_araddr(m_axi_araddr),\n    .m_axi_arlen(m_axi_arlen),\n    .m_axi_arsize(m_axi_arsize),\n    .m_axi_arburst(m_axi_arburst),\n    .m_axi_arlock(m_axi_arlock),\n    .m_axi_arcache(m_axi_arcache),\n    .m_axi_arprot(m_axi_arprot),\n    .m_axi_arregion(),\n    .m_axi_arqos(m_axi_arqos),\n    .m_axi_aruser(),\n    .m_axi_arvalid(m_axi_arvalid),\n    .m_axi_arready(m_axi_arready),\n    .m_axi_rid(m_axi_rid),\n    .m_axi_rdata(m_axi_rdata),\n    .m_axi_rresp(m_axi_rresp),\n    .m_axi_rlast(m_axi_rlast),\n    .m_axi_ruser(1'H0),\n    .m_axi_rvalid(m_axi_rvalid),\n    .m_axi_rready(m_axi_rready)\n  );\nendmodule"}
{"task_id": 1225, "completion": "parameter width = 32;\n   parameter depth = 2;\n   parameter reset_type = `RESET_TYPE_ASYNC;\n   input clk;\n   input reset;\n   input active;\n   input [0:width-1] data_in;\n   output [0:width-1] data_out;\n   wire [0:width-1] data_out;\n   genvar level;\n   wire [0:(depth+1)*width-1] data;\n   assign data[0:width-1] = data_in;\n   generate\n      for(level = 0; level < depth; level = level + 1)\n      begin:levels\n         wire [0:width-1] data_s, data_q;\n         assign data_s = data[level*width:(level+1)*width-1];\n         c_dff\n           #(.width(width),\n             .reset_type(reset_type))\n         dataq\n           (.clk(clk),\n            .reset(reset),\n            .active(active),\n            .d(data_s),\n            .q(data_q));\n         assign data[(level+1)*width:(level+2)*width-1] = data_q;\n      end\n   endgenerate\n   assign data_out = data[depth*width:(depth+1)*width-1];\nendmodule"}
{"task_id": 1227, "completion": "HS65_LS_AND2X4 I0 (o, i0, i1);\n    HS65_LS_AND3X4 I0 (o, i0, i1, i2);\n    HS65_LS_OR2X4 I0 (o, i0, i1);\n    HS65_LS_OR3X4 I0 (o, i0, i1, i2);\n    HS65_LS_NAND2X2 I0 (o, i0, i1);\n    HS65_LS_NAND3X2 I0 (o, i0, i1, i2);\n    HS65_LS_NOR2X2 I0 (o, i0, i1);\n    HS65_LS_NOR3X1 I0 (o, i0, i1, i2);\n    HS65_LS_PAO2X4 I0 (o, i0, i1, o);\n    HS65_LS_PAO3X4 I0 (o, i0, i1, i2, o);\n    // tkg_FIXME\n    HS65_LS_AO22X1 I0 (o, s0, u0, s0, o);\n    HS65_LS_AO22X1 I0 (o, i0, i1, i2, i3);\n    HS65_LS_AO222X2 I0 (o, i0, i1, i2, i3, i4, i5);\n    // tkg_FIXME\n    HS65_LS_GND I0 (o);\n    HS65_LS_IVX2 I0 (o, i);\n    HS65_LS_BFX2 I0 (o, i);\n    // tkg_FIXME\n    MUTEX I0 (ar, br, ag, bg);\n    endmodule"}
{"task_id": 1239, "completion": "DCM #(  .SIM_MODE(\"SAFE\"),  .CLKDV_DIVIDE(2.0),  .CLKFX_DIVIDE(7),  .CLKFX_MULTIPLY(25),  .CLKIN_DIVIDE_BY_2(\"FALSE\"),  .CLKIN_PERIOD(41.667),  .CLKOUT_PHASE_SHIFT(\"NONE\"),  .CLK_FEEDBACK(\"NONE\"),  .DESKEW_ADJUST(\"SYSTEM_SYNCHRONOUS\"),  .DFS_FREQUENCY_MODE(\"LOW\"),  .DLL_FREQUENCY_MODE(\"LOW\"),  .DUTY_CYCLE_CORRECTION(\"TRUE\"),  .FACTORY_JF(16'hFFFF),  .PHASE_SHIFT(0),  .STARTUP_WAIT(\"TRUE\")  ) DCM_inst (    .CLK0(CLK0),    .CLK180(CLK180),    .CLK270(CLK270),    .CLK2X(CLK2X),    .CLK2X180(CLK2X180),    .CLK90(CLK90),    .CLKDV(CLKDV),    .CLKFX(CLKFX),    .CLKFX180(CLKFX180),    .LOCKED(LOCKED),    .PSDONE(PSDONE),    .STATUS(STATUS),    .CLKFB(CLKFB),    .CLKIN(CLKIN),    .PSCLK(PSCLK),    .PSEN(PSEN),    .PSINCDEC(PSINCDEC),    .RST(RST)  );endmodule"}
{"task_id": 1210, "completion": "`include \"functions.vh\"\n\n    wire wGateRen;\n    wire wGateEmpty;\n    wire [C_DATA_WIDTH:0] wGateData;\n\n    wire wBufWen;\n    wire [C_FIFO_DEPTH_WIDTH-1:0] wBufCount;\n    wire [C_DATA_WIDTH-1:0] wBufData;\n\n    wire wTxn;\n    wire wTxnAck;\n    wire wTxnLast;\n    wire [31:0] wTxnLen;\n    wire [30:0] wTxnOff;\n    wire [31:0] wTxnWordsRecvd;\n    wire wTxnDone;\n    wire wTxnErr;\n\n    wire wSgElemRen;\n    wire wSgElemRdy;\n    wire wSgElemEmpty;\n    wire [31:0] wSgElemLen;\n    wire [63:0] wSgElemAddr;\n\n    reg [4:0] rWideRst=0;\n    reg rRst=0;\n\n    always @ (posedge CLK) begin\n        rRst <= #1 rWideRst[4]; \n        if (RST) \n            rWideRst <= #1 5'b11111;\n        else \n            rWideRst <= (rWideRst<<1);\n    end\n\n    tx_port_channel_gate_32 #(.C_DATA_WIDTH(C_DATA_WIDTH)) gate (\n        .RST(rRst),\n        .RD_CLK(CLK),\n        .RD_DATA(wGateData),\n        .RD_EMPTY(wGateEmpty),\n        .RD_EN(wGateRen),\n        .CHNL_CLK(CHNL_CLK),\n        .CHNL_TX(CHNL_TX),\n        .CHNL_TX_ACK(CHNL_TX_ACK),\n        .CHNL_TX_LAST(CHNL_TX_LAST),\n        .CHNL_TX_LEN(CHNL_TX_LEN),\n        .CHNL_TX_OFF(CHNL_TX_OFF),\n        .CHNL_TX_DATA(CHNL_TX_DATA),\n        .CHNL_TX_DATA_VALID(CHNL_TX_DATA_VALID),\n        .CHNL_TX_DATA_REN(CHNL_TX_DATA_REN)\n    );\n\n    tx_port_monitor_32 #(.C_DATA_WIDTH(C_DATA_WIDTH), .C_FIFO_DEPTH(C_FIFO_DEPTH)) monitor (\n        .RST(rRst),\n        .CLK(CLK),\n        .EVT_DATA(wGateData),\n        .EVT_DATA_EMPTY(wGateEmpty),\n        .EVT_DATA_RD_EN(wGateRen),\n        .WR_DATA(wBufData),\n        .WR_EN(wBufWen),\n        .WR_COUNT(wBufCount),\n        .TXN(wTxn),\n        .ACK(wTxnAck),\n        .LAST(wTxnLast),\n        .LEN(wTxnLen),\n        .OFF(wTxnOff),\n        .WORDS_RECVD(wTxnWordsRecvd),\n        .DONE(wTxnDone),\n        .TX_ERR(SG_ERR)\n    );\n\n    tx_port_buffer_32 #(.C_FIFO_DATA_WIDTH(C_DATA_WIDTH), .C_FIFO_DEPTH(C_FIFO_DEPTH)) buffer (\n        .CLK(CLK),\n        .RST(rRst | (TXN_DONE & wTxnErr)),\n        .RD_DATA(TX_DATA),\n        .RD_EN(TX_DATA_REN),\n        .WR_DATA(wBufData),\n        .WR_EN(wBufWen),\n        .WR_COUNT(wBufCount)\n    );\n\n    sg_list_reader_32 #(.C_DATA_WIDTH(C_DATA_WIDTH)) sgListReader (\n        .CLK(CLK),\n        .RST(rRst | SG_RST),\n        .BUF_DATA(SG_DATA),\n        .BUF_DATA_EMPTY(SG_DATA_EMPTY),\n        .BUF_DATA_REN(SG_DATA_REN),\n        .VALID(wSgElemRdy),\n        .EMPTY(wSgElemEmpty),\n        .REN(wSgElemRen),\n        .ADDR(wSgElemAddr),\n        .LEN(wSgElemLen)\n    );\n\n    tx_port_writer writer (\n        .CLK(CLK),\n        .RST(rRst),\n        .CONFIG_MAX_PAYLOAD_SIZE(CONFIG_MAX_PAYLOAD_SIZE),\n        .TXN(TXN),\n        .TXN_ACK(TXN_ACK),\n        .TXN_LEN(TXN_LEN),\n        .TXN_OFF_LAST(TXN_OFF_LAST),\n        .TXN_DONE_LEN(TXN_DONE_LEN),\n        .TXN_DONE(TXN_DONE),\n        .TXN_ERR(wTxnErr),\n        .TXN_DONE_ACK(TXN_DONE_ACK),\n        .NEW_TXN(wTxn),\n        .NEW_TXN_ACK(wTxnAck),\n        .NEW_TXN_LAST(wTxnLast),\n        .NEW_TXN_LEN(wTxnLen),\n        .NEW_TXN_OFF(wTxnOff),\n        .NEW_TXN_WORDS_RECVD(wTxnWordsRecvd),\n        .NEW_TXN_DONE(wTxnDone),\n        .SG_ELEM_ADDR(wSgElemAddr),\n        .SG_ELEM_LEN(wSgElemLen),\n        .SG_ELEM_RDY(wSgElemRdy),\n        .SG_ELEM_EMPTY(wSgElemEmpty),\n        .SG_ELEM_REN(wSgElemRen),\n        .SG_RST(SG_RST),\n        .SG_ERR(SG_ERR),\n        .TX_REQ(TX_REQ),\n        .TX_REQ_ACK(TX_REQ_ACK),\n        .TX_ADDR(TX_ADDR),\n        .TX_LEN(TX_LEN),\n        .TX_LAST(),\n        .TX_SENT(TX_SENT)\n    );\n\nendmodule"}
{"task_id": 1173, "completion": "localparam TRN_IDLE = 1'b0;\nlocalparam MASTER_NONE = 4'b0000;\nwire [3:0] masterAddrInProg;\nreg [3:0] masterDataInProg;\nreg addrPhMasterHREADY;\nwire addrPhMasterDataPhComplete;\nreg preHTRANS;\nalways @ ( posedge HCLK or negedge HRESETN )\nbegin\n    if ( !HRESETN )\n        masterDataInProg <= MASTER_NONE;\n    else\n        if ( HREADY_S )\n            masterDataInProg <= masterAddrInProg;\nend\nCOREAHBLITE_SLAVEARBITER slave_arbiter\n(\n    .HCLK(HCLK),\n    .HRESETN(HRESETN),\n    .MADDRSEL(MADDRSEL),\n    .ADDRPHEND(HREADY_S),\n    .M0GATEDHMASTLOCK(M0GATEDHMASTLOCK),\n    .M1GATEDHMASTLOCK(M1GATEDHMASTLOCK),\n    .M2GATEDHMASTLOCK(M2GATEDHMASTLOCK),\n    .M3GATEDHMASTLOCK(M3GATEDHMASTLOCK),\n    .MASTERADDRINPROG(masterAddrInProg)\n);\nalways @ ( * )\nbegin\n    casez ( masterAddrInProg )\n        4'b???1:\n        begin\n            HSEL = 1'b1;\n            preHTRANS = M0GATEDHTRANS;\n            HSIZE = M0GATEDHSIZE;\n            HWRITE = M0GATEDHWRITE;\n            HADDR = M0GATEDHADDR;\n            HMASTLOCK = M0GATEDHMASTLOCK;\n            addrPhMasterHREADY = MPREVDATASLAVEREADY[0];\n        end\n        4'b??1?:\n        begin\n            HSEL = 1'b1;\n            preHTRANS = M1GATEDHTRANS;\n            HSIZE = M1GATEDHSIZE;\n            HWRITE = M1GATEDHWRITE;\n            HADDR = M1GATEDHADDR;\n            HMASTLOCK = M1GATEDHMASTLOCK;\n            addrPhMasterHREADY = MPREVDATASLAVEREADY[1];\n        end\n        4'b?1??:\n        begin\n            HSEL = 1'b1;\n            preHTRANS = M2GATEDHTRANS;\n            HSIZE = M2GATEDHSIZE;\n            HWRITE = M2GATEDHWRITE;\n            HADDR = M2GATEDHADDR;\n            HMASTLOCK = M2GATEDHMASTLOCK;\n            addrPhMasterHREADY = MPREVDATASLAVEREADY[1];\n        end\n        4'b1???:\n        begin\n            HSEL = 1'b1;\n            preHTRANS = M3GATEDHTRANS;\n            HSIZE = M3GATEDHSIZE;\n            HWRITE = M3GATEDHWRITE;\n            HADDR = M3GATEDHADDR;\n            HMASTLOCK = M3GATEDHMASTLOCK;\n            addrPhMasterHREADY = MPREVDATASLAVEREADY[1];\n        end\n        default:\n        begin\n            HSEL = 1'b0;\n            preHTRANS = TRN_IDLE;\n            HSIZE = 2'b00;\n            HWRITE = 1'b0;\n            HADDR = 32'h0;\n            HMASTLOCK = 1'b0;\n            addrPhMasterHREADY = 1'b1;\n        end\n    endcase\nend\nassign addrPhMasterDataPhComplete = |(masterAddrInProg & MDATASEL);\nassign HTRANS = preHTRANS && (addrPhMasterHREADY || addrPhMasterDataPhComplete);\nassign HREADY_S = HREADYOUT;\nalways @ ( * )\nbegin\n    casez ( masterDataInProg )\n        4'b???1:\n        begin\n            HWDATA = HWDATA_M0;\n        end\n        4'b??1?:\n        begin\n            HWDATA = HWDATA_M1;\n        end\n        4'b?1??:\n        begin\n            HWDATA = HWDATA_M2;\n        end\n        4'b1???:\n        begin\n            HWDATA = HWDATA_M3;\n        end\n        default:\n        begin\n            HWDATA = 32'h0;\n        end\n    endcase\nend\nalways @ ( * )\nbegin\n    MHRESP = 2'b00;\n    casez ( masterDataInProg )\n        4'b???1:\n        begin\n            MHRESP[0] = HRESP;\n        end\n        4'b??1?:\n        begin\n            MHRESP[1] = HRESP;\n        end\n        4'b?1??:\n        begin\n            MHRESP[2] = HRESP;\n        end\n        4'b1???:\n        begin\n            MHRESP[3] = HRESP;\n        end\n        default:\n        begin\n            MHRESP = 2'b00;\n        end\n    endcase\nend\nalways @ ( * )\nbegin\n    if ( MADDRSEL[0] && !masterAddrInProg[0] )\n        MADDRREADY[0] = 1'b0;\n    else\n    if ( MADDRSEL[0] && masterAddrInProg[0] )\n        MADDRREADY[0] = HREADYOUT;\n    else\n        MADDRREADY[0] = 1'b1;\nend\nalways @ ( * )\nbegin\n    if ( MADDRSEL[1] && !masterAddrInProg[1] )\n        MADDRREADY[1] = 1'b0;\n    else\n    if ( MADDRSEL[1] && masterAddrInProg[1] )\n        MADDRREADY[1] = HREADYOUT;\n    else\n        MADDRREADY[1] = 1'b1;\nend\nalways @ ( * )\nbegin\n    if ( MADDRSEL[2] && !masterAddrInProg[2] )\n        MADDRREADY[2] = 1'b0;\n    else\n    if ( MADDRSEL[2] && masterAddrInProg[2] )\n        MADDRREADY[2] = HREADYOUT;\n    else\n        MADDRREADY[2] = 1'b1;\nend\nalways @ ( * )\nbegin\n    if ( MADDRSEL[3] && !masterAddrInProg[3] )\n        MADDRREADY[3] = 1'b0;\n    else\n    if ( MADDRSEL[3] && masterAddrInProg[3] )\n        MADDRREADY[3] = HREADYOUT;\n    else\n        MADDRREADY[3] = 1'b1;\nend\nalways @ ( * )\nbegin\n    if ( MDATASEL[0] && !masterDataInProg[0] )\n        MDATAREADY[0] = 1'b0;\n    else\n    if ( MDATASEL[0] && masterDataInProg[0] )\n        MDATAREADY[0] = HREADYOUT;\n    else\n        MDATAREADY[0] = 1'b1;\nend\nalways @ ( * )\nbegin\n    if ( MDATASEL[1] && !masterDataInProg[1] )\n        MDATAREADY[1] = 1'b0;\n    else\n    if ( MDATASEL[1] && masterDataInProg[1] )\n        MDATAREADY[1] = HREADYOUT;\n    else\n        MDATAREADY[1] = 1'b1;\nend\nalways @ ( * )\nbegin\n    if ( MDATASEL[2] && !masterDataInProg[2] )\n        MDATAREADY[2] = 1'b0;\n    else\n    if ( MDATASEL[2] && masterDataInProg[2] )\n        MDATAREADY[2] = HREADYOUT;\n    else\n        MDATAREADY[2] = 1'b1;\nend\nalways @ ( * )\nbegin\n    if ( MDATASEL[3] && !masterDataInProg[3] )\n        MDATAREADY[3] = 1'b0;\n    else\n    if ( MDATASEL[3] && masterDataInProg[3] )\n        MDATAREADY[3] = HREADYOUT;\n    else\n        MDATAREADY[3] = 1'b1;\nend\nendmodule"}
{"task_id": 1243, "completion": "xlslice #(\n    .DIN_WIDTH(16),\n    .DIN_FROM(15),\n    .DIN_TO(15)\n  ) inst (\n    .Din(Din),\n    .Dout(Dout)\n  );\nendmodule"}
{"task_id": 738, "completion": "reg [11:0] axi_spi_ctrl_reg;\n    always @ (posedge clk_i, negedge reset_n_i) begin\n        if (!reset_n_i) begin\n            axi_spi_ctrl_reg <= 32'd1;\n        end else if (reg_load_i & (reg_sel_i == 2'b0)) begin\n            axi_spi_ctrl_reg[10:8] <= reg_data_i[10:8];\n            axi_spi_ctrl_reg[3:0] <= reg_data_i[3:0];\n        end\n    end;\n    assign reg_control_o = {21'd0, axi_spi_ctrl_reg};\n    reg [13:0] trans_ctrl_reg;\n    always @ (posedge clk_i, negedge reset_n_i) begin\n        if (!reset_n_i) begin\n            trans_ctrl_reg <= 14'd0;\n        end else if (trans_start_i) begin\n            trans_ctrl_reg <= trans_ctrl_reg & 14'b01_1111_1111_1111;\n        end else if (reg_load_i & (reg_sel_i == 2'b1)) begin\n            trans_ctrl_reg[3:0] <= reg_data_i[3:0];\n            trans_ctrl_reg[6:5] <= reg_data_i[6:5];\n            trans_ctrl_reg[13:13] <= reg_data_i[13:13];\n        end\n    end;\n    assign reg_trans_ctrl_o = {18'd0, trans_ctrl_reg};\n    reg [2:0] status_reg;\n    always @ (posedge clk_i, negedge reset_n_i) begin\n        if (!reset_n_i) begin\n            status_reg <= 0;\n        end else begin\n            status_reg[0] <= spi_busy_i;\n            status_reg[1] <= rx_empty_i;\n            status_reg[2] <= tx_full_i;\n        end\n    end;\n    assign reg_status_o = {29'd0, status_reg};\nendmodule"}
{"task_id": 1171, "completion": "// \u8ba1\u7b97\u4e00\u4e2a\u6b63\u5219\u8868\u8fbe\u5f0f\u5339\u914d\u7a7a\u4e32\u7684\u51fd\u6570\n    function bool match_eps(reg_exp r) {\n        if (r == EmptySet) return false;\n        if (r == EmptyStr) return true;\n        if (r is Char) return false;\n        if (r is App) return match_eps(r.left) && match_eps(r.right);\n        if (r is Union) return match_eps(r.left) || match_eps(r.right);\n        if (r is Star) return true;\n    }\n\n    // \u8ba1\u7b97\u6b63\u5219\u8868\u8fbe\u5f0f\u7684\u5bfc\u6570\n    function reg_exp derive(ascii a, reg_exp r) {\n        if (r == EmptySet) return EmptySet;\n        if (r == EmptyStr) return EmptySet;\n        if (r is Char) return (r.char == a) ? EmptyStr : EmptySet;\n        if (r is App) {\n            // Combine derivatives\n            return Union(derive(a, r.left), concat(derive(a, r.right), match_eps(r.right));\n        }\n        if (r is Union) return Union(derive(a, r.left), derive(a, r.right));\n        if (r is Star) return App(derive(a, r.inner), Star(r.inner));\n    }\n\n    // \u6b63\u5219\u8868\u8fbe\u5f0f\u5339\u914d\u4e3b\u51fd\u6570\n    function bool regex_match(string s, reg_exp r) {\n        // \u5904\u7406\u5177\u4f53\u7684\u5339\u914d\u903b\u8f91\uff0c\u4f7f\u7528\u5df2\u5b9a\u4e49\u7684 match_eps \u548c derive\n    }\n\nendmodule"}
{"task_id": 1200, "completion": "reg TXReg = 1;\n  assign TX = TXReg;\n\n  reg [10:0] dataStore = 1536;\n  reg writing = 0;\n  assign ready = (writing==0);\n\n  reg [13:0] writeClock = 0;\n  reg [3:0] writeBit = 0;\n\n  always @(posedge CLK) begin\n    if(writing==0 && valid==1) begin\n      writing <= 1;\n      dataStore[8:1] <= data;\n      writeClock <= UART_PERIOD;\n      writeBit <= 0;\n      TXReg <= dataStore[0];\n    end else if(writing==1 && writeClock==0 && writeBit==9) begin\n      TXReg <= 1;\n      writing <= 0;\n    end else if(writing==1 && writeClock==0) begin\n      TXReg <= dataStore[writeBit];\n      writeBit <= writeBit+1;\n      writeClock <= UART_PERIOD;\n    end else if(writing==1) begin\n      TXReg <= dataStore[writeBit];\n      writeClock <= writeClock - 1;\n    end else begin\n      TXReg <= 1;\n    end \n  end\n\nendmodule\nmodule RXMOD(  input RX,  input CLK,  output [7:0] data,  output valid);\n  reg RX_1;\n  reg RX_2;\n  always @(posedge CLK) begin\n    RX_1 <= RX;\n    RX_2 <= RX_1;\n  end\n\n  wire RXi;\n  assign RXi = RX_2;\n\n  reg [8:0] dataReg;\n  reg validReg = 0;\n  assign data = dataReg[7:0];\n  assign valid = validReg;\n\n  reg [12:0] readClock = 0;\n  reg [3:0] readBit = 0;\n  reg reading = 0;\n\n  always @ (posedge CLK)\n  begin\n    if(RXi==0 && reading==0) begin\n      reading <= 1;\n      readClock <= UART_PERIOD_TH;\n      readBit <= 0;\n      validReg <= 0;\n    end else if(reading==1 && readClock==0 && readBit==8) begin\n      reading <= 0;\n      dataReg[8] <= RXi;\n      validReg <= 1;\n    end else if(reading==1 && readClock==0) begin\n      dataReg[readBit] <= RXi;\n      readClock <= UART_PERIOD;\n      readBit <= readBit + 1;\n      validReg <= 0;\n    end else if(reading==1 && readClock>0) begin\n      readClock <= readClock - 1;\n      validReg <= 0;\n    end else begin\n      validReg <= 0;\n    end\n  end\nendmodule\nmodule main (input CLK, input RX, output TX,\n  output LED0,\n  output LED1,\n  output LED2,\n  output LED3,\n  output LED4,\n  output PMOD_1,\n  output PMOD_2);\n  assign PMOD_1 = RX;\n  assign PMOD_2 = TX;\n\n  wire [7:0] readData;\n  wire readValid;\n\n  reg [7:0] readDataReg;\n  wire txReady;\n  reg txValid = 0;\n\n  always @(posedge CLK) begin\n    if(readValid) begin\n      readDataReg <= readData;\n      txValid <= 1;\n    end else if(txReady) begin\n      txValid <= 0;\n    end\n  end\n\n  assign LED4 = readValid;\n  assign {LED3, LED2, LED1, LED0} = readDataReg[3:0];\n\n  RXMOD rxmod(.RX(RX), .CLK(CLK), .data(readData), .valid(readValid) );\n  TXMOD txmod(.TX(TX), .CLK(CLK), .data(readDataReg+10), .valid(txValid), .ready(txReady) );\nendmodule"}
{"task_id": 1192, "completion": "wire [0:0] sub_wire2 = 1'h0;\n    wire [4:0] sub_wire3;\n    wire  sub_wire5;\n    wire  sub_wire0 = inclk0;\n    wire [1:0] sub_wire1 = {sub_wire2, sub_wire0};\n    wire [0:0] sub_wire4 = sub_wire3[0:0];\n    wire  c0 = sub_wire4;\n    wire  locked = sub_wire5;\n\n    altpll altpll_component (\n                .areset (areset),\n                .inclk (sub_wire1),\n                .clk (sub_wire3),\n                .locked (sub_wire5),\n                .activeclock (),\n                .clkbad (),\n                .clkena ({6{1'b1}}),\n                .clkloss (),\n                .clkswitch (1'b0),\n                .configupdate (1'b0),\n                .enable0 (),\n                .enable1 (),\n                .extclk (),\n                .extclkena ({4{1'b1}}),\n                .fbin (1'b1),\n                .fbmimicbidir (),\n                .fbout (),\n                .fref (),\n                .icdrclk (),\n                .pfdena (1'b1),\n                .phasecounterselect ({4{1'b1}}),\n                .phasedone (),\n                .phasestep (1'b1),\n                .phaseupdown (1'b1),\n                .pllena (1'b1),\n                .scanaclr (1'b0),\n                .scanclk (1'b0),\n                .scanclkena (1'b1),\n                .scandata (1'b0),\n                .scandataout (),\n                .scandone (),\n                .scanread (1'b0),\n                .scanwrite (1'b0),\n                .sclkout0 (),\n                .sclkout1 (),\n                .vcooverrange (),\n                .vcounderrange ();\n    defparam\n        altpll_component.bandwidth_type = \"AUTO\",\n        altpll_component.clk0_divide_by = 1,\n        altpll_component.clk0_duty_cycle = 50,\n        altpll_component.clk0_multiply_by = 20,\n        altpll_component.clk0_phase_shift = \"0\",\n        altpll_component.compensate_clock = \"CLK0\",\n        altpll_component.inclk0_input_frequency = 20000,\n        altpll_component.intended_device_family = \"Cyclone IV E\",\n        altpll_component.lpm_hint = \"CBX_MODULE_PREFIX=nsclock\",\n        altpll_component.lpm_type = \"altpll\",\n        altpll_component.operation_mode = \"NORMAL\",\n        altpll_component.pll_type = \"AUTO\",\n        altpll_component.port_activeclock = \"PORT_UNUSED\",\n        altpll_component.port_areset = \"PORT_USED\",\n        altpll_component.port_clkbad0 = \"PORT_UNUSED\",\n        altpll_component.port_clkbad1 = \"PORT_UNUSED\",\n        altpll_component.port_clkloss = \"PORT_UNUSED\",\n        altpll_component.port_clkswitch = \"PORT_UNUSED\",\n        altpll_component.port_configupdate = \"PORT_UNUSED\",\n        altpll_component.port_fbin = \"PORT_UNUSED\",\n        altpll_component.port_inclk0 = \"PORT_USED\",\n        altpll_component.port_inclk1 = \"PORT_UNUSED\",\n        altpll_component.port_locked = \"PORT_USED\",\n        altpll_component.port_pfdena = \"PORT_UNUSED\",\n        altpll_component.port_phasecounterselect = \"PORT_UNUSED\",\n        altpll_component.port_phasedone = \"PORT_UNUSED\",\n        altpll_component.port_phasestep = \"PORT_UNUSED\",\n        altpll_component.port_phaseupdown = \"PORT_UNUSED\",\n        altpll_component.port_pllena = \"PORT_UNUSED\",\n        altpll_component.port_scanaclr = \"PORT_UNUSED\",\n        altpll_component.port_scanclk = \"PORT_UNUSED\",\n        altpll_component.port_scanclkena = \"PORT_UNUSED\",\n        altpll_component.port_scandata = \"PORT_UNUSED\",\n        altpll_component.port_scandataout = \"PORT_UNUSED\",\n        altpll_component.port_scandone = \"PORT_UNUSED\",\n        altpll_component.port_scanread = \"PORT_UNUSED\",\n        altpll_component.port_scanwrite = \"PORT_UNUSED\",\n        altpll_component.port_clk0 = \"PORT_USED\",\n        altpll_component.port_clk1 = \"PORT_UNUSED\",\n        altpll_component.port_clk2 = \"PORT_UNUSED\",\n        altpll_component.port_clk3 = \"PORT_UNUSED\",\n        altpll_component.port_clk4 = \"PORT_UNUSED\",\n        altpll_component.port_clk5 = \"PORT_UNUSED\",\n        altpll_component.port_clkena0 = \"PORT_UNUSED\",\n        altpll_component.port_clkena1 = \"PORT_UNUSED\",\n        altpll_component.port_clkena2 = \"PORT_UNUSED\",\n        altpll_component.port_clkena3 = \"PORT_UNUSED\",\n        altpll_component.port_clkena4 = \"PORT_UNUSED\",\n        altpll_component.port_clkena5 = \"PORT_UNUSED\",\n        altpll_component.port_extclk0 = \"PORT_UNUSED\",\n        altpll_component.port_extclk1 = \"PORT_UNUSED\",\n        altpll_component.port_extclk2 = \"PORT_UNUSED\",\n        altpll_component.port_extclk3 = \"PORT_UNUSED\",\n        altpll_component.self_reset_on_loss_lock = \"OFF\",\n        altpll_component.width_clock = 5;\n\nendmodule"}
{"task_id": 1236, "completion": "reg [31:0] mem1[0:127];\nalways @(posedge sys_clk) begin\n\tif(p3_en)\n\t\tmem1[p3_a] <= p3_d;\n\tp1_d <= mem1[p1_a];\nend\n\nreg [31:0] mem2[0:127];\nalways @(posedge sys_clk) begin\n\tif(p3_en)\n\t\tmem2[p3_a] <= p3_d;\n\tp2_d <= mem2[p2_a];\nend\n\nendmodule"}
{"task_id": 1250, "completion": "wire idelay_ctrl_rdy_x0y5;\n   wire idelay_ctrl_rdy_x0y6;\n\n  (* IODELAY_GROUP = IODELAY_GRP *) IDELAYCTRL u_idelayctrl_x0y5\n    (\n     .RDY(idelay_ctrl_rdy_x0y5),\n     .REFCLK(clk200),\n     .RST(rst200)\n     );\n\n  (* IODELAY_GROUP = IODELAY_GRP *) IDELAYCTRL u_idelayctrl_x0y6\n    (\n     .RDY(idelay_ctrl_rdy_x0y6),\n     .REFCLK(clk200),\n     .RST(rst200)\n     );\n\n   assign idelay_ctrl_rdy = idelay_ctrl_rdy_x0y5 & idelay_ctrl_rdy_x0y6;\n\nendmodule"}
{"task_id": 1212, "completion": "reg en_bit, rw_bit, w_bit, start_cond, stop_cond;\n    wire busy_bit, r_bit;\n    bit_ctrl bit_controller (\n        .clk(clk),\n        .clk_frame(clk_frame),\n        .rst(rst),\n        .en(en_bit),\n        .rw(rw_bit),\n        .w_bit(w_bit),\n        .start_cond(start_cond),\n        .stop_cond(stop_cond),\n        .r_bit(r_bit),\n        .busy(busy_bit),\n        .SCL(SCL),\n        .SDA_in(SDA_in),\n        .SDA_out(SDA_out),\n        .SDA_oen(SDA_oen)\n    );\n    \n    reg[7:0] shift_reg;\n    reg[4:0] state;\n    reg[3:0] i;\n    \n    localparam reset = 0,\n               idle = 1,\n               start_c = 2,\n               start_w = 3,\n               send_bit = 4,\n               wait_tx = 5,\n               wait_tx2 = 6,\n               read_bit = 7,\n               wait_rx = 8,\n               wait_rx2 = 9,\n               stop_c = 10,\n               stop_w = 11,\n               read_ack = 12,\n               read_ack2 = 13,\n               read_ack3 = 14,\n               write_ack = 15,\n               write_ack2 = 16,\n               write_ack3 = 17,\n               error = 18;\n    \n    always@(posedge clk) begin\n        if(rst)  state <= reset;\n        case(state)\n            reset: begin\n                i <= 4'h0;\n                state <= idle;\n            end\n            idle: begin\n                i <= 4'h0;\n                if(en) begin\n                    if(start) state <= start_c;\n                    else if(rw) state <= send_bit;\n                    else state <= read_bit;\n                end\n                else state <= idle;\n            end\n            start_c: begin\n                i <= 4'h0;\n                if(busy_bit) state <= start_w;\n                else state <= start_c;\n            end\n            start_w: begin\n                i <= 4'h0;\n                if(busy_bit) state <= start_w;\n                else state <= send_bit;\n            end\n            send_bit: begin\n                i <= i;\n                if(busy_bit) state <= wait_tx;\n                else state <= send_bit;\n            end\n            wait_tx: begin\n                i <= i + 1;\n                state <= wait_tx2;\n            end\n            wait_tx2: begin\n                i <= i;\n                if(busy_bit) state <= wait_tx2;\n                else begin\n                    if(i == 4'h8) state <= read_ack;\n                    else state <= send_bit;\n                end\n            end\n            read_bit: begin\n                i <= i;\n                if(busy_bit) state <= wait_rx;\n                else state <= read_bit;\n            end\n            wait_rx: begin\n                i <= i + 1;\n                state <= wait_rx2;\n            end\n            wait_rx2: begin\n                i <= i;\n                if(busy_bit) state <= wait_rx2;\n                else begin\n                    if(i == 4'h8) state <= write_ack;\n                    else state <= read_bit;\n                end\n            end\n            stop_c: begin\n                i <= 4'h0;\n                if(busy_bit) state <= stop_w;\n                else state <= stop_c;\n            end\n            stop_w: begin\n                i <= 4'h0;\n                if(busy_bit) state <= stop_w;\n                else state <= idle;\n            end\n            read_ack: begin\n                i <= i;\n                if(busy_bit) state <= read_ack2;\n                else state <= read_ack;\n            end\n            read_ack2: begin\n                i <= i;\n                if(busy_bit) state <= read_ack2;\n                else state <= read_ack3;\n            end\n            read_ack3: begin\n                i <= i;\n                if(r_bit == 0) begin\n                    if(stop) state <= stop_c;\n                    else state <= idle;\n                end\n                else state <= error;\n            end\n            write_ack: begin\n                i <= i;\n                if(busy_bit) state <= write_ack2;\n                else state <= write_ack;\n            end\n            write_ack2: begin\n                i <= i;\n                if(busy_bit) state <= write_ack2;\n                else if(stop) state <= stop_c;\n                else state <= idle;\n            end\n            error: begin\n                i <= i;\n                state <= error;\n            end\n            default: begin\n                i <= 4'h0;\n                state <= idle;\n            end\n        endcase\n    end\n    \n    always@(negedge clk) begin\n        case(state)\n            reset: begin\n                shift_reg <= 8'h00;\n                in_byte <= 8'h00;\n            end\n            idle: begin\n                shift_reg <= out_byte;\n                in_byte <= in_byte;\n            end\n            start_c: begin\n                shift_reg <= shift_reg;\n                in_byte <= in_byte;\n            end\n            start_w: begin\n                shift_reg <= shift_reg;\n                in_byte <= in_byte;\n            end\n            send_bit: begin\n                shift_reg <= shift_reg;\n                in_byte <= in_byte;\n            end\n            wait_tx: begin\n                shift_reg <= shift_reg << 1;\n                in_byte <= in_byte;\n            end\n            wait_tx2: begin\n                shift_reg <= shift_reg;\n                in_byte <= in_byte;\n            end\n            read_bit: begin\n                shift_reg[7:1] <= shift_reg[7:1];\n                shift_reg[0] <= r_bit;\n                in_byte <= in_byte;\n            end\n            wait_rx: begin\n                shift_reg <= shift_reg << 1;\n                in_byte <= in_byte;\n            end\n            wait_rx2: begin\n                shift_reg <= shift_reg;\n                in_byte <= in_byte;\n            end\n            stop_c: begin\n                shift_reg <= shift_reg;\n                in_byte <= in_byte;\n            end\n            stop_w: begin\n                shift_reg <= shift_reg;\n                in_byte <= in_byte;\n            end\n            read_ack: begin\n                shift_reg <= shift_reg;\n                in_byte <= in_byte;\n            end\n            read_ack2: begin\n                shift_reg <= shift_reg;\n                in_byte <= in_byte;\n            end\n            read_ack3: begin\n                shift_reg <= shift_reg;\n                in_byte <= in_byte;\n            end\n            write_ack: begin\n                shift_reg[7:1] <= shift_reg[7:1];\n                shift_reg[0] <= r_bit;\n                in_byte <= in_byte;\n            end\n            write_ack2: begin\n                shift_reg <= shift_reg;\n                in_byte <= shift_reg;\n            end\n            error: begin\n                shift_reg <= 8'hFF;\n                in_byte <= 8'hFF;\n            end\n            default: begin\n                shift_reg <= 8'h00;\n                in_byte <= 8'h00;\n            end\n        endcase\n    end\n    \n    always@(*) begin\n        case(state)\n            reset: begin\n                busy <= 1'b1;\n                err <= 1'b1;\n                en_bit <= 1'b0;\n                rw_bit <= 1'b0;\n                w_bit <= 1'b0;\n                start_cond <= 1'b0;\n                stop_cond <= 1'b0;\n            end\n            idle: begin\n                busy <= 1'b0;\n                err <= 1'b0;\n                en_bit <= 1'b0;\n                rw_bit <= 1'b0;\n                w_bit <= shift_reg[7];\n                start_cond <= 1'b0;\n                stop_cond <= 1'b0;\n            end\n            start_c: begin\n                busy <= 1'b1;\n                err <= 1'b0;\n                en_bit <= 1'b1;\n                rw_bit <= 1'b0;\n                w_bit <= shift_reg[7];\n                start_cond <= 1'b1;\n                stop_cond <= 1'b0;\n            end\n            start_w: begin\n                busy <= 1'b1;\n                err <= 1'b0;\n                en_bit <= 1'b0;\n                rw_bit <= 1'b0;\n                w_bit <= shift_reg[7];\n                start_cond <= 1'b0;\n                stop_cond <= 1'b0;\n            end\n            send_bit: begin\n                busy <= 1'b1;\n                err <= 1'b0;\n                en_bit <= 1'b1;\n                rw_bit <= 1'b1;\n                w_bit <= shift_reg[7];\n                start_cond <= 1'b0;\n                stop_cond <= 1'b0;\n            end\n            wait_tx: begin\n                busy <= 1'b1;\n                err <= 1'b0;\n                en_bit <= 1'b0;\n                rw_bit <= 1'b0;\n                w_bit <= shift_reg[7];\n                start_cond <= 1'b0;\n                stop_cond <= 1'b0;\n            end\n            wait_tx2: begin\n                busy <= 1'b1;\n                err <= 1'b0;\n                en_bit <= 1'b0;\n                rw_bit <= 1'b0;\n                w_bit <= shift_reg[7];\n                start_cond <= 1'b0;\n                stop_cond <= 1'b0;\n            end\n            read_bit: begin\n                busy <= 1'b1;\n                err <= 1'b0;\n                en_bit <= 1'b1;\n                rw_bit <= 1'b0;\n                w_bit <= shift_reg[7];\n                start_cond <= 1'b0;\n                stop_cond <= 1'b0;\n            end\n            wait_rx: begin\n                busy <= 1'b1;\n                err <= 1'b0;\n                en_bit <= 1'b0;\n                rw_bit <= 1'b0;\n                w_bit <= shift_reg[7];\n                start_cond <= 1'b0;\n                stop_cond <= 1'b0;\n            end\n            wait_rx2: begin\n                busy <= 1'b1;\n                err <= 1'b0;\n                en_bit <= 1'b0;\n                rw_bit <= 1'b0;\n                w_bit <= shift_reg[7];\n                start_cond <= 1'b0;\n                stop_cond <= 1'b0;\n            end\n            stop_c: begin\n                busy <= 1'b1;\n                err <= 1'b0;\n                en_bit <= 1'b1;\n                rw_bit <= 1'b0;\n                w_bit <= shift_reg[7];\n                start_cond <= 1'b0;\n                stop_cond <= 1'b1;\n            end\n            stop_w: begin\n                busy <= 1'b1;\n                err <= 1'b0;\n                en_bit <= 1'b0;\n                rw_bit <= 1'b0;\n                w_bit <= shift_reg[7];\n                start_cond <= 1'b0;\n                stop_cond <= 1'b0;\n            end\n            read_ack: begin\n                busy <= 1'b1;\n                err <= 1'b0;\n                en_bit <= 1'b1;\n                rw_bit <= 1'b0;\n                w_bit <= shift_reg[7];\n                start_cond <= 1'b0;\n                stop_cond <= 1'b0;\n            end\n            read_ack2: begin\n                busy <= 1'b1;\n                err <= 1'b0;\n                en_bit <= 1'b0;\n                rw_bit <= 1'b0;\n                w_bit <= shift_reg[7];\n                start_cond <= 1'b0;\n                stop_cond <= 1'b0;\n            end\n            read_ack3: begin\n                busy <= 1'b1;\n                err <= 1'b0;\n                en_bit <= 1'b0;\n                rw_bit <= 1'b0;\n                w_bit <= shift_reg[7];\n                start_cond <= 1'b0;\n                stop_cond <= 1'b0;\n            end\n            write_ack: begin\n                busy <= 1'b1;\n                err <= 1'b0;\n                en_bit <= 1'b1;\n                rw_bit <= 1'b1;\n                w_bit <= ack_o;\n                start_cond <= 1'b0;\n                stop_cond <= 1'b0;\n            end\n            write_ack2: begin\n                busy <= 1'b1;\n                err <= 1'b0;\n                en_bit <= 1'b0;\n                rw_bit <= 1'b0;\n                w_bit <= ack_o;\n                start_cond <= 1'b0;\n                stop_cond <= 1'b0;\n            end\n            error: begin\n                busy <= 1'b0;\n                err <= 1'b1;\n                en_bit <= 1'b0;\n                rw_bit <= 1'b0;\n                w_bit <= 1'b0;\n                start_cond <= 1'b0;\n                stop_cond <= 1'b0;\n            end\n            default: begin\n                busy <= 1'b1;\n                err <= 1'b0;\n                en_bit <= 1'b1;\n                rw_bit <= 1'b1;\n                w_bit <= ack_o;\n                start_cond <= 1'b0;\n                stop_cond <= 1'b0;\n            end\n        endcase\n    end\n    \nendmodule"}
{"task_id": 1233, "completion": "wire             clk_en;\n  wire             control_continuous;\n  wire             control_interrupt_enable;\n  reg     [  3: 0] control_register;\n  wire             control_wr_strobe;\n  reg              counter_is_running;\n  wire             counter_is_zero;\n  wire    [ 31: 0] counter_load_value;\n  reg     [ 31: 0] counter_snapshot;\n  reg              delayed_unxcounter_is_zeroxx0;\n  wire             do_start_counter;\n  wire             do_stop_counter;\n  reg              force_reload;\n  reg     [ 31: 0] internal_counter;\n  wire             irq;\n  reg     [ 15: 0] period_h_register;\n  wire             period_h_wr_strobe;\n  reg     [ 15: 0] period_l_register;\n  wire             period_l_wr_strobe;\n  wire    [ 15: 0] read_mux_out;\n  reg     [ 15: 0] readdata;\n  wire             snap_h_wr_strobe;\n  wire             snap_l_wr_strobe;\n  wire    [ 31: 0] snap_read_value;\n  wire             snap_strobe;\n  wire             start_strobe;\n  wire             status_wr_strobe;\n  wire             stop_strobe;\n  wire             timeout_event;\n  reg              timeout_occurred;\n  assign clk_en = 1;\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          internal_counter <= 32'hF423;\n      else if (counter_is_running || force_reload)\n          if (counter_is_zero    || force_reload)\n              internal_counter <= counter_load_value;\n          else \n            internal_counter <= internal_counter - 1;\n    end\n\n\n  assign counter_is_zero = internal_counter == 0;\n  assign counter_load_value = {period_h_register,\n    period_l_register};\n\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          force_reload <= 0;\n      else if (clk_en)\n          force_reload <= period_h_wr_strobe || period_l_wr_strobe;\n    end\n\n\n  assign do_start_counter = start_strobe;\n  assign do_stop_counter = (stop_strobe                            ) ||\n    (force_reload                           ) ||\n    (counter_is_zero && ~control_continuous );\n\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          counter_is_running <= 1'b0;\n      else if (clk_en)\n          if (do_start_counter)\n              counter_is_running <= -1;\n          else if (do_stop_counter)\n              counter_is_running <= 0;\n    end\n\n\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          delayed_unxcounter_is_zeroxx0 <= 0;\n      else if (clk_en)\n          delayed_unxcounter_is_zeroxx0 <= counter_is_zero;\n    end\n\n\n  assign timeout_event = (counter_is_zero) & ~(delayed_unxcounter_is_zeroxx0);\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          timeout_occurred <= 0;\n      else if (clk_en)\n          if (status_wr_strobe)\n              timeout_occurred <= 0;\n          else if (timeout_event)\n              timeout_occurred <= -1;\n    end\n\n\n  assign irq = timeout_occurred && control_interrupt_enable;\n  assign read_mux_out = ({16 {(address == 2)}} & period_l_register) |\n    ({16 {(address == 3)}} & period_h_register) |\n    ({16 {(address == 4)}} & snap_read_value[15 : 0]) |\n    ({16 {(address == 5)}} & snap_read_value[31 : 16]) |\n    ({16 {(address == 1)}} & control_register) |\n    ({16 {(address == 0)}} & {counter_is_running,\n    timeout_occurred});\n\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          readdata <= 0;\n      else if (clk_en)\n          readdata <= read_mux_out;\n    end\n\n\n  assign period_l_wr_strobe = chipselect && ~write_n && (address == 2);\n  assign period_h_wr_strobe = chipselect && ~write_n && (address == 3);\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          period_l_register <= 62499;\n      else if (period_l_wr_strobe)\n          period_l_register <= writedata;\n    end\n\n\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          period_h_register <= 0;\n      else if (period_h_wr_strobe)\n          period_h_register <= writedata;\n    end\n\n\n  assign snap_l_wr_strobe = chipselect && ~write_n && (address == 4);\n  assign snap_h_wr_strobe = chipselect && ~write_n && (address == 5);\n  snap_strobe = snap_l_wr_strobe || snap_h_wr_strobe;\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          counter_snapshot <= 0;\n      else if (snap_strobe)\n          counter_snapshot <= internal_counter;\n    end\n\n\n  assign snap_read_value = counter_snapshot;\n  assign control_wr_strobe = chipselect && ~write_n && (address == 1);\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          control_register <= 0;\n      else if (control_wr_strobe)\n          control_register <= writedata[3 : 0];\n    end\n\n\n  assign stop_strobe = writedata[3] && control_wr_strobe;\n  assign start_strobe = writedata[2] && control_wr_strobe;\n  assign control_continuous = control_register[1];\n  assign control_interrupt_enable = control_register[0];\n  assign status_wr_strobe = chipselect && ~write_n && (address == 0);\nendmodule"}
{"task_id": 1260, "completion": "wire [WIDTH-1:0] data_int, data_int2;   wire src_rdy_1, dst_rdy_1, src_rdy_2, dst_rdy_2;   wire [4:0] s1_space, s1_occupied, s2_space, s2_occupied;   wire [15:0] l_space, l_occupied;   fifo_short #(.WIDTH(WIDTH)) head_fifo (.clk(clk),.reset(reset),.clear(clear), .datain(datain), .src_rdy_i(src_rdy_i), .dst_rdy_o(dst_rdy_o), .dataout(data_int), .src_rdy_o(src_rdy_1), .dst_rdy_i(dst_rdy_1), .space(s1_space),.occupied(s1_occupied));   fifo_long #(.WIDTH(WIDTH),.SIZE(SIZE)) middle_fifo (.clk(clk),.reset(reset),.clear(clear), .datain(data_int), .src_rdy_i(src_rdy_1), .dst_rdy_o(dst_rdy_1), .dataout(data_int2), .src_rdy_o(src_rdy_2), .dst_rdy_i(dst_rdy_2), .space(l_space),.occupied(l_occupied));   fifo_short #(.WIDTH(WIDTH)) tail_fifo (.clk(clk),.reset(reset),.clear(clear), .datain(data_int2), .src_rdy_i(src_rdy_2), .dst_rdy_o(dst_rdy_2), .dataout(dataout), .src_rdy_o(src_rdy_o), .dst_rdy_i(dst_rdy_i), .space(s2_space),.occupied(s2_occupied));   assign space = {11'b0,s1_space} + {11'b0,s2_space} + l_space;   assign occupied = {11'b0,s1_occupied} + {11'b0,s2_occupied} + l_occupied; endmodule"}
{"task_id": 1182, "completion": "input tck_i;\ninput tdi_i;\noutput tdo_o;\ninput rst_i;\ninput shift_dr_i;\ninput pause_dr_i;\ninput update_dr_i;\ninput debug_select_i;\n\n`ifdef DBG_WISHBONE_SUPPORTED\ninput wb_clk_i;\noutput [31:0] wb_adr_o;\noutput [31:0] wb_dat_o;\ninput [31:0] wb_dat_i;\noutput wb_cyc_o;\noutput wb_stb_o;\noutput [3:0] wb_sel_o;\noutput wb_we_o;\ninput wb_ack_i;\noutput wb_cab_o;\ninput wb_err_i;\noutput [2:0] wb_cti_o;\noutput [1:0] wb_bte_o;\n\nreg wishbone_module;\nreg wishbone_ce;\nwire tdi_wb;\nwire tdo_wb;\nwire crc_en_wb;\nwire shift_crc_wb;\n`else\nwire crc_en_wb = 1'b0;\nwire shift_crc_wb = 1'b0;\n`endif\n\n`ifdef DBG_CPU0_SUPPORTED\ninput cpu0_clk_i;\noutput [31:0] cpu0_addr_o;\ninput [31:0] cpu0_data_i;\noutput [31:0] cpu0_data_o;\ninput cpu0_bp_i;\noutput cpu0_stall_o;\noutput cpu0_stb_o;\noutput cpu0_we_o;\ninput cpu0_ack_i;\noutput cpu0_rst_o;\n\nreg cpu0_debug_module;\nreg cpu0_ce;\nwire cpu0_tdi;\nwire cpu0_tdo;\nwire cpu0_crc_en;\nwire cpu0_shift_crc;\n`else\nwire cpu0_crc_en = 1'b0;\nwire cpu0_shift_crc = 1'b0;\n`endif\n\n`ifdef DBG_CPU1_SUPPORTED\ninput cpu1_clk_i;\noutput [31:0] cpu1_addr_o;\ninput [31:0] cpu1_data_i;\noutput [31:0] cpu1_data_o;\ninput cpu1_bp_i;\noutput cpu1_stall_o;\noutput cpu1_stb_o;\noutput cpu1_we_o;\ninput cpu1_ack_i;\noutput cpu1_rst_o;\n\nreg cpu1_debug_module;\nreg cpu1_ce;\nwire cpu1_tdi;\nwire cpu1_tdo;\nwire cpu1_crc_en;\nwire cpu1_shift_crc;\n`else\nwire cpu1_crc_en = 1'b0;\nwire cpu1_shift_crc = 1'b0;\n`endif\n\nreg [`DBG_TOP_DATA_CNT -1:0] data_cnt;\nreg [`DBG_TOP_CRC_CNT -1:0] crc_cnt;\nreg [`DBG_TOP_STATUS_CNT_WIDTH -1:0] status_cnt;\nreg [`DBG_TOP_MODULE_DATA_LEN -1:0] module_dr;\nreg [`DBG_TOP_MODULE_ID_LENGTH -1:0] module_id;\n\nwire module_latch_en;\nwire data_cnt_end;\nwire crc_cnt_end;\nwire status_cnt_end;\nreg crc_cnt_end_q;\nreg module_select;\nreg module_select_error;\nwire crc_out;\nwire crc_match;\n\nwire data_shift_en;\nwire selecting_command;\n\nreg tdo_o;\n\nwire shift_crc;\n\nalways @ (posedge tck_i or posedge rst_i)\nbegin\n  if (rst_i)\n    data_cnt <=  {`DBG_TOP_DATA_CNT{1'b0}};\n  else if(shift_dr_i & (~data_cnt_end))\n    data_cnt <=  data_cnt + 1;\n  else if (update_dr_i)\n    data_cnt <=  {`DBG_TOP_DATA_CNT{1'b0}};\nend\n\nassign data_cnt_end = data_cnt == `DBG_TOP_MODULE_DATA_LEN;\n\nalways @ (posedge tck_i or posedge rst_i)\nbegin\n  if (rst_i)\n    crc_cnt <=  {`DBG_TOP_CRC_CNT{1'b0}};\n  else if(shift_dr_i & data_cnt_end & (~crc_cnt_end) & module_select)\n    crc_cnt <=  crc_cnt + 1;\n  else if (update_dr_i)\n    crc_cnt <=  {`DBG_TOP_CRC_CNT{1'b0}};\nend\n\nassign crc_cnt_end = crc_cnt == `DBG_TOP_CRC_LEN;\n\nalways @ (posedge tck_i or posedge rst_i)\nbegin\n  if (rst_i)\n    crc_cnt_end_q  <=  1'b0;\n  else\n    crc_cnt_end_q  <=  crc_cnt_end;\nend\n\nalways @ (posedge tck_i or posedge rst_i)\nbegin\n  if (rst_i)\n    status_cnt <=  {`DBG_TOP_STATUS_CNT_WIDTH{1'b0}};\n  else if(shift_dr_i & crc_cnt_end & (~status_cnt_end))\n    status_cnt <=  status_cnt + 1;\n  else if (update_dr_i)\n    status_cnt <=  {`DBG_TOP_STATUS_CNT_WIDTH{1'b0}};\nend\n\nassign status_cnt_end = status_cnt == `DBG_TOP_STATUS_LEN;\n\nassign selecting_command = shift_dr_i & (data_cnt == `DBG_TOP_DATA_CNT'h0) & debug_select_i;\n\nalways @ (posedge tck_i or posedge rst_i)\nbegin\n  if (rst_i)\n    module_select <=  1'b0;\n  else if(selecting_command & tdi_i)       // Chain select\n    module_select <=  1'b1;\n  else if (update_dr_i)\n    module_select <=  1'b0;\nend\n\nalways @ (module_id)\nbegin\n  `ifdef DBG_CPU0_SUPPORTED\n  cpu0_debug_module  <=  1'b0;\n  `endif\n  `ifdef DBG_CPU1_SUPPORTED\n  cpu1_debug_module  <=  1'b0;\n  `endif\n  `ifdef DBG_WISHBONE_SUPPORTED\n  wishbone_module   <=  1'b0;\n  `endif\n  module_select_error    <=  1'b0;\n  \n  case (module_id)                /* synthesis parallel_case */\n    `ifdef DBG_CPU0_SUPPORTED\n      `DBG_TOP_CPU0_DEBUG_MODULE     :   cpu0_debug_module   <=  1'b1;\n    `endif\n    `ifdef DBG_CPU1_SUPPORTED\n      `DBG_TOP_CPU1_DEBUG_MODULE     :   cpu1_debug_module   <=  1'b1;\n    `endif\n    `ifdef DBG_WISHBONE_SUPPORTED\n      `DBG_TOP_WISHBONE_DEBUG_MODULE :   wishbone_module     <=  1'b1;\n    `endif\n    default                          :   module_select_error <=  1'b1; \n  endcase\nend\n\nassign module_latch_en = module_select & crc_cnt_end & (~crc_cnt_end_q);\n\nalways @ (posedge tck_i or posedge rst_i)\nbegin\n  if (rst_i)\n    module_id <= {`DBG_TOP_MODULE_ID_LENGTH{1'b1}};\n  else if(module_latch_en & crc_match)\n    module_id <=  module_dr[`DBG_TOP_MODULE_DATA_LEN -2:0];\nend\n\nassign data_shift_en = shift_dr_i & (~data_cnt_end);\n\nalways @ (posedge tck_i or posedge rst_i)\nbegin\n  if (rst_i)\n    module_dr <=  0;\n  else if (data_shift_en)\n    module_dr[`DBG_TOP_MODULE_DATA_LEN -1:0] <=  {module_dr[`DBG_TOP_MODULE_DATA_LEN -2:0], tdi_i};\nend\n\ndbg_crc32_d1 i_dbg_crc32_d1_in\n             ( \n              .data       (tdi_i),\n              .enable     (shift_dr_i),\n              .shift      (1'b0),\n              .rst        (rst_i),\n              .sync_rst   (update_dr_i),\n              .crc_out    (),\n              .clk        (tck_i),\n              .crc_match  (crc_match)\n             );\n\nreg tdo_module_select;\nwire crc_en;\nwire crc_en_dbg;\nreg crc_started;\n\nassign crc_en = crc_en_dbg | crc_en_wb | cpu1_crc_en | cpu0_crc_en;\n\nassign crc_en_dbg = shift_dr_i & crc_cnt_end & (~status_cnt_end);\n\nalways @ (posedge tck_i or posedge rst_i)\nbegin\n  if (rst_i)\n    crc_started <=  1'b0;\n  else if (crc_en)\n    crc_started <=  1'b1;\n  else if (update_dr_i)\n    crc_started <=  1'b0;\nend\n\nreg tdo_tmp;\n\ndbg_crc32_d1 i_dbg_crc32_d1_out\n             ( \n              .data       (tdo_tmp),\n              .enable     (crc_en), \n              .shift      (shift_dr_i & crc_started & (~crc_en)),\n              .rst        (rst_i),\n              .sync_rst   (update_dr_i),\n              .crc_out    (crc_out),\n              .clk        (tck_i),\n              .crc_match  ()\n             );\n\nalways @ (status_cnt or crc_match or module_select_error or crc_out)\nbegin\n  case (status_cnt)                   /* synthesis full_case parallel_case */ \n    `DBG_TOP_STATUS_CNT_WIDTH'd0  : begin\n                        tdo_module_select = ~crc_match;\n                      end\n    `DBG_TOP_STATUS_CNT_WIDTH'd1  : begin\n                        tdo_module_select = module_select_error;\n                      end\n    `DBG_TOP_STATUS_CNT_WIDTH'd2  : begin\n                        tdo_module_select = 1'b0;\n                      end\n    `DBG_TOP_STATUS_CNT_WIDTH'd3  : begin\n                        tdo_module_select = 1'b0;\n                      end\n    `DBG_TOP_STATUS_CNT_WIDTH'd4  : begin\n                        tdo_module_select = crc_out;\n                      end\n     default : begin    tdo_module_select = 1'b0; end\n  endcase\nend\n\nassign shift_crc = shift_crc_wb | cpu1_shift_crc | cpu0_shift_crc;\n\nalways @ (shift_crc or crc_out or tdo_module_select\n`ifdef DBG_WISHBONE_SUPPORTED\n or wishbone_ce or tdo_wb\n`endif\n`ifdef DBG_CPU0_SUPPORTED\n or cpu0_ce or cpu0_tdo\n`endif\n`ifdef DBG_CPU1_SUPPORTED\n or cpu1_ce or cpu1_tdo\n`endif\n         )\nbegin\n  if (shift_crc)          // shifting crc\n    tdo_tmp = crc_out;\n  `ifdef DBG_WISHBONE_SUPPORTED\n  else if (wishbone_ce)   //  shifting data from wb\n    tdo_tmp = tdo_wb;\n  `endif\n  `ifdef DBG_CPU0_SUPPORTED\n  else if (cpu0_ce)        // shifting data from cpu\n    tdo_tmp = cpu0_tdo;\n  `endif\n  `ifdef DBG_CPU1_SUPPORTED\n  else if (cpu1_ce)        // shifting data from cpu\n    tdo_tmp = cpu1_tdo;\n  `endif\n  else\n    tdo_tmp = tdo_module_select;\nend\n\nalways @ (negedge tck_i)\nbegin\n  tdo_o <=  tdo_tmp;\nend\n\nalways @ (posedge tck_i or posedge rst_i)\nbegin\n  if (rst_i)\n    begin\n      `ifdef DBG_WISHBONE_SUPPORTED\n      wishbone_ce <=  1'b0;\n      `endif\n      `ifdef DBG_CPU0_SUPPORTED\n      cpu0_ce <=  1'b0;\n      `endif\n      `ifdef DBG_CPU1_SUPPORTED\n      cpu1_ce <=  1'b0;\n      `endif\n    end\n  else if(selecting_command & (~tdi_i))\n    begin\n      `ifdef DBG_WISHBONE_SUPPORTED\n      if (wishbone_module)      // wishbone CE\n        wishbone_ce <=  1'b1;\n      `endif\n      `ifdef DBG_CPU0_SUPPORTED\n      if (cpu0_debug_module)     // CPU CE\n        cpu0_ce <=  1'b1;\n      `endif\n      `ifdef DBG_CPU1_SUPPORTED\n      if (cpu1_debug_module)     // CPU CE\n        cpu1_ce <=  1'b1;\n      `endif\n    end\n  else if (update_dr_i)\n    begin\n      `ifdef DBG_WISHBONE_SUPPORTED\n      wishbone_ce <=  1'b0;\n      `endif\n      `ifdef DBG_CPU0_SUPPORTED\n      cpu0_ce <=  1'b0;\n      `endif\n      `ifdef DBG_CPU1_SUPPORTED\n      cpu1_ce <=  1'b0;\n      `endif\n    end\nend\n\n`ifdef DBG_WISHBONE_SUPPORTED\nassign tdi_wb  = wishbone_ce & tdi_i;\n`endif\n\n`ifdef DBG_CPU0_SUPPORTED\nassign cpu0_tdi = cpu0_ce & tdi_i;\n`endif\n`ifdef DBG_CPU1_SUPPORTED\nassign cpu1_tdi = cpu1_ce & tdi_i;\n`endif\n\n`ifdef DBG_WISHBONE_SUPPORTED\ndbg_wb i_dbg_wb (\n                  .tck_i            (tck_i),\n                  .tdi_i            (tdi_wb),\n                  .tdo_o            (tdo_wb),\n                  .shift_dr_i       (shift_dr_i),\n                  .pause_dr_i       (pause_dr_i),\n                  .update_dr_i      (update_dr_i),\n                  .wishbone_ce_i    (wishbone_ce),\n                  .crc_match_i      (crc_match),\n                  .crc_en_o         (crc_en_wb),\n                  .shift_crc_o      (shift_crc_wb),\n                  .rst_i            (rst_i),\n                  .wb_clk_i         (wb_clk_i),\n                  .wb_adr_o         (wb_adr_o), \n                  .wb_dat_o         (wb_dat_o),\n                  .wb_dat_i         (wb_dat_i),\n                  .wb_cyc_o         (wb_cyc_o),\n                  .wb_stb_o         (wb_stb_o),\n                  .wb_sel_o         (wb_sel_o),\n                  .wb_we_o          (wb_we_o),\n                  .wb_ack_i         (wb_ack_i),\n                  .wb_cab_o         (wb_cab_o),\n                  .wb_err_i         (wb_err_i),\n                  .wb_cti_o         (wb_cti_o),\n                  .wb_bte_o         (wb_bte_o)\n            );\n`endif\n\n`ifdef DBG_CPU0_SUPPORTED\ndbg_cpu i_dbg_cpu_or1k (\n                  .tck_i            (tck_i),\n                  .tdi_i            (cpu0_tdi),\n                  .tdo_o            (cpu0_tdo),\n                  .shift_dr_i       (shift_dr_i),\n                  .pause_dr_i       (pause_dr_i),\n                  .update_dr_i      (update_dr_i),\n                  .cpu_ce_i         (cpu0_ce),\n                  .crc_match_i      (crc_match),\n                  .crc_en_o         (cpu0_crc_en),\n                  .shift_crc_o      (cpu0_shift_crc),\n                  .rst_i            (rst_i),\n                  .cpu_clk_i        (cpu0_clk_i), \n                  .cpu_addr_o       (cpu0_addr_o), \n                  .cpu_data_i       (cpu0_data_i), \n                  .cpu_data_o       (cpu0_data_o),\n                  .cpu_bp_i         (cpu0_bp_i),\n                  .cpu_stall_o      (cpu0_stall_o),\n                  .cpu_stb_o        (cpu0_stb_o),\n                  .cpu_we_o         (cpu0_we_o),\n                  .cpu_ack_i        (cpu0_ack_i),\n                  .cpu_rst_o        (cpu0_rst_o)\n              );\n`endif  \n`ifdef DBG_CPU1_SUPPORTED\ndbg_cpu i_dbg_cpu_8051 (\n                  .tck_i            (tck_i),\n                  .tdi_i            (cpu1_tdi),\n                  .tdo_o            (cpu1_tdo),\n                  .shift_dr_i       (shift_dr_i),\n                  .pause_dr_i       (pause_dr_i),\n                  .update_dr_i      (update_dr_i),\n                  .cpu_ce_i         (cpu1_ce),\n                  .crc_match_i      (crc_match),\n                  .crc_en_o         (cpu1_crc_en),\n                  .shift_crc_o      (cpu1_shift_crc),\n                  .rst_i            (rst_i),\n                  .cpu_clk_i        (cpu1_clk_i), \n                  .cpu_addr_o       (cpu1_addr_o), \n                  .cpu_data_i       (cpu1_data_i), \n                  .cpu_data_o       (cpu1_data_o),\n                  .cpu_bp_i         (cpu1_bp_i),\n                  .cpu_stall_o      (cpu1_stall_o),\n                  .cpu_stb_o        (cpu1_stb_o),\n                  .cpu_we_o         (cpu1_we_o),\n                  .cpu_ack_i        (cpu1_ack_i),\n                  .cpu_rst_o        (cpu1_rst_o)\n              );\n`endif\nendmodule"}
{"task_id": 1206, "completion": "reg [dw-1:0] COEFFICIENT_0;\n\treg [dw-1:0] COEFFICIENT_1;\n\treg [dw-1:0] COEFFICIENT_2;\n\treg [dw-1:0] COEFFICIENT_3;\n\treg [dw-1:0] COEFFICIENT_4;\n\treg [dw-1:0] COEFFICIENT_5;\n\treg [dw-1:0] COEFFICIENT_6;\n\n\talways@(posedge clk) begin\n\t\tCOEFFICIENT_0 <= 18'd88;\n\t\tCOEFFICIENT_1 <= 18'd0;\n\t\tCOEFFICIENT_2 <= -18'd97;\n\t\tCOEFFICIENT_3 <= -18'd197;\n\t\tCOEFFICIENT_4 <= -18'd294;\n\t\tCOEFFICIENT_5 <= -18'd380;\n\t\tCOEFFICIENT_6 <= -18'd447;\n\tend\n\n\treg [N_VALID_REGS-1:0] VALID_PIPELINE_REGS;\n\n\talways@(posedge clk or posedge reset) begin\n\t\tif(reset) begin\n\t\t\tVALID_PIPELINE_REGS <= 0;\n\t\tend else begin\n\t\t\tif(clk_ena) begin\n\t\t\t\tVALID_PIPELINE_REGS <= {VALID_PIPELINE_REGS[N_VALID_REGS-2:0], i_valid};\n\t\t\tend else begin\n\t\t\t\tVALID_PIPELINE_REGS <= VALID_PIPELINE_REGS;\n\t\t\tend\n\t\tend\n\tend\n\n\twire [dw-1:0] INPUT_PIPELINE_REG_0;\n\twire [dw-1:0] INPUT_PIPELINE_REG_1;\n\twire [dw-1:0] INPUT_PIPELINE_REG_2;\n\twire [dw-1:0] INPUT_PIPELINE_REG_3;\n\twire [dw-1:0] INPUT_PIPELINE_REG_4;\n\twire [dw-1:0] INPUT_PIPELINE_REG_5;\n\twire [dw-1:0] INPUT_PIPELINE_REG_6;\n\twire [dw-1:0] INPUT_PIPELINE_REG_7;\n\twire [dw-1:0] INPUT_PIPELINE_REG_8;\n\twire [dw-1:0] INPUT_PIPELINE_REG_9;\n\twire [dw-1:0] INPUT_PIPELINE_REG_10;\n\twire [dw-1:0] INPUT_PIPELINE_REG_11;\n\twire [dw-1:0] INPUT_PIPELINE_REG_12;\n\twire [dw-1:0] INPUT_PIPELINE_REG_13;\n\n\tinput_pipeline in_pipe(\n\t\t.clk(clk), .clk_ena(clk_ena),\n\t\t.in_stream(i_in),\n\t\t.pipeline_reg_0(INPUT_PIPELINE_REG_0),\n\t\t.pipeline_reg_1(INPUT_PIPELINE_REG_1),\n\t\t.pipeline_reg_2(INPUT_PIPELINE_REG_2),\n\t\t.pipeline_reg_3(INPUT_PIPELINE_REG_3),\n\t\t.pipeline_reg_4(INPUT_PIPELINE_REG_4),\n\t\t.pipeline_reg_5(INPUT_PIPELINE_REG_5),\n\t\t.pipeline_reg_6(INPUT_PIPELINE_REG_6),\n\t\t.pipeline_reg_7(INPUT_PIPELINE_REG_7),\n\t\t.pipeline_reg_8(INPUT_PIPELINE_REG_8),\n\t\t.pipeline_reg_9(INPUT_PIPELINE_REG_9),\n\t\t.pipeline_reg_10(INPUT_PIPELINE_REG_10),\n\t\t.pipeline_reg_11(INPUT_PIPELINE_REG_11),\n\t\t.pipeline_reg_12(INPUT_PIPELINE_REG_12),\n\t\t.pipeline_reg_13(INPUT_PIPELINE_REG_13),\n\t\t.reset(reset);\n\tdefparam in_pipe.WIDTH = 18;\n\n\twire [dw-1:0] L0_output_wires_0;\n\twire [dw-1:0] L0_output_wires_1;\n\twire [dw-1:0] L0_output_wires_2;\n\twire [dw-1:0] L0_output_wires_3;\n\twire [dw-1:0] L0_output_wires_4;\n\twire [dw-1:0] L0_output_wires_5;\n\twire [dw-1:0] L0_output_wires_6;\n\n\tadder_with_1_reg L0_adder_0and13(\n\t\t.dataa (INPUT_PIPELINE_REG_0),\n\t\t.datab (INPUT_PIPELINE_REG_13),\n\t\t.result(L0_output_wires_0)\n\t);\n\n\tadder_with_1_reg L0_adder_1and12(\n\t\t.dataa (INPUT_PIPELINE_REG_1),\n\t\t.datab (INPUT_PIPELINE_REG_12),\n\t\t.result(L0_output_wires_1)\n\t);\n\n\tadder_with_1_reg L0_adder_2and11(\n\t\t.dataa (INPUT_PIPELINE_REG_2),\n\t\t.datab (INPUT_PIPELINE_REG_11),\n\t\t.result(L0_output_wires_2)\n\t);\n\n\tadder_with_1_reg L0_adder_3and10(\n\t\t.dataa (INPUT_PIPELINE_REG_3),\n\t\t.datab (INPUT_PIPELINE_REG_10),\n\t\t.result(L0_output_wires_3)\n\t);\n\n\tadder_with_1_reg L0_adder_4and9(\n\t\t.dataa (INPUT_PIPELINE_REG_4),\n\t\t.datab (INPUT_PIPELINE_REG_9),\n\t\t.result(L0_output_wires_4)\n\t);\n\n\tadder_with_1_reg L0_adder_5and8(\n\t\t.dataa (INPUT_PIPELINE_REG_5),\n\t\t.datab (INPUT_PIPELINE_REG_8),\n\t\t.result(L0_output_wires_5)\n\t);\n\n\tadder_with_1_reg L0_adder_6and7(\n\t\t.dataa (INPUT_PIPELINE_REG_6),\n\t\t.datab (INPUT_PIPELINE_REG_7),\n\t\t.result(L0_output_wires_6)\n\t);\n\n\twire [dw-1:0] L1_mult_wires_0;\n\twire [dw-1:0] L1_mult_wires_1;\n\twire [dw-1:0] L1_mult_wires_2;\n\twire [dw-1:0] L1_mult_wires_3;\n\twire [dw-1:0] L1_mult_wires_4;\n\twire [dw-1:0] L1_mult_wires_5;\n\twire [dw-1:0] L1_mult_wires_6;\n\n\tmultiplier_with_reg L1_mul_0(\n\t\t.dataa (L0_output_wires_0),\n\t\t.datab (COEFFICIENT_0),\n\t\t.result(L1_mult_wires_0)\n\t);\n\n\tmultiplier_with_reg L1_mul_1(\n\t\t.dataa (L0_output_wires_1),\n\t\t.datab (COEFFICIENT_1),\n\t\t.result(L1_mult_wires_1)\n\t);\n\n\tmultiplier_with_reg L1_mul_2(\n\t\t.dataa (L0_output_wires_2),\n\t\t.datab (COEFFICIENT_2),\n\t\t.result(L1_mult_wires_2)\n\t);\n\n\tmultiplier_with_reg L1_mul_3(\n\t\t.dataa (L0_output_wires_3),\n\t\t.datab (COEFFICIENT_3),\n\t\t.result(L1_mult_wires_3)\n\t);\n\n\tmultiplier_with_reg L1_mul_4(\n\t\t.dataa (L0_output_wires_4),\n\t\t.datab (COEFFICIENT_4),\n\t\t.result(L1_mult_wires_4)\n\t);\n\n\tmultiplier_with_reg L1_mul_5(\n\t\t.dataa (L0_output_wires_5),\n\t\t.datab (COEFFICIENT_5),\n\t\t.result(L1_mult_wires_5)\n\t);\n\n\tmultiplier_with_reg L1_mul_6(\n\t\t.dataa (L0_output_wires_6),\n\t\t.datab (COEFFICIENT_6),\n\t\t.result(L1_mult_wires_6)\n\t);\n\n\twire [dw-1:0] L1_output_wires_0;\n\twire [dw-1:0] L1_output_wires_1;\n\twire [dw-1:0] L1_output_wires_2;\n\twire [dw-1:0] L1_output_wires_3;\n\n\tadder_with_1_reg L1_adder_0and1(\n\t\t.dataa (L1_mult_wires_0),\n\t\t.datab (L1_mult_wires_1),\n\t\t.result(L1_output_wires_0)\n\t);\n\n\tadder_with_1_reg L1_adder_2and3(\n\t\t.dataa (L1_mult_wires_2),\n\t\t.datab (L1_mult_wires_3),\n\t\t.result(L1_output_wires_1)\n\t);\n\n\tadder_with_1_reg L1_adder_4and5(\n\t\t.dataa (L1_mult_wires_4),\n\t\t.datab (L1_mult_wires_5),\n\t\t.result(L1_output_wires_2)\n\t);\n\n\tone_register L1_byereg_for_6(\n\t\t.dataa (L1_mult_wires_6),\n\t\t.result(L1_output_wires_3)\n\t);\n\n\twire [dw-1:0] L2_output_wires_0;\n\twire [dw-1:0] L2_output_wires_1;\n\n\tadder_with_1_reg L2_adder_0and1(\n\t\t.dataa (L1_output_wires_0),\n\t\t.datab (L1_output_wires_1),\n\t\t.result(L2_output_wires_0)\n\t);\n\n\tadder_with_1_reg L2_adder_2and3(\n\t\t.dataa (L1_output_wires_2),\n\t\t.datab (L1_output_wires_3),\n\t\t.result(L2_output_wires_1)\n\t);\n\n\twire [dw-1:0] L3_output_wires_0;\n\n\tadder_with_1_reg L3_adder_0and1(\n\t\t.dataa (L2_output_wires_0),\n\t\t.datab (L2_output_wires_1),\n\t\t.result(L3_output_wires_0)\n\t);\n\n\treg     [17:0]  o_out;\n\n\talways @(posedge clk) begin\n\t\tif(clk_ena) begin\n\t\t\to_out <= L3_output_wires_0;\n\t\tend\n\tend\n\n\tassign o_valid = VALID_PIPELINE_REGS[N_VALID_REGS-1];\n\nendmodule"}
{"task_id": 1248, "completion": "BLK_MEM_GEN_V6_1 #(\n    .C_ADDRA_WIDTH(14),\n    .C_ADDRB_WIDTH(14),\n    .C_ALGORITHM(1),\n    .C_AXI_ID_WIDTH(4),\n    .C_AXI_SLAVE_TYPE(0),\n    .C_AXI_TYPE(1),\n    .C_BYTE_SIZE(9),\n    .C_COMMON_CLK(1),\n    .C_DEFAULT_DATA(\"0\"),\n    .C_DISABLE_WARN_BHV_COLL(0),\n    .C_DISABLE_WARN_BHV_RANGE(0),\n    .C_FAMILY(\"spartan3\"),\n    .C_HAS_AXI_ID(0),\n    .C_HAS_ENA(0),\n    .C_HAS_ENB(0),\n    .C_HAS_INJECTERR(0),\n    .C_HAS_MEM_OUTPUT_REGS_A(0),\n    .C_HAS_MEM_OUTPUT_REGS_B(0),\n    .C_HAS_MUX_OUTPUT_REGS_A(0),\n    .C_HAS_MUX_OUTPUT_REGS_B(0),\n    .C_HAS_REGCEA(0),\n    .C_HAS_REGCEB(0),\n    .C_HAS_RSTA(0),\n    .C_HAS_RSTB(0),\n    .C_HAS_SOFTECC_INPUT_REGS_A(0),\n    .C_HAS_SOFTECC_OUTPUT_REGS_B(0),\n    .C_INIT_FILE_NAME(\"no_coe_file_loaded\"),\n    .C_INITA_VAL(\"0\"),\n    .C_INITB_VAL(\"0\"),\n    .C_INTERFACE_TYPE(0),\n    .C_LOAD_INIT_FILE(0),\n    .C_MEM_TYPE(1),\n    .C_MUX_PIPELINE_STAGES(0),\n    .C_PRIM_TYPE(1),\n    .C_READ_DEPTH_A(16384),\n    .C_READ_DEPTH_B(16384),\n    .C_READ_WIDTH_A(8),\n    .C_READ_WIDTH_B(8),\n    .C_RST_PRIORITY_A(\"CE\"),\n    .C_RST_PRIORITY_B(\"CE\"),\n    .C_RST_TYPE(\"SYNC\"),\n    .C_RSTRAM_A(0),\n    .C_RSTRAM_B(0),\n    .C_SIM_COLLISION_CHECK(\"ALL\"),\n    .C_USE_BYTE_WEA(0),\n    .C_USE_BYTE_WEB(0),\n    .C_USE_DEFAULT_DATA(0),\n    .C_USE_ECC(0),\n    .C_USE_SOFTECC(0),\n    .C_WEA_WIDTH(1),\n    .C_WEB_WIDTH(1),\n    .C_WRITE_DEPTH_A(16384),\n    .C_WRITE_DEPTH_B(16384),\n    .C_WRITE_MODE_A(\"WRITE_FIRST\"),\n    .C_WRITE_MODE_B(\"WRITE_FIRST\"),\n    .C_WRITE_WIDTH_A(8),\n    .C_WRITE_WIDTH_B(8),\n    .C_XDEVICEFAMILY(\"spartan3\")\n  )\n  inst (\n    .CLKA(clka),\n    .WEA(wea),\n    .ADDRA(addra),\n    .DINA(dina),\n    .CLKB(clkb),\n    .ADDRB(addrb),\n    .DOUTB(doutb),\n    .RSTA(),\n    .ENA(),\n    .REGCEA(),\n    .DOUTA(),\n    .RSTB(),\n    .ENB(),\n    .REGCEB(),\n    .WEB(),\n    .DINB(),\n    .INJECTSBITERR(),\n    .INJECTDBITERR(),\n    .SBITERR(),\n    .DBITERR(),\n    .RDADDRECC(),\n    .S_ACLK(),\n    .S_ARESETN(),\n    .S_AXI_AWID(),\n    .S_AXI_AWADDR(),\n    .S_AXI_AWLEN(),\n    .S_AXI_AWSIZE(),\n    .S_AXI_AWBURST(),\n    .S_AXI_AWVALID(),\n    .S_AXI_AWREADY(),\n    .S_AXI_WDATA(),\n    .S_AXI_WSTRB(),\n    .S_AXI_WLAST(),\n    .S_AXI_WVALID(),\n    .S_AXI_WREADY(),\n    .S_AXI_BID(),\n    .S_AXI_BRESP(),\n    .S_AXI_BVALID(),\n    .S_AXI_BREADY(),\n    .S_AXI_ARID(),\n    .S_AXI_ARADDR(),\n    .S_AXI_ARLEN(),\n    .S_AXI_ARSIZE(),\n    .S_AXI_ARBURST(),\n    .S_AXI_ARVALID(),\n    .S_AXI_ARREADY(),\n    .S_AXI_RID(),\n    .S_AXI_RDATA(),\n    .S_AXI_RRESP(),\n    .S_AXI_RLAST(),\n    .S_AXI_RVALID(),\n    .S_AXI_RREADY(),\n    .S_AXI_INJECTSBITERR(),\n    .S_AXI_INJECTDBITERR(),\n    .S_AXI_SBITERR(),\n    .S_AXI_DBITERR(),\n    .S_AXI_RDADDRECC()\n  );\n\nendmodule"}
{"task_id": 1268, "completion": "// synthesis translate_off\n\n  BLK_MEM_GEN_V7_3 #(\n    .C_ADDRA_WIDTH(4),\n    .C_ADDRB_WIDTH(4),\n    .C_ALGORITHM(1),\n    .C_AXI_ID_WIDTH(4),\n    .C_AXI_SLAVE_TYPE(0),\n    .C_AXI_TYPE(1),\n    .C_BYTE_SIZE(9),\n    .C_COMMON_CLK(0),\n    .C_DEFAULT_DATA(\"0\"),\n    .C_DISABLE_WARN_BHV_COLL(0),\n    .C_DISABLE_WARN_BHV_RANGE(0),\n    .C_ENABLE_32BIT_ADDRESS(0),\n    .C_FAMILY(\"spartan6\"),\n    .C_HAS_AXI_ID(0),\n    .C_HAS_ENA(0),\n    .C_HAS_ENB(0),\n    .C_HAS_INJECTERR(0),\n    .C_HAS_MEM_OUTPUT_REGS_A(0),\n    .C_HAS_MEM_OUTPUT_REGS_B(0),\n    .C_HAS_MUX_OUTPUT_REGS_A(0),\n    .C_HAS_MUX_OUTPUT_REGS_B(0),\n    .C_HAS_REGCEA(0),\n    .C_HAS_REGCEB(0),\n    .C_HAS_RSTA(0),\n    .C_HAS_RSTB(0),\n    .C_HAS_SOFTECC_INPUT_REGS_A(0),\n    .C_HAS_SOFTECC_OUTPUT_REGS_B(0),\n    .C_INIT_FILE(\"BlankString\"),\n    .C_INIT_FILE_NAME(\"sounds_mem.mif\"),\n    .C_INITA_VAL(\"0\"),\n    .C_INITB_VAL(\"0\"),\n    .C_INTERFACE_TYPE(0),\n    .C_LOAD_INIT_FILE(1),\n    .C_MEM_TYPE(3),\n    .C_MUX_PIPELINE_STAGES(0),\n    .C_PRIM_TYPE(1),\n    .C_READ_DEPTH_A(16),\n    .C_READ_DEPTH_B(16),\n    .C_READ_WIDTH_A(32),\n    .C_READ_WIDTH_B(32),\n    .C_RST_PRIORITY_A(\"CE\"),\n    .C_RST_PRIORITY_B(\"CE\"),\n    .C_RST_TYPE(\"SYNC\"),\n    .C_RSTRAM_A(0),\n    .C_RSTRAM_B(0),\n    .C_SIM_COLLISION_CHECK(\"ALL\"),\n    .C_USE_BRAM_BLOCK(0),\n    .C_USE_BYTE_WEA(0),\n    .C_USE_BYTE_WEB(0),\n    .C_USE_DEFAULT_DATA(0),\n    .C_USE_ECC(0),\n    .C_USE_SOFTECC(0),\n    .C_WEA_WIDTH(1),\n    .C_WEB_WIDTH(1),\n    .C_WRITE_DEPTH_A(16),\n    .C_WRITE_DEPTH_B(16),\n    .C_WRITE_MODE_A(\"WRITE_FIRST\"),\n    .C_WRITE_MODE_B(\"WRITE_FIRST\"),\n    .C_WRITE_WIDTH_A(32),\n    .C_WRITE_WIDTH_B(32),\n    .C_XDEVICEFAMILY(\"spartan6\")\n  )\n  inst (\n    .CLKA(clka),\n    .ADDRA(addra),\n    .DOUTA(douta),\n    .RSTA(),\n    .ENA(),\n    .REGCEA(),\n    .WEA(),\n    .DINA(),\n    .CLKB(),\n    .RSTB(),\n    .ENB(),\n    .REGCEB(),\n    .WEB(),\n    .ADDRB(),\n    .DINB(),\n    .DOUTB(),\n    .INJECTSBITERR(),\n    .INJECTDBITERR(),\n    .SBITERR(),\n    .DBITERR(),\n    .RDADDRECC(),\n    .S_ACLK(),\n    .S_ARESETN(),\n    .S_AXI_AWID(),\n    .S_AXI_AWADDR(),\n    .S_AXI_AWLEN(),\n    .S_AXI_AWSIZE(),\n    .S_AXI_AWBURST(),\n    .S_AXI_AWVALID(),\n    .S_AXI_AWREADY(),\n    .S_AXI_WDATA(),\n    .S_AXI_WSTRB(),\n    .S_AXI_WLAST(),\n    .S_AXI_WVALID(),\n    .S_AXI_WREADY(),\n    .S_AXI_BID(),\n    .S_AXI_BRESP(),\n    .S_AXI_BVALID(),\n    .S_AXI_BREADY(),\n    .S_AXI_ARID(),\n    .S_AXI_ARADDR(),\n    .S_AXI_ARLEN(),\n    .S_AXI_ARSIZE(),\n    .S_AXI_ARBURST(),\n    .S_AXI_ARVALID(),\n    .S_AXI_ARREADY(),\n    .S_AXI_RID(),\n    .S_AXI_RDATA(),\n    .S_AXI_RRESP(),\n    .S_AXI_RLAST(),\n    .S_AXI_RVALID(),\n    .S_AXI_RREADY(),\n    .S_AXI_INJECTSBITERR(),\n    .S_AXI_INJECTDBITERR(),\n    .S_AXI_SBITERR(),\n    .S_AXI_DBITERR(),\n    .S_AXI_RDADDRECC()\n  );\n\n// synthesis translate_on\n\nendmodule"}
{"task_id": 1280, "completion": "wire             clk_en;\n    reg              data_out;\n    wire    [ 31: 0] readdata;\n    assign clk_en = 1;\n    assign read_mux_out = {1 {(address == 0)}} & data_out;\n    always @(posedge clk or negedge reset_n)\n        begin\n            if (reset_n == 0)\n                data_out <= 0;\n            else if (chipselect && ~write_n && (address == 0))\n                data_out <= writedata;\n        end\n    assign readdata = {32'b0 | read_mux_out};\n    assign out_port = data_out;\nendmodule"}
{"task_id": 1281, "completion": "parameter IN_REG = 1; wire dout0; wire dout1; wire dout2; generate if(!IN_REG) assign dout0 = din; else FDCE stage0 (.Q(dout0), .C(clk_in),  .CE(1'b1), .CLR(1'b0), .D(din)); endgenerate (* RLOC=\"X0Y0\" *) FDCE stage1 (.Q(dout1), .C(clk_out), .CE(1'b1), .CLR(1'b0), .D(dout0)); (* RLOC=\"X0Y0\" *) FDCE stage2 (.Q(dout2), .C(clk_out), .CE(1'b1), .CLR(1'b0), .D(dout1)); (* RLOC=\"X0Y0\" *) FDCE stage3 (.Q(dout ), .C(clk_out), .CE(1'b1), .CLR(1'b0), .D(dout2));endmodule"}
{"task_id": 1240, "completion": "wire [ 6: 0] fifo_wr_used;\nwire fifo_empty;\nassign stream_in_ready = ~(&(fifo_wr_used[6:4]));\nassign stream_out_empty = 'h0;\nassign stream_out_valid = ~fifo_empty;\ndcfifo Data_FIFO (\n\t.wrclk\t(clk_stream_in),\n\t.wrreq\t(stream_in_ready & stream_in_valid),\n\t.data\t\t({stream_in_data, stream_in_endofpacket, stream_in_startofpacket}),\n\t.rdclk\t(clk_stream_out),\n\t.rdreq\t(stream_out_ready & ~fifo_empty),\n\t.wrusedw\t(fifo_wr_used),\n\t.rdempty\t(fifo_empty),\n\t.q\t\t({stream_out_data, stream_out_endofpacket, stream_out_startofpacket})\n\t,\n\t.aclr\t\t(),\n\t.wrfull\t(),\n\t.wrempty\t(),\n\t.rdfull\t(),\n\t.rdusedw\t()\n);\ndefparam\n\tData_FIFO.intended_device_family\t= \"Cyclone II\",\n\tData_FIFO.lpm_hint\t\t= \"MAXIMIZE_SPEED=7\",\n\tData_FIFO.lpm_numwords\t\t= 128,\n\tData_FIFO.lpm_showahead\t\t= \"ON\",\n\tData_FIFO.lpm_type\t\t= \"dcfifo\",\n\tData_FIFO.lpm_width\t\t= DW + 3,\n\tData_FIFO.lpm_widthu\t\t= 7,\n\tData_FIFO.overflow_checking\t= \"OFF\",\n\tData_FIFO.rdsync_delaypipe\t\t= 5,\n\tData_FIFO.underflow_checking\t= \"OFF\",\n\tData_FIFO.use_eab\t\t= \"ON\",\n\tData_FIFO.wrsync_delaypipe\t\t= 5;\nendmodule"}
{"task_id": 1283, "completion": "input [`FORMAT_WORD_WIDTH-1:0] operand_in;  \n    output reg sign_out, isZero_out, isInf_out, isNan_out, isDenorm_out; \n    output reg [32:0] operand_out; //operand with leading significand bit included\n    reg sign; \n    reg [`FORMAT_EXP_WIDTH-1:0] exp; \n    reg [`FORMAT_FRAC_WIDTH-1:0] frac; \n    reg expIsMax, expIsNonZero, fracIsNonZero; \n    always @(operand_in) begin \n        sign = operand_in[`FORMAT_WORD_WIDTH-1]; //[31] \n        exp   = operand_in[(`FORMAT_WORD_WIDTH-2):(`FORMAT_WORD_WIDTH-`FORMAT_EXP_WIDTH-1)]; // [30:23] \n        frac  = operand_in[(`FORMAT_FRAC_WIDTH-1):0]; // [22:0] \n        expIsMax = &(exp); \n        expIsNonZero = |(exp); \n        fracIsNonZero = |(frac); \n        sign_out      = sign; \n        isZero_out    = ~expIsMax & ~expIsNonZero & ~fracIsNonZero; \n        isInf_out     = expIsMax & (~fracIsNonZero); \n        isNan_out     = expIsMax & fracIsNonZero; \n        isDenorm_out  = ~expIsMax & ~expIsNonZero & fracIsNonZero; \n        operand_out = (isDenorm_out) ? {sign, exp, 1'b0, frac} : {sign, exp, 1'b1, frac}; \n    end  \nendmodule"}
{"task_id": 1263, "completion": "wire [1024:0] _TECHMAP_DO_ = \"splitnets CARRY; clean\";\n\n        (* force_downto *)\n        wire [Y_WIDTH-1:0] A_buf, B_buf;\n        \\$pos #(.A_SIGNED(A_SIGNED), .A_WIDTH(A_WIDTH), .Y_WIDTH(Y_WIDTH)) A_conv (.A(A), .Y(A_buf));\n        \\$pos #(.A_SIGNED(B_SIGNED), .A_WIDTH(B_WIDTH), .Y_WIDTH(Y_WIDTH)) B_conv (.A(B), .Y(B_buf));\n\n        (* force_downto *)\n        wire [Y_WIDTH-1:0] AA = A_buf;\n        (* force_downto *)\n        wire [Y_WIDTH-1:0] BB = BI ? ~B_buf : B_buf;\n\twire [Y_WIDTH: 0 ] CARRY;\n\n\tassign CO[Y_WIDTH-1:0] = CARRY[Y_WIDTH:1];\n\tgenerate\n\t     adder intermediate_adder (\n\t       .cin     ( ),\n\t       .cout    (CARRY[0]),\n\t       .a       (CI     ),\n\t       .b       (CI     ),\n\t       .sumout  (      )\n\t     );\n\n\t     adder first_adder (\n\t       .cin     (CARRY[0]),\n\t       .cout    (CARRY[1]),\n\t       .a       (AA[0]  ),\n\t       .b       (BB[0]  ),\n\t       .sumout  (Y[0]   )\n\t     );\n\tendgenerate\n\n\tgenvar i;\n\tgenerate for (i = 1; i < Y_WIDTH ; i = i+1) begin:gen3\n\t     adder my_adder (\n\t       .cin     (CARRY[i]  ),\n\t       .cout    (CARRY[i+1]),\n\t       .a       (AA[i]     ),\n\t       .b       (BB[i]     ),\n\t       .sumout  (Y[i]      )\n\t     );\n\tend endgenerate\n\tassign X = AA ^ BB;\nendmodule"}
{"task_id": 1234, "completion": "reg [15:0]  identify;\n    reg [7:0] ingress;\n    reg [127:0] rloc_src, eid_dst;\n    reg [71:0]  metadata_parser;\n    reg [7:0] ip_protocol;\n    reg [127:0] ip_src_1, ip_src_2, ip_src_3, ip_src_4, ip_src_5, ip_src_6, ip_src_7, ip_src_8;\n    reg [127:0] ip_src_match;\n    reg [3:0] parser_state;\n    parameter idle = 4'd0,\n              parser_ip_src = 4'd1,\n              parser_ip_dst = 4'd2,\n              parser_udp = 4'd3,\n              parser_lisp_flag = 4'd4,\n              parser_eth_2 = 4'd5,\n              parser_eid_src = 4'd6,\n              parser_eid_dst = 4'd7,\n              parser_udp_2 = 4'd8,\n              trans_payload_notlisp = 4'd9,\n              trans_pkt_controller = 4'd10,\n              trans_payload = 4'd11,\n              discard = 4'd12,\n              discard_notlisp = 4'd13;\n    reg cdp2um_state;\n    always @ (posedge clk or negedge reset)\n    if(!reset) begin\n        um2cdp_tx_enable <= 1'b1;\n        cdp2um_state <= 1'b0;\n        um2cdp_path <= 1'b0;\n    end\n    else begin\n        case(cdp2um_state)\n            1'b0: begin\n                if((cdp2um_data_valid == 1'b0) && (buf_addr_full == 1'b0)) begin\n                    um2cdp_tx_enable <= 1'b1;\n                    cdp2um_state <= 1'b1;\n                end\n                else begin\n                    um2cdp_tx_enable <= 1'b0;\n                end\n            end\n            1'b1: begin\n                if(cdp2um_data_valid == 1'b1) begin\n                    um2cdp_tx_enable <= 1'b0;\n                    cdp2um_state <= 1'b0;\n                end\n            end\n        endcase\n    end\n    always @ (posedge clk or negedge reset)\n    if(!reset) begin\n        input_count <= 8'b0;\n        p0_a_count <= 8'b0;\n        p0_b_count <= 8'b0;\n        input_nobody_count <= 8'b0;\n        ingress <= 8'b0;\n        rloc_src <= 128'b0;\n        eid_dst <= 128'b0;\n        metadata_parser <= 72'b0;\n        pkt_metadata <= 360'b0;\n        pkt_metadata_valid <= 1'b0;\n        pkt_head_valid <= 1'b0;\n        pkt_head <= 139'b0;\n        pkt_payload_valid <= 1'b0;\n        pkt_payload <= 139'b0;\n        identify <= 16'b0;\n        ip_src_match <= 128'b0;\n        parser_state <= idle;\n    end\n    else begin\n        case(parser_state)\n            idle: begin\n                pkt_head_valid <= 1'b0;\n                pkt_payload_valid <= 1'b0;\n                pkt_metadata_valid <= 1'b0;\n                if(cdp2um_data_valid == 1'b1) begin\n                    if((cdp2um_data[138:136] == 3'b101) && (cdp2um_data[31:16] == 16'h86dd)) begin\n                        parser_state <= parser_ip_src;\n                        ingress <= {4'b0, cdp2um_data[131:128]};\n                        metadata_parser[63:48] <= cdp2um_data[15:0];\n                        pkt_head_valid <= 1'b1;\n                        pkt_head <= cdp2um_data;\n                    end\n                    else begin\n                        pkt_head_valid <= 1'b0;\n                        parser_state <= discard;\n                    end\n                end\n                else begin\n                    parser_state <= idle;\n                    pkt_head_valid <= 1'b0;\n                end\n            end\n            parser_ip_src: begin\n                pkt_head <= {3'b100, cdp2um_data[135:0]};\n                pkt_head_valid <= 1'b1;\n                rloc_src[127:48] <= cdp2um_data[79:0];\n                metadata_parser[47:0] <= cdp2um_data[127:80];\n                ip_protocol <= cdp2um_data[95:88];\n                switch(ingress[2:0]) {\n                    3'd0: ip_src_match <= ip_src_1;\n                    3'd1: ip_src_match <= ip_src_2;\n                    3'd2: ip_src_match <= ip_src_3;\n                    3'd3: ip_src_match <= ip_src_4;\n                    3'd4: ip_src_match <= ip_src_5;\n                    3'd5: ip_src_match <= ip_src_6;\n                    3'd6: ip_src_match <= ip_src_7;\n                    3'd7: ip_src_match <= ip_src_8;\n                }\n                parser_state <= parser_ip_dst;\n            end\n            parser_ip_dst: begin\n                pkt_head <= {3'b100, cdp2um_data[135:0]};\n                pkt_head_valid <= 1'b1;\n                rloc_src[47:0] <= cdp2um_data[127:80];\n                eid_dst[127:48] <= cdp2um_data[79:0];\n                parser_state <= parser_udp;\n            end\n            parser_udp: begin\n                switch(ingress[2:0]) {\n                    3'd0: {\n                        if({eid_dst[127:48], cdp2um_data[127:80]} != ip_src_1) {\n                            pkt_metadata_valid <= 1'b1;\n                            pkt_metadata <= {4'b1000, 356'b0};\n                            pkt_head_valid <= 1'b1;\n                            if((cdp2um_data[138:136] == 3'b110) || (cdp2um_data_valid == 1'b0)) {\n                                pkt_head <= {3'b110, cdp2um_data[135:0]};\n                                parser_state <= idle;\n                            }\n                            else {\n                                pkt_head <= {3'b100, cdp2um_data[135:0]};\n                                parser_state <= trans_pkt_controller;\n                            }\n                        }\n                        else {\n                            if((ip_protocol == 8'd17) && (cdp2um_data[63:48] == 16'd4341)) {\n                                parser_state <= parser_lisp_flag;\n                                p0_a_count <= p0_a_count + 1'b1;\n                                pkt_head_valid <= 1'b1;\n                                pkt_head <= {3'b100, cdp2um_data[135:0]};\n                                pkt_metadata_valid <= 1'b0;\n                                metadata_parser[71:64] <= {2'b11, 6'b0};\n                            }\n                            else {\n                                pkt_metadata_valid <= 1'b1;\n                                pkt_metadata <= {4'b1000, 356'b0};\n                                pkt_head_valid <= 1'b1;\n                                if((cdp2um_data[138:136] == 3'b110) || (cdp2um_data_valid == 1'b0)) {\n                                    pkt_head <= {3'b110, cdp2um_data[135:0]};\n                                    parser_state <= idle;\n                                }\n                                else {\n                                    pkt_head <= {3'b100, cdp2um_data[135:0]};\n                                    parser_state <= trans_pkt_controller;\n                                }\n                            }\n                        }\n                    }\n                    default: {\n                        if({eid_dst[127:48], cdp2um_data[127:80]} == ip_src_match) {\n                            pkt_metadata_valid <= 1'b1;\n                            pkt_metadata <= {2'b01, 358'b0};\n                            pkt_head_valid <= 1'b1;\n                            if((cdp2um_data[138:136] == 3'b110) || (cdp2um_data_valid == 1'b0)) {\n                                pkt_head <= {3'b110, cdp2um_data[135:0]};\n                                parser_state <= idle;\n                            }\n                            else {\n                                pkt_head <= {3'b100, cdp2um_data[135:0]};\n                                parser_state <= trans_pkt_controller;\n                            }\n                        }\n                        else {\n                            pkt_head_valid <= 1'b1;\n                            if((cdp2um_data[138:136] == 3'b110) || (cdp2um_data_valid == 1'b0)) {\n                                pkt_head <= {3'b110, cdp2um_data[135:0]};\n                                pkt_metadata_valid <= 1'b1;\n                                input_nobody_count <= input_nobody_count + 1'b1;\n                                pkt_metadata <= {4'h1, 4'b0, 16'b0, ingress, rloc_src, eid_dst, metadata_parser};\n                                parser_state <= idle;\n                            }\n                            else {\n                                pkt_head <= {3'b110, cdp2um_data[135:0]};\n                                input_count <= 8'd1 + input_count;\n                                parser_state <= trans_payload_notlisp;\n                            }\n                        }\n                    }\n                }\n            end\n            parser_lisp_flag: {\n                pkt_head <= {3'b100, cdp2um_data[135:0]};\n                if(cdp2um_data[79:72] == 8'd1) {\n                    if(cdp2um_data[48] == 1'b1) {\n                        identify <= cdp2um_data[71:56];\n                        p0_b_count <= p0_b_count + 1'b1;\n                        pkt_metadata <= {4'b0, 4'b1100, cdp2um_data[71:56], ingress, rloc_src, eid_dst, metadata_parser};\n                    }\n                    else {\n                        identify <= cdp2um_data[71:56];\n                        pkt_metadata <= {4'b0, 4'b1000, cdp2um_data[71:56], ingress, rloc_src, eid_dst, metadata_parser};\n                    }\n                }\n                else {\n                    pkt_metadata <= {8'b0, 16'b0, ingress, rloc_src, eid_dst, metadata_parser};\n                }\n                parser_state <= parser_eth_2;\n            end\n            parser_eth_2: {\n                pkt_head_valid <= 1'b1;\n                pkt_head <= {3'b100, cdp2um_data[135:0]};\n                parser_state <= parser_eid_src;\n            end\n            parser_eid_src: {\n                pkt_head <= {3'b100, cdp2um_data[135:0]};\n                parser_state <= parser_eid_dst;\n            end\n            parser_eid_dst: {\n                pkt_head_valid <= 1'b1;\n                pkt_head <= {3'b100, cdp2um_data[135:0]};\n                eid_dst[127:48] <= cdp2um_data[79:0];\n                parser_state <= parser_udp_2;\n            end\n            parser_udp_2: {\n                pkt_head_valid <= 1'b1;\n                pkt_metadata_valid <= 1'b1;\n                eid_dst[47:0] <= cdp2um_data[127:80];\n                if(cdp2um_data[138:136] == 3'b110) {\n                    pkt_head <= {3'b110, cdp2um_data[135:0]};\n                    parser_state <= idle;\n                    pkt_metadata <= {4'h1, pkt_metadata[355:200], eid_dst[127:48], cdp2um_data[127:80], metadata_parser};\n                }\n                else {\n                    pkt_head <= {3'b110, cdp2um_data[135:0]};\n                    parser_state <= trans_payload;\n                    pkt_metadata <= {4'h0, pkt_metadata[355:200], eid_dst[127:48], cdp2um_data[127:80], metadata_parser};\n                }\n            end\n            trans_payload_notlisp: {\n                if(metadata_parser[31:16] > 16'd1300) {\n                    pkt_metadata <= {4'h2, 4'b0, 16'b0, ingress, rloc_src, eid_dst, metadata_parser};\n                }\n                else {\n                    pkt_metadata <= {8'b0, 16'b0, ingress, rloc_src, eid_dst, metadata_parser};\n                }\n                pkt_metadata_valid <= 1'b1;\n                pkt_head_valid <= 1'b0;\n                pkt_payload_valid <= 1'b1;\n                if((cdp2um_data_valid == 1'b0) || (cdp2um_data[138:136] == 3'b110)) {\n                    parser_state <= idle;\n                    pkt_payload <= {3'b110, cdp2um_data[135:0]};\n                }\n                else {\n                    parser_state <= trans_payload;\n                    pkt_payload <= {3'b100, cdp2um_data[135:0]};\n                }\n            end\n            trans_payload: {\n                pkt_head_valid <= 1'b0;\n                pkt_metadata_valid <= 1'b0;\n                pkt_payload_valid <= 1'b1;\n                if((cdp2um_data_valid == 1'b0) || (cdp2um_data[138:136] == 3'b110)) {\n                    parser_state <= idle;\n                    pkt_payload <= {3'b110, cdp2um_data[135:0]};\n                }\n                else {\n                    parser_state <= trans_payload;\n                    pkt_payload <= {3'b100, cdp2um_data[135:0]};\n                }\n            end\n            trans_pkt_controller: {\n                pkt_metadata_valid <= 1'b0;\n                if((cdp2um_data_valid == 1'b0) || (cdp2um_data[138:136] == 3'b110)) {\n                    parser_state <= idle;\n                    pkt_head <= {3'b110, cdp2um_data[135:0]};\n                }\n                else {\n                    parser_state <= trans_pkt_controller;\n                    pkt_head <= {3'b100, cdp2um_data[135:0]};\n                }\n            end\n            discard: {\n                if(cdp2um_data[138:136] == 3'b110) parser_state <= idle;\n            end\n            default: {\n                parser_state <= idle;\n            }\n        endcase\n    end\n    always @ (posedge clk or negedge reset)\n    if(!reset) begin\n        ip_src_2 <= 128'b0; ip_src_3 <= 128'b0; ip_src_4 <= 128'b0;\n        ip_src_5 <= 128'b0; ip_src_6 <= 128'b0; ip_src_7 <= 128'b0; ip_src_8 <= 128'b0;\n    end\n    else begin\n        if(ip_src_valid == 1'b1) {\n            switch(ip_src[130:128]) {\n                3'd0: ip_src_1 <= ip_src[127:0];\n                3'd1: ip_src_2 <= ip_src[127:0];\n                3'd2: ip_src_3 <= ip_src[127:0];\n                3'd3: ip_src_4 <= ip_src[127:0];\n                3'd4: ip_src_5 <= ip_src[127:0];\n                3'd5: ip_src_6 <= ip_src[127:0];\n                3'd6: ip_src_7 <= ip_src[127:0];\n                3'd7: ip_src_8 <= ip_src[127:0];\n            }\n        }\n    end\nendmodule"}
{"task_id": 1287, "completion": "reg [127:0] shifter;\nreg [6:0] wrpointer;\nwire sel;\n\nassign sel = sel_akiko && address_in[7:1]==8'b0011_100;\n\nalways @(posedge clk)\n\tif (reset)\n\t\twrpointer <= 0;\n\telse if (!rd && sel)  \n\tbegin\n\t\tcase(wrpointer)\n\t\t\t0\t: shifter[127:112] <= data_in[15:0];\n\t\t\t1\t: shifter[111:96] <= data_in[15:0];\n\t\t\t2\t: shifter[95:80] <= data_in[15:0];\n\t\t\t3\t: shifter[79:64] <= data_in[15:0];\n\t\t\t4\t: shifter[63:48] <= data_in[15:0];\n\t\t\t5\t: shifter[47:32] <= data_in[15:0];\n\t\t\t6\t: shifter[31:16] <= data_in[15:0];\n\t\t\t7  : shifter[15:0] <= data_in[15:0];\n\t\tendcase\n\t\twrpointer <= wrpointer + 1;\n\tend\n\telse if (rd && sel)  \n\tbegin\n\t\tshifter[127:0] <= {shifter[126:0],1'b0};\n\t\twrpointer <= 0;\n\tend\n\nassign data_out[15:0] = sel_akiko && rd ? {shifter[127],shifter[119],shifter[111],shifter[103],shifter[95],shifter[87],\n\t\tshifter[79],shifter[71],shifter[63],shifter[55],shifter[47],shifter[39],shifter[31],\n\t\tshifter[23],shifter[15],shifter[7]} : 16'b0 ;\n\nendmodule"}
{"task_id": 1289, "completion": "reg [15:0] count;\n\n    always @ (posedge clk_i, negedge reset_n)            \n        begin\n            count <= count + 1;                        \n            if(!reset_n)\n                begin\n                    clk_o <= 0;\n                    count <= 0;\n                end\n            else\n                if(count >= 17333)                    \n                    begin\n                        clk_o <= ~clk_o;    \n                        count <= 0;                    \n                    end\n        end\n\nendmodule"}
{"task_id": 1291, "completion": "wire ns_l ;\n wire L_11 ;\n wire L_12 ;\n wire L_13 ;\n wire L_14 ;\n wire L_15 ;\n wire L_16 ;\n wire nL_14 ;\n\n INV I0 (ns_l, is_l);\n INV I1 (nL_14, L_14);\n\n AND2 I2 (Em, iv_l, ns_l);\n AND2 I3 (Es, L_12, nL_14);\n\n AND2 I4 (L_13, os_r, ov_r);\n AND2 I5 (L_16, L_12, L_14);\n\n OR2 I6 (L_11, iv_l, is_l);\n OR2 I7 (L_15, L_12, L_14);\n\n SRLOR_L I8 (L_12, L_11, clk, reset);\n SRLOR_L I9 (L_14, L_13, clk, reset);\n\n SRLOR_H I10 (ov_r, L_15, clk, reset);\n SRLOR_H I11 (is_l, L_16, clk, reset);\n\nendmodule"}
{"task_id": 1251, "completion": "reg [15-1:0] error;    always @(posedge clk_i) begin     if (rstn_i == 1'b0) begin        error <= 15'h0;     end     else begin        error <= $signed(set_sp_i) - $signed(dat_i);     end    end    reg [29-PSR-1:0] kp_reg;    wire [29-1:0] kp_mult;    always @(posedge clk_i) begin     if (rstn_i == 1'b0) begin        kp_reg <= {29-PSR{1'b0}};     end     else begin        kp_reg <= kp_mult[29-1:PSR];     end    end    assign kp_mult = $signed(error) * $signed(set_kp_i);    reg [29-1:0] ki_mult;    wire [33-1:0] int_sum;    reg [32-1:0] int_reg;    wire [32-ISR-1:0] int_shr;    always @(posedge clk_i) begin     if (rstn_i == 1'b0) begin        ki_mult <= {29{1'b0}};        int_reg <= {32{1'b0}};     end     else begin        ki_mult <= $signed(error) * $signed(set_ki_i);        if (int_rst_i)           int_reg <= 32'h0; // reset        else if (int_sum[33-1:33-2] == 2'b01)           int_reg <= 32'h7FFFFFFF; // max positive        else if (int_sum[33-1:33-2] == 2'b10)           int_reg <= 32'h80000000; // max negative        else           int_reg <= int_sum[32-1:0]; // use sum as it is     end    end    assign int_sum = $signed(ki_mult) + $signed(int_reg);    assign int_shr = int_reg[32-1:ISR];    wire [29-1:0] kd_mult;    reg [29-DSR-1:0] kd_reg;    reg [29-DSR-1:0] kd_reg_r;    reg [29-DSR:0] kd_reg_s;    always @(posedge clk_i) begin     if (rstn_i == 1'b0) begin        kd_reg <= {29-DSR{1'b0}};        kd_reg_r <= {29-DSR{1'b0}};        kd_reg_s <= {29-DSR+1{1'b0}};     end     else begin        kd_reg <= kd_mult[29-1:DSR];        kd_reg_r <= kd_reg;        kd_reg_s <= $signed(kd_reg) - $signed(kd_reg_r);     end    end    assign kd_mult = $signed(error) * $signed(set_kd_i);    wire [33-1:0] pid_sum;    reg [14-1:0] pid_out;    always @(posedge clk_i) begin     if (rstn_i == 1'b0) begin        pid_out <= 14'b0;     end     else begin        if ({pid_sum[33-1],|pid_sum[32-2:13]} == 2'b01)           pid_out <= 14'h1FFF;        else if ({pid_sum[33-1],&pid_sum[33-2:13]} == 2'b10)           pid_out <= 14'h2000;        else           pid_out <= pid_sum[14-1:0];     end    end    assign pid_sum = $signed(kp_reg) + $signed(int_shr) + $signed(kd_reg_s);    assign dat_o = pid_out;  endmodule"}
{"task_id": 1288, "completion": "input\t\tclk;\n\tinput\t\trst;\n\tinput\t\tdu_stall;\n\tinput\t\tspr_cs;\n\tinput\t\tspr_write;\n\tinput\t[31:0]\tspr_addr;\n\tinput\t[31:0]\tspr_dat_i;\n\toutput\t[31:0]\tspr_dat_o;\n\toutput\t\tintr;\n\n`ifdef OR1200_TT_IMPLEMENTED\n\n\t`ifdef OR1200_TT_TTMR\nreg\t[31:0]\tttmr;\n`else\nwire\t[31:0]\tttmr;\n`endif\n\n\t`ifdef OR1200_TT_TTCR\nreg\t[31:0]\tttcr;\n`else\nwire\t[31:0]\tttcr;\n`endif\n\n\twire\t\tttmr_sel;\n\twire\t\tttcr_sel;\n\twire\t\tmatch;\n\twire\t\trestart;\n\twire\t\tstop;\n\treg\t[31:0]\tspr_dat_o;\n\n\tassign ttmr_sel = (spr_cs && (spr_addr[`OR1200_TTOFS_BITS] == `OR1200_TT_OFS_TTMR)) ? 1'b1 : 1'b0;\n\tassign ttcr_sel = (spr_cs && (spr_addr[`OR1200_TTOFS_BITS] == `OR1200_TT_OFS_TTCR)) ? 1'b1 : 1'b0;\n\n\t`ifdef OR1200_TT_TTMR\nalways @(posedge clk or posedge rst)\n\tif (rst)\n\t\tttmr <= 32'b0;\n\telse if (ttmr_sel && spr_write)\n\t\tttmr <= #1 spr_dat_i;\n\telse if (ttmr[`OR1200_TT_TTMR_IE])\n\t\tttmr[`OR1200_TT_TTMR_IP] <= #1 ttmr[`OR1200_TT_TTMR_IP] | (match & ttmr[`OR1200_TT_TTMR_IE]);\n`else\nassign ttmr = {2'b11, 30'b0};\n`endif\n\n\t`ifdef OR1200_TT_TTCR\nalways @(posedge clk or posedge rst)\n\tif (rst)\n\t\tttcr <= 32'b0;\n\telse if (restart)\n\t\tttcr <= #1 32'b0;\n\telse if (ttcr_sel && spr_write)\n\t\tttcr <= #1 spr_dat_i;\n\telse if (!stop)\n\t\tttcr <= #1 ttcr + 32'd1;\n`else\nassign ttcr = 32'b0;\n`endif\n\n\talways @(spr_addr or ttmr or ttcr)\n\tcase (spr_addr[`OR1200_TTOFS_BITS])\n\t`ifdef OR1200_TT_READREGS\n\t\t`OR1200_TT_OFS_TTMR: spr_dat_o = ttmr;\n\t`endif\n\t\tdefault: spr_dat_o = ttcr;\n\tendcase\n\n\tassign match = (ttmr[`OR1200_TT_TTMR_TP] == ttcr[27:0]) ? 1'b1 : 1'b0;\n\n\tassign restart = match && (ttmr[`OR1200_TT_TTMR_M] == 2'b01);\n\n\tassign stop = match & (ttmr[`OR1200_TT_TTMR_M] == 2'b10) | (ttmr[`OR1200_TT_TTMR_M] == 2'b00) | du_stall;\n\n\tassign intr = ttmr[`OR1200_TT_TTMR_IP];\n\n`else\n\n\tassign intr = 1'b0;\n\n\t`ifdef OR1200_TT_READREGS\nassign spr_dat_o = 32'b0;\n`endif\n\n`endif\nendmodule"}
{"task_id": 1295, "completion": "xlslice #(\n    .DIN_WIDTH(32),\n    .DIN_FROM(30),\n    .DIN_TO(7)\n  ) inst (\n    .Din(Din),\n    .Dout(Dout)\n  );\nendmodule"}
{"task_id": 1264, "completion": "`include \"c_functions.v\"\n   `include \"c_constants.v\"\n   parameter num_ports = 8;\n   parameter num_priorities = 1;\n   parameter skip_empty_diags = 0;\n   localparam port_idx_width = clogb(num_ports);\n   parameter reset_type = `RESET_TYPE_ASYNC;\n   input clk;\n   input reset;\n   input active;\n   input [0:num_priorities*num_ports*num_ports-1] req_pr;\n   output [0:num_priorities*num_ports*num_ports-1] gnt_pr;\n   wire [0:num_priorities*num_ports*num_ports-1] gnt_pr;\n   output [0:num_ports*num_ports-1] gnt;\n   wire [0:num_ports*num_ports-1] gnt;\n   input update;\n   wire [0:port_idx_width-1] prio_next;\n   wire [0:port_idx_width-1] prio_s, prio_q;\n   assign prio_s = update ? prio_next : prio_q;\n   c_dff #(.width(port_idx_width), .reset_type(reset_type)) prioq (.clk(clk), .reset(reset), .active(active), .d(prio_s), .q(prio_q));\n   generate\n      wire [0:num_priorities*num_ports-1] first_diag_pr;\n      if(skip_empty_diags)\n      begin\n         wire [0:num_ports-1] first_diag;\n         if(num_priorities == 1)\n            assign first_diag = first_diag_pr;\n         else if(num_priorities > 1)\n         begin\n            wire [0:num_priorities-1] any_req_pr;\n            c_reduce_bits #(.num_ports(num_priorities), .width(num_ports), .op(`BINARY_OP_OR)) any_req_pr_rb (.data_in(first_diag_pr), .data_out(any_req_pr));\n            wire [0:num_priorities-1] any_req_mod_pr;\n            assign any_req_mod_pr = {any_req_pr[0:num_priorities-2], 1'b1};\n            wire [0:num_priorities-1] sel_pr;\n            c_lod #(.width(num_priorities)) sel_pr_lod (.data_in(any_req_mod_pr), .data_out(sel_pr));\n            c_select_1ofn #(.num_ports(num_priorities), .width(num_ports)) prio_next_sel (.select(sel_pr), .data_in(first_diag_pr), .data_out(first_diag));\n         end\n         c_encode #(.num_ports(num_ports), .offset(1)) prio_next_enc (.data_in(first_diag), .data_out(prio_next));\n      end\n      else\n      begin\n         c_incr #(.width(port_idx_width), .min_value(0), .max_value(num_ports-1)) prio_next_incr (.data_in(prio_q), .data_out(prio_next));\n      end\n      wire [0:num_priorities*num_ports*num_ports-1] gnt_intm_pr;\n      assign gnt = gnt_intm_pr[(num_priorities-1)*num_ports*num_ports:num_priorities*num_ports*num_ports-1];\n      genvar pr;\n      for(pr = 0; pr < num_priorities; pr = pr + 1)\n      begin:prs\n         wire [0:num_ports*num_ports-1] req;\n         assign req = req_pr[pr*num_ports*num_ports:(pr+1)*num_ports*num_ports-1];\n         if(skip_empty_diags)\n         begin\n            wire [0:num_ports-1] req_on_diag;\n            c_diag_op #(.width(num_ports), .op(`BINARY_OP_OR)) req_on_diag_dop (.data_in(req), .data_out(req_on_diag));\n            wire [0:num_ports-1] prio_port;\n            c_decode #(.num_ports(num_ports)) prio_port_dec (.data_in(prio_q), .data_out(prio_port));\n            wire [0:num_ports-1] first_diag;\n            c_prefix_arbiter_base #(.num_ports(num_ports)) first_diag_pa (.prio_port(prio_port), .req(req_on_diag), .gnt(first_diag));\n            assign first_diag_pr[pr*num_ports:(pr+1)*num_ports-1] = first_diag;\n         end\n         wire [0:num_ports*num_ports-1] gnt_intm_in;\n         if(pr == 0)\n            assign gnt_intm_in = {(num_ports*num_ports){1'b0}};\n         else if(pr > 0)\n            assign gnt_intm_in = gnt_intm_pr[(pr-1)*num_ports*num_ports:pr*num_ports*num_ports-1];\n         wire [0:num_ports-1] row_gnt;\n         c_reduce_bits #(.num_ports(num_ports), .width(num_ports), .op(`BINARY_OP_OR)) row_gnt_rb (.data_in(gnt_intm_in), .data_out(row_gnt));\n         wire [0:num_ports-1] col_gnt;\n         c_binary_op #(.num_ports(num_ports), .width(num_ports), .op(`BINARY_OP_OR)) col_gnt_bop (.data_in(gnt_intm_in), .data_out(col_gnt));\n         wire [0:num_ports*num_ports-1] mask;\n         c_mat_mult #(.dim1_width(num_ports), .dim2_width(1), .dim3_width(num_ports), .prod_op(`BINARY_OP_NOR), .sum_op(`BINARY_OP_OR)) mask_mmult (.input_a(row_gnt), .input_b(col_gnt), .result(mask));\n         wire [0:num_ports*num_ports-1] req_masked;\n         assign req_masked = req & mask;\n         wire [0:num_ports*num_ports-1] gnt;\n         assign gnt_pr[pr*num_ports*num_ports:(pr+1)*num_ports*num_ports-1] = gnt;\n         wire [0:num_ports*num_ports-1] gnt_intm_out;\n         assign gnt_intm_out = gnt_intm_in | gnt;\n         assign gnt_intm_pr[pr*num_ports*num_ports:(pr+1)*num_ports*num_ports-1] = gnt_intm_out;\n         wire [0:num_ports*num_ports-1] y;\n         genvar row;\n         for(row = 0; row < num_ports; row = row + 1)\n         begin:rows\n            wire [0:num_ports-1] req_row;\n            assign req_row = req_masked[row*num_ports:(row+1)*num_ports-1];\n            wire [0:port_idx_width-1] current_row;\n            assign current_row = row;\n            wire [0:num_ports-1] req_tmp;\n            c_rotate #(.width(num_ports), .rotate_dir(`ROTATE_DIR_RIGHT)) req_tmp_rot (.amount(current_row), .data_in(req_row), .data_out(req_tmp));\n            wire [0:num_ports-1] req_in;\n            c_rotate #(.width(num_ports), .rotate_dir(`ROTATE_DIR_LEFT)) req_in_rot (.amount(prio_q), .data_in(req_tmp), .data_out(req_in));\n            wire [0:num_ports-1] x_in, y_in;\n            wire [0:num_ports] x_out, y_out;\n            assign x_in = x_out[0:num_ports-1];\n            assign y_in = y[((row+num_ports)%num_ports)*num_ports:((row+num_ports)%num_ports+1)*num_ports-1];\n            assign x_out = {1'b1, (~y_in | ~req_in) & x_in};\n            assign y_out = {1'b1, (~x_in | ~req_in) & y_in};\n            wire [0:num_ports-1] gnt_out;\n            assign gnt_out = req_in & x_in & y_in;\n            assign y[((row+num_ports+1)%num_ports)*num_ports:((row+num_ports+1)%num_ports+1)*num_ports-1] = y_out[0:num_ports-1];\n            wire [0:num_ports-1] gnt_tmp;\n            c_rotate #(.width(num_ports), .rotate_dir(`ROTATE_DIR_RIGHT)) gnt_tmp_rot (.amount(prio_q), .data_in(gnt_out), .data_out(gnt_tmp));\n            wire [0:num_ports-1] gnt_row;\n            c_rotate #(.width(num_ports), .rotate_dir(`ROTATE_DIR_LEFT)) gnt_row_rot (.amount(current_row), .data_in(gnt_tmp), .data_out(gnt_row));\n            assign gnt[row*num_ports:(row+1)*num_ports-1] = gnt_row;\n         end\n      end\n   endgenerate\nendmodule"}
{"task_id": 1246, "completion": "reg localbus_ack_n;    reg [31:0] localbus_data_out;    wire bv_valid;    wire [35:0] bv;    reg set_valid_1, set_valid_2, set_valid_3;    reg read_valid_1, read_valid_2, read_valid_3;    wire data_out_valid_1, data_out_valid_2, data_out_valid_3;    wire [35:0] data_out_1, data_out_2, data_out_3;    wire [35:0] bv_1, bv_2, bv_3;    wire stage_enable_1, stage_enable_2, stage_enable_3;    reg [3:0] set_state;    parameter idle = 4'd0, ram_set = 4'd1, ram_read = 4'd2, wait_read = 4'd3, wait_back = 4'd4;    reg [31:0] localbus_addr;    reg [44:0] set_data;    reg [12:0] set_data_1;    reg [35:0] data_out;    reg [8:0] read_addr;    always @ (posedge clk or negedge reset)    begin        if(!reset)        begin            set_state <= idle;            set_valid_1 <= 1'b0; set_valid_2 <= 1'b0; set_valid_3 <= 1'b0;            read_valid_1 <= 1'b0; read_valid_2 <= 1'b0; read_valid_3 <= 1'b0;            localbus_addr <= 32'b0;            data_out <= 36'd0;            set_data <= 45'b0;            set_data_1 <= 13'b0;            read_addr <= 9'b0;            localbus_data_out <= 32'b0;            localbus_ack_n <= 1'b1;        end        else        begin            case(set_state)                idle:                begin                    if(localbus_ale == 1'b1)                    begin                        localbus_addr <= localbus_data;                        if(localbus_rd_wr == 1'b0)                        begin                            set_state <= ram_set;                        end                        else                        begin                            set_state <= ram_read;                        end                    end                end                ram_set:                begin                    if(localbus_cs_n == 1'b0)                    begin                        case(localbus_addr[0])                            1'd0: set_data_1 <= {localbus_addr[11:3], localbus_data[31], localbus_data[2:0]};                            1'd1:                            begin                                set_data <= {set_data_1, localbus_data};                                case(localbus_addr[13:12])                                    3'd0: set_valid_1 <= 1'b1;                                    3'd1: set_valid_2 <= 1'b1;                                    3'd2: set_valid_3 <= 1'b1;                                    3'd3: set_valid_3 <= 1'b0;                                endcase                            end                        endcase                        set_state <= wait_back;                        localbus_ack_n <= 1'b0;                    end                end                ram_read:                begin                    if(localbus_cs_n == 1'b0)                    begin                        case(localbus_addr[0])                            1'b0:                            begin                                read_addr <= localbus_addr[11:3];                                case(localbus_addr[13:12])                                    3'd0: read_valid_1 <= 1'b1;                                    3'd1: read_valid_2 <= 1'b1;                                    3'd2: read_valid_3 <= 1'b1;                                    3'd3: read_valid_3 <= 1'b1;                                endcase                            end                            1'b1: localbus_data_out <= data_out[31:0];                        endcase                        if(localbus_addr[0] == 1'b0)                        begin                            set_state <= wait_read;                        end                        else                        begin                            set_state <= wait_back;                            localbus_ack_n <= 1'b0;                        end                    end                end                wait_read:                begin                    read_valid_1 <= 1'b0; read_valid_2 <= 1'b0; read_valid_3 <= 1'b0;                    if((data_out_valid_1 == 1'b1) || (data_out_valid_2 == 1'b1) || (data_out_valid_3 == 1'b1))                    begin                        case({data_out_valid_1, data_out_valid_2, data_out_valid_3})                            3'd4:                            begin                                data_out <= data_out_1;                                localbus_data_out <= {data_out_1[35], 28'b0, data_out_1[34:32]};                            end                            3'd2:                            begin                                data_out <= data_out_2;                                localbus_data_out <= {data_out_2[35], 28'b0, data_out_2[34:32]};                            end                            3'd1:                            begin                                data_out <= data_out_3;                                localbus_data_out <= {data_out_3[35], 28'b0, data_out_3[34:32]};                            end                            default:                            begin                                data_out <= 36'b0;                                localbus_data_out <= 32'b0;                            end                        endcase                        localbus_ack_n <= 1'b0;                        set_state <= wait_back;                    end                end                wait_back:                begin                    set_valid_1 <= 1'b0; set_valid_2 <= 1'b0; set_valid_3 <= 1'b0;                    if(localbus_cs_n == 1'b1)                    begin                        localbus_ack_n <= 1'b1;                        set_state <= idle;                    end                end                default:                begin                    set_state <= idle;                end            endcase        end    end    lookup_9bit stage_1_1(    .clk(clk),    .reset(reset),    .set_valid(set_valid_1),    .set_data(set_data),    .read_valid(read_valid_1),    .read_addr(read_addr),    .data_out_valid(data_out_valid_1),    .data_out(data_out_1),    .key_valid(key_valid),    .key(key[26:18]),    .bv(bv_1),    .stage_enable(stage_enable_1)    );    lookup_9bit stage_1_2(    .clk(clk),    .reset(reset),    .set_valid(set_valid_2),    .set_data(set_data),    .read_valid(read_valid_2),    .read_addr(read_addr),    .data_out_valid(data_out_valid_2),    .data_out(data_out_2),    .key_valid(key_valid),    .key(key[17:9]),    .bv(bv_2),    .stage_enable()    );    lookup_9bit stage_1_3(    .clk(clk),    .reset(reset),    .set_valid(set_valid_3),    .set_data(set_data),    .read_valid(read_valid_3),    .read_addr(read_addr),    .data_out_valid(data_out_valid_3),    .data_out(data_out_3),    .key_valid(key_valid),    .key(key[8:0]),    .bv(bv_3),    .stage_enable()    );    hold1clk stage_2(    .clk(clk),    .reset(reset),    .stage_enable_in(stage_enable_1),    .stage_enable_out(stage_enable_2)    );    bv_and stage_3(    .clk(clk),    .reset(reset),    .stage_enable_in(stage_enable_2),    .stage_enable_out(stage_enable_3),    .bv_1(bv_1),    .bv_2(bv_2),    .bv_3(bv_3),    .bv_valid(bv_valid),    .bv(bv)    );endmodule"}
{"task_id": 1127, "completion": "function integer clogb2 (input integer size);\n    begin\n      size = size - 1;\n      for (clogb2=1; size>1; clogb2=clogb2+1)\n        size = size >> 1;\n    end\n  endfunction\n  localparam PRBS_SEQ_LEN_CYCLES = 128;\n  localparam PRBS_SEQ_LEN_CYCLES_BITS = clogb2(PRBS_SEQ_LEN_CYCLES);\n  reg phy_if_empty_r;\n  reg reseed_prbs_r;\n  reg [PRBS_SEQ_LEN_CYCLES_BITS-1:0] sample_cnt_r;\n  reg [PRBS_WIDTH - 1 :0] prbs;\n  reg [PRBS_WIDTH :1] lfsr_q;\n  always @(posedge clk_i) begin\n    phy_if_empty_r <= #TCQ phy_if_empty;\n  end\n  always @(posedge clk_i) begin\n    if (rst_i || ~clk_en_i) begin\n      sample_cnt_r <= #TCQ 'b0;\n      reseed_prbs_r <= #TCQ 1'b0;\n    end else if (clk_en_i && (~phy_if_empty_r || ~prbs_rdlvl_start)) begin\n      sample_cnt_r <= #TCQ sample_cnt_r + 1;\n      if (sample_cnt_r == PRBS_SEQ_LEN_CYCLES - 2)\n        reseed_prbs_r <= #TCQ 1'b1;\n      else\n        reseed_prbs_r <= #TCQ 1'b0;\n    end\n  end\n  always @ (posedge clk_i) begin\n    if ((reseed_prbs_r && clk_en_i) || rst_i || ~clk_en_i) begin\n      lfsr_q[4:1] <= #TCQ prbs_seed_i[3:0] | 4'h5;\n      lfsr_q[PRBS_WIDTH:5] <= #TCQ prbs_seed_i[PRBS_WIDTH-1:4];\n    end else if (clk_en_i && (~phy_if_empty_r || ~prbs_rdlvl_start)) begin\n      lfsr_q[PRBS_WIDTH:31] <= #TCQ lfsr_q[PRBS_WIDTH-1:30];\n      lfsr_q[30] <= #TCQ lfsr_q[16] ^ lfsr_q[13] ^ lfsr_q[5] ^ lfsr_q[1];\n      lfsr_q[29:9] <= #TCQ lfsr_q[28:8];\n      lfsr_q[8] <= #TCQ lfsr_q[32] ^ lfsr_q[7];\n      lfsr_q[7] <= #TCQ lfsr_q[32] ^ lfsr_q[6];\n      lfsr_q[6:4] <= #TCQ lfsr_q[5:3];\n      lfsr_q[3] <= #TCQ lfsr_q[32] ^ lfsr_q[2];\n      lfsr_q[2] <= #TCQ lfsr_q[1];\n      lfsr_q[1] <= #TCQ lfsr_q[32];\n    end\n  end\n  always @ (lfsr_q[PRBS_WIDTH:1]) begin\n    prbs = lfsr_q[PRBS_WIDTH:1];\n  end\n  localparam BRAM_ADDR_WIDTH = 8;\n  localparam BRAM_DATA_WIDTH = 18;\n  localparam BRAM_DEPTH = 256;\n  integer i,j;\n  (* RAM_STYLE = \"distributed\" *) reg [BRAM_ADDR_WIDTH - 1:0] rd_addr;\n  (* RAM_STYLE = \"distributed\" *) reg [BRAM_DATA_WIDTH - 1:0] mem_out;\n  reg [BRAM_DATA_WIDTH - 3:0] dout_o;\n  reg [DQ_WIDTH-1:0] sel;\n  reg [DQ_WIDTH-1:0] dout_rise0;\n  reg [DQ_WIDTH-1:0] dout_fall0;\n  reg [DQ_WIDTH-1:0] dout_rise1;\n  reg [DQ_WIDTH-1:0] dout_fall1;\n  reg [DQ_WIDTH-1:0] dout_rise2;\n  reg [DQ_WIDTH-1:0] dout_fall2;\n  reg [DQ_WIDTH-1:0] dout_rise3;\n  reg [DQ_WIDTH-1:0] dout_fall3;\n  always @ (rd_addr) begin\n    case (rd_addr)\n      8'd0 : mem_out = {2'b11, 8'b10101010,8'b10101010};\n      8'd1 : mem_out = {2'b01, 8'b11001100,8'b11001100};\n      8'd2 : mem_out = {2'b10, 8'b11001100,8'b11001100};\n      8'd3 : mem_out = {2'b01, 8'b11100011,8'b11100011};\n      8'd4 : mem_out = {2'b00, 8'b10001110,8'b10001110};\n      8'd5 : mem_out = {2'b10, 8'b00111000,8'b00111000};\n      8'd6 : mem_out = {2'b01, 8'b11110000,8'b11110000};\n      //... (\u7701\u7565\u7684\u90e8\u5206) ...\n      8'd255 : mem_out = {2'b00, 8'b00000001,8'b00000001};\n    endcase\n  end\n  always @ (posedge clk_i) begin\n    if (rst_i | reset_rd_addr)\n      rd_addr <= #TCQ 'b0;\n    else if (clk_en_i && prbs_rdlvl_done && (~phy_if_empty_r || ~complex_wr_done)) begin\n      if (rd_addr == 'd156) rd_addr <= #TCQ 'b0;\n      else rd_addr <= #TCQ rd_addr + 1;\n    end else if (clk_en_i && (~phy_if_empty_r || (~prbs_rdlvl_start && ~complex_wr_done))) begin\n      if (rd_addr == 'd148) rd_addr <= #TCQ 'b0;\n      else rd_addr <= #TCQ rd_addr + 1;\n    end\n  end\n  always @ (posedge clk_i) begin\n    if ((rd_addr < 42) && VCCO_PAT_EN)\n      dout_o <= #TCQ mem_out[BRAM_DATA_WIDTH-3:0];\n    else if ((rd_addr < 127) && VCCAUX_PAT_EN)\n      dout_o <= #TCQ mem_out[BRAM_DATA_WIDTH-3:0];\n    else if (ISI_PAT_EN && (rd_addr > 126))\n      dout_o <= #TCQ mem_out[BRAM_DATA_WIDTH-3:0];\n    else\n      dout_o <= #TCQ 'd0;\n  end\n  reg prbs_ignore_first_byte_r;\n  always @(posedge clk_i) prbs_ignore_first_byte_r <= #TCQ mem_out[16];\n  assign prbs_ignore_first_byte = prbs_ignore_first_byte_r;\n  reg prbs_ignore_last_bytes_r;\n  always @(posedge clk_i) prbs_ignore_last_bytes_r <= #TCQ mem_out[17];\n  assign prbs_ignore_last_bytes = prbs_ignore_last_bytes_r;\n  generate\n    if (FIXED_VICTIM == \"TRUE\") begin: victim_sel_fixed\n      always @(posedge clk_i)\n        sel <= #TCQ {DQ_WIDTH/8{8'h08}};\n    end else begin: victim_sel_rotate\n      always @(posedge clk_i)\n        if (rst_i)\n          sel <= #TCQ 'd0;\n        else begin\n          for (i = 0; i < DQ_WIDTH/8; i = i+1) begin\n            for (j=0; j <8 ; j = j+1) begin\n              if (j == victim_sel)\n                sel[i*8+j] <= #TCQ 1'b1;\n              else \n                sel[i*8+j] <= #TCQ 1'b0;\n            end\n          end\n        end\n    end\n  endgenerate\n  always @(*)\n    for (i = 0; i < DQ_WIDTH; i = i+1) begin\n      dout_rise0[i] = (dout_o[7]&&sel[i] || dout_o[15]&&~sel[i]);\n      dout_fall0[i] = (dout_o[6]&&sel[i] || dout_o[14]&&~sel[i]);\n      dout_rise1[i] = (dout_o[5]&&sel[i] || dout_o[13]&&~sel[i]);\n      dout_fall1[i] = (dout_o[4]&&sel[i] || dout_o[12]&&~sel[i]);\n      dout_rise2[i] = (dout_o[3]&&sel[i] || dout_o[11]&&~sel[i]);\n      dout_fall2[i] = (dout_o[2]&&sel[i] || dout_o[10]&&~sel[i]);\n      dout_rise3[i] = (dout_o[1]&&sel[i] || dout_o[9]&&~sel[i]);\n      dout_fall3[i] = (dout_o[0]&&sel[i] || dout_o[8]&&~sel[i]);\n    end\n  assign prbs_o = {dout_fall3, dout_rise3, dout_fall2, dout_rise2, dout_fall1, dout_rise1, dout_fall0, dout_rise0};\n  assign dbg_prbs_gen[9] = phy_if_empty_r;\n  assign dbg_prbs_gen[8] = clk_en_i;\n  assign dbg_prbs_gen[7:0] = rd_addr[7:0];\nendmodule"}
{"task_id": 1298, "completion": "input\t\tdin_31_16_eq_0;\ninput\t\tdin_31_24_eq_0;\ninput\t\tlead0_16b_2_hi;\ninput\t\tlead0_16b_1_hi;\ninput\t\tlead0_16b_0_hi;\ninput\t\tdin_15_0_eq_0;\ninput\t\tdin_15_8_eq_0;\ninput\t\tlead0_16b_2_lo;\ninput\t\tlead0_16b_1_lo;\ninput\t\tlead0_16b_0_lo;\n\noutput\t\tdin_31_0_eq_0;\noutput\t\tlead0_32b_3;\noutput\t\tlead0_32b_2;\noutput\t\tlead0_32b_1;\noutput\t\tlead0_32b_0;\n\nwire\t\tdin_31_0_eq_0;\nwire\t\tlead0_32b_3;\nwire\t\tlead0_32b_2;\nwire\t\tlead0_32b_1;\nwire\t\tlead0_32b_0;\n\nassign din_31_0_eq_0= din_15_0_eq_0 && din_31_16_eq_0;\n\nassign lead0_32b_3= ((!din_31_16_eq_0) && din_31_24_eq_0)\n\t\t|| (din_31_16_eq_0 && din_15_8_eq_0);\n\nassign lead0_32b_2= ((!din_31_16_eq_0) && lead0_16b_2_hi)\n\t\t|| (din_31_16_eq_0 && lead0_16b_2_lo);\n\nassign lead0_32b_1= ((!din_31_16_eq_0) && lead0_16b_1_hi)\n\t\t|| (din_31_16_eq_0 && lead0_16b_1_lo);\n\nassign lead0_32b_0= ((!din_31_16_eq_0) && lead0_16b_0_hi)\n\t\t|| (din_31_16_eq_0 && lead0_16b_0_lo);\n\nendmodule"}
{"task_id": 1297, "completion": "reg mode;\n  reg [0:63] key1;\n  reg [0:63] key2;\n  reg [0:63] key3;\n  wire des2_mode;\n  wire des1_validin;\n  wire [0:63] des1_key;\n  wire [0:63] des3_key;\n  wire [0:63] des1_dataout;\n  wire [0:63] des2_dataout;\n  wire des1_validout;\n  wire des2_validout;\n  assign des2_mode = ~mode;\n  assign des1_validin = valid_i & ready_o;\n  assign des1_key = (~mode_i) ? key1_i : key3_i;\n  assign des3_key = (~mode)   ? key3   : key1;\n  always @(posedge clk_i, negedge reset_i) begin\n    if (~reset_i) begin\n      mode  <= 0;\n      key1  <= 0;\n      key2  <= 0;\n      key3  <= 0;\n    end\n    else begin\n      if (valid_i && ready_o) begin\n        mode <= mode_i;\n        key1 <= key1_i;\n        key2 <= key2_i;\n        key3 <= key3_i;\n      end\n    end\n  end\n  always @(posedge clk_i, negedge reset_i) begin\n    if (~reset_i) begin\n      ready_o <= 1;\n    end\n    else begin\n      if (valid_i && ready_o) begin\n        ready_o <= 0;\n      end\n      if (valid_o) begin\n        ready_o <= 1;\n      end\n    end\n  end\n  des i1_des\n  (\n    .reset_i(reset_i),\n    .clk_i(clk_i),\n    .mode_i(mode_i),\n    .key_i(des1_key),\n    .data_i(data_i),\n    .valid_i(des1_validin),\n    .data_o(des1_dataout),\n    .valid_o(des1_validout)\n  );\n  des i2_des\n  (\n    .reset_i(reset_i),\n    .clk_i(clk_i),\n    .mode_i(des2_mode),\n    .key_i(key2),\n    .data_i(des1_dataout),\n    .valid_i(des1_validout),\n    .data_o(des2_dataout),\n    .valid_o(des2_validout)\n  );\n  des i3_des\n  (\n    .reset_i(reset_i),\n    .clk_i(clk_i),\n    .mode_i(mode),\n    .key_i(des3_key),\n    .data_i(des2_dataout),\n    .valid_i(des2_validout),\n    .data_o(data_o),\n    .valid_o(valid_o)\n  );\n\nendmodule"}
{"task_id": 1276, "completion": "FIFO_GENERATOR_V8_4 #(    .C_ADD_NGC_CONSTRAINT(0),    .C_APPLICATION_TYPE_AXIS(0),    .C_APPLICATION_TYPE_RACH(0),    .C_APPLICATION_TYPE_RDCH(0),    .C_APPLICATION_TYPE_WACH(0),    .C_APPLICATION_TYPE_WDCH(0),    .C_APPLICATION_TYPE_WRCH(0),    .C_AXI_ADDR_WIDTH(32),    .C_AXI_ARUSER_WIDTH(1),    .C_AXI_AWUSER_WIDTH(1),    .C_AXI_BUSER_WIDTH(1),    .C_AXI_DATA_WIDTH(64),    .C_AXI_ID_WIDTH(4),    .C_AXI_RUSER_WIDTH(1),    .C_AXI_TYPE(0),    .C_AXIS_TDATA_WIDTH(64),    .C_AXIS_TDEST_WIDTH(4),    .C_AXIS_TID_WIDTH(8),    .C_AXIS_TKEEP_WIDTH(4),    .C_AXIS_TSTRB_WIDTH(4),    .C_AXIS_TUSER_WIDTH(4),    .C_AXIS_TYPE(0),    .C_COMMON_CLOCK(0),    .C_COUNT_TYPE(0),    .C_DATA_COUNT_WIDTH(8),    .C_DEFAULT_VALUE(\"BlankString\"),    .C_DIN_WIDTH(256),    .C_DIN_WIDTH_AXIS(1),    .C_DIN_WIDTH_RACH(32),    .C_DIN_WIDTH_RDCH(64),    .C_DIN_WIDTH_WACH(32),    .C_DIN_WIDTH_WDCH(64),    .C_DIN_WIDTH_WRCH(2),    .C_DOUT_RST_VAL(\"0\"),    .C_DOUT_WIDTH(64),    .C_ENABLE_RLOCS(0),    .C_ENABLE_RST_SYNC(1),    .C_ERROR_INJECTION_TYPE(0),    .C_ERROR_INJECTION_TYPE_AXIS(0),    .C_ERROR_INJECTION_TYPE_RACH(0),    .C_ERROR_INJECTION_TYPE_RDCH(0),    .C_ERROR_INJECTION_TYPE_WACH(0),    .C_ERROR_INJECTION_TYPE_WDCH(0),    .C_ERROR_INJECTION_TYPE_WRCH(0),    .C_FAMILY(\"virtex6\"),    .C_FULL_FLAGS_RST_VAL(0),    .C_HAS_ALMOST_EMPTY(0),    .C_HAS_ALMOST_FULL(0),    .C_HAS_AXI_ARUSER(0),    .C_HAS_AXI_AWUSER(0),    .C_HAS_AXI_BUSER(0),    .C_HAS_AXI_RD_CHANNEL(0),    .C_HAS_AXI_RUSER(0),    .C_HAS_AXI_WR_CHANNEL(0),    .C_HAS_AXI_WUSER(0),    .C_HAS_AXIS_TDATA(0),    .C_HAS_AXIS_TDEST(0),    .C_HAS_AXIS_TID(0),    .C_HAS_AXIS_TKEEP(0),    .C_HAS_AXIS_TLAST(0),    .C_HAS_AXIS_TREADY(1),    .C_HAS_AXIS_TSTRB(0),    .C_HAS_AXIS_TUSER(0),    .C_HAS_BACKUP(0),    .C_HAS_DATA_COUNT(0),    .C_HAS_DATA_COUNTS_AXIS(0),    .C_HAS_DATA_COUNTS_RACH(0),    .C_HAS_DATA_COUNTS_RDCH(0),    .C_HAS_DATA_COUNTS_WACH(0),    .C_HAS_DATA_COUNTS_WDCH(0),    .C_HAS_DATA_COUNTS_WRCH(0),    .C_HAS_INT_CLK(0),    .C_HAS_MASTER_CE(0),    .C_HAS_MEMINIT_FILE(0),    .C_HAS_OVERFLOW(0),    .C_HAS_PROG_FLAGS_AXIS(0),    .C_HAS_PROG_FLAGS_RACH(0),    .C_HAS_PROG_FLAGS_RDCH(0),    .C_HAS_PROG_FLAGS_WACH(0),    .C_HAS_PROG_FLAGS_WDCH(0),    .C_HAS_PROG_FLAGS_WRCH(0),    .C_HAS_RD_DATA_COUNT(1),    .C_HAS_RD_RST(0),    .C_HAS_RST(1),    .C_HAS_SLAVE_CE(0),    .C_HAS_SRST(0),    .C_HAS_UNDERFLOW(0),    .C_HAS_VALID(0),    .C_HAS_WR_ACK(0),    .C_HAS_WR_DATA_COUNT(0),    .C_HAS_WR_RST(0),    .C_IMPLEMENTATION_TYPE(2),    .C_IMPLEMENTATION_TYPE_AXIS(1),    .C_IMPLEMENTATION_TYPE_RACH(1),    .C_IMPLEMENTATION_TYPE_RDCH(1),    .C_IMPLEMENTATION_TYPE_WACH(1),    .C_IMPLEMENTATION_TYPE_WDCH(1),    .C_IMPLEMENTATION_TYPE_WRCH(1),    .C_INIT_WR_PNTR_VAL(0),    .C_INTERFACE_TYPE(0),    .C_MEMORY_TYPE(1),    .C_MIF_FILE_NAME(\"BlankString\"),    .C_MSGON_VAL(1),    .C_OPTIMIZATION_MODE(0),    .C_OVERFLOW_LOW(0),    .C_PRELOAD_LATENCY(0),    .C_PRELOAD_REGS(1),    .C_PRIM_FIFO_TYPE(\"512x72\"),    .C_PROG_EMPTY_THRESH_ASSERT_VAL(4),    .C_PROG_EMPTY_THRESH_ASSERT_VAL_AXIS(1022),    .C_PROG_EMPTY_THRESH_ASSERT_VAL_RACH(1022),    .C_PROG_EMPTY_THRESH_ASSERT_VAL_RDCH(1022),    .C_PROG_EMPTY_THRESH_ASSERT_VAL_WACH(1022),    .C_PROG_EMPTY_THRESH_ASSERT_VAL_WDCH(1022),    .C_PROG_EMPTY_THRESH_ASSERT_NEGATE_VAL(5),    .C_PROG_EMPTY_TYPE(0),    .C_PROG_EMPTY_TYPE_AXIS(5),    .C_PROG_EMPTY_TYPE_RACH(5),    .C_PROG_EMPTY_TYPE_RDCH(5),    .C_PROG_EMPTY_TYPE_WACH(5),    .C_PROG_EMPTY_TYPE_WDCH(5),    .C_PROG_FULL_THRESH_ASSERT_VAL(128),    .C_PROG_FULL_THRESH_ASSERT_VAL_AXIS(1023),    .C_PROG_FULL_THRESH_ASSERT_VAL_RACH(1023),    .C_PROG_FULL_THRESH_ASSERT_VAL_RDCH(1023),    .C_PROG_FULL_THRESH_ASSERT_VAL_WACH(1023),    .C_PROG_FULL_THRESH_ASSERT_VAL_WDCH(1023),    .C_PROG_FULL_THRESH_NEGATE_VAL(127),    .C_PROG_FULL_TYPE(1),    .C_PROG_FULL_TYPE_AXIS(5),    .C_PROG_FULL_TYPE_RACH(5),    .C_PROG_FULL_TYPE_RDCH(5),    .C_PROG_FULL_TYPE_WACH(5),    .C_PROG_FULL_TYPE_WDCH(5),    .C_RACH_TYPE(0),    .C_RD_DATA_COUNT_WIDTH(11),    .C_RD_DEPTH(1024),    .C_RD_FREQ(1),    .C_RD_PNTR_WIDTH(10),    .C_RDCH_TYPE(0),    .C_REG_SLICE_MODE_AXIS(0),    .C_REG_SLICE_MODE_RACH(0),    .C_REG_SLICE_MODE_RDCH(0),    .C_REG_SLICE_MODE_WACH(0),    .C_REG_SLICE_MODE_WDCH(0),    .C_REG_SLICE_MODE_WRCH(0),    .C_SYNCHRONIZER_STAGE(2),    .C_UNDERFLOW_LOW(0),    .C_USE_COMMON_OVERFLOW(0),    .C_USE_COMMON_UNDERFLOW(0),    .C_USE_DEFAULT_SETTINGS(0),    .C_USE_DOUT_RST(1),    .C_USE_ECC(0),    .C_USE_ECC_AXIS(0),    .C_USE_ECC_RACH(0),    .C_USE_ECC_RDCH(0),    .C_USE_ECC_WACH(0),    .C_USE_ECC_WDCH(0),    .C_USE_ECC_WRCH(0),    .C_USE_EMBEDDED_REG(0),    .C_USE_FIFO16_FLAGS(0),    .C_USE_FWFT_DATA_COUNT(1),    .C_VALID_LOW(0),    .C_WACH_TYPE(0),    .C_WDCH_TYPE(0),    .C_WR_ACK_LOW(0),    .C_WR_DATA_COUNT_WIDTH(9),    .C_WR_DEPTH(256),    .C_WR_DEPTH_AXIS(1024),    .C_WR_DEPTH_RACH(16),    .C_WR_DEPTH_RDCH(1024),    .C_WR_DEPTH_WACH(16),    .C_WR_DEPTH_WDCH(1024),    .C_WR_DEPTH_WRCH(16),    .C_WR_FREQ(1),    .C_WR_PNTR_WIDTH(8),    .C_WR_PNTR_WIDTH_AXIS(10),    .C_WR_PNTR_WIDTH_RACH(4),    .C_WR_PNTR_WIDTH_RDCH(10),    .C_WR_PNTR_WIDTH_WACH(4),    .C_WR_PNTR_WIDTH_WDCH(10),    .C_WR_PNTR_WIDTH_WRCH(4),    .C_WR_RESPONSE_LATENCY(1),    .C_WRCH_TYPE(0)  )  inst (    .RST(rst),    .WR_CLK(wr_clk),    .RD_CLK(rd_clk),    .DIN(din),    .WR_EN(wr_en),    .RD_EN(rd_en),    .DOUT(dout),    .FULL(full),    .EMPTY(empty),    .RD_DATA_COUNT(rd_data_count),    .PROG_FULL(prog_full),    .BACKUP(),    .BACKUP_MARKER(),    .CLK(),    .SRST(),    .WR_RST(),    .RD_RST(),    .PROG_EMPTY_THRESH(),    .PROG_EMPTY_THRESH_ASSERT(),    .PROG_EMPTY_THRESH_NEGATE(),    .PROG_FULL_THRESH(),    .PROG_FULL_THRESH_ASSERT(),    .PROG_FULL_THRESH_NEGATE(),    .INT_CLK(),    .INJECTDBITERR(),    .INJECTSBITERR(),    .ALMOST_FULL(),    .WR_ACK(),    .OVERFLOW(),    .ALMOST_EMPTY(),    .VALID(),    .UNDERFLOW(),    .DATA_COUNT(),    .WR_DATA_COUNT(),    .PROG_EMPTY(),    .SBITERR(),    .DBITERR(),    .M_ACLK(),    .S_ACLK(),    .S_ARESETN(),    .M_ACLK_EN(),    .S_ACLK_EN(),    .S_AXI_AWID(),    .S_AXI_AWADDR(),    .S_AXI_AWLEN(),    .S_AXI_AWSIZE(),    .S_AXI_AWBURST(),    .S_AXI_AWLOCK(),    .S_AXI_AWCACHE(),    .S_AXI_AWPROT(),    .S_AXI_AWQOS(),    .S_AXI_AWREGION(),    .S_AXI_AWUSER(),    .S_AXI_AWVALID(),    .S_AXI_AWREADY(),    .S_AXI_WID(),    .S_AXI_WDATA(),    .S_AXI_WSTRB(),    .S_AXI_WLAST(),    .S_AXI_WUSER(),    .S_AXI_WVALID(),    .S_AXI_WREADY(),    .S_AXI_BID(),    .S_AXI_BRESP(),    .S_AXI_BUSER(),    .S_AXI_BVALID(),    .S_AXI_BREADY(),    .M_AXI_AWID(),    .M_AXI_AWADDR(),    .M_AXI_AWLEN(),    .M_AXI_AWSIZE(),    .M_AXI_AWBURST(),    .M_AXI_AWLOCK(),    .M_AXI_AWCACHE(),    .M_AXI_AWPROT(),    .M_AXI_AWQOS(),    .M_AXI_AWREGION(),    .M_AXI_AWUSER(),    .M_AXI_AWVALID(),    .M_AXI_AWREADY(),    .M_AXI_WID(),    .M_AXI_WDATA(),    .M_AXI_WSTRB(),    .M_AXI_WLAST(),    .M_AXI_WUSER(),    .M_AXI_WVALID(),    .M_AXI_WREADY(),    .M_AXI_BID(),    .M_AXI_BRESP(),    .M_AXI_BUSER(),    .M_AXI_BVALID(),    .M_AXI_BREADY(),    .S_AXI_ARID(),    .S_AXI_ARADDR(),    .S_AXI_ARLEN(),    .S_AXI_ARSIZE(),    .S_AXI_ARBURST(),    .S_AXI_ARLOCK(),    .S_AXI_ARCACHE(),    .S_AXI_ARPROT(),    .S_AXI_ARQOS(),    .S_AXI_ARREGION(),    .S_AXI_ARUSER(),    .S_AXI_ARVALID(),    .S_AXI_ARREADY(),    .S_AXI_RID(),    .S_AXI_RDATA(),    .S_AXI_RRESP(),    .S_AXI_RLAST(),    .S_AXI_RUSER(),    .S_AXI_RVALID(),    .S_AXI_RREADY(),    .M_AXI_ARID(),    .M_AXI_ARADDR(),    .M_AXI_ARLEN(),    .M_AXI_ARSIZE(),    .M_AXI_ARBURST(),    .M_AXI_ARLOCK(),    .M_AXI_ARCACHE(),    .M_AXI_ARPROT(),    .M_AXI_ARQOS(),    .M_AXI_ARREGION(),    .M_AXI_ARUSER(),    .M_AXI_ARVALID(),    .M_AXI_ARREADY(),    .M_AXI_RID(),    .M_AXI_RDATA(),    .M_AXI_RRESP(),    .M_AXI_RLAST(),    .M_AXI_RUSER(),    .M_AXI_RVALID(),    .M_AXI_RREADY(),    .S_AXIS_TVALID(),    .S_AXIS_TREADY(),    .S_AXIS_TDATA(),    .S_AXIS_TSTRB(),    .S_AXIS_TKEEP(),    .S_AXIS_TLAST(),    .S_AXIS_TID(),    .S_AXIS_TDEST(),    .S_AXIS_TUSER(),    .M_AXIS_TVALID(),    .M_AXIS_TREADY(),    .M_AXIS_TDATA(),    .M_AXIS_TSTRB(),    .M_AXIS_TKEEP(),    .M_AXIS_TLAST(),    .M_AXIS_TID(),    .M_AXIS_TDEST(),    .M_AXIS_TUSER(),    .AXI_AW_INJECTSBITERR(),    .AXI_AW_INJECTDBITERR(),    .AXI_AW_PROG_FULL_THRESH(),    .AXI_AW_PROG_EMPTY_THRESH(),    .AXI_AW_DATA_COUNT(),    .AXI_AW_WR_DATA_COUNT(),    .AXI_AW_RD_DATA_COUNT(),    .AXI_AW_SBITERR(),    .AXI_AW_DBITERR(),    .AXI_AW_OVERFLOW(),    .AXI_AW_UNDERFLOW(),    .AXI_W_INJECTSBITERR(),    .AXI_W_INJECTDBITERR(),    .AXI_W_PROG_FULL_THRESH(),    .AXI_W_PROG_EMPTY_THRESH(),    .AXI_W_DATA_COUNT(),    .AXI_W_WR_DATA_COUNT(),    .AXI_W_RD_DATA_COUNT(),    .AXI_W_SBITERR(),    .AXI_W_DBITERR(),    .AXI_W_OVERFLOW(),    .AXI_W_UNDERFLOW(),    .AXI_B_INJECTSBITERR(),    .AXI_B_INJECTDBITERR(),    .AXI_B_PROG_FULL_THRESH(),    .AXI_B_PROG_EMPTY_THRESH(),    .AXI_B_DATA_COUNT(),    .AXI_B_WR_DATA_COUNT(),    .AXI_B_RD_DATA_COUNT(),    .AXI_B_SBITERR(),    .AXI_B_DBITERR(),    .AXI_B_OVERFLOW(),    .AXI_B_UNDERFLOW(),    .AXI_AR_INJECTSBITERR(),    .AXI_AR_INJECTDBITERR(),    .AXI_AR_PROG_FULL_THRESH(),    .AXI_AR_PROG_EMPTY_THRESH(),    .AXI_AR_DATA_COUNT(),    .AXI_AR_WR_DATA_COUNT(),    .AXI_AR_RD_DATA_COUNT(),    .AXI_AR_SBITERR(),    .AXI_AR_DBITERR(),    .AXI_AR_OVERFLOW(),    .AXI_AR_UNDERFLOW(),    .AXI_R_INJECTSBITERR(),    .AXI_R_INJECTDBITERR(),    .AXI_R_PROG_FULL_THRESH(),    .AXI_R_PROG_EMPTY_THRESH(),    .AXI_R_DATA_COUNT(),    .AXI_R_WR_DATA_COUNT(),    .AXI_R_RD_DATA_COUNT(),    .AXI_R_SBITERR(),    .AXI_R_DBITERR(),    .AXI_R_OVERFLOW(),    .AXI_R_UNDERFLOW(),    .AXIS_INJECTSBITERR(),    .AXIS_INJECTDBITERR(),    .AXIS_PROG_FULL_THRESH(),    .AXIS_PROG_EMPTY_THRESH(),    .AXIS_DATA_COUNT(),    .AXIS_WR_DATA_COUNT(),    .AXIS_RD_DATA_COUNT(),    .AXIS_SBITERR(),    .AXIS_DBITERR(),    .AXIS_OVERFLOW(),    .AXIS_UNDERFLOW()  );  endmodule"}
{"task_id": 1309, "completion": "reg [31:0] integral; \n    reg busy_reg; \n\n    assign v = integral; \n    assign busy = busy_reg; \n\n    always @(posedge clk or posedge rst) begin \n        if (rst) begin \n            integral <= 0; \n            busy_reg <= 0; \n        end else if (enable) begin \n            busy_reg <= 1; \n            integral <= integral + a * dt; \n            busy_reg <= 0; \n        end \n    end \nendmodule"}
{"task_id": 1278, "completion": "wire rst_i;\n    assign rst_i = ~RST;\n    wire clk_200MHz_i;\n    assign clk_200MHz_i = CLK;\n    wire  [26:0] ram_a;\n    wire  [15:0] ram_dq_i;\n    wire  [15:0] ram_dq_o;\n    reg          ram_cen;\n    reg          ram_oen;\n    reg          ram_wen;\n    wire         ram_ub;\n    wire         ram_lb;\n\twire\t\tmem_init_calib_complete;\n\twire\t\tmem_rdy;\n\twire\t\tmem_wdf_rdy;\n\twire\t\trd_vld;\n\twire\t\trd_end;\n    reg [31:0] waddr, raddr;\n    reg [31:0] wdata;\n    reg [1:0] wassert;\n    reg rassert;\n    reg second;\n    reg operation;\n    reg oper;\n    reg cap;\n    assign ram_ub = ~(second?axi_wstrb[3]:axi_wstrb[1]);\n    assign ram_lb = ~(second?axi_wstrb[2]:axi_wstrb[0]);\n    assign ram_dq_i = second?wdata[31:16]:wdata[15:0];\n    always @(posedge CLK) begin : DEMUX_DQ\n        if(RST == 1'b0) begin\n            axi_rdata <= 0;\n        end else begin\n\t\t\tif(second && cap && !operation)\n\t\t\t\taxi_rdata[31:16] <= ram_dq_o;\n\t\t\tif(!second && cap && !operation)\n\t\t\t\taxi_rdata[15:0] <= ram_dq_o;\n        end\n    end\n    assign ram_a = (operation?({waddr[24:0],second, 1'b0}):({raddr[24:0],second, 1'b0}));\n    assign axi_awready = 1'b1;\n    assign axi_arready = 1'b1;\n    assign axi_wready = 1'b1;\n    always @(posedge CLK) begin : SINGLE_SHOT\n        if(RST == 1'b0) begin\n            waddr <= 0;\n            raddr <= 0;\n            wdata <= 0;\n            wassert <= 2'b00;\n            rassert <= 1'b0;\n        end else begin\n            if(axi_bvalid) begin\n                waddr <= waddr;\n                wassert[0] <= 1'b0;\n            end else if(axi_awvalid) begin\n                waddr <= axi_awaddr;\n                wassert[0] <= 1'b1;\n            end else begin\n                waddr <= waddr;\n                wassert[0] <= wassert[0];\n            end\n            if(axi_bvalid) begin\n                wdata <= wdata;\n                wassert[1] <= 1'b0;\n            end else if(axi_wvalid) begin\n                wdata <= axi_wdata;\n                wassert[1] <= 1'b1;\n            end else begin\n                wdata <= wdata;\n                wassert[1] <= wassert[1];\n            end\n            if(axi_rvalid) begin\n                raddr <= raddr;\n                rassert <= 1'b0;\n            end else if(axi_arvalid) begin\n                raddr <= axi_araddr;\n                rassert <= 1'b1;\n            end else begin\n                raddr <= raddr;\n                rassert <= rassert;\n            end\n        end\n    end\n    localparam ROP = (500/5) - 1;\n    localparam WOP = (500/5) - 1;\n    reg [5:0] count;\n    wire [5:0] limit;\n    assign limit = operation?WOP:ROP;\n    wire operend;\n    assign operend = count>=limit?1'b1:1'b0;\n    always @(posedge CLK) begin : OPER_COUNTER\n        if(RST == 1'b0) begin\n            count <= 0;\n        end else begin\n            if(oper) begin\n                if(operend)\n\t\t\t\tcount <= 0;\n\t\t\telse\n\t\t\t\tcount <= count+1;\n            end else {\n\t\t\tcount <= 0;\n            end\n        end\n    end\n    parameter st0_nothing = 0, st1_wwait = 1, st2_rwait = 2, st3_wwait2 = 3, st4_rwait2 = 4, st5_wready = 5, \n              st6_rready = 6, st7_winter = 7, st8_rinter = 8, st9_rcap = 9, st10_rcap2 = 10;\n    reg [3:0] state;\n    always @ (state) begin\n        case (state)\n            st0_nothing: begin\n                axi_bvalid = 1'b0;\n                axi_rvalid = 1'b0;\n                second = 1'b0;\n                operation = 1'b0;\n                oper = 1'b0; \n                cap = 1'b0;\n                ram_cen = 1'b1;\n                ram_oen = 1'b1;\n                ram_wen = 1'b1;\n            end\n            st1_wwait: begin\n                axi_bvalid = 1'b0;\n                axi_rvalid = 1'b0;\n                second = 1'b0;\n                operation = 1'b1;\n                oper = 1'b1;\n                cap = 1'b0;\n                ram_cen = 1'b0;\n                ram_oen = 1'b1;\n                ram_wen = 1'b0;\n            end\n            st2_rwait: begin\n                axi_bvalid = 1'b0;\n                axi_rvalid = 1'b0;\n                second = 1'b0;\n                operation = 1'b0;\n                oper = 1'b1;\n                cap = 1'b0;\n                ram_cen = 1'b0;\n                ram_oen = 1'b0;\n                ram_wen = 1'b1;\n            end\n            st3_wwait2: begin\n                axi_bvalid = 1'b0;\n                axi_rvalid = 1'b0;\n                second = 1'b1;\n                operation = 1'b1;\n                oper = 1'b1;\n                cap = 1'b0;\n                ram_cen = 1'b0;\n                ram_oen = 1'b1;\n                ram_wen = 1'b0;\n            end\n            st4_rwait2: begin\n                axi_bvalid = 1'b0;\n                axi_rvalid = 1'b0;\n                second = 1'b1;\n                operation = 1'b0;\n                oper = 1'b1;\n                cap = 1'b0;\n                ram_cen = 1'b0;\n                ram_oen = 1'b0;\n                ram_wen = 1'b1;\n            end\n            st5_wready: begin\n                axi_bvalid = 1'b1;\n                axi_rvalid = 1'b0;\n                second = 1'b0;\n                operation = 1'b0;\n                oper = 1'b0;\n                cap = 1'b0;\n                ram_cen = 1'b1;\n                ram_oen = 1'b1;\n                ram_wen = 1'b1;\n            end\n            st6_rready: begin\n                axi_bvalid = 1'b0;\n                axi_rvalid = 1'b1;\n                second = 1'b0;\n                operation = 1'b0;\n                oper = 1'b0;\n                cap = 1'b0;\n                ram_cen = 1'b1;\n                ram_oen = 1'b1;\n                ram_wen = 1'b1;\n            end\n            st7_winter: begin\n                axi_bvalid = 1'b0;\n                axi_rvalid = 1'b0;\n                second = 1'b0;\n                operation = 1'b0;\n                oper = 1'b0;\n                cap = 1'b0;\n                ram_cen = 1'b1;\n                ram_oen = 1'b1;\n                ram_wen = 1'b1;\n            end\n            st8_rinter: begin\n                axi_bvalid = 1'b0;\n                axi_rvalid = 1'b0;\n                second = 1'b0;\n                operation = 1'b0;\n                oper = 1'b0;\n                cap = 1'b0;\n                ram_cen = 1'b1;\n                ram_oen = 1'b1;\n                ram_wen = 1'b1;\n            end\n            st9_rcap: begin\n                axi_bvalid = 1'b0;\n                axi_rvalid = 1'b0;\n                second = 1'b0;\n                operation = 1'b0;\n                oper = 1'b0;\n                cap = 1'b1;\n                ram_cen = 1'b0;\n                ram_oen = 1'b0;\n                ram_wen = 1'b1;\n            end\n            st10_rcap2: begin\n                axi_bvalid = 1'b0;\n                axi_rvalid = 1'b0;\n                second = 1'b1;\n                operation = 1'b0;\n                oper = 1'b0;\n                cap = 1'b1;\n                ram_cen = 1'b0;\n                ram_oen = 1'b0;\n                ram_wen = 1'b1;\n            end\n            default: begin\n                axi_bvalid = 1'b0;\n                axi_rvalid = 1'b0;\n                second = 1'b0;\n                operation = 1'b0;\n                oper = 1'b0;\n                cap = 1'b0;\n                ram_cen = 1'b1;\n                ram_oen = 1'b1;\n                ram_wen = 1'b1;\n            end\n        endcase\n    end\n    always @ (posedge CLK) begin\n        if (RST == 1'b0)\n            state <= st0_nothing;\n        else\n            case (state)\n                st0_nothing:\n                    if(wassert == 2'b11 && mem_init_calib_complete && mem_rdy && mem_wdf_rdy)\n                        state <= st1_wwait;\n                    else if(rassert == 1'b1 && mem_init_calib_complete && mem_rdy && mem_wdf_rdy)\n                        state <= st2_rwait;\n                    else\n                        state <= st0_nothing;\n                st1_wwait:\n                    if (mem_init_calib_complete && mem_rdy && mem_wdf_rdy && operend)\n                        state <= st7_winter;\n                    else\n                        state <= st1_wwait;\n                st7_winter:\n                    if (mem_init_calib_complete && mem_rdy && mem_wdf_rdy)\n                        state <= st3_wwait2;\n                    else\n                        state <= st7_winter;\n                st3_wwait2:\n                    if (mem_init_calib_complete && mem_rdy && mem_wdf_rdy && operend)\n                        state <= st5_wready;\n                    else\n                        state <= st3_wwait2;\n                st5_wready:\n                    if (axi_bready)\n                        state <= st0_nothing;\n                    else\n                        state <= st5_wready;\n                st2_rwait:\n                    if (mem_init_calib_complete && mem_rdy && mem_wdf_rdy && rd_vld && rd_end)\n                        state <= st9_rcap;\n                    else\n                        state <= st2_rwait;\n                st9_rcap:\n                    state <= st8_rinter;\n                st8_rinter:\n                    if (mem_init_calib_complete && mem_rdy && mem_wdf_rdy)\n                        state <= st4_rwait2;\n                    else\n                        state <= st8_rinter;\n                st4_rwait2:\n                    if (mem_init_calib_complete && mem_rdy && mem_wdf_rdy && rd_vld && rd_end)\n                        state <= st10_rcap2;\n                    else\n                        state <= st4_rwait2;\n                st10_rcap2:\n                    state <= st6_rready;\n                st6_rready:\n                    if (axi_rready)\n                        state <= st0_nothing;\n                    else\n                        state <= st6_rready;\n                default:\n                    state <= st0_nothing;\n            endcase\n    end\n    ram2ddr ram2ddr_inst (\n       .clk_200MHz_i        (clk_200MHz_i),     \n       .ram_cen             (ram_cen),          \n       .ram_lb              (ram_lb),           \n       .ram_oen             (ram_oen),          \n       .ram_wen             (ram_wen),          \n       .rst_i               (rst_i),            \n       .device_temp_i       (12'b000000000000),\n       .ram_a               (ram_a[26:0]),      \n       .ram_dq_i            (ram_dq_i[15:0]),  \n\t   .mem_init_calib_complete(mem_init_calib_complete),\n\t   .mem_rdy             (mem_rdy),\n\t   .mem_wdf_rdy         (mem_wdf_rdy),\n\t   .rd_vld              (rd_vld),\n\t   .rd_end              (rd_end),\n       .ddr2_cas_n          (ddr2_cas_n),       \n       .ddr2_ras_n          (ddr2_ras_n),       \n       .ddr2_we_n           (ddr2_we_n),        \n       .ddr2_addr           (ddr2_addr[12:0]),  \n       .ddr2_ba             (ddr2_ba[2:0]),     \n       .ddr2_ck_n           (ddr2_ck_n[0:0]),   \n       .ddr2_ck_p           (ddr2_ck_p[0:0]),   \n       .ddr2_cke            (ddr2_cke[0:0]),    \n       .ddr2_cs_n           (ddr2_cs_n[0:0]),   \n       .ddr2_dm             (ddr2_dm[1:0]),     \n       .ddr2_odt            (ddr2_odt[0:0]),    \n       .ram_dq_o            (ram_dq_o[15:0])\n    );\nendmodule"}
{"task_id": 1310, "completion": "parameter [31:0] SIM_EFUSE_VALUE = 32'h00000000;\n\n`ifdef XIL_TIMING\n\n  parameter LOC = \"UNPLACED\";\n\n`endif\n    \n  output [31:0] EFUSEUSR;\n\n  assign EFUSEUSR = SIM_EFUSE_VALUE;\n\n  specify\n\n      specparam PATHPULSE$ = 0;\n\n  endspecify\nendmodule"}
{"task_id": 1294, "completion": "reg [15:0] mI2C_CLK_DIV;\n   reg [31:0] mI2C_DATA;\n   reg mI2C_CTRL_CLK;\n   reg mI2C_GO;\n   wire mI2C_END;\n   wire mI2C_ACK; \n   always@(posedge clock or negedge reset_n)\n   begin\n      if (!reset_n) begin\n         mI2C_CTRL_CLK <= 0;\n         mI2C_CLK_DIV <= 0;\n      end\n      else begin\n         if (mI2C_CLK_DIV < (CLK_FREQ / I2C_FREQ)) \n            mI2C_CLK_DIV <= mI2C_CLK_DIV + 1;\n         else begin\n            mI2C_CLK_DIV <= 0;\n            mI2C_CTRL_CLK <= ~mI2C_CTRL_CLK;\n         end\n      end\n   end\n   I2C_Controller u0 (\n      .CLOCK(mI2C_CTRL_CLK), \n      .I2C_SCLK(I2C_SCLK), \n      .I2C_SDAT(I2C_SDAT), \n      .I2C_DATA(mI2C_DATA), \n      .GO(mI2C_GO), \n      .END(mI2C_END), \n      .ACK(mI2C_ACK), \n      .RESET(reset_n) \n   );\n    parameter LUT_SIZE = 25;\n    reg [23:0] LUT_DATA;\n    reg [5:0] LUT_INDEX;\n    reg [3:0] mSetup_ST;\n    reg _ready;\n   always @(posedge mI2C_CTRL_CLK or negedge reset_n)\n   begin\n        if (!reset_n) begin\n            LUT_INDEX <= 0;\n            mSetup_ST <= 0;\n            mI2C_GO <= 0;\n            _ready <= 1'b0;\n        end\n        else if (LUT_INDEX < LUT_SIZE) begin\n            case (mSetup_ST)\n                0: begin\n                    mI2C_DATA <= {8'hBA, LUT_DATA};\n                    mI2C_GO <= 1;\n                    mSetup_ST <= 1;\n                end\n                1: begin\n                    if (mI2C_END) begin\n                        if (!mI2C_ACK)\n                            mSetup_ST <= 2;\n                        else\n                            mSetup_ST <= 0; \n                        mI2C_GO <= 0;\n                    end\n                end\n                2: begin\n                    LUT_INDEX <= LUT_INDEX + 1;\n                    mSetup_ST <= 0;\n                end\n            endcase\n            _ready <= 1'b0;\n        end\n        else begin\n            _ready <= 1'b1;\n        end\n    end\n    reg ready;\n    always @(posedge clock)\n    begin\n        if (reset_n) begin\n            ready <= _ready; \n        end\n        else begin\n            ready <= 1'b0;\n        end\n    end\n    assign out_ready = ready;\n    always begin\n        case (LUT_INDEX)\n            0: LUT_DATA <= 24'h000000;\n            1: LUT_DATA <= 24'h20c000;\n            2: LUT_DATA <= {8'h09, exposure}; \n            3: LUT_DATA <= 24'h050000;\n            4: LUT_DATA <= 24'h060019;\n            5: LUT_DATA <= 24'h0A8000;\n            6: LUT_DATA <= 24'h2B0013;\n            7: LUT_DATA <= 24'h2C009A;\n            8: LUT_DATA <= 24'h2D019C;\n            9: LUT_DATA <= 24'h2E0013;\n            10: LUT_DATA <= 24'h100051;\n            11: LUT_DATA <= 24'h112003;\n            12: LUT_DATA <= 24'h120001;\n            13: LUT_DATA <= 24'h100053;\n            14: LUT_DATA <= 24'h980000;\n            15: LUT_DATA <= 24'hA00000;\n            16: LUT_DATA <= 24'hA10000;\n            17: LUT_DATA <= 24'hA20FFF;\n            18: LUT_DATA <= {8'h01, start_row}; \n            19: LUT_DATA <= {8'h02, start_column}; \n            20: LUT_DATA <= {8'h03, row_size}; \n            21: LUT_DATA <= {8'h04, column_size}; \n            22: LUT_DATA <= {8'h22, row_mode}; \n            23: LUT_DATA <= {8'h23, column_mode}; \n            24: LUT_DATA <= 24'h4901A8;\n            default: LUT_DATA <= 24'h000000;\n        endcase\n    end\nendmodule"}
{"task_id": 1301, "completion": "reg SDO;\n    reg SCLK;\n    reg [31:0]SD;\n    reg [6:0]SD_COUNTER;\n\n    assign I2C_SCLK = SCLK | ( ((SD_COUNTER >= 4) & (SD_COUNTER <= 39))? ~CLOCK : 1'b0);\n    assign I2C_SDAT = SDO ? 1'bz : 1'b0;\n\n    reg ACK1,ACK2,ACK3,ACK4;\n    assign ACK = ACK1 | ACK2 |ACK3 |ACK4;\n\n    always @(negedge RESET or posedge CLOCK ) begin\n    if (!RESET) SD_COUNTER=6'b111111;\n    else begin\n    if (GO==0) \n        SD_COUNTER=0;\n        else \n        if (SD_COUNTER < 41) SD_COUNTER[6:0] = SD_COUNTER[6:0] + 7'd1;    \n    end\n    end\n    \n    always @(negedge RESET or  posedge CLOCK ) begin\n    if (!RESET) begin SCLK=1;SDO=1; ACK1=0;ACK2=0;ACK3=0;ACK4=0; END=1; end\n    else\n    case (SD_COUNTER)\n        6'd0  : begin ACK1=0 ;ACK2=0 ;ACK3=0 ;ACK4=0 ; END=0; SDO=1; SCLK=1;end\n        6'd1  : begin SD=I2C_DATA;SDO=0;end\n        6'd2  : SCLK=0;\n        6'd3  : SDO=SD[31];\n        6'd4  : SDO=SD[30];\n        6'd5  : SDO=SD[29];\n        6'd6  : SDO=SD[28];\n        6'd7  : SDO=SD[27];\n        6'd8  : SDO=SD[26];\n        6'd9  : SDO=SD[25];\n        6'd10 : SDO=SD[24];    \n        6'd11 : SDO=1'b1;//ACK\n        6'd12  : begin SDO=SD[23]; ACK1=I2C_SDAT; end\n        6'd13  : SDO=SD[22];\n        6'd14  : SDO=SD[21];\n        6'd15  : SDO=SD[20];\n        6'd16  : SDO=SD[19];\n        6'd17  : SDO=SD[18];\n        6'd18  : SDO=SD[17];\n        6'd19  : SDO=SD[16];\n        6'd20  : SDO=1'b1;//ACK\n        6'd21  : begin SDO=SD[15]; ACK2=I2C_SDAT; end\n        6'd22  : SDO=SD[14];\n        6'd23  : SDO=SD[13];\n        6'd24  : SDO=SD[12];\n        6'd25  : SDO=SD[11];\n        6'd26  : SDO=SD[10];\n        6'd27  : SDO=SD[9];\n        6'd28  : SDO=SD[8];\n        6'd29  : SDO=1'b1;//ACK\n        6'd30  : begin SDO=SD[7]; ACK3=I2C_SDAT; end\n        6'd31  : SDO=SD[6];\n        6'd32  : SDO=SD[5];\n        6'd33  : SDO=SD[4];\n        6'd34  : SDO=SD[3];\n        6'd35  : SDO=SD[2];\n        6'd36  : SDO=SD[1];\n        6'd37  : SDO=SD[0];\n        6'd38  : SDO=1'b1;//ACK\n        6'd39 : begin SDO=1'b0;    SCLK=1'b0; ACK4=I2C_SDAT; end    \n        6'd40 : SCLK=1'b1; \n        6'd41 : begin SDO=1'b1; END=1; end \n    endcase\n    end\nendmodule"}
{"task_id": 1313, "completion": "wire             clk_en;\n  reg     [  5: 0] data_out;\n  wire    [  5: 0] read_mux_out;\n  assign clk_en = 1;\n  assign read_mux_out = {6 {(address == 0)}} & data_out;\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          data_out <= 0;\n      else if (chipselect && ~write_n && (address == 0))\n          data_out <= writedata[5 : 0];\n    end\n  assign readdata = {32'b0 | read_mux_out};\n  assign out_port = data_out;\n\nendmodule"}
{"task_id": 1282, "completion": "axi_protocol_converter_v2_1_8_axi_protocol_converter #( .C_FAMILY(\"zynq\"), .C_M_AXI_PROTOCOL(2), .C_S_AXI_PROTOCOL(0), .C_IGNORE_ID(0), .C_AXI_ID_WIDTH(12), .C_AXI_ADDR_WIDTH(32), .C_AXI_DATA_WIDTH(32), .C_AXI_SUPPORTS_WRITE(1), .C_AXI_SUPPORTS_READ(1), .C_AXI_SUPPORTS_USER_SIGNALS(0), .C_AXI_AWUSER_WIDTH(1), .C_AXI_ARUSER_WIDTH(1), .C_AXI_WUSER_WIDTH(1), .C_AXI_RUSER_WIDTH(1), .C_AXI_BUSER_WIDTH(1), .C_TRANSLATION_MODE(2) ) inst ( .aclk(aclk), .aresetn(aresetn), .s_axi_awid(s_axi_awid), .s_axi_awaddr(s_axi_awaddr), .s_axi_awlen(s_axi_awlen), .s_axi_awsize(s_axi_awsize), .s_axi_awburst(s_axi_awburst), .s_axi_awlock(s_axi_awlock), .s_axi_awcache(s_axi_awcache), .s_axi_awprot(s_axi_awprot), .s_axi_awregion(s_axi_awregion), .s_axi_awqos(s_axi_awqos), .s_axi_awuser(1'H0), .s_axi_awvalid(s_axi_awvalid), .s_axi_awready(s_axi_awready), .s_axi_wid(12'H000), .s_axi_wdata(s_axi_wdata), .s_axi_wstrb(s_axi_wstrb), .s_axi_wlast(s_axi_wlast), .s_axi_wuser(1'H0), .s_axi_wvalid(s_axi_wvalid), .s_axi_wready(s_axi_wready), .s_axi_bid(s_axi_bid), .s_axi_bresp(s_axi_bresp), .s_axi_buser(), .s_axi_bvalid(s_axi_bvalid), .s_axi_bready(s_axi_bready), .s_axi_arid(s_axi_arid), .s_axi_araddr(s_axi_araddr), .s_axi_arlen(s_axi_arlen), .s_axi_arsize(s_axi_arsize), .s_axi_arburst(s_axi_arburst), .s_axi_arlock(s_axi_arlock), .s_axi_arcache(s_axi_arcache), .s_axi_arprot(s_axi_arprot), .s_axi_arregion(s_axi_arregion), .s_axi_arqos(s_axi_arqos), .s_axi_aruser(1'H0), .s_axi_arvalid(s_axi_arvalid), .s_axi_arready(s_axi_arready), .s_axi_rid(s_axi_rid), .s_axi_rdata(s_axi_rdata), .s_axi_rresp(s_axi_rresp), .s_axi_rlast(s_axi_rlast), .s_axi_ruser(), .s_axi_rvalid(s_axi_rvalid), .s_axi_rready(s_axi_rready), .m_axi_awid(), .m_axi_awaddr(m_axi_awaddr), .m_axi_awlen(), .m_axi_awsize(), .m_axi_awburst(), .m_axi_awlock(), .m_axi_awcache(), .m_axi_awprot(m_axi_awprot), .m_axi_awregion(), .m_axi_awqos(), .m_axi_awuser(), .m_axi_awvalid(m_axi_awvalid), .m_axi_awready(m_axi_awready), .m_axi_wid(), .m_axi_wdata(m_axi_wdata), .m_axi_wstrb(m_axi_wstrb), .m_axi_wlast(), .m_axi_wuser(), .m_axi_wvalid(m_axi_wvalid), .m_axi_wready(m_axi_wready), .m_axi_bid(12'H000), .m_axi_bresp(m_axi_bresp), .m_axi_buser(1'H0), .m_axi_bvalid(m_axi_bvalid), .m_axi_bready(m_axi_bready), .m_axi_arid(), .m_axi_araddr(m_axi_araddr), .m_axi_arlen(), .m_axi_arsize(), .m_axi_arburst(), .m_axi_arlock(), .m_axi_arcache(), .m_axi_arprot(m_axi_arprot), .m_axi_arregion(), .m_axi_arqos(), .m_axi_aruser(), .m_axi_arvalid(m_axi_arvalid), .m_axi_arready(m_axi_arready), .m_axi_rid(12'H000), .m_axi_rdata(m_axi_rdata), .m_axi_rresp(m_axi_rresp), .m_axi_rlast(1'H1), .m_axi_ruser(1'H0), .m_axi_rvalid(m_axi_rvalid), .m_axi_rready(m_axi_rready) ); endmodule"}
{"task_id": 1312, "completion": "reg[31:0] count;    reg[7:0] data;    always @(posedge clk or posedge rst) begin        if(rst)    data = 0;        else if(wr) begin                data = din;        end    end    wire tick;    reg[3:0] state,n_state;    parameter s0 = 0;    parameter s1 = 1;    parameter s2 = 2;    parameter s3 = 3;    parameter s4 = 4;    parameter s5 = 5;    parameter s6 = 6;    parameter s7 = 7;    parameter s8 = 8;    parameter s9 = 9;    always @(posedge clk or posedge rst) begin        if(rst)    begin            count <= 0;        end        else    begin            if(tick)    count <= 0;            else    count <= count + 1;        end    end    assign tick = (count == div) | (wr & (state==0));    always @(posedge clk or posedge rst) begin        if(rst)    state <= 0;        else if(tick) state <= n_state;    end    always @(state or wr) begin        if(state == 0) begin            if(wr)    n_state <= 1;            else    n_state <= 0;        end        else if(state < 10)    n_state <= state + 1;        else n_state <= 0;    end    always @(*) begin        case(state)            4'h0: txd <= 1;            4'h1: txd <= 0;            4'h2: txd <= data[0];            4'h3: txd <= data[1];            4'h4: txd <= data[2];            4'h5: txd <= data[3];            4'h6: txd <= data[4];            4'h7: txd <= data[5];            4'h8: txd <= data[6];            4'h9: txd <= data[7];            default: txd <= 1;        endcase    end    assign rdy = (state == s0);    ////////////////////RX Section////////////////////////////    reg[15:0] rx_baud_count;    wire rx_tick;    reg rx_baudgen_rst;    always @(posedge clk or posedge rst) begin        if(rst) rx_baud_count <= 0;        else            if(rx_baudgen_rst | (rx_baud_count == div))    rx_baud_count <= 0;            else rx_baud_count <= rx_baud_count + 1;    end    assign rx_tick = (rx_baud_count == div/2);    reg rx_shift;    reg[3:0] rx_bits_rxed,rx_bits_next_rxed;    reg[3:0] rx_state,rx_next_state;    always @(posedge clk or posedge rst) begin        if(rst)            dout <= 0;        else            if(rx_shift)    dout <= { rxd, dout[7:1] };    end    reg next_valid;    always @(posedge clk or posedge rst) begin        if(rst)         begin                rx_state <= 0;                rx_bits_rxed <= 0;            end        else            begin                rx_bits_rxed <= rx_bits_next_rxed;                rx_state <= rx_next_state;            end    end    always @(*) begin        rx_next_state <= rx_state;        rx_baudgen_rst <= 0;        rx_bits_next_rxed <= rx_bits_rxed;        rx_shift <= 0;        valid <= 0;        case(rx_state)            4'h0: begin                        if(rxd==0)    rx_next_state <= 1;                    end            4'h1: begin                        rx_baudgen_rst <= 1;                        rx_bits_next_rxed <= 0;                        rx_next_state <= 2;                    end            4'h2: begin                        if(rx_tick) rx_next_state <= 3;                    end            4'h3: begin                        rx_shift <= 1;                        rx_bits_next_rxed <= rx_bits_rxed + 1;                        if(rx_bits_rxed < 8)    rx_next_state <= 2;                        else    rx_next_state <= 4;                    end            4'h4: begin                        if(rx_tick) rx_next_state <= 5;                    end            4'h5: begin                        valid <= 1;                        if(rd)    rx_next_state <= 0;                    end        endcase    endendmodule"}
{"task_id": 1305, "completion": "input         clk;  \n   input         rstn;    \n   input         rx_req;              // core pkt request \n   input[135:0]  rx_desc;             // core pkt descriptor\n   input[63:0]   rx_data;             // core payload data\n   input[7:0]    rx_be;               // core byte enable bits\n   input         rx_dv;               // core rx_data is valid\n   input         rx_dfr;              // core has more data cycles\n   input         stream_ready;         // means streaming interface can accept more data\n   output        rx_ack;              // core rx_ack handshake\n   output        rx_abort;            // core rx_abort handshake \n   output        rx_retry;            // core rx_retry handshake\n   output        rx_ws;               // core data throttling\n   output        rx_mask;             // core rx_mask handshake\n   output        stream_wr;         // means stream_wrdata is valid\n   output[107:0] stream_wrdata;   \n   parameter DROP_MESSAGE = 1'b1;      // when 1'b1, the bridge acks messages from the core, then drops them.  \n   parameter STREAM_DESC1   = 2'h0;    // write hi descriptor to streaming interface\n   parameter STREAM_DESC2   = 2'h1;    // write lo descriptor to streaming interface  \n   parameter STREAM_DATA    = 2'h2;    // write dataphase to streaming interface  \n   parameter DEFERRED_CYCLE = 2'h3;    // write last data cycle to streaming interface if in deferred mode \n   wire          rx_abort;            \n   wire          rx_retry;            \n   wire          rx_mask;             \n   wire[107:0]   stream_wrdata;       \n   wire          stream_wr;         \n   wire          start_of_pkt_flag;     // menas this cycle is the first of the transfer (always desc phase 1)\n   wire          end_of_pkt_flag;       // means this cycle is the last of the transfer\n   reg           has_payload;           // means this transfer contains data cycles\n   wire[63:0]    muxed_stream_wrdata;     // mulitplexed desc/data bus data to be written to be transferred\n   wire[7:0]     muxed_bar_bits;        // multiplexed desc/data bus byte_ena/bar field to be transferred \n   reg[7:0]      rx_be_last;           // byte enable bits from last cycle.  for deferred mode.  \n   reg[63:0]     rx_data_last;         // payload data from last cycle.  for deferred mode.\n   reg           defer_data_cycle;      // when data phase coincides with descriptor phase, defer writing it to the fifo until after desc phase is written.\n   wire[7:0]     muxed_rx_be;          // byte enable bits to be muxed onto muxed_bar_bits\n   reg[1:0]      bridge_sm;             // bridge state machine. controls data throttling on both streaming and core interfaces\n   reg           enable_desc1;          // selects high descriptor bytes for streaming interface data\n   reg           enable_desc2;          // selects low descriptor bytes for streaming interface data \n   reg           write_streaming_data;  // writes data to streaming interface\n   reg           stream_deferred_data;  // means data payload is streamed in deferred mode\n   wire          rx_ack;              \n   wire          rx_ws;\n   reg           last_deferred_cycle;   // means current cycle is the last deferred data cycle\n   reg           enable_core_dataphase; // allows bridge to accept payload data from core\n   reg           filter_out_msg;        // if tlp is a message, ack it, and drop it.  do not pass to streaming interface.  active only if user parameter DROP_MESSAGE is true.\n   wire          filter_out_msg_n;\n   wire          type_is_message;  \n   wire          type_is_message_mem;\n   reg           type_is_message_mem_r;\n   wire[2:0]     rxdesc_type_field; \n   assign rx_abort = 1'b0;\n   assign rx_mask  = 1'b0;\n   assign rx_retry = 1'b0;  \n   assign stream_wrdata[`STREAM_DATA_BITS]    = muxed_stream_wrdata;\n   assign stream_wrdata[`STREAM_BAR_BITS]     = muxed_bar_bits;\n   assign stream_wrdata[`STREAM_BYTEENA_BITS] = muxed_rx_be;\n   assign stream_wrdata[`STREAM_SOP]          = start_of_pkt_flag;\n   assign stream_wrdata[`STREAM_EOP]          = end_of_pkt_flag;   \n   assign rxdesc_type_field = rx_desc[125:123]; \n   assign type_is_message   = (rxdesc_type_field == 3'b110) ? 1'b1 : 1'b0;  \n   assign type_is_message_mem = rx_req ? type_is_message : type_is_message_mem_r;\n   assign filter_out_msg_n  = type_is_message_mem & DROP_MESSAGE;\n   assign stream_wr         = stream_ready & (rx_req | write_streaming_data) & ~filter_out_msg_n;  \n   assign start_of_pkt_flag = rx_req & enable_desc1;\n   assign end_of_pkt_flag   = (write_streaming_data & ~stream_deferred_data & ~rx_dfr) | last_deferred_cycle;\n   assign muxed_stream_wrdata = stream_deferred_data ? rx_data_last    :   // data phase with cycle stealing - deferred cycle has priority over any new rx_req\n                              enable_desc1           ? rx_desc[127:64] :   // first descriptor phase\n                              enable_desc2           ? rx_desc[63:0]   :   // second descriptor phase \n                              rx_data;                                     // data phase without cycle stealing (write_streaming_data)\n   assign muxed_rx_be =  stream_deferred_data ? rx_be_last :  // data phase with cycle stealing\n                          rx_be;                               // data phase without cycle stealing     \n   assign muxed_bar_bits = rx_desc[135:128];  \n   assign rx_ws  = ~(enable_core_dataphase & stream_ready & rx_dv);\n   assign rx_ack = enable_desc2 & stream_ready;\n   always @(negedge rstn or posedge clk) begin\n      if (rstn == 1'b0) begin  \n\t      bridge_sm             <= STREAM_DESC1;\n\t\t  enable_desc1          <= 1'b1;\n\t\t  enable_desc2          <= 1'b0;\n\t\t  write_streaming_data  <= 1'b0;\n\t\t  stream_deferred_data  <= 1'b0;\n\t\t  has_payload           <= 1'b0; \n\t\t  last_deferred_cycle   <= 1'b0;\n\t\t  rx_data_last         <= 64'h0;\n\t\t  rx_be_last           <= 8'h0;  \n\t\t  enable_core_dataphase <= 1'b0;\n\t\t  filter_out_msg        <= 1'b0; \n\t\t  type_is_message_mem_r <= 1'b0;\n\t\t  defer_data_cycle      <= 1'b0; \n      end\n      else begin  \n\t      type_is_message_mem_r <= type_is_message_mem;\n\t      if (stream_ready) begin                                    // advance data transfer on stream_ready\n\t\t      rx_data_last <= rx_data;\n\t\t      rx_be_last   <= rx_be; \n\t          case (bridge_sm) \n\t\t\t      STREAM_DESC1: begin\n\t\t\t\t      if (rx_req) begin\n\t\t\t\t\t      enable_desc1          <= 1'b0;\n\t\t\t\t\t      enable_desc2          <= 1'b1;\n\t\t\t\t\t      has_payload           <= rx_desc[126];\n\t\t\t\t\t      bridge_sm             <= STREAM_DESC2;            \n\t\t\t\t\t      last_deferred_cycle   <= ~rx_desc[126];                            \n\t\t\t\t\t      enable_core_dataphase <= rx_desc[126];                             \n\t\t\t\t\t      filter_out_msg        <= filter_out_msg_n;\n\t\t\t\t      end\n\t\t\t      end\n\t\t\t      STREAM_DESC2: begin\n\t\t\t\t      enable_desc2     <= 1'b0;\n\t\t\t\t      defer_data_cycle <= rx_dv;\n\t\t\t\t      if (~rx_dfr & rx_dv) begin                    \n\t\t\t\t\t      last_deferred_cycle   <= 1'b1;\n\t\t\t\t\t      bridge_sm             <= DEFERRED_CYCLE;   \n\t\t\t\t\t      write_streaming_data  <= ~filter_out_msg;\n\t\t\t\t\t      stream_deferred_data  <= 1;\n\t\t\t\t\t      enable_core_dataphase <= 1'b0;\n\t\t\t\t      end\n\t\t\t\t      else if (has_payload) begin                     \n\t\t\t\t\t      bridge_sm             <= STREAM_DATA;\n\t\t\t\t\t      write_streaming_data  <= ~filter_out_msg;\n\t\t\t\t\t      stream_deferred_data  <= rx_dv;\n\t\t\t\t\t      enable_core_dataphase <= 1'b1;\n\t\t\t\t      end\n\t\t\t\t      else begin                                      \n\t\t\t\t\t      bridge_sm             <= STREAM_DESC1;\n\t\t\t\t\t      enable_desc1          <= 1'b1;           \n\t\t\t\t\t      enable_core_dataphase <= 1'b0;             \n\t\t\t\t\t      last_deferred_cycle   <= 1'b0;\n\t\t\t\t      end\n\t\t\t      end\n\t\t\t      STREAM_DATA: begin \n\t\t\t\t      if (~rx_dfr & rx_dv) begin\n\t\t\t\t\t      bridge_sm             <= defer_data_cycle ? DEFERRED_CYCLE : STREAM_DESC1;\n\t\t\t\t\t      last_deferred_cycle   <= defer_data_cycle ? 1'b1 : 1'b0;\n\t\t\t\t\t      enable_desc1          <= defer_data_cycle ? 1'b0 : 1'b1;\n\t\t\t\t\t      enable_desc2          <= 1'b0;\n\t\t\t\t\t      write_streaming_data  <= defer_data_cycle ? ~filter_out_msg : 1'b0;\n\t\t\t\t\t      enable_core_dataphase <= 1'b0;\n\t\t\t\t      end\n\t\t\t      end\n\t\t\t      DEFERRED_CYCLE: begin\n\t\t\t\t      bridge_sm             <= STREAM_DESC1;\n\t\t\t\t      enable_desc1          <= 1'b1;\n\t\t\t\t      enable_desc2          <= 1'b0;\n\t\t\t\t      write_streaming_data  <= 1'b0;\n\t\t\t\t      stream_deferred_data  <= 1'b0;\n\t\t\t\t      last_deferred_cycle   <= 1'b0;\n\t\t\t\t      enable_core_dataphase <= 1'b0;\n\t\t\t      end\n\t\t\t  endcase\n\t      end\n   end\nendmodule"}
{"task_id": 1327, "completion": "reg [31:0] mem1[0:3];\nreg [31:0] mem1_do;\nalways @(posedge sys_clk) begin\n\tif(we & ~wa[0])\n\t\tmem1[wa[2:1]] <= wd;\n\tmem1_do <= mem1[ra];\nend\n\nreg [31:0] mem2[0:3];\nreg [31:0] mem2_do;\nalways @(posedge sys_clk) begin\n\tif(we & wa[0])\n\t\tmem2[wa[2:1]] <= wd;\n\tmem2_do <= mem2[ra];\nend\n\nassign rd = {mem1_do, mem2_do};\n\nendmodule"}
{"task_id": 1043, "completion": "`define DEFAULT_CONTROL        \\\n    reg_dst = 7;        \\\n    reg_src = 7;        \\\n    alu_input = 0;        \\\n    alu_op = `CLR;        \\\n    psw_we = 0;                 \\\n    reg_we = 0;                 \\\n    reg_from_mem = 0;           \\\n    mem_we = 0;                 \\\n    mem_byte = 0;        \\\n    mem_addr = 0;        \\\n    z_we = 0;                   \\\n    x_we = 0;                   \\\n    y_we = 0;                   \\\n    ir_we = 0\n\n    always @(cmd or cycle) begin\n        casez ({ cycle, cmd })\n        { 3'd0, 16'ozzzzzz }: begin `DEFAULT_CONTROL;\n                cnext = 1;        // Next cycle 1\n                reg_dst = 7;        // Use R7 (PC)\n                alu_input = `ALU_SRC_DST; // ALU destination from PC\n                alu_op = `INC2;        // Compute PC+2\n                reg_we = 1;        // Write to PC...\n                reg_from_mem = 0;    // ...from ALU\n                mem_addr = `MEM_DST;    // Get M[PC]...\n                ir_we = 1;        // ...latch instruction\n                x_we = 1;        // ...write X\n        end\n        default: begin `DEFAULT_CONTROL;\n                cnext = 0;        // Next cycle 0\n                $display (\"%4d-%d) unknown opcode %o\", $time, cycle, cmd);\n                $finish;\n        end\n\n        .......\n\n    endcase\n    end\n\nendmodule"}
{"task_id": 1308, "completion": "fmrv32im_axilm inst (\n    .RST_N(RST_N),\n    .CLK(CLK),\n    .M_AXI_AWADDR(M_AXI_AWADDR),\n    .M_AXI_AWCACHE(M_AXI_AWCACHE),\n    .M_AXI_AWPROT(M_AXI_AWPROT),\n    .M_AXI_AWVALID(M_AXI_AWVALID),\n    .M_AXI_AWREADY(M_AXI_AWREADY),\n    .M_AXI_WDATA(M_AXI_WDATA),\n    .M_AXI_WSTRB(M_AXI_WSTRB),\n    .M_AXI_WVALID(M_AXI_WVALID),\n    .M_AXI_WREADY(M_AXI_WREADY),\n    .M_AXI_BVALID(M_AXI_BVALID),\n    .M_AXI_BREADY(M_AXI_BREADY),\n    .M_AXI_BRESP(M_AXI_BRESP),\n    .M_AXI_ARADDR(M_AXI_ARADDR),\n    .M_AXI_ARCACHE(M_AXI_ARCACHE),\n    .M_AXI_ARPROT(M_AXI_ARPROT),\n    .M_AXI_ARVALID(M_AXI_ARVALID),\n    .M_AXI_ARREADY(M_AXI_ARREADY),\n    .M_AXI_RDATA(M_AXI_RDATA),\n    .M_AXI_RRESP(M_AXI_RRESP),\n    .M_AXI_RVALID(M_AXI_RVALID),\n    .M_AXI_RREADY(M_AXI_RREADY),\n    .BUS_WAIT(BUS_WAIT),\n    .BUS_ENA(BUS_ENA),\n    .BUS_WSTB(BUS_WSTB),\n    .BUS_ADDR(BUS_ADDR),\n    .BUS_WDATA(BUS_WDATA),\n    .BUS_RDATA(BUS_RDATA)\n  );\nendmodule"}
{"task_id": 1324, "completion": "`include \"c_functions.v\"\n   `include \"c_constants.v\"\n   `include \"rtr_constants.v\"\n   `include \"vcr_constants.v\"\n   parameter num_vcs = 4;\n   parameter num_ports = 5;\n   parameter sw_alloc_spec = 1;\n   parameter elig_mask = `ELIG_MASK_NONE;\n   parameter reset_type = `RESET_TYPE_ASYNC;\n   input clk;\n   input reset;\n   input vc_active;\n   input vc_gnt;\n   input [0:num_ports-1] vc_sel_ip;\n   input [0:num_vcs-1] vc_sel_ivc;\n   input sw_active;\n   input sw_gnt;\n   input [0:num_ports-1] sw_sel_ip;\n   input [0:num_vcs-1] sw_sel_ivc;\n   input flit_valid;\n   input flit_tail;\n   output flit_sel;\n   wire flit_sel;\n   output elig;\n   wire elig;\n   input full;\n   input full_prev;\n   input empty;\n   wire alloc_active;\n   assign alloc_active = vc_active | flit_valid;\n   wire allocated;\n   wire allocated_s, allocated_q;\n   assign allocated_s = vc_gnt | allocated;\n   c_dff\n     #(.width(1),\n       .reset_type(reset_type))\n   allocatedq\n     (.clk(clk),\n      .reset(reset),\n      .active(alloc_active),\n      .d(allocated_s),\n      .q(allocated_q));\n   assign allocated = allocated_q & ~(flit_valid & flit_sel & flit_tail);\n   wire [0:num_ports-1]  allocated_ip_s, allocated_ip_q;\n   assign allocated_ip_s = allocated ? allocated_ip_q : vc_sel_ip;\n   c_dff\n     #(.width(num_ports),\n       .reset_type(reset_type))\n   allocated_ipq\n     (.clk(clk),\n      .reset(1'b0),\n      .active(vc_active),\n      .d(allocated_ip_s),\n      .q(allocated_ip_q));\n   wire port_match;\n   wire vc_match;\n   generate\n      if(sw_alloc_spec)\n         assign port_match = |(sw_sel_ip & allocated_ip_s);\n      else\n         assign port_match = |(sw_sel_ip & allocated_ip_q);\n      if(num_vcs == 1)\n         assign vc_match = 1'b1;\n      else if(num_vcs > 1)\n      begin\n         wire [0:num_vcs-1] allocated_ivc_s, allocated_ivc_q;\n         assign allocated_ivc_s = allocated ? allocated_ivc_q : vc_sel_ivc;\n         c_dff\n           #(.width(num_vcs),\n             .reset_type(reset_type))\n         allocated_ivcq\n           (.clk(clk),\n            .reset(1'b0),\n            .active(vc_active),\n            .d(allocated_ivc_s),\n            .q(allocated_ivc_q));\n         if(sw_alloc_spec)\n            assign vc_match = |(sw_sel_ivc & allocated_ivc_s);\n         else\n            assign vc_match = |(sw_sel_ivc & allocated_ivc_q);\n      end\n   endgenerate\n   wire match_s, match_q;\n   assign match_s = sw_gnt ? (port_match & vc_match) : match_q;\n   c_dff\n     #(.width(1),\n       .reset_type(reset_type))\n   matchq\n     (.clk(clk),\n      .reset(reset),\n      .active(sw_active),\n      .d(match_s),\n      .q(match_q));\n   generate\n      if(sw_alloc_spec && (elig_mask == `ELIG_MASK_NONE))\n         assign flit_sel = allocated_q & match_q & ~full_prev;\n      else\n         assign flit_sel = allocated_q & match_q;\n   endgenerate\n   generate\n      case(elig_mask)\n         `ELIG_MASK_NONE:\n            begin\n               assign elig = ~allocated;\n            end\n         `ELIG_MASK_FULL:\n            begin\n               assign elig = ~allocated & ~full;\n            end\n         `ELIG_MASK_USED:\n            begin\n               assign elig = ~allocated & empty;\n            end\n      endcase\n   endgenerate\nendmodule"}
{"task_id": 1332, "completion": "tri0 GSR = glbl.GSR;\n\n    wire o_out;\n    wire SRI_in;\n\n    assign O = (GSR) ? 0 : o_out;\n    or O1 (o_out, SRI_in, DI);\n\n    assign SRI_in = IS_SRI_INVERTED ^ SRI;\n\n  specify\n  (DI => O) = (0:0:0, 0:0:0);\n  (SRI => O) = (0:0:0, 0:0:0);\n    $width (negedge SRI, 0:0:0, 0, notifier);\n    $width (posedge SRI, 0:0:0, 0, notifier);\n  specparam PATHPULSE$ = 0;\n  endspecify\nendmodule"}
{"task_id": 1331, "completion": "// \u5b9a\u4e49\u7c7b\u578b\u548c\u5e38\u91cf\u7684\u63d0\u53d6\n  Extract Inductive bool => \"bool\" [\"true\" \"false\"].\n  Extract Inductive nat => \"int\" [\"0\" \"(fun x -> x + 1)\"].\n  Extract Constant plus => \"( + )\".\n  Extract Constant mult => \"( * )\".\n  Extract Constant eqb => \"( = )\".\n\n  Extraction \"imp1.ml\" ceval_step.\n  Extraction \"imp2.ml\" ceval_step.\n\n  // \u5b8c\u6574\u793a\u4f8b\n  Extraction \"imp.ml\" empty_st ceval_step parse.\n\n  // \u8fd0\u884c\u751f\u6210\u7684 Imp \u6c42\u503c\u5668\u4ee3\u7801\n  // ...\nendmodule"}
{"task_id": 1328, "completion": "IBUF clkin1_ibufg\n   (.O (clk125_clk_gen),\n    .I (clk125));\n\n  wire [15:0] do_unused;\n  wire        drdy_unused;\n  wire        psdone_unused;\n  wire        clk_locked_int;\n  wire        clkfbout_clk_gen;\n  wire        clkfboutb_unused;\n  wire clkout0b_unused;\n  wire clkout1_unused;\n  wire clkout1b_unused;\n  wire clkout2_unused;\n  wire clkout2b_unused;\n  wire clkout3_unused;\n  wire clkout3b_unused;\n  wire clkout4_unused;\n  wire        clkout5_unused;\n  wire        clkout6_unused;\n  wire        clkfbstopped_unused;\n  wire        clkinstopped_unused;\n\n  MMCME2_ADV\n  #(.BANDWIDTH            (\"HIGH\"),\n    .CLKOUT4_CASCADE      (\"FALSE\"),\n    .COMPENSATION         (\"ZHOLD\"),\n    .STARTUP_WAIT         (\"FALSE\"),\n    .DIVCLK_DIVIDE        (6),\n    .CLKFBOUT_MULT_F      (53.375),\n    .CLKFBOUT_PHASE       (0.000),\n    .CLKFBOUT_USE_FINE_PS (\"FALSE\"),\n    .CLKOUT0_DIVIDE_F     (87.375),\n    .CLKOUT0_PHASE        (0.000),\n    .CLKOUT0_DUTY_CYCLE   (0.500),\n    .CLKOUT0_USE_FINE_PS  (\"FALSE\"),\n    .CLKIN1_PERIOD        (8.0))\n  mmcm_adv_inst\n    // Output clocks\n   (\n    .CLKFBOUT            (clkfbout_clk_gen),\n    .CLKFBOUTB           (clkfboutb_unused),\n    .CLKOUT0             (clk_clk_gen),\n    .CLKOUT0B            (clkout0b_unused),\n    .CLKOUT1             (clkout1_unused),\n    .CLKOUT1B            (clkout1b_unused),\n    .CLKOUT2             (clkout2_unused),\n    .CLKOUT2B            (clkout2b_unused),\n    .CLKOUT3             (clkout3_unused),\n    .CLKOUT3B            (clkout3b_unused),\n    .CLKOUT4             (clkout4_unused),\n    .CLKOUT5             (clkout5_unused),\n    .CLKOUT6             (clkout6_unused),\n     // Input clock control\n    .CLKFBIN             (clkfbout_clk_gen),\n    .CLKIN1              (clk125_clk_gen),\n    .CLKIN2              (1'b0),\n     // Tied to always select the primary input clock\n    .CLKINSEL            (1'b1),\n    // Ports for dynamic reconfiguration\n    .DADDR               (7'h0),\n    .DCLK                (1'b0),\n    .DEN                 (1'b0),\n    .DI                  (16'h0),\n    .DO                  (do_unused),\n    .DRDY                (drdy_unused),\n    .DWE                 (1'b0),\n    // Ports for dynamic phase shift\n    .PSCLK               (1'b0),\n    .PSEN                (1'b0),\n    .PSINCDEC            (1'b0),\n    .PSDONE              (psdone_unused),\n    // Other control and status signals\n    .LOCKED              (clk_locked_int),\n    .CLKINSTOPPED        (clkinstopped_unused),\n    .CLKFBSTOPPED        (clkfbstopped_unused),\n    .PWRDWN              (1'b0),\n    .RST                 (1'b0));\n\n  assign clk_locked = clk_locked_int;\n\n  BUFG clkout1_buf\n   (.O   (clk),\n    .I   (clk_clk_gen));\n\nendmodule"}
{"task_id": 1333, "completion": "parameter FETCH0=0, FETCH1=1, RDMEM=2, RDMEM2=3, EXEC=4 ;   parameter AND=5'bx0000,  LDA=5'bx0001, NOT=5'bx0010, ADD=5'bx0011;   parameter LDAP=5'b01001, STA=5'b11000, STAP=5'b01000;   parameter JPC=5'b11001,  JPZ=5'b11010, JP=5'b11011,  JSR=5'b11100;   parameter RTS=5'b11101,  BSW=5'b11110;   reg [15:0] OR_q, PC_q;   reg [15:0] ACC_q;   reg [2:0]  FSM_q;   reg [4:0]  IR_q;   reg        C_q;   wire       writeback_w = ((FSM_q == EXEC) && (IR_q == STA || IR_q == STAP)) & reset_b ;   assign rnw = ~writeback_w ;   assign data = (writeback_w)?ACC_q:16'bz ;   assign address = ( writeback_w || FSM_q == RDMEM || FSM_q==RDMEM2)? OR_q:PC_q;   always @ (posedge clk or negedge reset_b )     if (!reset_b)       FSM_q <= FETCH0;     else       case(FSM_q)         FETCH0 : FSM_q <= FETCH1;         FETCH1 : FSM_q <= (IR_q[4])?EXEC:RDMEM ;         RDMEM  : FSM_q <= (IR_q==LDAP)?RDMEM2:EXEC;         RDMEM2 : FSM_q <= EXEC;         EXEC   : FSM_q <= FETCH0;       endcase   always @ (posedge clk)     begin        IR_q <= (FSM_q == FETCH0)? data[15:11] : IR_q;        OR_q[15:0] <= data ;        if ( FSM_q == EXEC )          casex (IR_q)            JSR    : ACC_q <= PC_q ;            AND    : {C_q, ACC_q}  <= {1'b0, ACC_q & OR_q};            BSW    : ACC_q <= {ACC_q[7:0], ACC_q[15:8]};            NOT    : ACC_q <= ~OR_q;            LDA    : ACC_q <= OR_q;            LDAP   : ACC_q <= OR_q;            ADD    : {C_q,ACC_q} <= ACC_q + C_q + OR_q;            default: {C_q,ACC_q} <= {C_q,ACC_q};          endcase     end   always @ (posedge clk or negedge reset_b )     if (!reset_b) // On reset start execution at 0x00 to leave page zero clear for variables       PC_q <= 16'h0000;     else       if ( FSM_q == FETCH0 || FSM_q == FETCH1 )         PC_q <= PC_q + 1;       else         case (IR_q)           JP    : PC_q <= OR_q;           JPC   : PC_q <= (C_q)?OR_q:PC_q;           JPZ   : PC_q <= ~(|ACC_q)?OR_q:PC_q;           JSR   : PC_q <= OR_q;           RTS   : PC_q <= ACC_q;           default: PC_q <= PC_q;         endcase   endmodule"}
{"task_id": 1337, "completion": "always @(posedge clk)  begin  if (ce0)  begin  if (we0)  begin  ram[addr0] <= d0;  q0 <= d0; end  else  q0 <= ram[addr0]; end end always @(posedge clk)  begin  if (ce1)  begin  q1 <= ram[addr1]; end endendmodule"}
{"task_id": 1299, "completion": "reg [dw-1:0] COEFFICIENT_0;\n\treg [dw-1:0] COEFFICIENT_1;\n\treg [dw-1:0] COEFFICIENT_2;\n\treg [dw-1:0] COEFFICIENT_3;\n\treg [dw-1:0] COEFFICIENT_4;\n\treg [dw-1:0] COEFFICIENT_5;\n\treg [dw-1:0] COEFFICIENT_6;\n\treg [dw-1:0] COEFFICIENT_7;\n\treg [dw-1:0] COEFFICIENT_8;\n\treg [dw-1:0] COEFFICIENT_9;\n\treg [dw-1:0] COEFFICIENT_10;\n\treg [dw-1:0] COEFFICIENT_11;\n\treg [dw-1:0] COEFFICIENT_12;\n\treg [dw-1:0] COEFFICIENT_13;\n\treg [dw-1:0] COEFFICIENT_14;\n\treg [dw-1:0] COEFFICIENT_15;\n\treg [dw-1:0] COEFFICIENT_16;\n\treg [dw-1:0] COEFFICIENT_17;\n\treg [dw-1:0] COEFFICIENT_18;\n\treg [dw-1:0] COEFFICIENT_19;\n\treg [dw-1:0] COEFFICIENT_20;\n\treg [dw-1:0] COEFFICIENT_21;\n\treg [dw-1:0] COEFFICIENT_22;\n\treg [dw-1:0] COEFFICIENT_23;\n\talways@(posedge clk) begin\n\t\tCOEFFICIENT_0 <= 18'd88;\n\t\tCOEFFICIENT_1 <= 18'd0;\n\t\tCOEFFICIENT_2 <= -18'd97;\n\t\tCOEFFICIENT_3 <= -18'd197;\n\t\tCOEFFICIENT_4 <= -18'd294;\n\t\tCOEFFICIENT_5 <= -18'd380;\n\t\tCOEFFICIENT_6 <= -18'd447;\n\t\tCOEFFICIENT_7 <= -18'd490;\n\t\tCOEFFICIENT_8 <= -18'd504;\n\t\tCOEFFICIENT_9 <= -18'd481;\n\t\tCOEFFICIENT_10 <= -18'd420;\n\t\tCOEFFICIENT_11 <= -18'd319;\n\t\tCOEFFICIENT_12 <= -18'd178;\n\t\tCOEFFICIENT_13 <= 18'd0;\n\t\tCOEFFICIENT_14 <= 18'd212;\n\t\tCOEFFICIENT_15 <= 18'd451;\n\t\tCOEFFICIENT_16 <= 18'd710;\n\t\tCOEFFICIENT_17 <= 18'd980;\n\t\tCOEFFICIENT_18 <= 18'd1252;\n\t\tCOEFFICIENT_19 <= 18'd1514;\n\t\tCOEFFICIENT_20 <= 18'd1756;\n\t\tCOEFFICIENT_21 <= 18'd1971;\n\t\tCOEFFICIENT_22 <= 18'd2147;\n\t\tCOEFFICIENT_23 <= 18'd2278;\n\tend\n\treg [N_VALID_REGS-1:0] VALID_PIPELINE_REGS;\n\talways@(posedge clk or posedge reset) begin\n\t\tif(reset) begin\n\t\t\tVALID_PIPELINE_REGS <= 0;\n\t\tend else begin\n\t\t\tif(clk_ena) begin\n\t\t\t\tVALID_PIPELINE_REGS <= {VALID_PIPELINE_REGS[N_VALID_REGS-2:0], i_valid};\n\t\t\tend else begin\n\t\t\t\tVALID_PIPELINE_REGS <= VALID_PIPELINE_REGS;\n\t\t\tend\n\t\tend\n\tend\n\twire [dw-1:0] INPUT_PIPELINE_REG_0;\n\tinput_pipeline in_pipe(\n\t\t.clk(clk), .clk_ena(clk_ena),\n\t\t.in_stream(i_in),\n\t\t.pipeline_reg_0(INPUT_PIPELINE_REG_0),\n\t\t...\n\t);\n\tassign o_out = L5_output_wires_0;\n\tassign o_valid = VALID_PIPELINE_REGS[N_VALID_REGS-1];\nendmodule"}
{"task_id": 1341, "completion": "wire    dm_out;\n  wire    dm_ce_r;\n\n  FDRSE_1 u_dm_ce\n    (\n     .Q    (dm_ce_r),\n     .C    (clk90),\n     .CE   (1'b1),\n     .D    (dm_ce),\n     .R   (1'b0),\n     .S   (1'b0)\n     ) /* synthesis syn_preserve=1 */;\n\n  ODDR #\n    (\n     .SRTYPE(\"SYNC\"),\n     .DDR_CLK_EDGE(\"SAME_EDGE\")\n     )\n    u_oddr_dm\n      (\n       .Q  (dm_out),\n       .C  (clk90),\n       .CE (dm_ce_r),\n       .D1 (mask_data_rise),\n       .D2 (mask_data_fall),\n       .R  (1'b0),\n       .S  (1'b0)\n       );\n\n  OBUF u_obuf_dm\n    (\n     .I (dm_out),\n     .O (ddr_dm)\n     );\n\nendmodule"}
{"task_id": 1317, "completion": "localparam USER_DR_LENGTH = AWIDTH + 34;reg [USER_DR_LENGTH-1:0] sr, nsr, dr;logic[3:0] state, nstate; logic [4:0] ir;wire jtag_reset;wire shift_dr;wire pause_dr;wire update_dr;wire capture_dr;wire shift_ir;wire pause_ir ;wire update_ir ;wire capture_ir;wire[1:0] dr_en;wire devid_sel;wire [5:0] abits;assign abits = AWIDTH[5:0];localparam TEST_LOGIC_RESET_STATE = 0;localparam RUN_TEST_IDLE_STATE    = 1;localparam SELECT_DR_SCAN_STATE   = 2;localparam CAPTURE_DR_STATE       = 3;localparam SHIFT_DR_STATE         = 4;localparam EXIT1_DR_STATE         = 5;localparam PAUSE_DR_STATE         = 6;localparam EXIT2_DR_STATE         = 7;localparam UPDATE_DR_STATE        = 8;localparam SELECT_IR_SCAN_STATE   = 9;localparam CAPTURE_IR_STATE       = 10;localparam SHIFT_IR_STATE         = 11;localparam EXIT1_IR_STATE         = 12;localparam PAUSE_IR_STATE         = 13;localparam EXIT2_IR_STATE         = 14;localparam UPDATE_IR_STATE        = 15;always_comb  begin; nstate = state; case(state) TEST_LOGIC_RESET_STATE: nstate = tms ? TEST_LOGIC_RESET_STATE : RUN_TEST_IDLE_STATE; RUN_TEST_IDLE_STATE:    nstate = tms ? SELECT_DR_SCAN_STATE   : RUN_TEST_IDLE_STATE; SELECT_DR_SCAN_STATE:   nstate = tms ? SELECT_IR_SCAN_STATE   : CAPTURE_DR_STATE; CAPTURE_DR_STATE:       nstate = tms ? EXIT1_DR_STATE         : SHIFT_DR_STATE; SHIFT_DR_STATE:         nstate = tms ? EXIT1_DR_STATE         : SHIFT_DR_STATE; EXIT1_DR_STATE:         nstate = tms ? UPDATE_DR_STATE        : PAUSE_DR_STATE; PAUSE_DR_STATE:         nstate = tms ? EXIT2_DR_STATE         : PAUSE_DR_STATE; EXIT2_DR_STATE:         nstate = tms ? UPDATE_DR_STATE        : SHIFT_DR_STATE; UPDATE_DR_STATE:        nstate = tms ? SELECT_DR_SCAN_STATE   : RUN_TEST_IDLE_STATE; SELECT_IR_SCAN_STATE:   nstate = tms ? TEST_LOGIC_RESET_STATE : CAPTURE_IR_STATE; CAPTURE_IR_STATE:       nstate = tms ? EXIT1_IR_STATE         : SHIFT_IR_STATE; SHIFT_IR_STATE:         nstate = tms ? EXIT1_IR_STATE         : SHIFT_IR_STATE; EXIT1_IR_STATE:         nstate = tms ? UPDATE_IR_STATE        : PAUSE_IR_STATE; PAUSE_IR_STATE:         nstate = tms ? EXIT2_IR_STATE         : PAUSE_IR_STATE; EXIT2_IR_STATE:         nstate = tms ? UPDATE_IR_STATE        : SHIFT_IR_STATE; UPDATE_IR_STATE:        nstate = tms ? SELECT_DR_SCAN_STATE   : RUN_TEST_IDLE_STATE; default:                nstate = TEST_LOGIC_RESET_STATE; endcase end always @ (posedge tck or negedge trst) begin if(!trst) state <= TEST_LOGIC_RESET_STATE; else state <= nstate; end assign jtag_reset = state == TEST_LOGIC_RESET_STATE;assign shift_dr   = state == SHIFT_DR_STATE;assign pause_dr   = state == PAUSE_DR_STATE;assign update_dr  = state == UPDATE_DR_STATE;assign capture_dr = state == CAPTURE_DR_STATE;assign shift_ir   = state == SHIFT_IR_STATE;assign pause_ir   = state == PAUSE_IR_STATE;assign update_ir  = state == UPDATE_IR_STATE;assign capture_ir = state == CAPTURE_IR_STATE;assign tdoEnable = shift_dr | shift_ir;always @ (negedge tck or negedge trst) begin if (!trst) ir <= 5'b1; else begin if (jtag_reset) ir <= 5'b1; else if (update_ir) ir <= (sr[4:0] == '0) ? 5'h1f :sr[4:0]; end end assign devid_sel  = ir == 5'b00001;assign dr_en[0]   = ir == 5'b10000;assign dr_en[1]   = ir == 5'b10001;always @ (posedge tck or negedge trst) begin if(!trst)begin sr <= '0; end else begin sr <= nsr; end end always_comb begin nsr = sr; case(1) shift_dr:   begin case(1) dr_en[1]:   nsr = {tdi, sr[USER_DR_LENGTH-1:1]}; dr_en[0],devid_sel:  nsr = {{USER_DR_LENGTH-32{1'b0}},tdi, sr[31:1]}; default:    nsr = {{USER_DR_LENGTH-1{1'b0}},tdi}; endcase end capture_dr: begin nsr[0] = 1'b0; case(1) dr_en[0]:   nsr = {{USER_DR_LENGTH-15{1'b0}}, idle, dmi_stat, abits, version}; dr_en[1]:   nsr = {{AWIDTH{1'b0}}, rd_data, rd_status}; devid_sel:  nsr = {{USER_DR_LENGTH-32{1'b0}}, jtag_id, 1'b1}; endcase end shift_ir:   nsr = {{USER_DR_LENGTH-5{1'b0}},tdi, sr[4:1]}; capture_ir: nsr = {{USER_DR_LENGTH-1{1'b0}},1'b1}; endcase end always @ (negedge tck ) tdo <= sr[0]; always @ (posedge tck or negedge trst) begin if(!trst) begin dmi_hard_reset <= 1'b0; dmi_reset      <= 1'b0; end else if (update_dr & dr_en[0]) begin dmi_hard_reset <= sr[17]; dmi_reset      <= sr[16]; end else begin dmi_hard_reset <= 1'b0; dmi_reset      <= 1'b0; end end always @ (posedge tck or negedge trst) begin if(!trst) dr <=  '0; else begin if (update_dr & dr_en[1]) dr <= sr; else dr <= {dr[USER_DR_LENGTH-1:2],2'b0}; end end assign {wr_addr, wr_data, wr_en, rd_en} = dr;endmodule"}
{"task_id": 1343, "completion": "wire [5:0] sub_wire0;\n    wire sub_wire2;\n    wire [0:0] sub_wire3 = 1'h0;\n    wire [0:0] sub_wire5 = 1'h1;\n    wire [0:0] sub_wire1 = sub_wire0[0:0];\n    wire c0 = sub_wire1;\n    wire locked = sub_wire2;\n    wire [5:0] sub_wire4 = {sub_wire3, sub_wire3, sub_wire3, sub_wire3, sub_wire3, sub_wire5};\n    wire sub_wire6 = inclk0;\n    wire [1:0] sub_wire7 = {sub_wire3, sub_wire6};\n    wire [3:0] sub_wire8 = {sub_wire3, sub_wire3, sub_wire3, sub_wire3};\n\n    altpll altpll_component (\n                .clkena(sub_wire4),\n                .inclk(sub_wire7),\n                .extclkena(sub_wire8),\n                .areset(areset),\n                .clk(sub_wire0),\n                .locked(sub_wire2)\n                );\n    defparam\n        altpll_component.bandwidth = 500000,\n        altpll_component.bandwidth_type = \"CUSTOM\",\n        altpll_component.clk0_divide_by = 4,\n        altpll_component.clk0_duty_cycle = 50,\n        altpll_component.clk0_multiply_by = 5,\n        altpll_component.clk0_phase_shift = \"0\",\n        altpll_component.compensate_clock = \"CLK0\",\n        altpll_component.inclk0_input_frequency = 10000,\n        altpll_component.intended_device_family = \"Stratix GX\",\n        altpll_component.invalid_lock_multiplier = 5,\n        altpll_component.lpm_type = \"altpll\",\n        altpll_component.operation_mode = \"NORMAL\",\n        altpll_component.pll_type = \"ENHANCED\",\n        altpll_component.spread_frequency = 0,\n        altpll_component.valid_lock_multiplier = 1;\nendmodule"}
{"task_id": 1336, "completion": "(* syn_encoding = \"user\" *)\n    (* fsm_encoding = \"user\" *)\n    reg     [1:0]                    rState=`S_TXPORTGATE64_IDLE, _rState=`S_TXPORTGATE64_IDLE;\n    reg                             rFifoWen=0, _rFifoWen=0;\n    reg     [C_FIFO_DATA_WIDTH-1:0]    rFifoData=0, _rFifoData=0;\n    wire                            wFifoFull;\n\n    reg                             rChnlTx=0, _rChnlTx=0;\n    reg                             rChnlLast=0, _rChnlLast=0;\n    reg     [31:0]                    rChnlLen=0, _rChnlLen=0;\n    reg     [30:0]                    rChnlOff=0, _rChnlOff=0;\n    reg                             rAck=0, _rAck=0;\n    reg                             rPause=0, _rPause=0;\n    reg                             rClosed=0, _rClosed=0;\n\n    assign CHNL_TX_ACK = rAck;\n    assign CHNL_TX_DATA_REN = (rState[1] & !rState[0] & !wFifoFull); // S_TXPORTGATE64_OPEN\n\n\n    always @ (posedge CHNL_CLK) begin\n        rChnlTx <= #1 (RST ? 1'd0 : _rChnlTx);\n        rChnlLast <= #1 _rChnlLast;\n        rChnlLen <= #1 _rChnlLen;\n        rChnlOff <= #1 _rChnlOff;\n    end\n\n    always @ (*) begin\n        _rChnlTx = CHNL_TX;\n        _rChnlLast = CHNL_TX_LAST;\n        _rChnlLen = CHNL_TX_LEN;\n        _rChnlOff = CHNL_TX_OFF;\n    end\n\n    (* RAM_STYLE=\"DISTRIBUTED\" *)\n    async_fifo #(.C_WIDTH(C_FIFO_DATA_WIDTH), .C_DEPTH(C_FIFO_DEPTH)) fifo (\n        .WR_CLK(CHNL_CLK),\n        .WR_RST(RST),\n        .WR_EN(rFifoWen),\n        .WR_DATA(rFifoData),\n        .WR_FULL(wFifoFull),\n        .RD_CLK(RD_CLK),\n        .RD_RST(RST),\n        .RD_EN(RD_EN),\n        .RD_DATA(RD_DATA),\n        .RD_EMPTY(RD_EMPTY)\n    );\n\n    always @ (posedge CHNL_CLK) begin\n        rState <= #1 (RST ? `S_TXPORTGATE64_IDLE : _rState);\n        rFifoWen <= #1 (RST ? 1'd0 : _rFifoWen);\n        rFifoData <= #1 _rFifoData;\n        rAck <= #1 (RST ? 1'd0 : _rAck);\n        rPause <= #1 (RST ? 1'd0 : _rPause);\n        rClosed <= #1 (RST ? 1'd0 : _rClosed);\n    end\n\n    always @ (*) begin\n        _rState = rState;\n        _rFifoWen = rFifoWen;\n        _rFifoData = rFifoData;\n        _rPause = rPause;\n        _rAck = rAck;\n        _rClosed = rClosed;\n        case (rState)\n\n        `S_TXPORTGATE64_IDLE: begin\n            _rPause = 0;\n            _rClosed = 0;\n            if (!wFifoFull) begin\n                _rAck = rChnlTx;\n                _rFifoWen = rChnlTx;\n                _rFifoData = {1'd1, rChnlLen, rChnlOff, rChnlLast};\n                if (rChnlTx)\n                    _rState = `S_TXPORTGATE64_OPENING;\n            end\n        end\n\n        `S_TXPORTGATE64_OPENING: begin\n            _rAck = 0;\n            _rClosed = (rClosed | !rChnlTx);\n            if (!wFifoFull) begin\n                if (rClosed | !rChnlTx)\n                    _rState = `S_TXPORTGATE64_CLOSED;\n                else\n                    _rState = `S_TXPORTGATE64_OPEN;\n            end\n        end\n\n        `S_TXPORTGATE64_OPEN: begin\n            if (!wFifoFull) begin\n                _rFifoWen = CHNL_TX_DATA_VALID;\n                _rFifoData = {1'd0, CHNL_TX_DATA};\n            end\n            if (!rChnlTx)\n                _rState = `S_TXPORTGATE64_CLOSED;\n        end\n        \n        `S_TXPORTGATE64_CLOSED: begin\n            if (!wFifoFull) begin\n                _rPause = 1;\n                _rFifoWen = 1;\n                _rFifoData = {1'd1, {C_DATA_WIDTH{1'd0}}};\n                if (rPause)\n                _rState = `S_TXPORTGATE64_IDLE;\n            end\n        end\n        \n        endcase    \n    end\n\nendmodule"}
{"task_id": 1340, "completion": "wire[ADDR_WIDTH - 1:0] shiftReg_addr; wire[DATA_WIDTH - 1:0] shiftReg_data, shiftReg_q; wire shiftReg_ce; reg[ADDR_WIDTH:0] mOutPtr = {(ADDR_WIDTH+1){1'b1}}; reg internal_empty_n = 0, internal_full_n = 1; assign if_empty_n = internal_empty_n; assign if_full_n = internal_full_n; assign shiftReg_data = if_din; assign if_dout = shiftReg_q; always @ (posedge clk) begin if (reset == 1'b1) begin mOutPtr <= ~{ADDR_WIDTH+1{1'b0}}; internal_empty_n <= 1'b0; internal_full_n <= 1'b1; end else begin if (((if_read & if_read_ce) == 1 & internal_empty_n == 1) && ((if_write & if_write_ce) == 0 | internal_full_n == 0)) begin mOutPtr <= mOutPtr - 1; if (mOutPtr == 0) internal_empty_n <= 1'b0; internal_full_n <= 1'b1; end else if (((if_read & if_read_ce) == 0 | internal_empty_n == 0) && ((if_write & if_write_ce) == 1 & internal_full_n == 1)) begin mOutPtr <= mOutPtr + 1; internal_empty_n <= 1'b1; if (mOutPtr == DEPTH - 2) internal_full_n <= 1'b0; end end end always @* begin shiftReg_addr = mOutPtr[ADDR_WIDTH] == 1'b0 ? mOutPtr[ADDR_WIDTH-1:0]:{ADDR_WIDTH{1'b0}}; shiftReg_ce = (if_write & if_write_ce) & internal_full_n; end fifo_w64_d2_A_shiftReg #( .DATA_WIDTH(DATA_WIDTH), .ADDR_WIDTH(ADDR_WIDTH), .DEPTH(DEPTH)) U_fifo_w64_d2_A_ram ( .clk(clk), .data(shiftReg_data), .ce(shiftReg_ce), .a(shiftReg_addr), .q(shiftReg_q)); endmodule"}
{"task_id": 1353, "completion": "reg  [9:0] pixel_count;\nreg  [9:0] line_count;\n\nassign PIXEL_X    = pixel_count;\nassign PIXEL_Y    = line_count;\n\nassign PIXEL_COLOR_OUT = (pixel_count<(`VISIBLE_SCREEN_WIDTH) /*&& (line_count<`VISIBLE_SCREEN_HEIGHT)*/)\n\t\t\t\t\t\t? (PIXEL_COLOR_IN) : (8'b00000000);\n\t\nassign H_SYNC_NEG = (pixel_count>=656 && pixel_count<752) ? (1'b0) : (1'b1);\nassign V_SYNC_NEG = (line_count>=490 && line_count<492) ? (1'b0) : (1'b1);\n\nalways @(posedge CLOCK) begin\n\tif (RESET) begin\n\t\tpixel_count <= 10'b0;\n\t\tline_count <= 10'b0;\n\tend\n\telse if (pixel_count == (`TOTAL_SCREEN_WIDTH-1)) begin\n\t\tpixel_count <= 0;\n\t\tif (line_count == (`TOTAL_SCREEN_HEIGHT-1)) begin\n\t\t\tline_count <= 0;\n\t\tend \n\t\telse begin\n\t\t\tline_count <= line_count + 1;\n\t\tend\n\tend \n\telse begin\n\t\tpixel_count <= pixel_count + 1;\n\t\tline_count <= line_count;\n\tend\nend\n\nendmodule"}
{"task_id": 1320, "completion": "parameter dw = 18; parameter N = 31; parameter N_UNIQ = 16; localparam N_VALID_REGS = 32; reg [dw-1:0] COEFFICIENT_0; reg [dw-1:0] COEFFICIENT_1; reg [dw-1:0] COEFFICIENT_2; reg [dw-1:0] COEFFICIENT_3; reg [dw-1:0] COEFFICIENT_4; reg [dw-1:0] COEFFICIENT_5; reg [dw-1:0] COEFFICIENT_6; reg [dw-1:0] COEFFICIENT_7; reg [dw-1:0] COEFFICIENT_8; reg [dw-1:0] COEFFICIENT_9; reg [dw-1:0] COEFFICIENT_10; reg [dw-1:0] COEFFICIENT_11; reg [dw-1:0] COEFFICIENT_12; reg [dw-1:0] COEFFICIENT_13; reg [dw-1:0] COEFFICIENT_14; reg [dw-1:0] COEFFICIENT_15; always@(posedge clk) begin COEFFICIENT_0 <= 18'd88; COEFFICIENT_1 <= 18'd0; COEFFICIENT_2 <= -18'd97; COEFFICIENT_3 <= -18'd197; COEFFICIENT_4 <= -18'd294; COEFFICIENT_5 <= -18'd380; COEFFICIENT_6 <= -18'd447; COEFFICIENT_7 <= -18'd490; COEFFICIENT_8 <= -18'd504; COEFFICIENT_9 <= -18'd481; COEFFICIENT_10 <= -18'd420; COEFFICIENT_11 <= -18'd319; COEFFICIENT_12 <= -18'd178; COEFFICIENT_13 <= 18'd0; COEFFICIENT_14 <= 18'd212; COEFFICIENT_15 <= 18'd451; end reg [N_VALID_REGS-1:0] VALID_PIPELINE_REGS; always@(posedge clk or posedge reset) begin if(reset) begin VALID_PIPELINE_REGS <= 0; end else begin if(clk_ena) begin VALID_PIPELINE_REGS <= {VALID_PIPELINE_REGS[N_VALID_REGS-2:0], i_valid}; end else begin VALID_PIPELINE_REGS <= VALID_PIPELINE_REGS; end end end wire [dw-1:0] INPUT_PIPELINE_REG_0; wire [dw-1:0] INPUT_PIPELINE_REG_1; wire [dw-1:0] INPUT_PIPELINE_REG_2; wire [dw-1:0] INPUT_PIPELINE_REG_3; wire [dw-1:0] INPUT_PIPELINE_REG_4; wire [dw-1:0] INPUT_PIPELINE_REG_5; wire [dw-1:0] INPUT_PIPELINE_REG_6; wire [dw-1:0] INPUT_PIPELINE_REG_7; wire [dw-1:0] INPUT_PIPELINE_REG_8; wire [dw-1:0] INPUT_PIPELINE_REG_9; wire [dw-1:0] INPUT_PIPELINE_REG_10; wire [dw-1:0] INPUT_PIPELINE_REG_11; wire [dw-1:0] INPUT_PIPELINE_REG_12; wire [dw-1:0] INPUT_PIPELINE_REG_13; wire [dw-1:0] INPUT_PIPELINE_REG_14; wire [dw-1:0] INPUT_PIPELINE_REG_15; wire [dw-1:0] INPUT_PIPELINE_REG_16; wire [dw-1:0] INPUT_PIPELINE_REG_17; wire [dw-1:0] INPUT_PIPELINE_REG_18; wire [dw-1:0] INPUT_PIPELINE_REG_19; wire [dw-1:0] INPUT_PIPELINE_REG_20; wire [dw-1:0] INPUT_PIPELINE_REG_21; wire [dw-1:0] INPUT_PIPELINE_REG_22; wire [dw-1:0] INPUT_PIPELINE_REG_23; wire [dw-1:0] INPUT_PIPELINE_REG_24; wire [dw-1:0] INPUT_PIPELINE_REG_25; wire [dw-1:0] INPUT_PIPELINE_REG_26; wire [dw-1:0] INPUT_PIPELINE_REG_27; wire [dw-1:0] INPUT_PIPELINE_REG_28; wire [dw-1:0] INPUT_PIPELINE_REG_29; wire [dw-1:0] INPUT_PIPELINE_REG_30; input_pipeline in_pipe(.clk(clk), .clk_ena(clk_ena), .in_stream(i_in), .pipeline_reg_0(INPUT_PIPELINE_REG_0), .pipeline_reg_1(INPUT_PIPELINE_REG_1), .pipeline_reg_2(INPUT_PIPELINE_REG_2), .pipeline_reg_3(INPUT_PIPELINE_REG_3), .pipeline_reg_4(INPUT_PIPELINE_REG_4), .pipeline_reg_5(INPUT_PIPELINE_REG_5), .pipeline_reg_6(INPUT_PIPELINE_REG_6), .pipeline_reg_7(INPUT_PIPELINE_REG_7), .pipeline_reg_8(INPUT_PIPELINE_REG_8), .pipeline_reg_9(INPUT_PIPELINE_REG_9), .pipeline_reg_10(INPUT_PIPELINE_REG_10), .pipeline_reg_11(INPUT_PIPELINE_REG_11), .pipeline_reg_12(INPUT_PIPELINE_REG_12), .pipeline_reg_13(INPUT_PIPELINE_REG_13), .pipeline_reg_14(INPUT_PIPELINE_REG_14), .pipeline_reg_15(INPUT_PIPELINE_REG_15), .pipeline_reg_16(INPUT_PIPELINE_REG_16), .pipeline_reg_17(INPUT_PIPELINE_REG_17), .pipeline_reg_18(INPUT_PIPELINE_REG_18), .pipeline_reg_19(INPUT_PIPELINE_REG_19), .pipeline_reg_20(INPUT_PIPELINE_REG_20), .pipeline_reg_21(INPUT_PIPELINE_REG_21), .pipeline_reg_22(INPUT_PIPELINE_REG_22), .pipeline_reg_23(INPUT_PIPELINE_REG_23), .pipeline_reg_24(INPUT_PIPELINE_REG_24), .pipeline_reg_25(INPUT_PIPELINE_REG_25), .pipeline_reg_26(INPUT_PIPELINE_REG_26), .pipeline_reg_27(INPUT_PIPELINE_REG_27), .pipeline_reg_28(INPUT_PIPELINE_REG_28), .pipeline_reg_29(INPUT_PIPELINE_REG_29), .pipeline_reg_30(INPUT_PIPELINE_REG_30), .reset(reset)); defparam in_pipe.WIDTH = 18; wire [dw-1:0] L0_output_wires_0; wire [dw-1:0] L0_output_wires_1; wire [dw-1:0] L0_output_wires_2; wire [dw-1:0] L0_output_wires_3; wire [dw-1:0] L0_output_wires_4; wire [dw-1:0] L0_output_wires_5; wire [dw-1:0] L0_output_wires_6; wire [dw-1:0] L0_output_wires_7; wire [dw-1:0] L0_output_wires_8; wire [dw-1:0] L0_output_wires_9; wire [dw-1:0] L0_output_wires_10; wire [dw-1:0] L0_output_wires_11; wire [dw-1:0] L0_output_wires_12; wire [dw-1:0] L0_output_wires_13; wire [dw-1:0] L0_output_wires_14; wire [dw-1:0] L0_output_wires_15; adder_with_1_reg L0_adder_0and30(.dataa (INPUT_PIPELINE_REG_0), .datab (INPUT_PIPELINE_REG_30), .result(L0_output_wires_0)); adder_with_1_reg L0_adder_1and29(.dataa (INPUT_PIPELINE_REG_1), .datab (INPUT_PIPELINE_REG_29), .result(L0_output_wires_1)); adder_with_1_reg L0_adder_2and28(.dataa (INPUT_PIPELINE_REG_2), .datab (INPUT_PIPELINE_REG_28), .result(L0_output_wires_2)); adder_with_1_reg L0_adder_3and27(.dataa (INPUT_PIPELINE_REG_3), .datab (INPUT_PIPELINE_REG_27), .result(L0_output_wires_3)); adder_with_1_reg L0_adder_4and26(.dataa (INPUT_PIPELINE_REG_4), .datab (INPUT_PIPELINE_REG_26), .result(L0_output_wires_4)); adder_with_1_reg L0_adder_5and25(.dataa (INPUT_PIPELINE_REG_5), .datab (INPUT_PIPELINE_REG_25), .result(L0_output_wires_5)); adder_with_1_reg L0_adder_6and24(.dataa (INPUT_PIPELINE_REG_6), .datab (INPUT_PIPELINE_REG_24), .result(L0_output_wires_6)); adder_with_1_reg L0_adder_7and23(.dataa (INPUT_PIPELINE_REG_7), .datab (INPUT_PIPELINE_REG_23), .result(L0_output_wires_7)); adder_with_1_reg L0_adder_8and22(.dataa (INPUT_PIPELINE_REG_8), .datab (INPUT_PIPELINE_REG_22), .result(L0_output_wires_8)); adder_with_1_reg L0_adder_9and21(.dataa (INPUT_PIPELINE_REG_9), .datab (INPUT_PIPELINE_REG_21), .result(L0_output_wires_9)); adder_with_1_reg L0_adder_10and20(.dataa (INPUT_PIPELINE_REG_10), .datab (INPUT_PIPELINE_REG_20), .result(L0_output_wires_10)); adder_with_1_reg L0_adder_11and19(.dataa (INPUT_PIPELINE_REG_11), .datab (INPUT_PIPELINE_REG_19), .result(L0_output_wires_11)); adder_with_1_reg L0_adder_12and18(.dataa (INPUT_PIPELINE_REG_12), .datab (INPUT_PIPELINE_REG_18), .result(L0_output_wires_12)); adder_with_1_reg L0_adder_13and17(.dataa (INPUT_PIPELINE_REG_13), .datab (INPUT_PIPELINE_REG_17), .result(L0_output_wires_13)); adder_with_1_reg L0_adder_14and16(.dataa (INPUT_PIPELINE_REG_14), .datab (INPUT_PIPELINE_REG_16), .result(L0_output_wires_14)); one_register L0_byereg_for_15(.dataa (INPUT_PIPELINE_REG_15), .result(L0_output_wires_15)); wire [dw-1:0] L1_mult_wires_0; wire [dw-1:0] L1_mult_wires_1; wire [dw-1:0] L1_mult_wires_2; wire [dw-1:0] L1_mult_wires_3; wire [dw-1:0] L1_mult_wires_4; wire [dw-1:0] L1_mult_wires_5; wire [dw-1:0] L1_mult_wires_6; wire [dw-1:0] L1_mult_wires_7; wire [dw-1:0] L1_mult_wires_8; wire [dw-1:0] L1_mult_wires_9; wire [dw-1:0] L1_mult_wires_10; wire [dw-1:0] L1_mult_wires_11; wire [dw-1:0] L1_mult_wires_12; wire [dw-1:0] L1_mult_wires_13; wire [dw-1:0] L1_mult_wires_14; wire [dw-1:0] L1_mult_wires_15; multiplier_with_reg L1_mul_0(.dataa (L0_output_wires_0), .datab (COEFFICIENT_0), .result(L1_mult_wires_0)); multiplier_with_reg L1_mul_1(.dataa (L0_output_wires_1), .datab (COEFFICIENT_1), .result(L1_mult_wires_1)); multiplier_with_reg L1_mul_2(.dataa (L0_output_wires_2), .datab (COEFFICIENT_2), .result(L1_mult_wires_2)); multiplier_with_reg L1_mul_3(.dataa (L0_output_wires_3), .datab (COEFFICIENT_3), .result(L1_mult_wires_3)); multiplier_with_reg L1_mul_4(.dataa (L0_output_wires_4), .datab (COEFFICIENT_4), .result(L1_mult_wires_4)); multiplier_with_reg L1_mul_5(.dataa (L0_output_wires_5), .datab (COEFFICIENT_5), .result(L1_mult_wires_5)); multiplier_with_reg L1_mul_6(.dataa (L0_output_wires_6), .datab (COEFFICIENT_6), .result(L1_mult_wires_6)); multiplier_with_reg L1_mul_7(.dataa (L0_output_wires_7), .datab (COEFFICIENT_7), .result(L1_mult_wires_7)); multiplier_with_reg L1_mul_8(.dataa (L0_output_wires_8), .datab (COEFFICIENT_8), .result(L1_mult_wires_8)); multiplier_with_reg L1_mul_9(.dataa (L0_output_wires_9), .datab (COEFFICIENT_9), .result(L1_mult_wires_9)); multiplier_with_reg L1_mul_10(.dataa (L0_output_wires_10), .datab (COEFFICIENT_10), .result(L1_mult_wires_10)); multiplier_with_reg L1_mul_11(.dataa (L0_output_wires_11), .datab (COEFFICIENT_11), .result(L1_mult_wires_11)); multiplier_with_reg L1_mul_12(.dataa (L0_output_wires_12), .datab (COEFFICIENT_12), .result(L1_mult_wires_12)); multiplier_with_reg L1_mul_13(.dataa (L0_output_wires_13), .datab (COEFFICIENT_13), .result(L1_mult_wires_13)); multiplier_with_reg L1_mul_14(.dataa (L0_output_wires_14), .datab (COEFFICIENT_14), .result(L1_mult_wires_14)); multiplier_with_reg L1_mul_15(.dataa (L0_output_wires_15), .datab (COEFFICIENT_15), .result(L1_mult_wires_15)); wire [dw-1:0] L1_output_wires_0; wire [dw-1:0] L1_output_wires_1; wire [dw-1:0] L1_output_wires_2; wire [dw-1:0] L1_output_wires_3; wire [dw-1:0] L1_output_wires_4; wire [dw-1:0] L1_output_wires_5; wire [dw-1:0] L1_output_wires_6; wire [dw-1:0] L1_output_wires_7; adder_with_1_reg L1_adder_0and1(.dataa (L1_mult_wires_0), .datab (L1_mult_wires_1), .result(L1_output_wires_0)); adder_with_1_reg L1_adder_2and3(.dataa (L1_mult_wires_2), .datab (L1_mult_wires_3), .result(L1_output_wires_1)); adder_with_1_reg L1_adder_4and5(.dataa (L1_mult_wires_4), .datab (L1_mult_wires_5), .result(L1_output_wires_2)); adder_with_1_reg L1_adder_6and7(.dataa (L1_mult_wires_6), .datab (L1_mult_wires_7), .result(L1_output_wires_3)); adder_with_1_reg L1_adder_8and9(.dataa (L1_mult_wires_8), .datab (L1_mult_wires_9), .result(L1_output_wires_4)); adder_with_1_reg L1_adder_10and11(.dataa (L1_mult_wires_10), .datab (L1_mult_wires_11), .result(L1_output_wires_5)); adder_with_1_reg L1_adder_12and13(.dataa (L1_mult_wires_12), .datab (L1_mult_wires_13), .result(L1_output_wires_6)); adder_with_1_reg L1_adder_14and15(.dataa (L1_mult_wires_14), .datab (L1_mult_wires_15), .result(L1_output_wires_7)); wire [dw-1:0] L2_output_wires_0; wire [dw-1:0] L2_output_wires_1; wire [dw-1:0] L2_output_wires_2; wire [dw-1:0] L2_output_wires_3; adder_with_1_reg L2_adder_0and1(.dataa (L1_output_wires_0), .datab (L1_output_wires_1), .result(L2_output_wires_0)); adder_with_1_reg L2_adder_2and3(.dataa (L1_output_wires_2), .datab (L1_output_wires_3), .result(L2_output_wires_1)); adder_with_1_reg L2_adder_4and5(.dataa (L1_output_wires_4), .datab (L1_output_wires_5), .result(L2_output_wires_2)); adder_with_1_reg L2_adder_6and7(.dataa (L1_output_wires_6), .datab (L1_output_wires_7), .result(L2_output_wires_3)); wire [dw-1:0] L3_output_wires_0; wire [dw-1:0] L3_output_wires_1; adder_with_1_reg L3_adder_0and1(.dataa (L2_output_wires_0), .datab (L2_output_wires_1), .result(L3_output_wires_0)); adder_with_1_reg L3_adder_2and3(.dataa (L2_output_wires_2), .datab (L2_output_wires_3), .result(L3_output_wires_1)); wire [dw-1:0] L4_output_wires_0; adder_with_1_reg L4_adder_0and1(.dataa (L3_output_wires_0), .datab (L3_output_wires_1), .result(L4_output_wires_0)); reg [17:0] o_out; always @(posedge clk) begin if(clk_ena) begin o_out <= L4_output_wires_0; end end assign o_valid = VALID_PIPELINE_REGS[N_VALID_REGS-1]; endmodule"}
{"task_id": 1261, "completion": "wire debug;\n\n    reg scl;\n    reg sda_en;\n    reg ack_status;\n    reg [3:0] main_state;\n    reg [4:0] i2c_state;\n    reg [7:0] data_reg;\n\n    parameter data_7 = 4'h0;\n    parameter data_6 = 4'h1;\n    parameter data_5 = 4'h2;\n    parameter data_4 = 4'h3;\n    parameter data_3 = 4'h4;\n    parameter data_2 = 4'h5;\n    parameter data_1 = 4'h6;\n    parameter data_0 = 4'h7;\n    parameter data_act = 4'h8;\n\n    parameter idle_status = 4'h0;\n    parameter start_status = 4'h1;\n    parameter address_status = 4'h2;\n    parameter read_status = 4'h3;\n    parameter write_status = 4'h4;\n    parameter stop_status = 4'h5;\n    parameter delay_status = 4'h6;\n\n    `define clock_100K 'd250\n    `define clock_100K_delay (`clock_100K - 150)\n    `define clock_100K_delay_1 (`clock_100K - 10)\n    `define clock_100K_delay_2 (`clock_100K - 20)\n    `define delay_scls 'd14 \n\n    reg start_reg;\n    reg stop_reg;\n    reg control_phase;\n\n    wire scl_risingedge;\n    wire scl_fallingedge;\n\n    reg sda_w;\n    reg sda_c;\n\n    reg [6:0] addr_reg;\n    reg [7:0] delay_reg;\n    reg addressed;\n\n    reg control_flag;\n\n    assign sda_out = control_phase ? sda_c : sda_w;\n\n    reg [7:0] clk_div;\n    always @(posedge clock or negedge reset_n) begin\n        if (!reset_n) begin\n            scl <= 1'bz;\n            clk_div <= 'h0;\n        end else begin\n            if (main_state != idle_status && main_state != stop_status) begin\n                if (main_state == delay_status) begin\n                    scl <= 1'b0;\n                    clk_div <= 'h0;\n                end else if (clk_div > `clock_100K) begin\n                    scl <= ~scl;\n                    clk_div <= 'h0;\n                end else\n                    clk_div <= clk_div + 1'b1;\n            end else if (main_state == idle_status)\n                scl <= 1'b1;\n            else if (main_state == stop_status)\n                if (delay_reg < `clock_100K && ~control_flag)\n                    scl <= 1'b0;\n                else\n                    scl <= 1'b1;\n            end\n    end\n\n    reg curr, last;\n    always @(posedge clock) begin\n        if (!reset_n) begin\n            curr <= 1'b0;\n            last <= 1'b0;\n        end else begin\n            curr <= scl;\n            last <= curr;\n        end\n    end\n\n    assign scl_risingedge = curr & (~last);\n    assign scl_fallingedge = ~curr & (last);\n    assign debug = sda_out;\n\n    always @(posedge clock or negedge reset_n) begin\n        if (!reset_n) begin\n            start_reg <= 1'b0;\n            control_flag <= 1'b0;\n            stop_reg <= 1'b0;\n            sda_c <= 1'b1;\n        end else begin\n            if (main_state == start_status) begin\n                if (scl && (~control_flag) && (~scl_risingedge) && (~start_reg)) begin\n                    if (delay_reg > `clock_100K_delay) begin\n                        control_flag <= 1'b1;\n                        sda_c <= 1'b0;\n                    end\n                end\n                if (~scl && control_flag) begin\n                    start_reg <= 1'b1;\n                    control_flag <= 1'b0;\n                    sda_c <= 1'b1;\n                end\n            end else if (main_state == stop_status) begin\n                if (~scl && ~control_flag && ~stop_reg) begin\n                    if (delay_reg > `clock_100K_delay_1) begin\n                        control_flag <= 1'b1;\n                        sda_c <= 1'b0;\n                    end\n                end\n                if (scl && control_flag && delay_reg == `clock_100K_delay_2) begin\n                    stop_reg <= 1'b1;\n                    control_flag <= 1'b1;\n                    sda_c <= 1'b1;\n                end\n            end else if (main_state == address_status) begin\n                start_reg <= 1'b0;\n                sda_c <= 1'b0;\n            end else if (main_state == idle_status) begin\n                stop_reg <= 1'b0;\n                sda_c <= 1'b1;\n            end else begin\n                start_reg <= 1'b0;\n                control_flag <= 1'b0;\n                stop_reg <= 1'b0;\n                sda_c <= 1'b0;\n            end\n        end\n    end\n\n    always @(posedge clock or negedge reset_n) begin\n        if (!reset_n) begin\n            main_state <= idle_status;\n            control_phase <= 1'b1;\n            delay_reg <= 'h0;\n            addr_reg <= 7'b1111110;\n        end else begin\n            case (main_state)\n                idle_status: begin\n                    if (RD || WR) begin\n                        main_state <= start_status;\n                        control_phase <= 1'b1;\n                        addr_reg <= 7'b1111110;\n                    end else begin\n                        main_state <= idle_status;\n                        control_phase <= 1'b0;\n                    end\n                end\n                start_status: begin\n                    if ((RD || WR) && start_reg) begin\n                        main_state <= address_status;\n                        control_phase <= 1'b0;\n                        delay_reg <= 'h0;\n                    end else begin\n                        main_state <= start_status;\n                        control_phase <= 1'b1;\n                        delay_reg <= delay_reg + 1'b1;\n                    end\n                end\n                address_status: begin\n                    if (ack_status && addressed && ~scl) begin\n                        main_state <= delay_status;\n                        addr_reg <= `delay_scls;\n                    end else if (!ack_status) begin\n                        main_state <= stop_status;\n                        control_phase <= 1'b1;\n                        delay_reg <= 'h0;\n                    end\n                end\n                delay_status: begin\n                    delay_reg <= delay_reg + 1;\n                    if (delay_reg > `clock_100K) begin\n                        addr_reg <= addr_reg - 1;\n                        delay_reg <= 0;\n                    end\n                    if (RD && addr_reg == 'd0) begin\n                        main_state <= read_status;\n                        delay_reg <= 'd0;\n                    end else if (WR && addr_reg == 'd0) begin\n                        main_state <= write_status;\n                        delay_reg <= 'd0;\n                    end\n                end\n                read_status: begin\n                    if (RD)\n                        main_state <= read_status;\n                    else if (WR)\n                        main_state <= start_status;\n                    else begin\n                        main_state <= stop_status;\n                        control_phase <= 1'b1;\n                        delay_reg <= 'h0;\n                    end\n                end\n                write_status: begin\n                    if (WR && !ack_status)\n                        main_state <= stop_status;\n                    else if (WR)\n                        main_state <= write_status;\n                    else if (RD)\n                        main_state <= start_status;\n                    else begin\n                        main_state <= stop_status;\n                        control_phase <= 1'b1;\n                        delay_reg <= 'h0;\n                    end\n                end\n                stop_status: begin\n                    if (stop_reg) begin\n                        main_state <= idle_status;\n                        delay_reg <= 'h0;\n                    end else\n                        delay_reg <= delay_reg + 1'b1;\n                end\n                default:\n                    main_state <= idle_status;\n            endcase\n        end\n    end\n\n    reg op_flag;\n    always @(posedge clock or negedge reset_n) begin\n        if (!reset_n) begin\n            ack_status <= 1'b1;\n            i2c_state <= data_7;\n            sda_en <= 1'b0;\n            sda_w <= 1'b1;\n            addressed <= 1'b0;\n            op_flag <= 1'b0;\n        end else begin\n            if (main_state == idle_status) begin\n                data_reg <= data;\n                sda_en <= 1'b1;\n                sda_w <= 1'b1;\n                ack_status <= 1'b1;\n                i2c_state <= data_7;\n                addressed <= 1'b0;\n                op_flag <= 1'b0;\n            end else if (main_state == address_status || main_state == read_status || main_state == write_status || main_state == start_status || main_state == delay_status) begin\n                case (i2c_state)\n                    data_7: begin\n                        if (scl_fallingedge) begin\n                            op_flag <= 1'b1;\n                            if (main_state == start_status) begin\n                                sda_w <= addr_reg[6];\n                                sda_en <= 1'b1;\n                                addressed <= 1'b0;\n                            end else if (main_state == read_status) begin\n                                sda_en <= 1'b0;\n                            end else if (main_state == write_status) begin\n                                sda_en <= 1'b1;\n                                sda_w <= data_reg[7];\n                            end else if (main_state == delay_status) begin\n                                sda_en <= WR ? 1'b1 : 1'b0;\n                                sda_w <= WR ? data_reg[7] : 1'b1;\n                            end\n                        end else if (scl_risingedge && op_flag) begin\n                            i2c_state <= data_6;\n                            op_flag <= 1'b0;\n                        end\n                    end\n                    data_6: begin\n                        if (scl_fallingedge) begin\n                            op_flag <= 1'b1;\n                            if (main_state == address_status) begin\n                                sda_w <= addr_reg[5];\n                            end else if (main_state == read_status) begin\n                                i2c_state <= data_6;\n                            end else if (main_state == write_status) begin\n                                sda_w <= data_reg[6];\n                            end\n                        end else if (scl_risingedge && op_flag) begin\n                            i2c_state <= data_5;\n                            op_flag <= 1'b0;\n                        end\n                    end\n                    data_5: begin\n                        if (scl_fallingedge) begin\n                            op_flag <= 1'b1;\n                            if (main_state == address_status) begin\n                                sda_w <= addr_reg[4];\n                            end else if (main_state == read_status) begin\n                                i2c_state <= data_5;\n                            end else if (main_state == write_status) begin\n                                sda_w <= data_reg[5];\n                            end\n                        end else if (scl_risingedge && op_flag) begin\n                            i2c_state <= data_4;\n                            op_flag <= 1'b0;\n                        end\n                    end\n                    data_4: begin\n                        if (scl_fallingedge) begin\n                            op_flag <= 1'b1;\n                            if (main_state == address_status) begin\n                                sda_w <= addr_reg[3];\n                            end else if (main_state == read_status) begin\n                                i2c_state <= data_4;\n                            end else if (main_state == write_status) begin\n                                sda_w <= data_reg[4];\n                            end\n                        end else if (scl_risingedge && op_flag) begin\n                            i2c_state <= data_3;\n                            op_flag <= 1'b0;\n                        end\n                    end\n                    data_3: begin\n                        if (scl_fallingedge) begin\n                            op_flag <= 1'b1;\n                            if (main_state == address_status) begin\n                                sda_w <= addr_reg[2];\n                            end else if (main_state == read_status) begin\n                                i2c_state <= data_3;\n                            end else if (main_state == write_status) begin\n                                sda_w <= data_reg[3];\n                            end\n                        end else if (scl_risingedge && op_flag) begin\n                            i2c_state <= data_2;\n                            op_flag <= 1'b0;\n                        end\n                    end\n                    data_2: begin\n                        if (scl_fallingedge) begin\n                            op_flag <= 1'b1;\n                            if (main_state == address_status) begin\n                                sda_w <= addr_reg[1];\n                            end else if (main_state == read_status) begin\n                                i2c_state <= data_2;\n                            end else if (main_state == write_status) begin\n                                sda_w <= data_reg[2];\n                            end\n                        end else if (scl_risingedge && op_flag) begin\n                            i2c_state <= data_1;\n                            op_flag <= 1'b0;\n                        end\n                    end\n                    data_1: begin\n                        if (scl_fallingedge) begin\n                            op_flag <= 1'b1;\n                            if (main_state == address_status) begin\n                                sda_w <= addr_reg[0];\n                            end else if (main_state == read_status) begin\n                                i2c_state <= data_1;\n                            end else if (main_state == write_status) begin\n                                sda_w <= data_reg[1];\n                            end\n                        end else if (scl_risingedge && op_flag) begin\n                            i2c_state <= data_0;\n                            op_flag <= 1'b0;\n                        end\n                    end\n                    data_0: begin\n                        if (scl_fallingedge) begin\n                            op_flag <= 1'b1;\n                            if (main_state == address_status) begin\n                                sda_w <= ~WR;\n                            end else if (main_state == read_status) begin\n                                i2c_state <= data_0;\n                            end else if (main_state == write_status) begin\n                                sda_w <= data_reg[0];\n                            end\n                        end else if (scl_risingedge && op_flag) begin\n                            i2c_state <= data_act;\n                            op_flag <= 1'b0;\n                        end\n                    end\n                    data_act: begin\n                        if (scl_risingedge && op_flag) begin\n                            op_flag <= 1'b0;\n                            if (main_state == address_status) begin\n                                ack_status <= 1'b1;\n                                i2c_state <= data_7;\n                                addressed <= 1'b1;\n                            end else if (main_state == read_status) begin\n                                ack_status <= 1'b1;\n                            end else if (main_state == write_status) begin\n                                ack_status <= ~sda_in;\n                            end\n                        end else if (scl_fallingedge) begin\n                            op_flag <= 1'b1;\n                            data_reg <= data;\n                            if (main_state == read_status) begin\n                                sda_w <= 1'b0;\n                                sda_en <= 1'b1;\n                            end else begin\n                                sda_en <= 1'b0;\n                            end\n                        end\n                    end\n                    default:\n                        i2c_state <= i2c_state;\n                endcase\n            end else if (main_state == stop_status) begin\n                sda_en <= 1'b1;\n                sda_w <= 1'b1;\n            end else begin\n                ack_status <= 1'b0;\n                addressed <= 1'b0;\n                i2c_state <= data_7;\n            end\n        end\n    end\nendmodule"}
{"task_id": 1322, "completion": "reg [1:0] cSCL, cSDA;      \n    reg [2:0] fSCL, fSDA;      \n    reg sSCL, sSDA;      \n    reg dSCL, dSDA;      \n    reg dscl_oen;        \n    reg sda_chk;         \n    reg clk_en;          \n    reg slave_wait;      \n    reg [15:0] cnt;      \n    reg [13:0] filter_cnt;      \n    reg [5:0] c_state; \n    always @(posedge clk)      dscl_oen <= #1 scl_oen;    \n    always @(posedge clk or negedge nReset)      if (!nReset) slave_wait <= 1'b0;      else         slave_wait <= (scl_oen & ~dscl_oen & ~sSCL) | (slave_wait & ~sSCL);    \n    wire scl_sync   = dSCL & ~sSCL & scl_oen;    \n    always @(posedge clk or negedge nReset)      if (~nReset)      begin        cnt    <= #1 16'h0;        clk_en <= #1 1'b1;      end      else if (rst || ~|cnt || !ena || scl_sync)      begin        cnt    <= #1 clk_cnt;        clk_en <= #1 1'b1;      end      else if (slave_wait)      begin        cnt    <= #1 cnt;        clk_en <= #1 1'b0;      end      else      begin        cnt    <= #1 cnt - 16'h1;        clk_en <= #1 1'b0;      end    \n    always @(posedge clk or negedge nReset)      if (!nReset)      begin        cSCL <= #1 2'b00;        cSDA <= #1 2'b00;      end      else if (rst)      begin        cSCL <= #1 2'b00;        cSDA <= #1 2'b00;      end      else      begin        cSCL <= {cSCL[0],scl_i};        cSDA <= {cSDA[0],sda_i};      end    \n    always @(posedge clk or negedge nReset)      if      (!nReset     ) filter_cnt <= 14'h0;      else if (rst || !ena ) filter_cnt <= 14'h0;      else if (~|filter_cnt) filter_cnt <= clk_cnt >> 2;      else                   filter_cnt <= filter_cnt -1;    \n    always @(posedge clk or negedge nReset)      if (!nReset)      begin        fSCL <= 3'b111;        fSDA <= 3'b111;      end      else if (rst)      begin        fSCL <= 3'b111;        fSDA <= 3'b111;      end      else if (~|filter_cnt)      begin        fSCL <= {fSCL[1:0],cSCL[1]};        fSDA <= {fSDA[1:0],cSDA[1]};      end    \n    always @(posedge clk or negedge nReset)      if (~nReset)      begin        sSCL <= #1 1'b1;        sSDA <= #1 1'b1;        dSCL <= #1 1'b1;        dSDA <= #1 1'b1;      end      else if (rst)      begin        sSCL <= #1 1'b1;        sSDA <= #1 1'b1;        dSCL <= #1 1'b1;        dSDA <= #1 1'b1;      end      else      begin        sSCL <= #1 &fSCL[2:1] | &fSCL[1:0] | (fSCL[2] & fSCL[0]);        sSDA <= #1 &fSDA[2:1] | &fSDA[1:0] | (fSDA[2] & fSDA[0]);        dSCL <= #1 sSCL;        dSDA <= #1 sSDA;      end    \n    reg sta_condition;    \n    reg sto_condition;    \n    always @(posedge clk or negedge nReset)      if (~nReset)      begin        sta_condition <= #1 1'b0;        sto_condition <= #1 1'b0;      end      else if (rst)      begin        sta_condition <= #1 1'b0;        sto_condition <= #1 1'b0;      end      else      begin        sta_condition <= #1 ~sSDA & dSDA & sSCL;        sto_condition <= #1 sSDA & ~dSDA & sSCL;      end    \n    always @(posedge clk or negedge nReset)      if      (!nReset) busy <= #1 1'b0;      else if (rst    ) busy <= #1 1'b0;      else              busy <= #1 (sta_condition | busy) & ~sto_condition;    \n    reg cmd_stop;    \n    always @(posedge clk or negedge nReset)      if (~nReset)          cmd_stop <= #1 1'b0;      else if (rst)          cmd_stop <= #1 1'b0;      else if (clk_en)          cmd_stop <= #1 cmd == `I2C_CMD_STOP;    \n    always @(posedge clk or negedge nReset)      if (~nReset)          al <= #1 1'b0;      else if (rst)          al <= #1 1'b0;      else          al <= #1 (sda_chk & ~sSDA & sda_oen) | (|c_state & sto_condition & ~cmd_stop);    \n    always @(posedge clk)      if (sSCL & ~dSCL) dout <= #1 sSDA;    \n    parameter    idle    = 0;    \n    parameter    start_a = 1;    \n    parameter    start_b = 2;    \n    parameter    start_c = 3;    \n    parameter    start_d = 4;    \n    parameter    start_e = 5;    \n    parameter    stop_a  = 6;    \n    parameter    stop_b  = 7;    \n    parameter    stop_c  = 8;    \n    parameter    stop_d  = 9;    \n    parameter    rd_a    = 10;    \n    parameter    rd_b    = 11;    \n    parameter    rd_c    = 12;    \n    parameter    rd_d    = 13;    \n    parameter    wr_a    = 14;    \n    parameter    wr_b    = 15;    \n    parameter    wr_c    = 16;    \n    parameter    wr_d    = 17;    \n    always @(posedge clk or negedge nReset)      if (!nReset)      begin        c_state <= #1 idle;        cmd_ack <= #1 1'b0;        scl_oen <= #1 1'b1;        sda_oen <= #1 1'b1;        sda_chk <= #1 1'b0;      end      else if (rst | al)      begin        c_state <= #1 idle;        cmd_ack <= #1 1'b0;        scl_oen <= #1 1'b1;        sda_oen <= #1 1'b1;        sda_chk <= #1 1'b0;      end      else      begin        cmd_ack   <= #1 1'b0; // default no command acknowledge + assert cmd_ack only 1clk cycle        if (clk_en)            case (c_state) // synopsys full_case parallel_case              idle:              begin                  case (cmd) // synopsys full_case parallel_case                     `I2C_CMD_START: c_state <= #1 start_a;                     `I2C_CMD_STOP:  c_state <= #1 stop_a;                     `I2C_CMD_WRITE: c_state <= #1 wr_a;                     `I2C_CMD_READ:  c_state <= #1 rd_a;                     default:        c_state <= #1 idle;                  endcase                  scl_oen <= #1 scl_oen; // keep SCL in same state                  sda_oen <= #1 sda_oen; // keep SDA in same state                  sda_chk <= #1 1'b0;    // don't check SDA output              end              start_a:              begin                  c_state <= #1 start_b;                  scl_oen <= #1 scl_oen; // keep SCL in same state                  sda_oen <= #1 1'b1;    // set SDA high                  sda_chk <= #1 1'b0;    // don't check SDA output              end              start_b:              begin                  c_state <= #1 start_c;                  scl_oen <= #1 1'b1; // set SCL high                  sda_oen <= #1 1'b1; // keep SDA high                  sda_chk <= #1 1'b0; // don't check SDA output              end              start_c:              begin                  c_state <= #1 start_d;                  scl_oen <= #1 1'b1; // keep SCL high                  sda_oen <= #1 1'b0; // set SDA low                  sda_chk <= #1 1'b0; // don't check SDA output              end              start_d:              begin                  c_state <= #1 start_e;                  scl_oen <= #1 1'b1; // keep SCL high                  sda_oen <= #1 1'b0; // keep SDA low                  sda_chk <= #1 1'b0; // don't check SDA output              end              start_e:              begin                  c_state <= #1 idle;                  cmd_ack <= #1 1'b1;                  scl_oen <= #1 1'b0; // set SCL low                  sda_oen <= #1 1'b0; // keep SDA low                  sda_chk <= #1 1'b0; // don't check SDA output              end              stop_a:              begin                  c_state <= #1 stop_b;                  scl_oen <= #1 1'b0; // keep SCL low                  sda_oen <= #1 1'b0; // set SDA low                  sda_chk <= #1 1'b0; // don't check SDA output              end              stop_b:              begin                  c_state <= #1 stop_c;                  scl_oen <= #1 1'b1; // set SCL high                  sda_oen <= #1 1'b0; // keep SDA low                  sda_chk <= #1 1'b0; // don't check SDA output              end              stop_c:              begin                  c_state <= #1 stop_d;                  scl_oen <= #1 1'b1; // keep SCL high                  sda_oen <= #1 1'b0; // keep SDA low                  sda_chk <= #1 1'b0; // don't check SDA output              end              stop_d:              begin                  c_state <= #1 idle;                  cmd_ack <= #1 1'b1;                  scl_oen <= #1 1'b1; // keep SCL high                  sda_oen <= #1 1'b1; // set SDA high                  sda_chk <= #1 1'b0; // don't check SDA output              end              rd_a:              begin                  c_state <= #1 rd_b;                  scl_oen <= #1 1'b0; // keep SCL low                  sda_oen <= #1 1'b1; // tri-state SDA                  sda_chk <= #1 1'b0; // don't check SDA output              end              rd_b:              begin                  c_state <= #1 rd_c;                  scl_oen <= #1 1'b1; // set SCL high                  sda_oen <= #1 1'b1; // keep SDA tri-stated                  sda_chk <= #1 1'b0; // don't check SDA output              end              rd_c:              begin                  c_state <= #1 rd_d;                  scl_oen <= #1 1'b1; // keep SCL high                  sda_oen <= #1 1'b1; // keep SDA tri-stated                  sda_chk <= #1 1'b0; // don't check SDA output              end              rd_d:              begin                  c_state <= #1 idle;                  cmd_ack <= #1 1'b1;                  scl_oen <= #1 1'b0; // set SCL low                  sda_oen <= #1 1'b1; // keep SDA tri-stated                  sda_chk <= #1 1'b0; // don't check SDA output              end              wr_a:              begin                  c_state <= #1 wr_b;                  scl_oen <= #1 1'b0; // keep SCL low                  sda_oen <= #1 din;  // set SDA                  sda_chk <= #1 1'b0; // don't check SDA output (SCL low)              end              wr_b:              begin                  c_state <= #1 wr_c;                  scl_oen <= #1 1'b1; // set SCL high                  sda_oen <= #1 din;  // keep SDA                  sda_chk <= #1 1'b0; // don't check SDA output yet              end              wr_c:              begin                  c_state <= #1 wr_d;                  scl_oen <= #1 1'b1; // keep SCL high                  sda_oen <= #1 din;                  sda_chk <= #1 1'b1; // check SDA output              end              wr_d:              begin                  c_state <= #1 idle;                  cmd_ack <= #1 1'b1;                  scl_oen <= #1 1'b0; // set SCL low                  sda_oen <= #1 din;                  sda_chk <= #1 1'b0; // don't check SDA output (SCL low)              end              endcase      end    \n    assign scl_o = 1'b0;    \n    assign sda_o = 1'b0;  \nendmodule"}
{"task_id": 1356, "completion": "flop_gated_latch f0(q0,d,clk,en);\n  flop_gated_latch f1(q1,d,clk,en);\n  flop_gated_flop f2(q2,d,clk,en);\n  flop_gated_flop f3(q3,d,clk,en);\n  assign res = (q0 + q1) * (q2 - q3);\nendmodule"}
{"task_id": 1361, "completion": "SB_PLL40_CORE #(                .FEEDBACK_PATH(\"DELAY\"),                .DELAY_ADJUSTMENT_MODE_FEEDBACK(\"FIXED\"),                .DELAY_ADJUSTMENT_MODE_RELATIVE(\"FIXED\"),                .PLLOUT_SELECT(\"GENCLK\"),                .SHIFTREG_DIV_MODE(1'b0),                .FDA_FEEDBACK(4'b1111),                .FDA_RELATIVE(4'b1111),                .DIVR(4'b0000),                .DIVF(7'b0000000),                .DIVQ(3'b001),                .FILTER_RANGE(3'b000),                .ENABLE_ICEGATE(1'b0),                .TEST_MODE(1'b0)        ) uut (                .REFERENCECLK   (REFERENCECLK   ),                .PLLOUTCORE     (PLLOUTCORE     ),                .PLLOUTGLOBAL   (PLLOUTGLOBAL   ),                .EXTFEEDBACK    (EXTFEEDBACK    ),                .DYNAMICDELAY   (DYNAMICDELAY   ),                .LOCK           (LOCK           ),                .BYPASS         (BYPASS         ),                .RESETB         (RESETB         ),                .LATCHINPUTVALUE(LATCHINPUTVALUE),                .SDO            (SDO            ),                .SDI            (SDI            ),                .SCLK           (SCLK           )        );endmodule"}
{"task_id": 1357, "completion": "reg\t[width-1:0]\tmuxout;\nreg\t[width-1:0]\tmuxreg;\nreg\t\t\tmuxreg_valid;\n\nalways @(posedge clk or `OR1200_RST_EVENT rst) begin\n\tif (rst == `OR1200_RST_VALUE) begin\n\t\tmuxreg <=  32'd0;\n\t\tmuxreg_valid <=  1'b0;\n\tend\n\telse if (!wb_freeze) begin\n\t\tmuxreg <=  muxout;\n\t\tmuxreg_valid <=  rfwb_op[0];\n\tend\nend\n\nalways @(muxin_a or muxin_b or muxin_c or muxin_d or muxin_e or rfwb_op) begin\n`ifdef OR1200_ADDITIONAL_SYNOPSYS_DIRECTIVES\n\tcasez(rfwb_op[`OR1200_RFWBOP_WIDTH-1:1]) // synopsys parallel_case infer_mux\n`else\n\tcasez(rfwb_op[`OR1200_RFWBOP_WIDTH-1:1]) // synopsys parallel_case\n`endif\n\t\t`OR1200_RFWBOP_ALU: muxout = muxin_a;\n\t\t`OR1200_RFWBOP_LSU: begin\n\t\t\tmuxout = muxin_b;\n`ifdef OR1200_VERBOSE\n\t\t\t$display(\"  WBMUX: muxin_b %h\", muxin_b);\n`endif\n\t\tend\n\t\t`OR1200_RFWBOP_SPRS: begin\n\t\t\tmuxout = muxin_c;\n`ifdef OR1200_VERBOSE\n\t\t\t$display(\"  WBMUX: muxin_c %h\", muxin_c);\n`endif\n\t\tend\n\t\t`OR1200_RFWBOP_LR: begin\n\t\t\tmuxout = muxin_d + 32'h8;\n`ifdef OR1200_VERBOSE\n\t\t\t$display(\"  WBMUX: muxin_d %h\", muxin_d + 4'h8);\n`endif\n\t\tend\n`ifdef OR1200_FPU_IMPLEMENTED\n\t\t`OR1200_RFWBOP_FPU : begin\n\t\t\tmuxout = muxin_e;\n`ifdef OR1200_VERBOSE\n\t\t\t$display(\"  WBMUX: muxin_e %h\", muxin_e);\n`endif\n\t\tend\n`endif\n\t\tdefault : begin\n\t\t\tmuxout = 0;\n\t\tend\n\tendcase\nend\n\nendmodule"}
{"task_id": 1359, "completion": "wire Feedback;\nreg [9:0] x;\nwire [9:0] Random;\nreg  [9:0] RandomLatched;\n\nalways @ (posedge MTxClk or posedge Reset)\nbegin\n  if(Reset)\n    x[9:0] <=  0;\n  else\n    x[9:0] <=  {x[8:0], Feedback};\nend\n\nassign Feedback = ~(x[2] ^ x[9]);\n\nassign Random [0] = x[0];\nassign Random [1] = (RetryCnt > 1) ? x[1] : 1'b0;\nassign Random [2] = (RetryCnt > 2) ? x[2] : 1'b0;\nassign Random [3] = (RetryCnt > 3) ? x[3] : 1'b0;\nassign Random [4] = (RetryCnt > 4) ? x[4] : 1'b0;\nassign Random [5] = (RetryCnt > 5) ? x[5] : 1'b0;\nassign Random [6] = (RetryCnt > 6) ? x[6] : 1'b0;\nassign Random [7] = (RetryCnt > 7) ? x[7] : 1'b0;\nassign Random [8] = (RetryCnt > 8) ? x[8] : 1'b0;\nassign Random [9] = (RetryCnt > 9) ? x[9] : 1'b0;\n\nalways @ (posedge MTxClk or posedge Reset)\nbegin\n  if(Reset)\n    RandomLatched <=  10'h000;\n  else\n    begin\n      if(StateJam & StateJam_q)\n        RandomLatched <=  Random;\n    end\nend\n\nassign RandomEq0 = RandomLatched == 10'h0; \n\nassign RandomEqByteCnt = ByteCnt[9:0] == RandomLatched & (&NibCnt[6:0]);\nendmodule"}
{"task_id": 1349, "completion": "localparam integer KEY_WIDTH = 32;\n    localparam integer KEY_NUM   = 4;\n    localparam integer WORD      = 8;\n    localparam integer ROUNDS    = 10;\n\n    wire  [KEY_WIDTH - 1 : 0] key   [0 : KEY_NUM - 1];\n    wire  [     WORD - 1 : 0] rot_in[0 : KEY_NUM - 1];\n    wire  [KEY_WIDTH - 1 : 0] g_func;\n    reg   [     WORD - 1 : 0] rc_dir, rc_inv;\n    wire  [     WORD - 1 : 0] rc;\n\n    generate\n\tgenvar i;\n\tfor(i = 0; i < KEY_NUM; i = i + 1)\n\tbegin:KG\n\t\tassign key[KEY_NUM - 1 - i] = key_in[KEY_WIDTH*(i + 1) - 1 : KEY_WIDTH*i];\n\tend\n    endgenerate\n\n    generate\n\tgenvar j;\n\tfor(j = 0; j < KEY_NUM; j = j + 1)\n\tbegin:KGO\n\t\tif(j == 0)\n\t\t\tassign key_out[KEY_WIDTH*(KEY_NUM - j) - 1 : KEY_WIDTH*(KEY_NUM - j - 1)] = key[j] ^ g_func;\n\t\telse\n\t\t\tif(j == 1)\n\t\t\t\tassign key_out[KEY_WIDTH*(KEY_NUM - j) - 1 : KEY_WIDTH*(KEY_NUM - j - 1)] = (add_w_out) ? key[j] ^ key[j - 1] ^ g_func : key[j] ^ key[j - 1];\n\t\t\telse\n\t\t\t\tassign key_out[KEY_WIDTH*(KEY_NUM - j) - 1 : KEY_WIDTH*(KEY_NUM - j - 1)] = key[j] ^ key[j - 1];\n\tend\n    endgenerate\n\n    generate\n\tgenvar k;\n\tfor(k = 0; k < KEY_NUM; k = k + 1)\n\tbegin:GFIG\n\t\tassign rot_in[k] = (enc_dec) ? key[KEY_NUM - 1][WORD*(k + 1) - 1 : WORD*k] : key[KEY_NUM - 1][WORD*(k + 1) - 1 : WORD*k] ^ key[KEY_NUM - 2][WORD*(k + 1) - 1 : WORD*k];\n\tend\n    endgenerate\n\n    generate\n\tgenvar l;\n\tfor(l = 0; l < KEY_NUM; l = l + 1)\n\tbegin:GFIG1\n\t\tassign g_in[WORD*(l + 1) - 1 : WORD*l] = rot_in[(KEY_NUM + l - 1)%KEY_NUM];\n\tend\n    endgenerate\n\n    assign g_func = {g_out[KEY_WIDTH - 1 : KEY_WIDTH - WORD] ^ rc, g_out[KEY_WIDTH - WORD - 1 : 0]};\n\n    assign rc = (enc_dec) ? rc_dir : rc_inv;\n\n    always @(*)\n    begin: RC_DIR\n\t    integer i;\n\t    for(i = 0; i < ROUNDS; i = i + 1)\n\t\t    if(round == 8)\n\t\t\t\trc_dir = 8'h1b;\n\t\t\telse \n\t\t\tif(round == 9)\n\t\t\t\trc_dir = 8'h36;\n\t\t\telse\n\t\t\t\trc_dir = 8'h01 << round;\n\tend\n\n    always @(*)\n    begin: RC_INV\n\t    integer i;\n\t    for(i = 0; i < ROUNDS; i = i + 1)\n\t\t    if(round == 1)\n\t\t\t\trc_inv = 8'h1b;\n\t\t\telse \n\t\t\tif(round == 0)\n\t\t\t\trc_inv = 8'h36;\n\t\t\telse\n\t\t\t\trc_inv = 8'h80 >> (round - 2);\n\tend\nendmodule"}
{"task_id": 1350, "completion": "wire [31:0]FIR_resized1_m_axis_data_tdata;\n  wire FIR_resized1_m_axis_data_tvalid;\n  wire [31:0]FIR_resized2_m_axis_data_tdata;\n  wire [31:0]FIR_resized3_m_axis_data_tdata;\n  wire [31:0]FIR_resized3_m_axis_data_tdata1;\n  wire FIR_resized3_m_axis_data_tvalid;\n  wire FIR_resized3_m_axis_data_tvalid1;\n  wire [31:0]FIR_resized4_m_axis_data_tdata;\n  wire [31:0]FIR_resized5_m_axis_data_tdata;\n  wire [31:0]FIR_resized6_m_axis_data_tdata;\n  wire FIR_resized6_m_axis_data_tvalid;\n  wire [31:0]FIR_resized7_m_axis_data_tdata;\n  wire Net;\n  wire [39:0]cic_compiler_0_m_axis_data_tdata;\n  wire cic_compiler_0_m_axis_data_tvalid;\n  wire [47:0]cic_compiler_1_m_axis_data_tdata;\n  wire cic_compiler_1_m_axis_data_tvalid;\n  wire [15:0]wavegen_m_axis_data_tdata;\n  wire wavegen_m_axis_data_tvalid;\n  wire [15:0]xlconcat_0_dout;\n  wire [23:0]xlconcat_1_dout;\n  wire [23:0]xlconcat_2_dout;\n  wire [23:0]xlconcat_3_dout;\n  wire [6:0]xlconstant_0_dout;\n  wire [6:0]xlconstant_1_dout;\n  wire [1:0]xlconstant_2_dout;\n  wire [6:0]xlconstant_3_dout;\n  wire [13:0]xlslice_0_Dout;\n  wire [0:0]xlslice_10_Dout;\n  wire [23:0]xlslice_11_Dout;\n  wire [0:0]xlslice_13_Dout;\n  wire [23:0]xlslice_15_Dout;\n  wire [15:0]xlslice_17_Dout;\n  wire [23:0]xlslice_6_Dout;\n  wire [15:0]xlslice_7_Dout;\n  wire [23:0]xlslice_8_Dout;\n  wire [0:0]xlslice_9_Dout;\n\n  design_1_FIR_resized1_1 FIR_resized0\n       (.aclk(Net),\n        .m_axis_data_tdata(FIR_resized3_m_axis_data_tdata),\n        .m_axis_data_tvalid(FIR_resized3_m_axis_data_tvalid),\n        .s_axis_data_tdata(xlconcat_1_dout),\n        .s_axis_data_tvalid(cic_compiler_0_m_axis_data_tvalid));\n  design_1_FIR_resized_0 FIR_resized1\n       (.aclk(Net),\n        .m_axis_data_tdata(FIR_resized1_m_axis_data_tdata),\n        .m_axis_data_tvalid(FIR_resized1_m_axis_data_tvalid),\n        .s_axis_data_tdata(xlslice_8_Dout),\n        .s_axis_data_tvalid(FIR_resized3_m_axis_data_tvalid));\n  design_1_FIR_resized1_0 FIR_resized2\n       (.aclk(Net),\n        .m_axis_data_tdata(FIR_resized2_m_axis_data_tdata),\n        .s_axis_data_tdata(xlslice_6_Dout),\n        .s_axis_data_tvalid(FIR_resized1_m_axis_data_tvalid));\n  design_1_FIR_resized1_3 FIR_resized3\n       (.aclk(Net),\n        .m_axis_data_tdata(FIR_resized3_m_axis_data_tdata1),\n        .m_axis_data_tvalid(FIR_resized3_m_axis_data_tvalid1),\n        .s_axis_data_tdata(xlconcat_2_dout),\n        .s_axis_data_tvalid(wavegen_m_axis_data_tvalid));\n  design_1_FIR_resized2_2 FIR_resized4\n       (.aclk(Net),\n        .m_axis_data_tdata(FIR_resized4_m_axis_data_tdata),\n        .s_axis_data_tdata(xlslice_11_Dout),\n        .s_axis_data_tvalid(FIR_resized3_m_axis_data_tvalid1));\n  design_1_FIR_resized4_0 FIR_resized5\n       (.aclk(Net),\n        .m_axis_data_tdata(FIR_resized5_m_axis_data_tdata),\n        .s_axis_data_tdata(xlconcat_2_dout),\n        .s_axis_data_tvalid(wavegen_m_axis_data_tvalid));\n  design_1_FIR_resized0_0 FIR_resized6\n       (.aclk(Net),\n        .m_axis_data_tdata(FIR_resized6_m_axis_data_tdata),\n        .m_axis_data_tvalid(FIR_resized6_m_axis_data_tvalid),\n        .s_axis_data_tdata(xlconcat_3_dout),\n        .s_axis_data_tvalid(cic_compiler_1_m_axis_data_tvalid));\n  design_1_FIR_resized2_0 FIR_resized7\n       (.aclk(Net),\n        .m_axis_data_tdata(FIR_resized7_m_axis_data_tdata),\n        .s_axis_data_tdata(xlslice_15_Dout),\n        .s_axis_data_tvalid(FIR_resized6_m_axis_data_tvalid));\n  design_1_cic_compiler_0_0 cic_compiler_0\n       (.aclk(Net),\n        .m_axis_data_tdata(cic_compiler_0_m_axis_data_tdata),\n        .m_axis_data_tvalid(cic_compiler_0_m_axis_data_tvalid),\n        .s_axis_data_tdata(xlconcat_0_dout),\n        .s_axis_data_tvalid(wavegen_m_axis_data_tvalid));\n  design_1_cic_compiler_0_1 cic_compiler_1\n       (.aclk(Net),\n        .m_axis_data_tdata(cic_compiler_1_m_axis_data_tdata),\n        .m_axis_data_tvalid(cic_compiler_1_m_axis_data_tvalid),\n        .s_axis_data_tdata(xlconcat_0_dout),\n        .s_axis_data_tvalid(wavegen_m_axis_data_tvalid));\n  design_1_clk_gen_0_0 clk\n       (.clk(Net));\n  design_1_dds_compiler_0_1 wavegen\n       (.aclk(Net),\n        .m_axis_data_tdata(wavegen_m_axis_data_tdata),\n        .m_axis_data_tvalid(wavegen_m_axis_data_tvalid));\n  design_1_xlconcat_0_0 xlconcat_0\n       (.In0(xlconstant_2_dout),\n        .In1(xlslice_0_Dout),\n        .dout(xlconcat_0_dout));\n  design_1_xlconcat_0_1 xlconcat_1\n       (.In0(xlconstant_0_dout),\n        .In1(xlslice_7_Dout),\n        .In2(xlslice_9_Dout),\n        .dout(xlconcat_1_dout));\n  design_1_xlconcat_1_0 xlconcat_2\n       (.In0(xlconstant_1_dout),\n        .In1(xlconcat_0_dout),\n        .In2(xlslice_13_Dout),\n        .dout(xlconcat_2_dout));\n  design_1_xlconcat_1_1 xlconcat_3\n       (.In0(xlconstant_3_dout),\n        .In1(xlslice_17_Dout),\n        .In2(xlslice_10_Dout),\n        .dout(xlconcat_3_dout));\n  design_1_xlconstant_0_0 xlconstant_0\n       (.dout(xlconstant_0_dout));\n  design_1_xlconstant_0_1 xlconstant_1\n       (.dout(xlconstant_1_dout));\n  design_1_xlconstant_2_0 xlconstant_2\n       (.dout(xlconstant_2_dout));\n  design_1_xlconstant_0_2 xlconstant_3\n       (.dout(xlconstant_3_dout));\n  design_1_xlslice_0_1 xlslice_0\n       (.Din(wavegen_m_axis_data_tdata),\n        .Dout(xlslice_0_Dout));\n  design_1_xlslice_9_1 xlslice_10\n       (.Din(xlslice_17_Dout),\n        .Dout(xlslice_10_Dout));\n  design_1_xlslice_6_3 xlslice_11\n       (.Din(FIR_resized3_m_axis_data_tdata1),\n        .Dout(xlslice_11_Dout));\n  design_1_xlslice_4_2 xlslice_12\n       (.Din(FIR_resized4_m_axis_data_tdata));\n  design_1_xlslice_9_0 xlslice_13\n       (.Din(xlconcat_0_dout),\n        .Dout(xlslice_13_Dout));\n  design_1_xlslice_6_2 xlslice_14\n       (.Din(FIR_resized7_m_axis_data_tdata));\n  design_1_xlslice_14_0 xlslice_15\n       (.Din(FIR_resized6_m_axis_data_tdata),\n        .Dout(xlslice_15_Dout));\n  design_1_xlslice_12_0 xlslice_16\n       (.Din(FIR_resized5_m_axis_data_tdata));\n  design_1_xlslice_7_2 xlslice_17\n       (.Din(cic_compiler_1_m_axis_data_tdata),\n        .Dout(xlslice_17_Dout));\n  design_1_xlslice_4_0 xlslice_4\n       (.Din(FIR_resized2_m_axis_data_tdata));\n  design_1_xlslice_6_0 xlslice_6\n       (.Din(FIR_resized1_m_axis_data_tdata),\n        .Dout(xlslice_6_Dout));\n  design_1_xlslice_6_1 xlslice_7\n       (.Din(cic_compiler_0_m_axis_data_tdata),\n        .Dout(xlslice_7_Dout));\n  design_1_xlslice_7_0 xlslice_8\n       (.Din(FIR_resized3_m_axis_data_tdata),\n        .Dout(xlslice_8_Dout));\n  design_1_xlslice_3_0 xlslice_9\n       (.Din(xlslice_7_Dout),\n        .Dout(xlslice_9_Dout));\nendmodule"}
{"task_id": 1351, "completion": "parameter WIDTH = 640;\n\nwire [7:0] shift_reg_out[3:0];\n\nreg [7:0] original_line_1[4:0];\nreg [7:0] original_line_2[4:0];\nreg [7:0] original_line_3[4:0];\nreg [7:0] original_line_4[4:0];\nreg [7:0] original_line_5[4:0];\n\nreg [15:0] sum_level_1[12:0];\nreg [15:0] sum_level_2[6:0];\nreg [15:0] sum_level_3[4:0];\nreg [15:0] sum_level_4[2:0];\nreg [15:0] sum_level_5[1:0];\nreg [15:0] sum_level_6;\nreg [8:0] sum_level_7;\n\ninteger i;\n\nalways @(posedge clk) begin\n\tif (reset == 1'b1) begin\n\t\tfor (i = 4; i >= 0; i = i-1) begin\n\t\t\toriginal_line_1[i] <= 8'h00;\n\t\t\toriginal_line_2[i] <= 8'h00;\n\t\t\toriginal_line_3[i] <= 8'h00;\n\t\t\toriginal_line_4[i] <= 8'h00;\n\t\t\toriginal_line_5[i] <= 8'h00;\n\t\tend\n\n\t\tfor (i = 12; i >= 0; i = i-1) begin\n\t\t\tsum_level_1[i] <= 16'h0000;\n\t\tend\n\n\t\tfor (i = 6; i >= 0; i = i-1) begin\n\t\t\tsum_level_2[i] <= 16'h0000;\n\t\tend\n\n\t\tfor (i = 4; i >= 0; i = i-1) begin\n\t\t\tsum_level_3[i] <= 16'h0000;\n\t\tend\n\n\t\tsum_level_4[0] <= 16'h0000;\n\t\tsum_level_4[1] <= 16'h0000;\n\t\tsum_level_4[2] <= 16'h0000;\n\t\t\n\t\tsum_level_5[0] <= 16'h0000;\n\t\tsum_level_5[1] <= 16'h0000;\n\n\t\tsum_level_6 <= 16'h0000;\n\t\tsum_level_7 <= 9'h000;\n\tend else if (data_en == 1'b1) begin\n\t\tfor (i = 4; i > 0; i = i-1) begin\n\t\t\toriginal_line_1[i] <= original_line_1[i-1];\n\t\t\toriginal_line_2[i] <= original_line_2[i-1];\n\t\t\toriginal_line_3[i] <= original_line_3[i-1];\n\t\t\toriginal_line_4[i] <= original_line_4[i-1];\n\t\t\toriginal_line_5[i] <= original_line_5[i-1];\n\t\tend\n\t\toriginal_line_1[0] <= data_in;\n\t\toriginal_line_2[0] <= shift_reg_out[0];\n\t\toriginal_line_3[0] <= shift_reg_out[1];\n\t\toriginal_line_4[0] <= shift_reg_out[2];\n\t\toriginal_line_5[0] <= shift_reg_out[3];\n\n\t\tsum_level_1[0] <= {7'h00,original_line_1[0], 1'b0} + {7'h00,original_line_1[4], 1'b0};\n\t\tsum_level_1[1] <= {7'h00,original_line_5[0], 1'b0} + {7'h00,original_line_5[4], 1'b0};\n\t\tsum_level_1[2] <= {6'h00,original_line_1[1], 2'h0} + {6'h00,original_line_1[3], 2'h0};\n\t\tsum_level_1[3] <= {6'h00,original_line_2[0], 2'h0} + {6'h00,original_line_2[4], 2'h0};\n\t\tsum_level_1[4] <= {6'h00,original_line_4[0], 2'h0} + {6'h00,original_line_4[4], 2'h0};\n\t\tsum_level_1[5] <= {6'h00,original_line_5[1], 2'h0} + {6'h00,original_line_5[3], 2'h0};\n\t\tsum_level_1[6] <= {8'h00,original_line_1[2]} + {8'h00,original_line_5[2]};\n\t\tsum_level_1[7] <= {8'h00,original_line_3[0]} + {8'h00,original_line_3[4]};\n\t\tsum_level_1[8] <= {8'h00,original_line_2[1]} + {8'h00,original_line_2[3]};\n\t\tsum_level_1[9] <= {8'h00,original_line_4[1]} + {8'h00,original_line_4[3]};\n\t\tsum_level_1[10] <= {8'h00,original_line_2[2]} + {8'h00,original_line_4[2]};\n\t\tsum_level_1[11] <= {8'h00,original_line_3[1]} + {8'h00,original_line_3[3]};\n\t\tsum_level_1[12] <= {4'h0,original_line_3[2], 4'h0} - original_line_3[2];\n\t\t\n\t\tsum_level_2[0] <= sum_level_1[0] + sum_level_1[1];\n\t\tsum_level_2[1] <= sum_level_1[2] + sum_level_1[3];\n\t\tsum_level_2[2] <= sum_level_1[4] + sum_level_1[5];\n\t\tsum_level_2[3] <= sum_level_1[6] + sum_level_1[7];\n\t\tsum_level_2[4] <= sum_level_1[8] + sum_level_1[9];\n\t\tsum_level_2[5] <= sum_level_1[10] + sum_level_1[11];\n\t\tsum_level_2[6] <= sum_level_1[12];\n\t\t\n\t\tsum_level_3[0] <= sum_level_2[0] + sum_level_2[6];\n\t\tsum_level_3[1] <= sum_level_2[1] + sum_level_2[2];\n\t\tsum_level_3[2] <= {sum_level_2[3], 2'h0} + sum_level_2[3];\n\t\tsum_level_3[3] <= {sum_level_2[4], 3'h0} + sum_level_2[4];\n\t\tsum_level_3[4] <= {sum_level_2[5], 3'h0} + {sum_level_2[5], 2'h0};\n\t\t\n\t\tsum_level_4[0] <= sum_level_3[0] + sum_level_3[1];\n\t\tsum_level_4[1] <= sum_level_3[2] + sum_level_3[3];\n\t\tsum_level_4[2] <= sum_level_3[4];\n\t\t\n\t\tsum_level_5[0] <= sum_level_4[0] + sum_level_4[1];\n\t\tsum_level_5[1] <= sum_level_4[2];\n\n\t\tsum_level_6 <= sum_level_5[0] + sum_level_5[1];\n\t\t\n\t\t\n\t\tsum_level_7 <= sum_level_6[15:7];\n\tend\nend\n\nassign data_out = sum_level_7;\n\naltera_up_edge_detection_data_shift_register shift_register_1 (\n\t.clock(clk),\n\t.clken(data_en),\n\t.shiftin(data_in),\n\t.shiftout(shift_reg_out[0]),\n\t.taps()\n);\ndefparam\n\tshift_register_1.DW = 8,\n\tshift_register_1.SIZE = WIDTH;\n\naltera_up_edge_detection_data_shift_register shift_register_2 (\n\t.clock(clk),\n\t.clken(data_en),\n\t.shiftin(shift_reg_out[0]),\n\t.shiftout(shift_reg_out[1]),\n\t.taps()\n);\ndefparam\n\tshift_register_2.DW = 8,\n\tshift_register_2.SIZE = WIDTH;\n\naltera_up_edge_detection_data_shift_register shift_register_3 (\n\t.clock(clk),\n\t.clken(data_en),\n\t.shiftin(shift_reg_out[1]),\n\t.shiftout(shift_reg_out[2]),\n\t.taps()\n);\ndefparam\n\tshift_register_3.DW = 8,\n\tshift_register_3.SIZE = WIDTH;\n\naltera_up_edge_detection_data_shift_register shift_register_4 (\n\t.clock(clk),\n\t.clken(data_en),\n\t.shiftin(shift_reg_out[2]),\n\t.shiftout(shift_reg_out[3]),\n\t.taps()\n);\ndefparam\n\tshift_register_4.DW = 8,\n\tshift_register_4.SIZE = WIDTH;\n\nendmodule"}
{"task_id": 470, "completion": "SEG7_LUT u0 (oSEG0, {iDIG[16], iDIG[3:0]}  );\nSEG7_LUT u1 (oSEG1, {iDIG[17], iDIG[7:4]}  );\nSEG7_LUT u2 (oSEG2, {iDIG[18], iDIG[11:8]} );\nSEG7_LUT u3 (oSEG3, {iDIG[19], iDIG[15:12]});\nendmodule"}
{"task_id": 1366, "completion": "parameter divider = 50;\n    reg [8:0] clk_counter;\n    reg div_clk;\n    reg scl_en;\n    reg [6:0] shift_buffer;\n    reg shift_busy;\n    reg [2:0] shift_counter;\n    assign reset_n = !reset;\n    assign avs_slave_readdata = shift_busy;\n    assign scl = scl_en ? div_clk : 0;\n    assign sld = (!scl_en && shift_busy) ? div_clk : 0;\n    assign sdi = shift_buffer[6];\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            clk_counter <= 1;\n            div_clk <= 0;\n            scl_en <= 0;\n            shift_busy <= 0;\n            shift_counter <= 0;\n        end else begin\n            if (shift_busy) begin\n                if (clk_counter == (divider/2)) begin\n                    clk_counter <= 1;\n                    div_clk <= !div_clk;\n                    if (div_clk) begin\n                        if (!scl_en) begin\n                            shift_busy <= 0;\n                        end else begin\n                            if (shift_counter == 6) begin\n                                scl_en <= 0;\n                            end else begin\n                                shift_counter <= shift_counter + 1;\n                                shift_buffer <= shift_buffer << 1;\n                            end\n                        end\n                    end\n                end else begin\n                    clk_counter = clk_counter + 1;\n                end\n            end else begin\n                clk_counter <= 1;\n                shift_counter <= 0;\n                div_clk <= 0;\n                if (avs_slave_write) begin\n                    shift_buffer <= avs_slave_writedata;\n                    shift_busy <= 1;\n                    scl_en <= 1;\n                end\n            end\n        end\n    end\nendmodule"}
{"task_id": 1371, "completion": "reg [3:0] in_bar;    always @(*)    begin        in_bar=~in;        out[1]=in[0]        &    in_bar[1]    &    in_bar[2]    &    in_bar[3];        out[2]=in_bar[0]    &    in[1]        &    in_bar[2]    &    in_bar[3];        out[3]=in[0]        &    in[1]        &    in_bar[2]    &    in_bar[3];        out[4]=in_bar[0]    &    in_bar[1]    &    in[2]        &    in_bar[3];        out[5]=in[0]        &    in_bar[1]    &    in[2]        &    in_bar[3];        out[6]=in_bar[0]    &    in[1]        &    in[2]        &    in_bar[3];        out[7]=in[0]        &    in[1]        &    in[2]        &    in_bar[3];        out[8]=in_bar[0]    &    in_bar[1]    &    in_bar[2]    &    in[3];        out[9]=in[0]        &    in_bar[1]    &    in_bar[2]    &    in[3];        out[10]=in_bar[0]    &    in[1]        &    in_bar[2]    &    in[3];        out[11]=in[0]        &    in[1]        &    in_bar[2]    &    in[3];        out[12]=in_bar[0]    &    in_bar[1]    &    in[2]        &    in[3];        out[13]=in[0]        &    in_bar[1]    &    in[2]        &    in[3];        out[14]=in_bar[0]    &    in[1]        &    in[2]        &    in[3];        out[15]=in[0]        &    in[1]        &    in[2]        &    in[3];    endendmodule"}
{"task_id": 1358, "completion": "reg           Nvalid;\n  reg           EndBusy_d;\n  reg           EndBusy;\n  reg           WCtrlData_q1;\n  reg           WCtrlData_q2;\n  reg           WCtrlData_q3;\n  reg           WCtrlDataStart;\n  reg           WCtrlDataStart_q;\n  reg           WCtrlDataStart_q1;\n  reg           WCtrlDataStart_q2;\n  reg           RStat_q1;\n  reg           RStat_q2;\n  reg           RStat_q3;\n  reg           RStatStart;\n  reg           RStatStart_q1;\n  reg           RStatStart_q2;\n  reg           ScanStat_q1;\n  reg           ScanStat_q2;\n  reg           SyncStatMdcEn;\n  wire          WriteDataOp;\n  wire          ReadStatusOp;\n  wire          ScanStatusOp;\n  wire          StartOp;\n  wire          EndOp;\n  reg           InProgress;\n  reg           InProgress_q1;\n  reg           InProgress_q2;\n  reg           InProgress_q3;\n  reg           WriteOp;\n  reg     [6:0] BitCounter;\n  wire    [3:0] ByteSelect;\n  wire          MdcEn;\n  wire          ShiftedBit;\n  wire          MdcEn_n;\n  wire          LatchByte1_d2;\n  wire          LatchByte0_d2;\n  reg           LatchByte1_d;\n  reg           LatchByte0_d;\n  reg     [1:0] LatchByte;\n  reg           UpdateMIIRX_DATAReg;\n\n  always @ (posedge Clk or posedge Reset)\n  begin\n    if(Reset)\n    begin\n      EndBusy_d <=  1'b0;\n      EndBusy <=  1'b0;\n    end\n    else\n    begin\n      EndBusy_d <=  ~InProgress_q2 & InProgress_q3;\n      EndBusy   <=  EndBusy_d;\n    end\n  end\n\n  always @ (posedge Clk or posedge Reset)\n  begin\n    if(Reset)\n      UpdateMIIRX_DATAReg <=  0;\n    else\n    if(EndBusy & ~WCtrlDataStart_q)\n      UpdateMIIRX_DATAReg <=  1;\n    else\n      UpdateMIIRX_DATAReg <=  0;\n  end\n\n  always @ (posedge Clk or posedge Reset)\n  begin\n    if(Reset)\n    begin\n      WCtrlData_q1 <=  1'b0;\n      WCtrlData_q2 <=  1'b0;\n      WCtrlData_q3 <=  1'b0;\n      RStat_q1 <=  1'b0;\n      RStat_q2 <=  1'b0;\n      RStat_q3 <=  1'b0;\n      ScanStat_q1  <=  1'b0;\n      ScanStat_q2  <=  1'b0;\n      SyncStatMdcEn <=  1'b0;\n    end\n    else\n    begin\n      WCtrlData_q1 <=  WCtrlData;\n      WCtrlData_q2 <=  WCtrlData_q1;\n      WCtrlData_q3 <=  WCtrlData_q2;\n      RStat_q1 <=  RStat;\n      RStat_q2 <=  RStat_q1;\n      RStat_q3 <=  RStat_q2;\n      ScanStat_q1  <=  ScanStat;\n      ScanStat_q2  <=  ScanStat_q1;\n      if(MdcEn)\n        SyncStatMdcEn  <=  ScanStat_q2;\n    end\n  end\n\n  always @ (posedge Clk or posedge Reset)\n  begin\n    if(Reset)\n    begin\n      WCtrlDataStart <=  1'b0;\n      WCtrlDataStart_q <=  1'b0;\n      RStatStart <=  1'b0;\n    end\n    else\n    begin\n      if(EndBusy)\n      begin\n        WCtrlDataStart <=  1'b0;\n        RStatStart <=  1'b0;\n      end\n      else\n      begin\n        if(WCtrlData_q2 & ~WCtrlData_q3)\n          WCtrlDataStart <=  1'b1;\n        if(RStat_q2 & ~RStat_q3)\n          RStatStart <=  1'b1;\n        WCtrlDataStart_q <=  WCtrlDataStart;\n      end\n    end\n  end\n\n  always @ (posedge Clk or posedge Reset)\n  begin\n    if(Reset)\n      Nvalid <=  1'b0;\n    else\n    begin\n      if(~InProgress_q2 & InProgress_q3)\n      begin\n        Nvalid <=  1'b0;\n      end\n      else\n      begin\n        if(ScanStat_q2  & ~SyncStatMdcEn)\n          Nvalid <=  1'b1;\n      end\n    end\n  end\n\n  always @ (posedge Clk or posedge Reset)\n  begin\n    if(Reset)\n    begin\n      WCtrlDataStart_q1 <=  1'b0;\n      WCtrlDataStart_q2 <=  1'b0;\n      RStatStart_q1 <=  1'b0;\n      RStatStart_q2 <=  1'b0;\n      InProgress_q1 <=  1'b0;\n      InProgress_q2 <=  1'b0;\n      InProgress_q3 <=  1'b0;\n      LatchByte0_d <=  1'b0;\n      LatchByte1_d <=  1'b0;\n      LatchByte <=  2'b00;\n    end\n    else\n    begin\n      if(MdcEn)\n      begin\n        WCtrlDataStart_q1 <=  WCtrlDataStart;\n        WCtrlDataStart_q2 <=  WCtrlDataStart_q1;\n        RStatStart_q1 <=  RStatStart;\n        RStatStart_q2 <=  RStatStart_q1;\n        LatchByte[0] <=  LatchByte0_d;\n        LatchByte[1] <=  LatchByte1_d;\n        LatchByte0_d <=  LatchByte0_d2;\n        LatchByte1_d <=  LatchByte1_d2;\n        InProgress_q1 <=  InProgress;\n        InProgress_q2 <=  InProgress_q1;\n        InProgress_q3 <=  InProgress_q2;\n      end\n    end\n  end\n\n  assign WriteDataOp  = WCtrlDataStart_q1 & ~WCtrlDataStart_q2;\n  assign ReadStatusOp = RStatStart_q1     & ~RStatStart_q2;\n  assign ScanStatusOp = SyncStatMdcEn     & ~InProgress & ~InProgress_q1 & ~InProgress_q2;\n  assign StartOp      = WriteDataOp | ReadStatusOp | ScanStatusOp;\n  assign Busy = WCtrlData | WCtrlDataStart | RStat | RStatStart | SyncStatMdcEn | EndBusy | InProgress | InProgress_q3 | Nvalid;\n  always @ (posedge Clk or posedge Reset)\n  begin\n    if(Reset)\n    begin\n      InProgress <=  1'b0;\n      WriteOp <=  1'b0;\n    end\n    else\n    begin\n      if(MdcEn)\n      begin\n        if(StartOp)\n        begin\n          if(~InProgress)\n            WriteOp <=  WriteDataOp;\n          InProgress <=  1'b1;\n        end\n        else\n        begin\n          if(EndOp)\n          begin\n            InProgress <=  1'b0;\n            WriteOp <=  1'b0;\n          end\n        end\n      end\n    end\n  end\n  always @ (posedge Clk or posedge Reset)\n  begin\n    if(Reset)\n      BitCounter[6:0] <=  7'h0;\n    else\n    begin\n      if(MdcEn)\n      begin\n        if(InProgress)\n        begin\n          if(NoPre & ( BitCounter == 7'h0 ))\n            BitCounter[6:0] <=  7'h21;\n          else\n            BitCounter[6:0] <=  BitCounter[6:0] + 1;\n        end\n        else\n          BitCounter[6:0] <=  7'h0;\n      end\n    end\n  end\n  assign EndOp = BitCounter==63;\n  assign ByteSelect[0] = InProgress & ((NoPre & (BitCounter == 7'h0)) | (~NoPre & (BitCounter == 7'h20)));\n  assign ByteSelect[1] = InProgress & (BitCounter == 7'h28);\n  assign ByteSelect[2] = InProgress & WriteOp & (BitCounter == 7'h30);\n  assign ByteSelect[3] = InProgress & WriteOp & (BitCounter == 7'h38);\n  assign LatchByte1_d2 = InProgress & ~WriteOp & BitCounter == 7'h37;\n  assign LatchByte0_d2 = InProgress & ~WriteOp & BitCounter == 7'h3F;\n  eth_clockgen clkgen(.Clk(Clk), .Reset(Reset), .Divider(Divider[7:0]), .MdcEn(MdcEn), .MdcEn_n(MdcEn_n), .Mdc(Mdc));\n  eth_shiftreg shftrg(.Clk(Clk), .Reset(Reset), .MdcEn_n(MdcEn_n), .Mdi(Mdi), .Fiad(Fiad), .Rgad(Rgad), .CtrlData(CtrlData), .WriteOp(WriteOp), .ByteSelect(ByteSelect), .LatchByte(LatchByte), .ShiftedBit(ShiftedBit), .Prsd(Prsd), .LinkFail(LinkFail));\n  eth_outputcontrol outctrl(.Clk(Clk), .Reset(Reset), .MdcEn_n(MdcEn_n), .InProgress(InProgress), .ShiftedBit(ShiftedBit), .BitCounter(BitCounter), .WriteOp(WriteOp), .NoPre(NoPre), .Mdo(Mdo), .MdoEn(MdoEn));\n\nendmodule"}
{"task_id": 1266, "completion": "(* ASYNC_REG = \"TRUE\", SHIFT_EXTRACT = \"NO\" *)    reg                 pclk_sel_reg1;    (* ASYNC_REG = \"TRUE\", SHIFT_EXTRACT = \"NO\" *)    reg                 resetovrd_start_reg1;    (* ASYNC_REG = \"TRUE\", SHIFT_EXTRACT = \"NO\" *)    reg                 txresetdone_reg1;    (* ASYNC_REG = \"TRUE\", SHIFT_EXTRACT = \"NO\" *)    reg                 rxresetdone_reg1;    (* ASYNC_REG = \"TRUE\", SHIFT_EXTRACT = \"NO\" *)    reg                 txelecidle_reg1;    (* ASYNC_REG = \"TRUE\", SHIFT_EXTRACT = \"NO\" *)    reg                 txcompliance_reg1;    (* ASYNC_REG = \"TRUE\", SHIFT_EXTRACT = \"NO\" *)    reg                 rxcdrlock_reg1;    (* ASYNC_REG = \"TRUE\", SHIFT_EXTRACT = \"NO\" *)    reg                 rxvalid_reg1;    (* ASYNC_REG = \"TRUE\", SHIFT_EXTRACT = \"NO\" *)    reg                 rxstatus_reg1;    (* ASYNC_REG = \"TRUE\", SHIFT_EXTRACT = \"NO\" *)    reg                 rate_done_reg1;    (* ASYNC_REG = \"TRUE\", SHIFT_EXTRACT = \"NO\" *)    reg                 rst_idle_reg1;    (* ASYNC_REG = \"TRUE\", SHIFT_EXTRACT = \"NO\" *)    reg                 rate_rxsync_reg1;    (* ASYNC_REG = \"TRUE\", SHIFT_EXTRACT = \"NO\" *)    reg                 rate_idle_reg1;    (* ASYNC_REG = \"TRUE\", SHIFT_EXTRACT = \"NO\" *)    reg                 rate_gen3_reg1;    (* ASYNC_REG = \"TRUE\", SHIFT_EXTRACT = \"NO\" *)    reg                 rxeq_adapt_done_reg1;    (* ASYNC_REG = \"TRUE\", SHIFT_EXTRACT = \"NO\" *)    reg                 pclk_sel_reg2;    (* ASYNC_REG = \"TRUE\", SHIFT_EXTRACT = \"NO\" *)    reg                 resetovrd_start_reg2;    (* ASYNC_REG = \"TRUE\", SHIFT_EXTRACT = \"NO\" *)    reg                 txresetdone_reg2;    (* ASYNC_REG = \"TRUE\", SHIFT_EXTRACT = \"NO\" *)    reg                 rxresetdone_reg2;    (* ASYNC_REG = \"TRUE\", SHIFT_EXTRACT = \"NO\" *)    reg                 txelecidle_reg2;    (* ASYNC_REG = \"TRUE\", SHIFT_EXTRACT = \"NO\" *)    reg                 txcompliance_reg2;    (* ASYNC_REG = \"TRUE\", SHIFT_EXTRACT = \"NO\" *)    reg                 rxcdrlock_reg2;    (* ASYNC_REG = \"TRUE\", SHIFT_EXTRACT = \"NO\" *)    reg                 rxvalid_reg2;    (* ASYNC_REG = \"TRUE\", SHIFT_EXTRACT = \"NO\" *)    reg                 rxstatus_reg2;    (* ASYNC_REG = \"TRUE\", SHIFT_EXTRACT = \"NO\" *)    reg                 rate_done_reg2;    (* ASYNC_REG = \"TRUE\", SHIFT_EXTRACT = \"NO\" *)    reg                 rst_idle_reg2;    (* ASYNC_REG = \"TRUE\", SHIFT_EXTRACT = \"NO\" *)    reg                 rate_rxsync_reg2;    (* ASYNC_REG = \"TRUE\", SHIFT_EXTRACT = \"NO\" *)    reg                 rate_idle_reg2;    (* ASYNC_REG = \"TRUE\", SHIFT_EXTRACT = \"NO\" *)    reg                 rate_gen3_reg2;    (* ASYNC_REG = \"TRUE\", SHIFT_EXTRACT = \"NO\" *)    reg                 rxeq_adapt_done_reg2;    reg         [ 1:0]  oobclk_cnt    =  2'd0;    reg         [ 7:0]  reset_cnt     =  8'd127;    reg         [ 3:0]  rxcdrlock_cnt =  4'd0;    reg         [ 3:0]  rxvalid_cnt   =  4'd0;    reg         [21:0]  converge_cnt  = 22'd0;    reg                 converge_gen3 =  1'd0;    reg                 oobclk   = 1'd0;    reg         [ 7:0]  reset    = 8'h00;    reg                 gen3_rdy = 1'd0;    reg         [ 1:0]  fsm      = 2'd0;    localparam          FSM_IDLE       = 2'd0;    localparam          FSM_RESETOVRD  = 2'd1;    localparam          FSM_RESET_INIT = 2'd2;    localparam          FSM_RESET      = 2'd3;    localparam converge_max_cnt = (PCIE_SIM_MODE == \"TRUE\") ? 22'd100 : CONVERGE_MAX;    always @ (posedge USER_TXUSRCLK)    begin        if (!USER_RST_N)        begin            pclk_sel_reg1        <= 1'd0;            resetovrd_start_reg1 <= 1'd0;            txresetdone_reg1     <= 1'd0;            rxresetdone_reg1     <= 1'd0;            txelecidle_reg1      <= 1'd0;            txcompliance_reg1    <= 1'd0;            rxcdrlock_reg1       <= 1'd0;            rxeq_adapt_done_reg1 <= 1'd0;            pclk_sel_reg2        <= 1'd0;            resetovrd_start_reg2 <= 1'd0;            txresetdone_reg2     <= 1'd0;            rxresetdone_reg2     <= 1'd0;            txelecidle_reg2      <= 1'd0;            txcompliance_reg2    <= 1'd0;            rxcdrlock_reg2       <= 1'd0;            rxeq_adapt_done_reg2 <= 1'd0;        end        else        begin            pclk_sel_reg1        <= USER_PCLK_SEL;            resetovrd_start_reg1 <= USER_RESETOVRD_START;            txresetdone_reg1     <= USER_TXRESETDONE;            rxresetdone_reg1     <= USER_RXRESETDONE;            txelecidle_reg1      <= USER_TXELECIDLE;            txcompliance_reg1    <= USER_TXCOMPLIANCE;            rxcdrlock_reg1       <= USER_RXCDRLOCK_IN;            rxeq_adapt_done_reg1 <= USER_RXEQ_ADAPT_DONE;            pclk_sel_reg2        <= pclk_sel_reg1;            resetovrd_start_reg2 <= resetovrd_start_reg1;            txresetdone_reg2     <= txresetdone_reg1;            rxresetdone_reg2     <= rxresetdone_reg1;            txelecidle_reg2      <= txelecidle_reg1;            txcompliance_reg2    <= txcompliance_reg1;            rxcdrlock_reg2       <= rxcdrlock_reg1;            rxeq_adapt_done_reg2 <= rxeq_adapt_done_reg1;        end    end    always @ (posedge USER_RXUSRCLK)    begin        if (!USER_RXUSRCLK_RST_N)        begin            rxvalid_reg1     <= 1'd0;            rxstatus_reg1    <= 1'd0;            rst_idle_reg1    <= 1'd0;            rate_done_reg1   <= 1'd0;            rate_rxsync_reg1 <= 1'd0;            rate_idle_reg1   <= 1'd0;            rate_gen3_reg1   <= 1'd0;            rxvalid_reg2     <= 1'd0;            rxstatus_reg2    <= 1'd0;            rst_idle_reg2    <= 1'd0;            rate_done_reg2   <= 1'd0;            rate_rxsync_reg2 <= 1'd0;            rate_idle_reg2   <= 1'd0;            rate_gen3_reg2   <= 1'd0;        end        else        begin            rxvalid_reg1     <= USER_RXVALID_IN;            rxstatus_reg1    <= USER_RXSTATUS_IN;            rst_idle_reg1    <= USER_RST_IDLE;            rate_done_reg1   <= USER_RATE_DONE;            rate_rxsync_reg1 <= USER_RATE_RXSYNC;            rate_idle_reg1   <= USER_RATE_IDLE;            rate_gen3_reg1   <= USER_RATE_GEN3;            rxvalid_reg2     <= rxvalid_reg1;            rxstatus_reg2    <= rxstatus_reg1;            rst_idle_reg2    <= rst_idle_reg1;            rate_done_reg2   <= rate_done_reg1;            rate_rxsync_reg2 <= rate_rxsync_reg1;            rate_idle_reg2    <= rate_idle_reg1;            rate_gen3_reg2    <= rate_gen3_reg1;        end    end    generate if (PCIE_USE_MODE == \"1.0\") begin : resetovrd    always @ (posedge USER_TXUSRCLK)    begin        if (!USER_RST_N)            reset_cnt <= 8'd127;        else            if (((fsm == FSM_RESETOVRD) || (fsm == FSM_RESET)) && (reset_cnt != 8'd0))                reset_cnt <= reset_cnt - 8'd1;            else                case (reset)                    8'b00000000 : reset_cnt <= 8'd127;                    8'b11111111 : reset_cnt <= 8'd127;                    8'b11111110 : reset_cnt <= 8'd127;                    8'b11111100 : reset_cnt <= 8'd127;                    8'b11111000 : reset_cnt <= 8'd127;                    8'b11110000 : reset_cnt <= 8'd127;                    8'b11100000 : reset_cnt <= 8'd127;                    8'b11000000 : reset_cnt <= 8'd127;                    8'b10000000 : reset_cnt <= 8'd127;                    default     : reset_cnt <= 8'd127;                endcase    end     always @ (posedge USER_TXUSRCLK)    begin        if (!USER_RST_N)            reset <= 8'h00;        else            if (fsm == FSM_RESET_INIT)                reset <= 8'hFF;            else if ((fsm == FSM_RESET) && (reset_cnt == 8'd0))                reset <= {reset[6:0], 1'd0};            else            reset <= reset;    end        always @ (posedge USER_TXUSRCLK)    begin        if (!USER_RST_N)            fsm <= FSM_IDLE;        else        begin            case (fsm)            FSM_IDLE       : fsm <= resetovrd_start_reg2 ? FSM_RESETOVRD : FSM_IDLE;            FSM_RESETOVRD  : fsm <= (reset_cnt == 8'd0) ? FSM_RESET_INIT : FSM_RESETOVRD;            FSM_RESET_INIT : fsm <= FSM_RESET;            FSM_RESET      : fsm <= ((reset == 8'd0) && rxresetdone_reg2) ? FSM_IDLE : FSM_RESET;            default        : fsm <= FSM_IDLE;            endcase        end    end    end else begin : resetovrd_disble    always @ (posedge USER_TXUSRCLK)    begin        if (!USER_RST_N)        begin            reset_cnt <= 8'hFF;            reset <= 8'd0;            fsm <= 2'd0;        end        else        begin            reset_cnt <= 8'hFF;            reset <= 8'd0;            fsm <= 2'd0;        end    end    end endgenerate    generate if (PCIE_OOBCLK_MODE == 1) begin : oobclk_div    always @ (posedge USER_OOBCLK_IN)    begin        if (!USER_RST_N)        begin            oobclk_cnt <= 2'd0;            oobclk     <= 1'd0;        end        else        begin            oobclk_cnt <= oobclk_cnt + 2'd1;            oobclk     <= pclk_sel_reg2 ? oobclk_cnt[1] : oobclk_cnt[0];        end    end    end else begin : oobclk_div_disable    always @ (posedge USER_OOBCLK_IN)    begin        if (!USER_RST_N)        begin            oobclk_cnt <= 2'd0;            oobclk     <= 1'd0;        end        else        begin            oobclk_cnt <= 2'd0;            oobclk     <= 1'd0;        end    end    end    endgenerate    always @ (posedge USER_TXUSRCLK)    begin        if (!USER_RST_N)            rxcdrlock_cnt <= 4'd0;        else            if (rxcdrlock_reg2 && (rxcdrlock_cnt != RXCDRLOCK_MAX))                rxcdrlock_cnt <= rxcdrlock_cnt + 4'd1;            else if (rxcdrlock_reg2 && (rxcdrlock_cnt == RXCDRLOCK_MAX))                rxcdrlock_cnt <= rxcdrlock_cnt;            else            rxcdrlock_cnt <= 4'd0;    end    always @ (posedge USER_RXUSRCLK)    begin        if (!USER_RXUSRCLK_RST_N)            rxvalid_cnt <= 4'd0;        else            if (rxvalid_reg2 && (rxvalid_cnt != RXVALID_MAX) && (!rxstatus_reg2))                rxvalid_cnt <= rxvalid_cnt + 4'd1;            else if (rxvalid_reg2 && (rxvalid_cnt == RXVALID_MAX))                rxvalid_cnt <= rxvalid_cnt;            else            rxvalid_cnt <= 4'd0;    end    always @ (posedge USER_TXUSRCLK)    begin        if (!USER_RST_N)            converge_cnt <= 22'd0;        else            if (rst_idle_reg2 && rate_idle_reg2 && !rate_gen3_reg2)            begin                if (converge_cnt < converge_max_cnt)                    converge_cnt <= converge_cnt + 22'd1;                else                    converge_cnt <= converge_cnt;            end            else            converge_cnt <= 22'd0;    end    always @ (posedge USER_TXUSRCLK)    begin        if (!USER_RST_N)            converge_gen3 <= 1'd0;        else            if (rate_gen3_reg2)            begin                if (rxeq_adapt_done_reg2)                    converge_gen3 <= 1'd1;                else                    converge_gen3 <= converge_gen3;            end            else            converge_gen3 <= 1'd0;    end    always @ (posedge USER_RXUSRCLK)    begin        if (!USER_RXUSRCLK_RST_N)            gen3_rdy <= 1'd0;        else            gen3_rdy <= rate_idle_reg2 && rate_gen3_reg2;    end    assign USER_RESETOVRD = (fsm != FSM_IDLE);    assign USER_TXPMARESET = 1'd0;    assign USER_RXPMARESET = reset[0];    assign USER_RXCDRRESET = reset[1];    assign USER_RXCDRFREQRESET = reset[2];    assign USER_RXDFELPMRESET = reset[3];    assign USER_EYESCANRESET = reset[4];    assign USER_TXPCSRESET = 1'd0;    assign USER_RXPCSRESET = reset[5];    assign USER_RXBUFRESET = reset[6];    assign USER_RESETOVRD_DONE = (fsm == FSM_IDLE);    assign USER_OOBCLK = oobclk;    assign USER_RESETDONE = (txresetdone_reg2 && rxresetdone_reg2);    assign USER_ACTIVE_LANE = !(txelecidle_reg2 && txcompliance_reg2);    assign USER_RXCDRLOCK_OUT = (USER_RXCDRLOCK_IN && (rxcdrlock_cnt == RXCDRLOCK_MAX));    assign USER_RXVALID_OUT = ((USER_RXVALID_IN && (rxvalid_cnt == RXVALID_MAX)) && rst_idle_reg2 && rate_idle_reg2);    assign USER_PHYSTATUS_OUT = (!rst_idle_reg2 || ((rate_idle_reg2 || rate_rxsync_reg2) && USER_PHYSTATUS_IN) || rate_done_reg2);    assign USER_PHYSTATUS_RST = !rst_idle_reg2;    assign USER_GEN3_RDY = 0;    assign USER_RX_CONVERGE = (converge_cnt == converge_max_cnt) || converge_gen3;endmodule"}
{"task_id": 1380, "completion": "feedforward_ST_WandB_ram feedforward_ST_WandB_ram_U(\n    .clk( clk ),\n    .addr0( address0 ),\n    .ce0( ce0 ),\n    .d0( d0 ),\n    .we0( we0 ),\n    .q0( q0 ));\n\nendmodule"}
{"task_id": 1375, "completion": "localparam integer SIZE      = 32;\nlocalparam integer WORD_SIZE = 8;\nlocalparam integer NUM_WORDS = 4;\n\nwire [WORD_SIZE - 1 : 0] col  [0 : NUM_WORDS - 1];\nwire [WORD_SIZE - 1 : 0] sum_p[0 : NUM_WORDS - 1];\nwire [WORD_SIZE - 1 : 0] y    [0 : NUM_WORDS - 2];\n\nfunction [7:0] aes_mult_02;\n  input [7:0] data_in;\n  begin\n    aes_mult_02 = (data_in << 1) ^ {8{data_in[7]}} & 8'h1b;\n  end\nendfunction\n\nfunction [7:0] aes_mult_04;\n  input [7:0] data_in;\n  begin\n    aes_mult_04 = ((data_in << 2) ^ {8{data_in[6]}} & 8'h1b) ^ {8{data_in[7]}} & 8'h36;\n  end\nendfunction\n\ngenerate\n\tgenvar i;\n\tfor(i = 0 ; i < NUM_WORDS; i = i + 1)\n\tbegin:WBT\n\t\tassign col[i] = mix_in[WORD_SIZE*(i + 1) - 1: WORD_SIZE*i];\n\tend\nendgenerate\n\ngenerate\n\tgenvar j;\n\tfor(j = 0; j < NUM_WORDS; j = j + 1)\n\tbegin:DMCO\n\t\tassign sum_p[j] = col[(j + 1)%NUM_WORDS] ^ col[(j + 2)%NUM_WORDS] ^ col[(j + 3)%NUM_WORDS];\n\t\tassign mix_out_enc[ WORD_SIZE*(j + 1) - 1 : WORD_SIZE*j] = aes_mult_02(col[j] ^ col[(j + NUM_WORDS - 1)%NUM_WORDS]) ^ sum_p[j];\n\tend\nendgenerate\n\nassign y[0] = aes_mult_04(col[2] ^ col[0]); \nassign y[1] = aes_mult_04(col[3] ^ col[1]);\nassign y[2] = aes_mult_02(  y[1] ^   y[0]);  \nassign mix_out_dec = mix_out_enc ^ {2{y[2] ^ y[1], y[2] ^ y[0]}};\n\nendmodule"}
{"task_id": 1381, "completion": "reg                rotary_q1;\n  reg                rotary_q2;\n  reg                rotary_q1_dly;\n  reg                rotary_q2_dly;\n\n  always @(posedge clk)\n  begin : filter\n    case ({sync_rot_b, sync_rot_a})\n      0: rotary_q1 <= 1'b0;\n      1: rotary_q2 <= 1'b0;\n      2: rotary_q2 <= 1'b1;\n      3: rotary_q1 <= 1'b1;\n    endcase\n    rotary_q1_dly <= rotary_q1;\n    rotary_q2_dly <= rotary_q2;\n    event_rot_l <=  rotary_q2_dly && !rotary_q1_dly && rotary_q1;\n    event_rot_r <= !rotary_q2_dly && !rotary_q1_dly && rotary_q1;\n  end\n\nendmodule"}
{"task_id": 1376, "completion": "reg\t[15:0]\tdat_o;\n\treg\t\tack_o;\n\treg\t\tstall_o;\n\n\treg\t[4:0]\tbits_o;\n\treg\teedc_o, eedd_o;\n\treg\t[2:0]\ttxcmod_o;\n\treg\trxcpol_o;\n\treg\t[4:0]\tintena_o;\n\treg\t[19:0]\tbitrat_o;\n\treg\trxq_pop_o;\n\treg\trxq_oe_o;\n\treg\ttxq_we_o;\n\treg\t[15:0]\ttxq_dat_o;\n\treg\ttxdlb_o, txclb_o;\n\n\twire [4:0] events = {txq_idle_i, txq_not_full_i, txq_empty_i, rxq_full_i, rxq_not_empty_i};\n\tassign irq_o = |(intena_o & events);\n\n\talways @(posedge clk_i) begin\n\t\tdat_o <= 0;\n\t\tack_o <= 0;\n\t\tstall_o <= 0;\n\t\tbits_o <= bits_o;\n\t\teedc_o <= eedc_o;\n\t\teedd_o <= eedd_o;\n\t\ttxcmod_o <= txcmod_o;\n\t\trxcpol_o <= rxcpol_o;\n\t\tintena_o <= intena_o;\n\t\tbitrat_o <= bitrat_o;\n\t\trxq_pop_o <= 0;\n\t\trxq_oe_o <= 0;\n\t\ttxq_we_o <= 0;\n\t\ttxq_dat_o <= txq_dat_o;\n\n\t\tif(reset_i) begin\n\t\t\tbits_o <= 10;\n\t\t\t{eedc_o, eedd_o} <= 2'b11;\n\t\t\ttxcmod_o <= 3'b100;\n\t\t\trxcpol_o <= 0;\n\t\t\tintena_o <= 5'b00000;\n\t\t\tbitrat_o <= 20'd83332;\n\t\tend\n\t\telse begin\n\t\t\tif(cyc_i & stb_i & we_i) begin\n\t\t\t\tcase(adr_i)\n\t\t\t\t`SIA_ADR_CONFIG: begin\n\t\t\t\t\tif(sel_i[0]) begin\n\t\t\t\t\t\tbits_o <= dat_i[4:0];\n\t\t\t\t\tend\n\t\t\t\t\tif(sel_i[1]) begin\n\t\t\t\t\t\teedc_o <= dat_i[8];\n\t\t\t\t\t\teedd_o <= dat_i[9];\n\t\t\t\t\t\ttxcmod_o <= dat_i[12:10];\n\t\t\t\t\t\trxcpol_o <= dat_i[13];\n\t\t\t\t\t\ttxdlb_o <= dat_i[14];\n\t\t\t\t\t\ttxclb_o <= dat_i[15];\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\t`SIA_ADR_INTENA: begin\n\t\t\t\t\tif(sel_i[0]) intena_o <= dat_i[4:0];\n\t\t\t\tend\n\t\t\t\t`SIA_ADR_TRXDAT: begin\n\t\t\t\t\tif(sel_i[0]) txq_dat_o[7:0] <= dat_i[7:0];\n\t\t\t\t\tif(sel_i[1]) txq_dat_o[15:8] <= dat_i[15:8];\n\t\t\t\t\ttxq_we_o <= sel_i[1];\n\t\t\t\tend\n\t\t\t\t`SIA_ADR_zero0: begin /* do nothing */ end\n\t\t\t\t`SIA_ADR_zero1: begin /* do nothing */ end\n\t\t\t\t`SIA_ADR_BITRATL: begin\n\t\t\t\t\tif(sel_i[0]) bitrat_o[7:0] <= dat_i[7:0];\n\t\t\t\t\tif(sel_i[1]) bitrat_o[15:8] <= dat_i[15:8];\n\t\t\t\tend\n\t\t\t\t`SIA_ADR_BITRATH: begin\n\t\t\t\t\tif(sel_i[0]) bitrat_o[19:16] <= dat_i[3:0];\n\t\t\t\tend\n\t\t\t\tendcase\n\t\t\t\tack_o <= 1;\n\t\t\tend\n\n\t\t\tif(cyc_i & stb_i & ~we_i) begin\n\t\t\t\tcase(adr_i)\n\t\t\t\t`SIA_ADR_CONFIG: dat_o <= {txclb_o, txdlb_o, rxcpol_o, txcmod_o, eedd_o, eedc_o, 3'd0, bits_o};\n\t\t\t\t`SIA_ADR_STATUS: dat_o <= {|events, 10'd0, events};\n\t\t\t\t`SIA_ADR_INTENA: dat_o <= {11'd0, intena_o};\n\t\t\t\t`SIA_ADR_TRXDAT: begin\n\t\t\t\t\tdat_o <= rxq_dat_i;\n\t\t\t\t\trxq_oe_o <= 1;\n\t\t\t\t\trxq_pop_o <= sel_i[1];\n\t\t\t\tend\n\t\t\t\t`SIA_ADR_zero0: dat_o <= 0;\n\t\t\t\t`SIA_ADR_zero1: dat_o <= 0;\n\t\t\t\t`SIA_ADR_BITRATL: dat_o <= bitrat_o[15:0];\n\t\t\t\t`SIA_ADR_BITRATH: dat_o <= {12'd0, bitrat_o[19:16]};\n\t\t\t\tendcase\n\t\t\t\tack_o <= 1;\n\t\t\tend\n\t\tend\n\tend\nendmodule"}
{"task_id": 1383, "completion": "wire             clk_en;  \n  wire    [ 15: 0] data_in;  \n  wire    [ 15: 0] read_mux_out;  \n  reg     [ 15: 0] readdata;  \n  assign clk_en = 1;  \n  assign read_mux_out = {16 {(address == 0)}} & data_in;  \n  always @(posedge clk or negedge reset_n)  \n    begin  \n      if (reset_n == 0)  \n          readdata <= 0;  \n      else if (clk_en)  \n          readdata <= read_mux_out;  \n    end  \n  assign data_in = in_port;  \nendmodule"}
{"task_id": 1384, "completion": "wire [2:0] MEM_data_shift_ctr;  wire [31:0]Mem_d_l,Mem_d_r;  assign MEM_data_shift_ctr[2] = (IR[31])&(!IR[30])&(!IR[29])&(((!IR[28])&(IR[27])) | ((IR[27])&(!IR[26])) );  assign MEM_data_shift_ctr[1] = (IR[31])&(!IR[30])&(!IR[29])&(((!IR[27])&(IR[26])) | ((IR[28])&(IR[27])&(!IR[26])));  assign MEM_data_shift_ctr[0] = (IR[31])&(!IR[30])&(!IR[29])&(((IR[28])&(!IR[27])) | ((!IR[28])&(IR[27])&(!IR[26])));  MUX4_1 mux4_1_10(Mem_addr_in[1:0],Mem_data_out[31:24],Mem_data_out[23:16],Mem_data_out[15:8],Mem_data_out[7:0],Mem_d_l[31:24]);  MUX4_1 mux4_1_11(Mem_addr_in[1:0],Mem_data_out[23:16],Mem_data_out[15:8],Mem_data_out[7:0],8'b0,Mem_d_l[23:16]);  MUX4_1 mux4_1_12(Mem_addr_in[1:0],Mem_data_out[15:8],Mem_data_out[7:0],8'b0,8'b0,Mem_d_l[15:8]);  MUX4_1 mux4_1_13(Mem_addr_in[1:0],Mem_data_out[7:0],8'b0,8'b0,8'b0,Mem_d_l[7:0]);  MUX4_1 mux4_1_14(Mem_addr_in[1:0],8'b0,8'b0,8'b0,Mem_data_out[31:24],Mem_d_r[31:24]);  MUX4_1 mux4_1_15(Mem_addr_in[1:0],8'b0,8'b0,Mem_data_out[31:24],Mem_data_out[23:16],Mem_d_r[23:16]);  MUX4_1 mux4_1_16(Mem_addr_in[1:0],8'b0,Mem_data_out[31:24],Mem_data_out[23:16],Mem_data_out[15:8],Mem_d_r[15:8]);  MUX4_1 mux4_1_17(Mem_addr_in[1:0],Mem_data_out[31:24],Mem_data_out[23:16],Mem_data_out[15:8],Mem_data_out[7:0],Mem_d_r[7:0]);  MUX8_1 mux8_1_10(MEM_data_shift_ctr[2:0],{8{Mem_d_l[31]}},8'b0,{8{Mem_d_l[31]}},8'b0,Mem_d_l[31:24],Mem_d_l[31:24],Mem_d_r[31:24],8'b0,Mem_data_shift[31:24]);  MUX8_1 mux8_1_11(MEM_data_shift_ctr[2:0],{8{Mem_d_l[31]}},8'b0,{8{Mem_d_l[31]}},8'b0,Mem_d_l[23:16],Mem_d_l[23:16],Mem_d_r[23:16],8'b0,Mem_data_shift[23:16]);  MUX8_1 mux8_1_12(MEM_data_shift_ctr[2:0],{8{Mem_d_l[31]}},8'b0,Mem_d_l[31:24],Mem_d_l[31:24],Mem_d_l[15:8],Mem_d_l[15:8],Mem_d_r[15:8],8'b0,Mem_data_shift[15:8]);  MUX8_1 mux8_1_13(MEM_data_shift_ctr[2:0],Mem_d_l[31:24],Mem_d_l[31:24],Mem_d_l[23:16],Mem_d_l[23:16],Mem_d_l[7:0],Mem_d_l[7:0],Mem_d_r[7:0],8'b0,Mem_data_shift[7:0]);  endmodule"}
{"task_id": 1389, "completion": "reg [4:0] count;\n\n\talways @* begin\n\t\tcount = 0;\n\t\tif (d == 32'h0) begin\n\t\t\tclz = 5'd32;\n\t\tend else begin\n\t\t\tfor (int i = 31; i >= 0; i = i - 1) begin\n\t\t\t\tif (d[i] == 1'b0)\n\t\t\t\t\tcount = count + 1;\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\tend\n\t\t\tclz = count;\n\t\tend\n\tend\n\nendmodule"}
{"task_id": 1373, "completion": "wire dfifo_in_dst_rdy, dfifo_in_src_rdy, dfifo_out_dst_rdy, dfifo_out_src_rdy;\n   wire tfifo_in_dst_rdy, tfifo_in_src_rdy, tfifo_out_dst_rdy, tfifo_out_src_rdy;\n\n   wire do_xfer_in = dfifo_in_src_rdy & dfifo_in_dst_rdy;\n   wire do_xfer_out = src_rdy_o & dst_rdy_i;\n   wire have_space = dfifo_in_dst_rdy & tfifo_in_dst_rdy;\n   reg [15:0] pkt_len_in, pkt_len_out;\n   wire [15:0] tfifo_data;\n   wire [35:0] dfifo_out_data;\n   \n   assign dst_rdy_o = have_space;\n   assign dfifo_in_src_rdy = src_rdy_i & have_space;\n   \n   fifo_cascade #(.WIDTH(36), .SIZE(BUF_SIZE)) dfifo\n     (.clk(clk), .reset(reset), .clear(clear),\n      .datain(data_i), .src_rdy_i(dfifo_in_src_rdy), .dst_rdy_o(dfifo_in_dst_rdy),\n      .dataout(dfifo_out_data), .src_rdy_o(dfifo_out_src_rdy),  .dst_rdy_i(dfifo_out_dst_rdy) );\n\n   fifo_short #(.WIDTH(16)) tfifo\n     (.clk(clk), .reset(reset), .clear(clear),\n      .datain(pkt_len_in),  .src_rdy_i(tfifo_in_src_rdy), .dst_rdy_o(tfifo_in_dst_rdy),\n      .dataout(tfifo_data), .src_rdy_o(tfifo_out_src_rdy), .dst_rdy_i(tfifo_out_dst_rdy),\n      .space(), .occupied() );\n\n   always @(posedge clk)\n     if(reset | clear)\n       pkt_len_in <= 0;\n     else if(do_xfer_in)\n       if(data_i[32])   \n\t\t pkt_len_in <= 2;\n       else\n\t\t pkt_len_in <= pkt_len_in + 1;\n\n   assign tfifo_in_src_rdy = do_xfer_in & data_i[33];\n   assign tfifo_out_dst_rdy = do_xfer_out & data_o[33];\n\n   always @(posedge clk)\n     if(reset | clear)\n       pkt_len_out <= (PROT_ENG_FLAGS ? 1'b0 : 1'b1);\n     else if(do_xfer_out)\n       if(dfifo_out_data[33]) \n\t\t pkt_len_out <= (PROT_ENG_FLAGS ? 1'b0 : 1'b1);\n       else\n\t\t pkt_len_out <= pkt_len_out + 1;\n   \n   assign dfifo_out_dst_rdy = do_xfer_out & (pkt_len_out != 0);\n\n   wire [1:0] port_sel_bits = PORT_SEL;\n   \n   assign data_o = (pkt_len_out == 0) ? {3'b000, 1'b1, 13'b0, port_sel_bits, 1'b1, tfifo_data[13:0],2'b00} :\n\t\t   (pkt_len_out == 1) ? {3'b000, (PROT_ENG_FLAGS ? 1'b0: 1'b1), dfifo_out_data[31:16],tfifo_data} : \n\t\t   {dfifo_out_data[35:33], 1'b0, dfifo_out_data[31:0] };\n\n   assign src_rdy_o = dfifo_out_src_rdy & tfifo_out_src_rdy;\nendmodule"}
{"task_id": 1387, "completion": "wire [7:0]    led;\n   assign GPIO_LED = led[3:0];\n\n   opc5system #(\n    .CLKSPEED(40000000),\n    .BAUD(115200),\n    .RAMSIZE(14),\n    .SEVEN_SEG_DUTY_CYCLE(7)\n   ) system (\n      .clk(USER_CLOCK),\n      .sw({4'b0, GPIO_DIP4, GPIO_DIP3, GPIO_DIP2, GPIO_DIP1}),\n      .led(led),\n      .rxd(USB_RS232_RXD),\n      .txd(USB_RS232_TXD),\n      .seg(),\n      .an(),\n      .select(!USER_RESET)\n    );\n\n   assign SPI_SCK     = 1'b1;\n   assign SPI_CS_n    = 1'b1;\n   assign SPI_IO1     = 1'bz;\n   assign SPI_IO2     = 1'bz;\n   assign SPI_IO3     = 1'bz;\n   assign SPI_IO4     = 1'bz;\n   assign SCL         = 1'bz;\n   assign LPDDR_A    = 13'b0;\n   assign LPDDR_BA    = 1'b0;\n   assign LPDDR_DQ   = 16'bz;\n   assign LPDDR_LDM   = 1'b0;\n   assign LPDDR_UDM   = 1'b0;\n   assign LPDDR_LDQS  = 1'bz;\n   assign LPDDR_UDQS  = 1'bz;\n   assign LPDDR_CKE   = 1'b0;\n   assign LPDDR_CAS_n = 1'b1;\n   assign LPDDR_RAS_n = 1'b1;\n   assign LPDDR_WE_n  = 1'b1;\n   assign LPDDR_RZQ   = 1'bz;\n   assign ETH_RESET_n = 1'b1;\n   assign ETH_TX_D    = 4'bz;\n   assign ETH_TX_EN   = 1'b0;\n   \n   OBUFDS LPDDR_CK_inst (\n      .O(LPDDR_CK_P),  // Diff_p output (connect directly to top-level port)\n      .OB(LPDDR_CK_N), // Diff_n output (connect directly to top-level port)\n      .I(1'b0)\n    );\n\nendmodule"}
{"task_id": 1394, "completion": "wire             clk_en;\n    reg     [  3: 0] d1_data_in;\n    reg     [  3: 0] d2_data_in;\n    wire    [  3: 0] data_in;\n    reg     [  3: 0] edge_capture;\n    wire             edge_capture_wr_strobe;\n    wire    [  3: 0] edge_detect;\n    reg     [  3: 0] irq_mask;\n    wire    [  3: 0] read_mux_out;\n    reg     [ 31: 0] readdata;\n    assign clk_en = 1;\n    assign read_mux_out = ({4 {(address == 0)}} & data_in) |\n      ({4 {(address == 2)}} & irq_mask) |\n      ({4 {(address == 3)}} & edge_capture);\n\n    always @(posedge clk or negedge reset_n)\n      begin\n        if (reset_n == 0)\n            readdata <= 0;\n        else if (clk_en)\n            readdata <= {32'b0 | read_mux_out};\n      end\n\n    assign data_in = in_port;\n    always @(posedge clk or negedge reset_n)\n      begin\n        if (reset_n == 0)\n            irq_mask <= 0;\n        else if (chipselect && ~write_n && (address == 2))\n            irq_mask <= writedata[3 : 0];\n      end\n\n    assign irq = |(edge_capture & irq_mask);\n    assign edge_capture_wr_strobe = chipselect && ~write_n && (address == 3);\n    always @(posedge clk or negedge reset_n)\n      begin\n        if (reset_n == 0)\n            edge_capture[0] <= 0;\n        else if (clk_en)\n            if (edge_capture_wr_strobe && writedata[0])\n                edge_capture[0] <= 0;\n            else if (edge_detect[0])\n                edge_capture[0] <= -1;\n      end\n\n    always @(posedge clk or negedge reset_n)\n      begin\n        if (reset_n == 0)\n            edge_capture[1] <= 0;\n        else if (clk_en)\n            if (edge_capture_wr_strobe && writedata[1])\n                edge_capture[1] <= 0;\n            else if (edge_detect[1])\n                edge_capture[1] <= -1;\n      end\n\n    always @(posedge clk or negedge reset_n)\n      begin\n        if (reset_n == 0)\n            edge_capture[2] <= 0;\n        else if (clk_en)\n            if (edge_capture_wr_strobe && writedata[2])\n                edge_capture[2] <= 0;\n            else if (edge_detect[2])\n                edge_capture[2] <= -1;\n      end\n\n    always @(posedge clk or negedge reset_n)\n      begin\n        if (reset_n == 0)\n            edge_capture[3] <= 0;\n        else if (clk_en)\n            if (edge_capture_wr_strobe && writedata[3])\n                edge_capture[3] <= 0;\n            else if (edge_detect[3])\n                edge_capture[3] <= -1;\n      end\n\n    always @(posedge clk or negedge reset_n)\n      begin\n        if (reset_n == 0)\n          begin\n            d1_data_in <= 0;\n            d2_data_in <= 0;\n          end\n        else if (clk_en)\n          begin\n            d1_data_in <= data_in;\n            d2_data_in <= d1_data_in;\n          end\n      end\n\n    assign edge_detect = d1_data_in ^  d2_data_in;\nendmodule"}
{"task_id": 1368, "completion": "assign equiv = (state_a == state_b);\nendmodule"}
{"task_id": 1365, "completion": "// synthesis translate_off\n\n  BLK_MEM_GEN_V7_3 #(\n    .C_ADDRA_WIDTH(11),\n    .C_ADDRB_WIDTH(11),\n    .C_ALGORITHM(1),\n    .C_AXI_ID_WIDTH(4),\n    .C_AXI_SLAVE_TYPE(0),\n    .C_AXI_TYPE(1),\n    .C_BYTE_SIZE(9),\n    .C_COMMON_CLK(1),\n    .C_DEFAULT_DATA(\"0\"),\n    .C_DISABLE_WARN_BHV_COLL(0),\n    .C_DISABLE_WARN_BHV_RANGE(0),\n    .C_ENABLE_32BIT_ADDRESS(0),\n    .C_FAMILY(\"spartan3\"),\n    .C_HAS_AXI_ID(0),\n    .C_HAS_ENA(0),\n    .C_HAS_ENB(0),\n    .C_HAS_INJECTERR(0),\n    .C_HAS_MEM_OUTPUT_REGS_A(0),\n    .C_HAS_MEM_OUTPUT_REGS_B(0),\n    .C_HAS_MUX_OUTPUT_REGS_A(0),\n    .C_HAS_MUX_OUTPUT_REGS_B(0),\n    .C_HAS_REGCEA(0),\n    .C_HAS_REGCEB(0),\n    .C_HAS_RSTA(0),\n    .C_HAS_RSTB(0),\n    .C_HAS_SOFTECC_INPUT_REGS_A(0),\n    .C_HAS_SOFTECC_OUTPUT_REGS_B(0),\n    .C_INIT_FILE(\"BlankString\"),\n    .C_INIT_FILE_NAME(\"no_coe_file_loaded\"),\n    .C_INITA_VAL(\"0\"),\n    .C_INITB_VAL(\"0\"),\n    .C_INTERFACE_TYPE(0),\n    .C_LOAD_INIT_FILE(0),\n    .C_MEM_TYPE(1),\n    .C_MUX_PIPELINE_STAGES(0),\n    .C_PRIM_TYPE(1),\n    .C_READ_DEPTH_A(2048),\n    .C_READ_DEPTH_B(2048),\n    .C_READ_WIDTH_A(24),\n    .C_READ_WIDTH_B(24),\n    .C_RST_PRIORITY_A(\"CE\"),\n    .C_RST_PRIORITY_B(\"CE\"),\n    .C_RST_TYPE(\"SYNC\"),\n    .C_RSTRAM_A(0),\n    .C_RSTRAM_B(0),\n    .C_SIM_COLLISION_CHECK(\"ALL\"),\n    .C_USE_BRAM_BLOCK(0),\n    .C_USE_BYTE_WEA(0),\n    .C_USE_BYTE_WEB(0),\n    .C_USE_DEFAULT_DATA(0),\n    .C_USE_ECC(0),\n    .C_USE_SOFTECC(0),\n    .C_WEA_WIDTH(1),\n    .C_WEB_WIDTH(1),\n    .C_WRITE_DEPTH_A(2048),\n    .C_WRITE_DEPTH_B(2048),\n    .C_WRITE_MODE_A(\"WRITE_FIRST\"),\n    .C_WRITE_MODE_B(\"WRITE_FIRST\"),\n    .C_WRITE_WIDTH_A(24),\n    .C_WRITE_WIDTH_B(24),\n    .C_XDEVICEFAMILY(\"spartan3\")\n  )\n  inst (\n    .CLKA(clka),\n    .WEA(wea),\n    .ADDRA(addra),\n    .DINA(dina),\n    .CLKB(clkb),\n    .ADDRB(addrb),\n    .DOUTB(doutb),\n    .RSTA(),\n    .ENA(),\n    .REGCEA(),\n    .DOUTA(),\n    .RSTB(),\n    .ENB(),\n    .REGCEB(),\n    .WEB(),\n    .DINB(),\n    .INJECTSBITERR(),\n    .INJECTDBITERR(),\n    .SBITERR(),\n    .DBITERR(),\n    .RDADDRECC(),\n    .S_ACLK(),\n    .S_ARESETN(),\n    .S_AXI_AWID(),\n    .S_AXI_AWADDR(),\n    .S_AXI_AWLEN(),\n    .S_AXI_AWSIZE(),\n    .S_AXI_AWBURST(),\n    .S_AXI_AWVALID(),\n    .S_AXI_AWREADY(),\n    .S_AXI_WDATA(),\n    .S_AXI_WSTRB(),\n    .S_AXI_WLAST(),\n    .S_AXI_WVALID(),\n    .S_AXI_WREADY(),\n    .S_AXI_BID(),\n    .S_AXI_BRESP(),\n    .S_AXI_BVALID(),\n    .S_AXI_BREADY(),\n    .S_AXI_ARID(),\n    .S_AXI_ARADDR(),\n    .S_AXI_ARLEN(),\n    .S_AXI_ARSIZE(),\n    .S_AXI_ARBURST(),\n    .S_AXI_ARVALID(),\n    .S_AXI_ARREADY(),\n    .S_AXI_RID(),\n    .S_AXI_RDATA(),\n    .S_AXI_RRESP(),\n    .S_AXI_RLAST(),\n    .S_AXI_RVALID(),\n    .S_AXI_RREADY(),\n    .S_AXI_INJECTSBITERR(),\n    .S_AXI_INJECTDBITERR(),\n    .S_AXI_SBITERR(),\n    .S_AXI_DBITERR(),\n    .S_AXI_RDADDRECC()\n  );\n\n  // synthesis translate_on\n\nendmodule"}
{"task_id": 1363, "completion": "reg [ 1:0] cSCL, cSDA;      \n    reg [ 2:0] fSCL, fSDA;      \n    reg        sSCL, sSDA;      \n    reg        dSCL, dSDA;      \n    reg        dscl_oen;        \n    reg        sda_chk;         \n    reg        clk_en;          \n    reg        slave_wait;      \n    reg [15:0] cnt;             \n    reg [13:0] filter_cnt;      \n\n    reg [5:0] c_state; \n\n    always @(posedge clk)  \n      dscl_oen <= #1 scl_oen;  \n\n    always @(posedge clk or negedge nReset)  \n      if (!nReset) slave_wait <= 1'b0;  \n      else         slave_wait <= (scl_oen & ~dscl_oen & ~sSCL) | (slave_wait & ~sSCL);  \n\n    wire scl_sync   = dSCL & ~sSCL & scl_oen;  \n\n    always @(posedge clk or negedge nReset)  \n      if (~nReset)  \n      begin  \n          cnt    <= #1 16'h0;  \n          clk_en <= #1 1'b1;  \n      end  \n      else if (rst || ~|cnt || !ena || scl_sync)  \n      begin  \n          cnt    <= #1 clk_cnt;  \n          clk_en <= #1 1'b1;  \n      end  \n      else if (slave_wait)  \n      begin  \n          cnt    <= #1 cnt;  \n          clk_en <= #1 1'b0;  \n      end  \n      else  \n      begin  \n          cnt    <= #1 cnt - 16'h1;  \n          clk_en <= #1 1'b0;  \n      end  \n\n    always @(posedge clk or negedge nReset)  \n      if (!nReset)  \n      begin  \n          cSCL <= #1 2'b00;  \n          cSDA <= #1 2'b00;  \n      end  \n      else if (rst)  \n      begin  \n          cSCL <= #1 2'b00;  \n          cSDA <= #1 2'b00;  \n      end  \n      else  \n      begin  \n          cSCL <= {cSCL[0],scl_i};  \n          cSDA <= {cSDA[0],sda_i};  \n      end  \n\n    always @(posedge clk or negedge nReset)  \n      if      (!nReset     ) filter_cnt <= 14'h0;  \n      else if (rst || !ena ) filter_cnt <= 14'h0;  \n      else if (~|filter_cnt) filter_cnt <= clk_cnt >> 2; //16x I2C bus frequency  \n      else                   filter_cnt <= filter_cnt -1;  \n\n    always @(posedge clk or negedge nReset)  \n      if (!nReset)  \n      begin  \n          fSCL <= 3'b111;  \n          fSDA <= 3'b111;  \n      end  \n      else if (rst)  \n      begin  \n          fSCL <= 3'b111;  \n          fSDA <= 3'b111;  \n      end  \n      else if (~|filter_cnt)  \n      begin  \n          fSCL <= {fSCL[1:0],cSCL[1]};  \n          fSDA <= {fSDA[1:0],cSDA[1]};  \n      end  \n\n    always @(posedge clk or negedge nReset)  \n      if (~nReset)  \n      begin  \n          sSCL <= #1 1'b1;  \n          sSDA <= #1 1'b1;  \n\n          dSCL <= #1 1'b1;  \n          dSDA <= #1 1'b1;  \n      end  \n      else if (rst)  \n      begin  \n          sSCL <= #1 1'b1;  \n          sSDA <= #1 1'b1;  \n\n          dSCL <= #1 1'b1;  \n          dSDA <= #1 1'b1;  \n      end  \n      else  \n      begin  \n          sSCL <= #1 &fSCL[2:1] | &fSCL[1:0] | (fSCL[2] & fSCL[0]);  \n          sSDA <= #1 &fSDA[2:1] | &fSDA[1:0] | (fSDA[2] & fSDA[0]);  \n\n          dSCL <= #1 sSCL;  \n          dSDA <= #1 sSDA;  \n      end  \n\n    reg sta_condition;  \n    reg sto_condition;  \n    always @(posedge clk or negedge nReset)  \n      if (~nReset)  \n      begin  \n          sta_condition <= #1 1'b0;  \n          sto_condition <= #1 1'b0;  \n      end  \n      else if (rst)  \n      begin  \n          sta_condition <= #1 1'b0;  \n          sto_condition <= #1 1'b0;  \n      end  \n      else  \n      begin  \n          sta_condition <= #1 ~sSDA &  dSDA & sSCL;  \n          sto_condition <= #1  sSDA & ~dSDA & sSCL;  \n      end  \n\n    always @(posedge clk or negedge nReset)  \n      if      (!nReset) busy <= #1 1'b0;  \n      else if (rst    ) busy <= #1 1'b0;  \n      else              busy <= #1 (sta_condition | busy) & ~sto_condition;  \n\n    reg cmd_stop;  \n    always @(posedge clk or negedge nReset)  \n      if (~nReset)  \n          cmd_stop <= #1 1'b0;  \n      else if (rst)  \n          cmd_stop <= #1 1'b0;  \n      else if (clk_en)  \n          cmd_stop <= #1 cmd == `I2C_CMD_STOP;  \n\n    always @(posedge clk or negedge nReset)  \n      if (~nReset)  \n          al <= #1 1'b0;  \n      else if (rst)  \n          al <= #1 1'b0;  \n      else  \n          al <= #1 (sda_chk & ~sSDA & sda_oen) | (|c_state & sto_condition & ~cmd_stop);  \n\n    always @(posedge clk)  \n      if (sSCL & ~dSCL) dout <= #1 sSDA;  \n\n    parameter    idle    = 0;  \n    parameter    start_a = 1;  \n    parameter    start_b = 2;  \n    parameter    start_c = 3;  \n    parameter    start_d = 4;  \n    parameter    start_e = 5;  \n    parameter    stop_a  = 6;  \n    parameter    stop_b  = 7;  \n    parameter    stop_c  = 8;  \n    parameter    stop_d  = 9;  \n    parameter    rd_a    = 10;  \n    parameter    rd_b    = 11;  \n    parameter    rd_c    = 12;  \n    parameter    rd_d    = 13;  \n    parameter    wr_a    = 14;  \n    parameter    wr_b    = 15;  \n    parameter    wr_c    = 16;  \n    parameter    wr_d    = 17;  \n\n    always @(posedge clk or negedge nReset)  \n      if (!nReset)  \n      begin  \n          c_state <= #1 idle;  \n          cmd_ack <= #1 1'b0;  \n          scl_oen <= #1 1'b1;  \n          sda_oen <= #1 1'b1;  \n          sda_chk <= #1 1'b0;  \n      end  \n      else if (rst | al)  \n      begin  \n          c_state <= #1 idle;  \n          cmd_ack <= #1 1'b0;  \n          scl_oen <= #1 1'b1;  \n          sda_oen <= #1 1'b1;  \n          sda_chk <= #1 1'b0;  \n      end  \n      else  \n      begin  \n          cmd_ack   <= #1 1'b0;  \n\n          if (clk_en)  \n              case (c_state)  \n                    idle:  \n                    begin  \n                        case (cmd)  \n                             `I2C_CMD_START: c_state <= #1 start_a;  \n                             `I2C_CMD_STOP:  c_state <= #1 stop_a;  \n                             `I2C_CMD_WRITE: c_state <= #1 wr_a;  \n                             `I2C_CMD_READ:  c_state <= #1 rd_a;  \n                             default:        c_state <= #1 idle;  \n                        endcase  \n\n                        scl_oen <= #1 scl_oen;  \n                        sda_oen <= #1 sda_oen;  \n                        sda_chk <= #1 1'b0;  \n                    end  \n\n                    start_a:  \n                    begin  \n                        c_state <= #1 start_b;  \n                        scl_oen <= #1 scl_oen;  \n                        sda_oen <= #1 1'b1;  \n                        sda_chk <= #1 1'b0;  \n                    end  \n\n                    start_b:  \n                    begin  \n                        c_state <= #1 start_c;  \n                        scl_oen <= #1 1'b1;  \n                        sda_oen <= #1 1'b1;  \n                        sda_chk <= #1 1'b0;  \n                    end  \n\n                    start_c:  \n                    begin  \n                        c_state <= #1 start_d;  \n                        scl_oen <= #1 1'b1;  \n                        sda_oen <= #1 1'b0;  \n                        sda_chk <= #1 1'b0;  \n                    end  \n\n                    start_d:  \n                    begin  \n                        c_state <= #1 start_e;  \n                        scl_oen <= #1 1'b1;  \n                        sda_oen <= #1 1'b0;  \n                        sda_chk <= #1 1'b0;  \n                    end  \n\n                    start_e:  \n                    begin  \n                        c_state <= #1 idle;  \n                        cmd_ack <= #1 1'b1;  \n                        scl_oen <= #1 1'b0;  \n                        sda_oen <= #1 1'b0;  \n                        sda_chk <= #1 1'b0;  \n                    end  \n\n                    stop_a:  \n                    begin  \n                        c_state <= #1 stop_b;  \n                        scl_oen <= #1 1'b0;  \n                        sda_oen <= #1 1'b0;  \n                        sda_chk <= #1 1'b0;  \n                    end  \n\n                    stop_b:  \n                    begin  \n                        c_state <= #1 stop_c;  \n                        scl_oen <= #1 1'b1;  \n                        sda_oen <= #1 1'b0;  \n                        sda_chk <= #1 1'b0;  \n                    end  \n\n                    stop_c:  \n                    begin  \n                        c_state <= #1 stop_d;  \n                        scl_oen <= #1 1'b1;  \n                        sda_oen <= #1 1'b0;  \n                        sda_chk <= #1 1'b0;  \n                    end  \n\n                    stop_d:  \n                    begin  \n                        c_state <= #1 idle;  \n                        cmd_ack <= #1 1'b1;  \n                        scl_oen <= #1 1'b1;  \n                        sda_oen <= #1 1'b1;  \n                        sda_chk <= #1 1'b0;  \n                    end  \n\n                    rd_a:  \n                    begin  \n                        c_state <= #1 rd_b;  \n                        scl_oen <= #1 1'b0;  \n                        sda_oen <= #1 1'b1;  \n                        sda_chk <= #1 1'b0;  \n                    end  \n\n                    rd_b:  \n                    begin  \n                        c_state <= #1 rd_c;  \n                        scl_oen <= #1 1'b1;  \n                        sda_oen <= #1 1'b1;  \n                        sda_chk <= #1 1'b0;  \n                    end  \n\n                    rd_c:  \n                    begin  \n                        c_state <= #1 rd_d;  \n                        scl_oen <= #1 1'b1;  \n                        sda_oen <= #1 1'b1;  \n                        sda_chk <= #1 1'b0;  \n                    end  \n\n                    rd_d:  \n                    begin  \n                        c_state <= #1 idle;  \n                        cmd_ack <= #1 1'b1;  \n                        scl_oen <= #1 1'b0;  \n                        sda_oen <= #1 1'b1;  \n                        sda_chk <= #1 1'b0;  \n                    end  \n\n                    wr_a:  \n                    begin  \n                        c_state <= #1 wr_b;  \n                        scl_oen <= #1 1'b0;  \n                        sda_oen <= #1 din;  \n                        sda_chk <= #1 1'b0;  \n                    end  \n\n                    wr_b:  \n                    begin  \n                        c_state <= #1 wr_c;  \n                        scl_oen <= #1 1'b1;  \n                        sda_oen <= #1 din;  \n                        sda_chk <= #1 1'b0;  \n                    end  \n\n                    wr_c:  \n                    begin  \n                        c_state <= #1 wr_d;  \n                        scl_oen <= #1 1'b1;  \n                        sda_oen <= #1 din;  \n                        sda_chk <= #1 1'b1;  \n                    end  \n\n                    wr_d:  \n                    begin  \n                        c_state <= #1 idle;  \n                        cmd_ack <= #1 1'b1;  \n                        scl_oen <= #1 1'b0;  \n                        sda_oen <= #1 din;  \n                        sda_chk <= #1 1'b0;  \n                    end  \n              endcase  \n      end  \n\n    assign scl_o = 1'b0;  \n    assign sda_o = 1'b0;  \nendmodule"}
{"task_id": 1396, "completion": "wire q0,q1,q2,q3; flop_gated_latch f0(q0,d,clk,en); flop_gated_latch f1(q1,d,clk,en); flop_gated_flop f2(q2,d,clk,en); flop_gated_flop f3(q3,d,d,clk,en); assign res = (q0 + q1) * (q2 - q3);endmodule"}
{"task_id": 1391, "completion": "reg [bitwidth+1:0] x0,y0;\n   reg [zwidth-2:0] z0;\n   wire [bitwidth+1:0] x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15,x16,x17,x18,x19,x20;\n   wire [bitwidth+1:0] y1,y2,y3,y4,y5,y6,y7,y8,y9,y10,y11,y12,y13,y14,y15,y16,y17,y18,y19,y20;\n   wire [zwidth-2:0] z1,z2,z3,z4,z5,z6,z7,z8,z9,z10,z11,z12,z13,z14,z15,z16,z17,z18,z19,z20;\n   wire [bitwidth+1:0] xi_ext = {{2{xi[bitwidth-1]}},xi};\n   wire [bitwidth+1:0] yi_ext = {{2{yi[bitwidth-1]}},yi};\n   localparam c00 = 23'd2097152;\n   localparam c01 = 23'd1238021;\n   localparam c02 = 23'd654136;\n   localparam c03 = 23'd332050;\n   localparam c04 = 23'd166669;\n   localparam c05 = 23'd83416;\n   localparam c06 = 23'd41718;\n   localparam c07 = 23'd20860;\n   localparam c08 = 23'd10430;\n   localparam c09 = 23'd5215;\n   localparam c10 = 23'd2608;\n   localparam c11 = 23'd1304;\n   localparam c12 = 23'd652;\n   localparam c13 = 23'd326;\n   localparam c14 = 23'd163;\n   localparam c15 = 23'd81;\n   localparam c16 = 23'd41;\n   localparam c17 = 23'd20;\n   localparam c18 = 23'd10;\n   localparam c19 = 23'd5;\n   localparam c20 = 23'd3;\n   localparam c21 = 23'd1;\n   localparam c22 = 23'd1;\n   localparam c23 = 23'd0;\n   always @(posedge clock)\n     if(reset)\n       begin\n          x0 <= 0; y0 <= 0; z0 <= 0;\n       end\n     else\n       begin\n          z0 <= zi[zwidth-2:0];\n          case (zi[zwidth-1:zwidth-2])\n            2'b00, 2'b11 : \n              begin\n                 x0 <= xi_ext;\n                 y0 <= yi_ext;\n              end\n            2'b01, 2'b10 :\n              begin\n                 x0 <= -xi_ext;\n                 y0 <= -yi_ext;\n              end\n          endcase\n       end\n   cordic_stage #(bitwidth+2,zwidth-1,0) cordic_stage0 (clock,reset,enable,x0,y0,z0,c00,x1,y1,z1);\n   cordic_stage #(bitwidth+2,zwidth-1,1) cordic_stage1 (clock,reset,enable,x1,y1,z1,c01,x2,y2,z2);\n   cordic_stage #(bitwidth+2,zwidth-1,2) cordic_stage2 (clock,reset,enable,x2,y2,z2,c02,x3,y3,z3);\n   cordic_stage #(bitwidth+2,zwidth-1,3) cordic_stage3 (clock,reset,enable,x3,y3,z3,c03,x4,y4,z4);\n   cordic_stage #(bitwidth+2,zwidth-1,4) cordic_stage4 (clock,reset,enable,x4,y4,z4,c04,x5,y5,z5);\n   cordic_stage #(bitwidth+2,zwidth-1,5) cordic_stage5 (clock,reset,enable,x5,y5,z5,c05,x6,y6,z6);\n   cordic_stage #(bitwidth+2,zwidth-1,6) cordic_stage6 (clock,reset,enable,x6,y6,z6,c06,x7,y7,z7);\n   cordic_stage #(bitwidth+2,zwidth-1,7) cordic_stage7 (clock,reset,enable,x7,y7,z7,c07,x8,y8,z8);\n   cordic_stage #(bitwidth+2,zwidth-1,8) cordic_stage8 (clock,reset,enable,x8,y8,z8,c08,x9,y9,z9);\n   cordic_stage #(bitwidth+2,zwidth-1,9) cordic_stage9 (clock,reset,enable,x9,y9,z9,c09,x10,y10,z10);\n   cordic_stage #(bitwidth+2,zwidth-1,10) cordic_stage10 (clock,reset,enable,x10,y10,z10,c10,x11,y11,z11);\n   cordic_stage #(bitwidth+2,zwidth-1,11) cordic_stage11 (clock,reset,enable,x11,y11,z11,c11,x12,y12,z12);\n   cordic_stage #(bitwidth+2,zwidth-1,12) cordic_stage12 (clock,reset,enable,x12,y12,z12,c12,x13,y13,z13);\n   cordic_stage #(bitwidth+2,zwidth-1,13) cordic_stage13 (clock,reset,enable,x13,y13,z13,c13,x14,y14,z14);\n   cordic_stage #(bitwidth+2,zwidth-1,14) cordic_stage14 (clock,reset,enable,x14,y14,z14,c14,x15,y15,z15);\n   cordic_stage #(bitwidth+2,zwidth-1,15) cordic_stage15 (clock,reset,enable,x15,y15,z15,c15,x16,y16,z16);\n   cordic_stage #(bitwidth+2,zwidth-1,16) cordic_stage16 (clock,reset,enable,x16,y16,z16,c16,x17,y17,z17);\n   cordic_stage #(bitwidth+2,zwidth-1,17) cordic_stage17 (clock,reset,enable,x17,y17,z17,c17,x18,y18,z18);\n   cordic_stage #(bitwidth+2,zwidth-1,18) cordic_stage18 (clock,reset,enable,x18,y18,z18,c18,x19,y19,z19);\n   cordic_stage #(bitwidth+2,zwidth-1,19) cordic_stage19 (clock,reset,enable,x19,y19,z19,c19,x20,y20,z20);\n   assign xo = x20[bitwidth:1];  \n   assign yo = y20[bitwidth:1];\n   assign zo = z20;\nendmodule"}
{"task_id": 1402, "completion": "reg [1:0] int_comp_reg;\n  wire int_comp_wire;\n\n  generate\n    if(AXIS_TDATA_SIGNED == \"TRUE\")\n    begin : SIGNED\n      assign int_comp_wire = $signed(s_axis_tdata & msk_data) >= $signed(lvl_data);\n    end\n    else\n    begin : UNSIGNED\n      assign int_comp_wire = (s_axis_tdata & msk_data) >= lvl_data;\n    end\n  endgenerate\n\n  always @(posedge aclk)\n  begin\n    if(s_axis_tvalid)\n    begin\n      int_comp_reg <= {int_comp_reg[0], int_comp_wire};\n    end\n  end\n\n  assign s_axis_tready = 1'b1;\n\n  assign trg_flag = s_axis_tvalid & (pol_data ^ int_comp_reg[0]) & (pol_data ^ ~int_comp_reg[1]);\n\nendmodule"}
{"task_id": 1407, "completion": "wire [2*N-1:0] o_large;\n  assign o = o_large[N-1:0];\n\n  MULT \n  #(\n    .N(N), \n    .M(N/CC)\n  ) u_MULT ( \n    .A(g_input),\n    .B(e_input),\n    .O(o_large)\n  );  \n\nendmodule"}
{"task_id": 1390, "completion": "localparam NUM_IBUFS\t= 32;\n    localparam NUM_MCELLS\t= 32;\n    localparam BITS_PER_ROW\t= 8;\n    reg[BITS_PER_ROW-1:0] row_config[39:0];\n    integer i;\n    always @(*) begin\n        for(i=0; i<40; i=i+1)\n            row_config[i] <= config_bits[i*BITS_PER_ROW +: BITS_PER_ROW];\n    end\n    wire[65:0] zbus =\n    {\n        macrocell_in,\n        ibuf_in[31:16],\n        dedicated_in,\n        ibuf_in[15:0]\n    };\n    wire[5:0] zia_row_inputs[39:0];\n    assign zia_row_inputs[0] = {zbus[58], zbus[46], zbus[34], zbus[22], zbus[10], zbus[0]};\n    assign zia_row_inputs[1] = {zbus[61], zbus[48], zbus[41], zbus[23], zbus[11], zbus[1]};\n    assign zia_row_inputs[2] = {zbus[60], zbus[53], zbus[35], zbus[30], zbus[12], zbus[2]};\n    assign zia_row_inputs[3] = {zbus[55], zbus[47], zbus[42], zbus[26], zbus[13], zbus[3]};\n    assign zia_row_inputs[4] = {zbus[59], zbus[44], zbus[38], zbus[28], zbus[14], zbus[4]};\n    assign zia_row_inputs[5] = {zbus[56], zbus[50], zbus[40], zbus[31], zbus[15], zbus[5]};\n    assign zia_row_inputs[6] = {zbus[62], zbus[52], zbus[33], zbus[21], zbus[16], zbus[6]};\n    assign zia_row_inputs[7] = {zbus[64], zbus[45], zbus[32], zbus[27], zbus[17], zbus[7]};\n    assign zia_row_inputs[8] = {zbus[57], zbus[43], zbus[39], zbus[25], zbus[18], zbus[8]};\n    assign zia_row_inputs[9] = {zbus[54], zbus[51], zbus[37], zbus[24], zbus[19], zbus[9]};\n    assign zia_row_inputs[10] = {zbus[63], zbus[49], zbus[36], zbus[29], zbus[20], zbus[7]};\n    assign zia_row_inputs[11] = {zbus[59], zbus[47], zbus[35], zbus[23], zbus[11], zbus[0]};\n    assign zia_row_inputs[12] = {zbus[64], zbus[50], zbus[37], zbus[30], zbus[12], zbus[1]};\n    assign zia_row_inputs[13] = {zbus[62], zbus[49], zbus[42], zbus[24], zbus[19], zbus[2]};\n    assign zia_row_inputs[14] = {zbus[61], zbus[44], zbus[36], zbus[31], zbus[15], zbus[3]};\n    assign zia_row_inputs[15] = {zbus[56], zbus[48], zbus[33], zbus[27], zbus[17], zbus[4]};\n    assign zia_row_inputs[16] = {zbus[60], zbus[45], zbus[39], zbus[29], zbus[20], zbus[5]};\n    assign zia_row_inputs[17] = {zbus[57], zbus[51], zbus[41], zbus[22], zbus[10], zbus[6]};\n    assign zia_row_inputs[18] = {zbus[63], zbus[53], zbus[34], zbus[21], zbus[16], zbus[7]};\n    assign zia_row_inputs[19] = {zbus[55], zbus[46], zbus[32], zbus[28], zbus[14], zbus[8]};\n    assign zia_row_inputs[20] = {zbus[58], zbus[43], zbus[40], zbus[26], zbus[13], zbus[9]};\n    assign zia_row_inputs[21] = {zbus[54], zbus[52], zbus[38], zbus[25], zbus[18], zbus[8]};\n    assign zia_row_inputs[22] = {zbus[60], zbus[48], zbus[36], zbus[24], zbus[12], zbus[0]};\n    assign zia_row_inputs[23] = {zbus[54], zbus[53], zbus[39], zbus[26], zbus[19], zbus[1]};\n    assign zia_row_inputs[24] = {zbus[55], zbus[51], zbus[38], zbus[31], zbus[13], zbus[2]};\n    assign zia_row_inputs[25] = {zbus[63], zbus[50], zbus[33], zbus[25], zbus[20], zbus[3]};\n    assign zia_row_inputs[26] = {zbus[62], zbus[45], zbus[37], zbus[22], zbus[16], zbus[4]};\n    assign zia_row_inputs[27] = {zbus[57], zbus[49], zbus[34], zbus[28], zbus[18], zbus[5]};\n    assign zia_row_inputs[28] = {zbus[61], zbus[46], zbus[40], zbus[30], zbus[11], zbus[6]};\n    assign zia_row_inputs[29] = {zbus[58], zbus[52], zbus[42], zbus[23], zbus[10], zbus[7]};\n    assign zia_row_inputs[30] = {zbus[64], zbus[44], zbus[35], zbus[21], zbus[17], zbus[8]};\n    assign zia_row_inputs[31] = {zbus[56], zbus[47], zbus[32], zbus[29], zbus[15], zbus[9]};\n    assign zia_row_inputs[32] = {zbus[59], zbus[43], zbus[41], zbus[27], zbus[14], zbus[9]};\n    assign zia_row_inputs[33] = {zbus[61], zbus[49], zbus[37], zbus[25], zbus[13], zbus[0]};\n    assign zia_row_inputs[34] = {zbus[60], zbus[43], zbus[42], zbus[28], zbus[15], zbus[1]};\n    assign zia_row_inputs[35] = {zbus[54], zbus[44], zbus[40], zbus[27], zbus[20], zbus[2]};\n    assign zia_row_inputs[36] = {zbus[56], zbus[52], zbus[39], zbus[22], zbus[14], zbus[3]};\n    assign zia_row_inputs[37] = {zbus[64], zbus[51], zbus[34], zbus[26], zbus[11], zbus[4]};\n    assign zia_row_inputs[38] = {zbus[63], zbus[46], zbus[38], zbus[23], zbus[17], zbus[5]};\n    assign zia_row_inputs[39] = {zbus[58], zbus[50], zbus[35], zbus[29], zbus[19], zbus[6]};\n    always @(*) begin\n        for(i=0; i<40; i=i+1) begin\n            if(row_config[i][7])\n                zia_out[i] <= 1'b1;\n            else if(!row_config[i][6])\n                zia_out[i] <= 1'b0;\n            else if(!row_config[i][5])\n                zia_out[i] <= zia_row_inputs[i][5];\n            else if(!row_config[i][4])\n                zia_out[i] <= zia_row_inputs[i][4];\n            else if(!row_config[i][3])\n                zia_out[i] <= zia_row_inputs[i][3];\n            else if(!row_config[i][2])\n                zia_out[i] <= zia_row_inputs[i][2];\n            else if(!row_config[i][1])\n                zia_out[i] <= zia_row_inputs[i][1];\n            else if(!row_config[i][0])\n                zia_out[i] <= zia_row_inputs[i][0];\n            else\n                zia_out[i] <= 0;\n        end\n    end\nendmodule"}
{"task_id": 1404, "completion": "localparam [1:0]init_state  = 2'b00,start = 2'b01,data  = 2'b10,stop  = 2'b11;\n   \n   reg [1:0] state, state_next;\n   reg [3:0] s, s_next;\n   reg [2:0] n, n_next;\n   reg [7:0] b, b_next;\n   reg tx_reg, tx_next;\n   \n   always @(posedge clk)\n      if (reset)\n         begin\n            state <= init_state;\n            s <= 0;\n            n <= 0;\n            b <= 0;\n            tx_reg <= 1'b1;\n         end\n      else\n         begin\n            state <= state_next;\n            s <= s_next;\n            n <= n_next;\n            b <= b_next;\n            tx_reg <= tx_next;\n         end\n   \n   always @*\n   begin\n      state_next = state;\n      tx_done_tck = 1'b0;\n      s_next = s;\n      n_next = n;\n      b_next = b;\n      tx_next = tx_reg ;\n      if(state==init_state)\n            begin\n               tx_next = 1'b1;\n               if (tx_start)\n                  begin\n                     state_next = start;\n                     s_next = 0;\n                     b_next = din;\n                  end\n            end\n        else if(state==start)\n            begin\n               tx_next = 1'b0;\n               if (s_tck)\n                  if (s==15)\n                     begin\n                        state_next = data;\n                        s_next = 0;\n                        n_next = 0;\n                     end\n                  else\n                     s_next = s + 1;\n            end\n         else if(state==data)\n            begin\n               tx_next = b[0];\n               if (s_tck)\n                  if (s==15)\n                     begin\n                        s_next = 0;\n                        b_next = b >> 1;\n                        if (n==(DBIT-1))\n                           state_next = stop ;\n                        else\n                           n_next = n + 1;\n                     end\n                  else\n                     s_next = s + 1;\n            end\n         else if(state==stop)\n            begin\n               tx_next = 1'b1;\n               if (s_tck)\n                  if (s==(SB_tck-1))\n                     begin\n                        state_next = init_state;\n                        tx_done_tck = 1'b1;\n                     end\n                  else\n                     s_next = s + 1;\n            end\n   end\n   \n   assign tx = tx_reg;\n\nendmodule"}
{"task_id": 1409, "completion": "reg rd_en_r;  wire full;  wire empty;  wire wr_en;  reg mcb_rd_fifo_port_almost_full;  reg [6:0] buf_avail_r;  reg [6:0] rd_data_received_counts;  reg [6:0] rd_data_counts_asked;  reg dfifo_has_enough_room;  reg [1:0] wait_cnt;  reg wait_done;  assign rd_mdata_en = rd_en_r;  generate if (FAMILY == \"SPARTAN6\") begin: gen_sp6_cmd_rdy always @ (posedge clk_i) cmd_rdy_o <= #TCQ !full  & dfifo_has_enough_room; end else begin: gen_v6_cmd_rdy always @ (posedge clk_i) cmd_rdy_o <= #TCQ !full & wait_done &  dfifo_has_enough_room; end endgenerate always @ (posedge clk_i) begin if (rst_i) wait_cnt <= #TCQ 'b0; else if (cmd_rdy_o && cmd_valid_i) wait_cnt <= #TCQ 2'b10; else if (wait_cnt > 0) wait_cnt <= #TCQ wait_cnt - 1'b1; end always @(posedge clk_i) begin if (rst_i) wait_done <= #TCQ 1'b1; else if (cmd_rdy_o && cmd_valid_i) wait_done <= #TCQ 1'b0; else if (wait_cnt == 0) wait_done <= #TCQ 1'b1; else wait_done <= #TCQ 1'b0; end reg dfifo_has_enough_room_d1; always @ (posedge clk_i) begin dfifo_has_enough_room <=  #TCQ (buf_avail_r >= 32 ) ? 1'b1: 1'b0; dfifo_has_enough_room_d1 <= #TCQ dfifo_has_enough_room; end assign wr_en    = cmd_valid_i & !full  & wait_done; always @ (posedge clk_i) begin if (rst_i) begin rd_data_counts_asked <= #TCQ 'b0; end else if (cmd_en_i && cmd_sent[0] == 1 && ~memc_cmd_full_i) begin if (FAMILY == \"SPARTAN6\") rd_data_counts_asked <= #TCQ rd_data_counts_asked + (bl_sent + 7'b0000001); else if (nCK_PER_CLK == 4 || (nCK_PER_CLK == 2 && (MEM_BURST_LEN == 4 || MEM_BURST_LEN == 2 ))) rd_data_counts_asked <= #TCQ rd_data_counts_asked + 1'b1; else if (nCK_PER_CLK == 2 && MEM_BURST_LEN == 8) rd_data_counts_asked <= #TCQ rd_data_counts_asked + 2'b10; end end always @ (posedge clk_i) begin if (rst_i) begin rd_data_received_counts <= #TCQ 'b0; end else if (data_valid_i) begin rd_data_received_counts <= #TCQ rd_data_received_counts + 1'b1; end end always @ (posedge clk_i) if (rd_data_received_counts[6] == rd_data_counts_asked[6]) buf_avail_r <= #TCQ (rd_data_received_counts[5:0] - rd_data_counts_asked[5:0] + 7'd64 ); else buf_avail_r <= #TCQ  ( rd_data_received_counts[5:0] - rd_data_counts_asked[5:0] ); always @ (posedge clk_i) begin rd_en_r <= #TCQ cmd_start_i; end assign gen_valid_o = !empty; mig_7series_v2_0_afifo #( .TCQ (TCQ), .DSIZE (BL_WIDTH+ADDR_WIDTH), .FIFO_DEPTH (16), .ASIZE (4), .SYNC (1) ) rd_fifo ( .wr_clk (clk_i), .rst (rst_i), .wr_en (wr_en), .wr_data ({bl_i,addr_i}), .rd_en (rd_en_r), .rd_clk (clk_i), .rd_data ({gen_bl_o,gen_addr_o}), .full (full), .empty (empty), .almost_full ()); endmodule"}
{"task_id": 1415, "completion": "reg [31:0] i_data0_reg;\n\twire [30:0] o_data0_from_mult;\n\n\talways @(posedge clk) begin\n\t\ti_data0_reg <= i_data0;\n\t\to_data0 <= o_data0_from_mult;\n\tend\n\n\tmultiplier_block mult_blk(\n\t\t.i_data0(i_data0_reg),\n\t\t.o_data0(o_data0_from_mult)\n\t);\n\nendmodule"}
{"task_id": 1386, "completion": "parameter TCQ  = 1;\n    generate\n    if (PIPE_PIPELINE_STAGES == 0) begin : pipe_stages_0\n        assign pipe_tx_rcvr_det_o = pipe_tx_rcvr_det_i;\n        assign pipe_tx_reset_o  = pipe_tx_reset_i;\n        assign pipe_tx_rate_o = pipe_tx_rate_i;\n        assign pipe_tx_deemph_o = pipe_tx_deemph_i;\n        assign pipe_tx_margin_o = pipe_tx_margin_i;\n        assign pipe_tx_swing_o = pipe_tx_swing_i;\n    end else if (PIPE_PIPELINE_STAGES == 1) begin : pipe_stages_1\n    reg                pipe_tx_rcvr_det_q       ;\n    reg                pipe_tx_reset_q          ;\n    reg                pipe_tx_rate_q           ;\n    reg                pipe_tx_deemph_q         ;\n    reg [2:0]          pipe_tx_margin_q         ;\n    reg                pipe_tx_swing_q          ;\n        always @(posedge pipe_clk) begin\n        if (rst_n)\n        begin\n            pipe_tx_rcvr_det_q <= #TCQ 0;\n            pipe_tx_reset_q  <= #TCQ 1'b1;\n            pipe_tx_rate_q <= #TCQ 0;\n            pipe_tx_deemph_q <= #TCQ 1'b1;\n            pipe_tx_margin_q <= #TCQ 0;\n            pipe_tx_swing_q <= #TCQ 0;\n        end\n        else\n        begin\n            pipe_tx_rcvr_det_q <= #TCQ pipe_tx_rcvr_det_i;\n            pipe_tx_reset_q  <= #TCQ pipe_tx_reset_i;\n            pipe_tx_rate_q <= #TCQ pipe_tx_rate_i;\n            pipe_tx_deemph_q <= #TCQ pipe_tx_deemph_i;\n            pipe_tx_margin_q <= #TCQ pipe_tx_margin_i;\n            pipe_tx_swing_q <= #TCQ pipe_tx_swing_i;\n          end\n        end\n        assign pipe_tx_rcvr_det_o = pipe_tx_rcvr_det_q;\n        assign pipe_tx_reset_o  = pipe_tx_reset_q;\n        assign pipe_tx_rate_o = pipe_tx_rate_q;\n        assign pipe_tx_deemph_o = pipe_tx_deemph_q;\n        assign pipe_tx_margin_o = pipe_tx_margin_q;\n        assign pipe_tx_swing_o = pipe_tx_swing_q;\n    end else if (PIPE_PIPELINE_STAGES == 2) begin : pipe_stages_2\n    reg                pipe_tx_rcvr_det_q       ;\n    reg                pipe_tx_reset_q          ;\n    reg                pipe_tx_rate_q           ;\n    reg                pipe_tx_deemph_q         ;\n    reg [2:0]          pipe_tx_margin_q         ;\n    reg                pipe_tx_swing_q          ;\n    reg                pipe_tx_rcvr_det_qq      ;\n    reg                pipe_tx_reset_qq         ;\n    reg                pipe_tx_rate_qq          ;\n    reg                pipe_tx_deemph_qq        ;\n    reg [2:0]          pipe_tx_margin_qq        ;\n    reg                pipe_tx_swing_qq         ;\n        always @(posedge pipe_clk) begin\n        if (rst_n)\n        begin\n            pipe_tx_rcvr_det_q <= #TCQ 0;\n            pipe_tx_reset_q  <= #TCQ 1'b1;\n            pipe_tx_rate_q <= #TCQ 0;\n            pipe_tx_deemph_q <= #TCQ 1'b1;\n            pipe_tx_margin_q <= #TCQ 0;\n            pipe_tx_swing_q <= #TCQ 0;\n            pipe_tx_rcvr_det_qq <= #TCQ 0;\n            pipe_tx_reset_qq  <= #TCQ 1'b1;\n            pipe_tx_rate_qq <= #TCQ 0;\n            pipe_tx_deemph_qq <= #TCQ 1'b1;\n            pipe_tx_margin_qq <= #TCQ 0;\n            pipe_tx_swing_qq <= #TCQ 0;\n        end\n        else\n        begin\n            pipe_tx_rcvr_det_q <= #TCQ pipe_tx_rcvr_det_i;\n            pipe_tx_reset_q  <= #TCQ pipe_tx_reset_i;\n            pipe_tx_rate_q <= #TCQ pipe_tx_rate_i;\n            pipe_tx_deemph_q <= #TCQ pipe_tx_deemph_i;\n            pipe_tx_margin_q <= #TCQ pipe_tx_margin_i;\n            pipe_tx_swing_q <= #TCQ pipe_tx_swing_i;\n            pipe_tx_rcvr_det_qq <= #TCQ pipe_tx_rcvr_det_q;\n            pipe_tx_reset_qq  <= #TCQ pipe_tx_reset_q;\n            pipe_tx_rate_qq <= #TCQ pipe_tx_rate_q;\n            pipe_tx_deemph_qq <= #TCQ pipe_tx_deemph_q;\n            pipe_tx_margin_qq <= #TCQ pipe_tx_margin_q;\n            pipe_tx_swing_qq <= #TCQ pipe_tx_swing_q;\n          end\n        end\n        assign pipe_tx_rcvr_det_o = pipe_tx_rcvr_det_qq;\n        assign pipe_tx_reset_o  = pipe_tx_reset_qq;\n        assign pipe_tx_rate_o = pipe_tx_rate_qq;\n        assign pipe_tx_deemph_o = pipe_tx_deemph_qq;\n        assign pipe_tx_margin_o = pipe_tx_margin_qq;\n        assign pipe_tx_swing_o = pipe_tx_swing_qq;\n    end\n    endgenerate\nendmodule"}
{"task_id": 1405, "completion": "`ifdef ENABLE_ADC\n      ///////// ADC 3.3 V /////////\n      input              ADC_CLK_10,\n`endif\n        \n`ifdef ENABLE_AUDIO\n      ///////// AUDIO 2.5 V /////////\n      inout              AUDIO_BCLK,\n      output             AUDIO_DIN_MFP1,\n      input              AUDIO_DOUT_MFP2,\n      inout              AUDIO_GPIO_MFP5,\n      output             AUDIO_MCLK,\n      input              AUDIO_MISO_MFP4,\n      inout              AUDIO_RESET_n,\n      output             AUDIO_SCLK_MFP3,\n      output             AUDIO_SCL_SS_n,\n      inout              AUDIO_SDA_MOSI,\n      output             AUDIO_SPI_SELECT,\n      inout              AUDIO_WCLK,\n`endif\n        \n`ifdef ENABLE_CAMERA\n      // 2.5 V\n      output             CAMERA_I2C_SCL,\n      inout              CAMERA_I2C_SDA,\n      // 3.3 V LVTTL\n      output             CAMERA_PWDN_n,\n`endif\n        \n`ifdef ENABLE_DAC\n      ///////// DAC 3.3 V LVTTL /////////\n      inout              DAC_DATA,\n      output             DAC_SCLK,\n      output             DAC_SYNC_n,\n`endif\n        \n`ifdef ENABLE_DDR3\n      // \"SSTL-15 CLASS I\"\n      output      [14:0] DDR3_A,\n      output      [2:0]  DDR3_BA,\n      output             DDR3_CKE, \n      output             DDR3_CAS_n,\n      output             DDR3_CS_n,\n      output      [2:0]  DDR3_DM,\n      inout       [23:0] DDR3_DQ,\n      output             DDR3_ODT,\n      output             DDR3_RAS_n,\n      output             DDR3_RESET_n,\n      output             DDR3_WE_n,\n      // \"DIFFERENTIAL 1.5-V SSTL CLASS I\"\n      inout              DDR3_CK_n,\n      inout              DDR3_CK_p,\n      inout       [2:0]  DDR3_DQS_n,\n      inout       [2:0]  DDR3_DQS_p,\n`endif \n\n`ifdef ENABLE_FLASH\n      // \"3.3-V LVTTL\"\n      inout       [3:0]  FLASH_DATA,\n      output             FLASH_DCLK,\n      output             FLASH_NCSO,\n      output             FLASH_RESET_n,\n`endif\n       \n      `ifdef ENABLE_GPIO\n      // \"3.3-V LVTTL\"\n      inout       [7:0]  GPIO,\n      `endif\n\t \n`ifdef ENABLE_GSENSOR\n      // 2.5 V\n      output             GSENSOR_CS_n,\n      input       [2:1]  GSENSOR_INT,\n      inout              GSENSOR_SCLK,\n      inout              GSENSOR_SDI,\n      inout              GSENSOR_SDO,\n`endif\n        \n`ifdef ENABLE_HDMI\n      // \"3.3-V LVTTL\"\n      input              HDMI_AP,\n      inout              HDMI_I2C_SCL,\n      inout              HDMI_I2C_SDA,\n      inout              HDMI_LRCLK,\n      inout              HDMI_MCLK,\n      input              HDMI_RX_CLK,\n      input       [23:0] HDMI_RX_D,\n      input              HDMI_RX_DE,\n      inout              HDMI_RX_HS,\n      input              HDMI_RX_INT1,\n      inout              HDMI_RX_RESET_n,\n      input              HDMI_RX_VS,\n      inout              HDMI_SCLK,\n`endif\n        \n`ifdef ENABLE_HEX0\n      // \"3.3-V LVTTL\"\n      output      [6:0]  HEX0,\n`endif\n\n`ifdef ENABLE_HEX1\n      // \"3.3-V LVTTL\"\n      output      [6:0]  HEX1,\n`endif\n        \n`ifdef ENABLE_KEY\n      // \"1.5 V SCHMITT TRIGGER\" \n      input       [4:0]  KEY,\n`endif\n        \n`ifdef ENABLE_LEDR\n      // \"3.3-V LVTTL\"\n      output      [9:0]  LEDR,\n`endif\n        \n`ifdef ENABLE_LSENSOR\n      // \"3.3-V LVTTL\"\n      inout              LSENSOR_INT,\n      output             LSENSOR_SCL,\n      inout              LSENSOR_SDA,\n`endif\n        \n`ifdef ENABLE_MAX10\n      //  \"3.3-V LVTTL\"\n      input              MAX10_CLK1_50,\n      input              MAX10_CLK2_50,\n      input              MAX10_CLK3_50,\n`endif\n        \n`ifdef ENABLE_MIPI\n      // \"3.3-V LVTTL\"\n      output             MIPI_CS_n,\n      output             MIPI_I2C_SCL,\n      inout              MIPI_I2C_SDA,\n      input              MIPI_PIXEL_CLK,\n      input       [23:0] MIPI_PIXEL_D,\n      input              MIPI_PIXEL_HS,\n      input              MIPI_PIXEL_VS,\n      output             MIPI_REFCLK,\n      output             MIPI_RESET_n,\n`endif\n\n`ifdef ENABLE_MTL2\n      // \"3.3-V LVTTL\"\n      output      [7:0]  MTL2_B,\n      inout              MTL2_BL_ON_n,\n      output             MTL2_DCLK,\n      output      [7:0]  MTL2_G,\n      output             MTL2_HSD,\n      output             MTL2_I2C_SCL,\n      inout              MTL2_I2C_SDA,\n      input              MTL2_INT,\n      output      [7:0]  MTL2_R,\n      output             MTL2_VSD,\n`endif\n        \n`ifdef ENABLE_NET\n      // 2.5 V \n      output             NET_GTX_CLK,\n      input              NET_INT_n,\n      input              NET_LINK100,\n      output             NET_MDC,\n      inout              NET_MDIO,\n      output             NET_RST_N,\n      input              NET_RX_CLK,\n      input              NET_RX_COL,\n      input              NET_RX_CRS,\n      input       [3:0]  NET_RX_D,\n      input              NET_RX_DV,\n      input              NET_RX_ER,\n      input              NET_TX_CLK,\n      output      [3:0]  NET_TX_D,\n      output             NET_TX_EN,\n      output             NET_TX_ER,\n`endif\n        \n`ifdef ENABLE_PM\n      //  \"3.3-V LVTTL\"\n      output             PM_I2C_SCL,\n      inout              PM_I2C_SDA,\n`endif\n\n`ifdef ENABLE_PS2\n      // \"3.3-V LVTTL\"\n      inout              PS2_CLK,\n      inout              PS2_CLK2,\n      inout              PS2_DAT,\n      inout              PS2_DAT2,\n`endif\n\n`ifdef ENABLE_RH\n      // \"3.3-V LVTTL\"\n      input              RH_TEMP_DRDY_n,\n      output             RH_TEMP_I2C_SCL,\n      inout              RH_TEMP_I2C_SDA,\n`endif\n        \n`ifdef ENABLE_SD\n      // 2.5 V  \n      output             SD_CLK,\n      inout              SD_CMD,\n      inout       [3:0]  SD_DATA,\n`endif\n\n`ifdef ENABLE_SW\n      // 1.5 V \n      input       [9:0]  SW,\n`endif\n        \n`ifdef ENABLE_UART\n      // 2.5 V \n      output             UART_RESET_n,\n      input              UART_RX,\n      output             UART_TX,\n`endif\n\n      ///////// FPGA /////////\n      input              FPGA_RESET_n\n\n);\n\n  // wires & inputs\n    wire          clk;\n    wire          clkIn     =  MAX10_CLK1_50;\n    wire          rst_n     =  KEY[0];\n    wire          clkEnable =  SW [9] | ~KEY[1];\n    wire [  3:0 ] clkDevide =  SW [8:5];\n    wire [  4:0 ] regAddr   =  SW [4:0];\n    wire [ 31:0 ] regData;\n\n    //cores\n    sm_top sm_top\n    (\n        .clkIn      ( clkIn     ),\n        .rst_n      ( rst_n     ),\n        .clkDevide  ( clkDevide ),\n        .clkEnable  ( clkEnable ),\n        .clk        ( clk       ),\n        .regAddr    ( regAddr   ),\n        .regData    ( regData   )\n    );\n\n    //outputs\n    assign LEDR[0]   = clk;\n    assign LEDR[9:1] = regData[8:0];\n\n    wire [ 31:0 ] h7segment = regData;\n\n    sm_hex_display digit_1 ( h7segment [ 7: 4] , HEX1 [6:0] );\n    sm_hex_display digit_0 ( h7segment [ 3: 0] , HEX0 [6:0] );\n\nendmodule"}
{"task_id": 1413, "completion": "reg [31:0] mem = 32'b0;\n\n`ifdef cyclonev\nspecify\n    $setup(A1ADDR, posedge CLK1, 86);\n    $setup(A1DATA, posedge CLK1, 86);\n    $setup(A1EN, posedge CLK1, 86);\n\n    (B1ADDR[0] => B1DATA) = 487;\n    (B1ADDR[1] => B1DATA) = 475;\n    (B1ADDR[2] => B1DATA) = 382;\n    (B1ADDR[3] => B1DATA) = 284;\n    (B1ADDR[4] => B1DATA) = 96;\nendspecify\n`endif\n`ifdef arriav\nspecify\n    $setup(A1ADDR, posedge CLK1, 62);\n    $setup(A1DATA, posedge CLK1, 62);\n    $setup(A1EN, posedge CLK1, 62);\n\n    (B1ADDR[0] => B1DATA) = 370;\n    (B1ADDR[1] => B1DATA) = 292;\n    (B1ADDR[2] => B1DATA) = 218;\n    (B1ADDR[3] => B1DATA) = 74;\n    (B1ADDR[4] => B1DATA) = 177;\nendspecify\n`endif\n`ifdef cyclone10gx\nspecify\n    $setup(A1ADDR, posedge CLK1, 86);\n    $setup(A1DATA, posedge CLK1, 86);\n    $setup(A1EN, posedge CLK1, 86);\n\n    (B1ADDR[0] => B1DATA) = 487;\n    (B1ADDR[1] => B1DATA) = 475;\n    (B1ADDR[2] => B1DATA) = 382;\n    (B1ADDR[3] => B1DATA) = 284;\n    (B1ADDR[4] => B1DATA) = 96;\nendspecify\n`endif\n\nalways @(posedge CLK1)\n    if (A1EN) mem[A1ADDR] <= A1DATA;\n\nassign B1DATA = mem[B1ADDR];\n\nendmodule"}
{"task_id": 1397, "completion": "/*AUTOINPUT*/\n  input [RANK_BM_BV_WIDTH-1:0] act_this_rank_r;\n  input                 app_periodic_rd_req;\n  input                 app_ref_req;\n  input                 app_zq_req;\n  input                 app_sr_req;\n  input                 clk;\n  input                 col_rd_wr;\n  input                 init_calib_complete;\n  input                 insert_maint_r1;\n  input                 maint_wip_r;\n  input                 periodic_rd_ack_r;\n  input [(RANKS*nBANK_MACHS)-1:0] rank_busy_r;\n  input [RANK_BM_BV_WIDTH-1:0] rd_this_rank_r;\n  input                 rst;\n  input [nBANK_MACHS-1:0] sending_col;\n  input [nBANK_MACHS-1:0] sending_row;\n  input [7:0]           slot_0_present;\n  input [7:0]           slot_1_present;\n  input [RANK_BM_BV_WIDTH-1:0] wr_this_rank_r;\n\n  /*AUTOOUTPUT*/\n  output                maint_req_r;\n  output                periodic_rd_r;\n  output [RANK_WIDTH-1:0] periodic_rd_rank_r;\n\n  /*AUTOWIRE*/\n  wire                  maint_prescaler_tick_r;\n  wire                  refresh_tick;\n\n  output [RANKS-1:0] inhbt_act_faw_r;\n  output [RANKS-1:0] inhbt_rd;\n  output [RANKS-1:0] inhbt_wr;\n  output [RANK_WIDTH-1:0] maint_rank_r;\n  output maint_zq_r;\n  output maint_sre_r;\n  output maint_srx_r;\n  output app_sr_active;\n  output app_ref_ack;\n  output app_zq_ack;\n  output maint_ref_zq_wip;\n\n  wire [RANKS-1:0] refresh_request;\n  wire [RANKS-1:0] periodic_rd_request;\n  wire [RANKS-1:0] clear_periodic_rd_request;\n\n  genvar ID;\n  generate\n    for (ID=0; ID<RANKS; ID=ID+1) begin:rank_cntrl\n      mig_7series_v1_8_rank_cntrl #\n        (/*AUTOINSTPARAM*/\n         .BURST_MODE                    (BURST_MODE),\n         .ID                            (ID),\n         .nBANK_MACHS                   (nBANK_MACHS),\n         .nCK_PER_CLK                   (nCK_PER_CLK),\n         .CL                            (CL),\n         .CWL                           (CWL),\n         .DQRD2DQWR_DLY                 (DQRD2DQWR_DLY),\n         .nFAW                          (nFAW),\n         .nREFRESH_BANK                 (nREFRESH_BANK),\n         .nRRD                          (nRRD),\n         .nWTR                          (nWTR),\n         .PERIODIC_RD_TIMER_DIV         (PERIODIC_RD_TIMER_DIV),\n         .RANK_BM_BV_WIDTH              (RANK_BM_BV_WIDTH),\n         .RANK_WIDTH                    (RANK_WIDTH),\n         .RANKS                         (RANKS),\n         .REFRESH_TIMER_DIV             (REFRESH_TIMER_DIV))\n        rank_cntrl0 \n          (.clear_periodic_rd_request   (clear_periodic_rd_request[ID]),\n           .inhbt_act_faw_r             (inhbt_act_faw_r[ID]),\n           .inhbt_rd                    (inhbt_rd[ID]),\n           .inhbt_wr                    (inhbt_wr[ID]),\n           .periodic_rd_request         (periodic_rd_request[ID]),\n           .refresh_request             (refresh_request[ID]),\n           /*AUTOINST*/\n           .clk                         (clk),\n           .rst                         (rst),\n           .col_rd_wr                   (col_rd_wr),\n           .sending_row                 (sending_row[nBANK_MACHS-1:0]),\n           .act_this_rank_r             (act_this_rank_r[RANK_BM_BV_WIDTH-1:0]),\n           .sending_col                 (sending_col[nBANK_MACHS-1:0]),\n           .wr_this_rank_r              (wr_this_rank_r[RANK_BM_BV_WIDTH-1:0]),\n           .app_ref_req                 (app_ref_req),\n           .init_calib_complete         (init_calib_complete),\n           .rank_busy_r                 (rank_busy_r[(RANKS*nBANK_MACHS)-1:0]),\n           .refresh_tick                (refresh_tick),\n           .insert_maint_r1             (insert_maint_r1),\n           .maint_zq_r                  (maint_zq_r),\n           .maint_sre_r                 (maint_sre_r),\n           .maint_srx_r                 (maint_srx_r),\n           .maint_rank_r                (maint_rank_r[RANK_WIDTH-1:0]),\n           .app_periodic_rd_req         (app_periodic_rd_req),\n           .maint_prescaler_tick_r      (maint_prescaler_tick_r),\n           .rd_this_rank_r              (rd_this_rank_r[RANK_BM_BV_WIDTH-1:0]));\n    end\n  endgenerate\n\n  mig_7series_v1_8_rank_common #\n    (/*AUTOINSTPARAM*/\n     .DRAM_TYPE                         (DRAM_TYPE),\n     .MAINT_PRESCALER_DIV               (MAINT_PRESCALER_DIV),\n     .nBANK_MACHS                       (nBANK_MACHS),\n     .nCKESR                            (nCKESR),\n     .nCK_PER_CLK                       (nCK_PER_CLK),\n     .PERIODIC_RD_TIMER_DIV             (PERIODIC_RD_TIMER_DIV),\n     .RANK_WIDTH                        (RANK_WIDTH),\n     .RANKS                             (RANKS),\n     .REFRESH_TIMER_DIV                 (REFRESH_TIMER_DIV),\n     .ZQ_TIMER_DIV                      (ZQ_TIMER_DIV))\n    rank_common0\n    (.clear_periodic_rd_request         (clear_periodic_rd_request[RANKS-1:0]),\n     .maint_prescaler_tick_r            (maint_prescaler_tick_r),\n     .refresh_tick                      (refresh_tick),\n     .maint_zq_r                        (maint_zq_r),\n     .maint_sre_r                       (maint_sre_r),\n     .maint_srx_r                       (maint_srx_r),\n     .maint_req_r                       (maint_req_r),\n     .maint_rank_r                      (maint_rank_r[RANK_WIDTH-1:0]),\n     .maint_ref_zq_wip                  (maint_ref_zq_wip),\n     .periodic_rd_r                     (periodic_rd_r),\n     .periodic_rd_rank_r                (periodic_rd_rank_r[RANK_WIDTH-1:0]),\n     .clk                               (clk),\n     .rst                               (rst),\n     .init_calib_complete               (init_calib_complete),\n     .app_ref_req                       (app_ref_req),\n     .app_ref_ack                       (app_ref_ack),\n     .app_zq_req                        (app_zq_req),\n     .app_zq_ack                        (app_zq_ack),\n     .app_sr_req                        (app_sr_req),\n     .app_sr_active                     (app_sr_active),\n     .insert_maint_r1                   (insert_maint_r1),\n     .refresh_request                   (refresh_request[RANKS-1:0]),\n     .maint_wip_r                       (maint_wip_r),\n     .slot_0_present                    (slot_0_present[7:0]),\n     .slot_1_present                    (slot_1_present[7:0]),\n     .periodic_rd_request               (periodic_rd_request[RANKS-1:0]),\n     .periodic_rd_ack_r                 (periodic_rd_ack_r));\n\nendmodule"}
{"task_id": 1406, "completion": "input rst, clk, cpu_stall, int;\n    input pc_j;\n    input pc_b;\n    input [31:0] b_addr;\n    input [31:0] j_addr;\n    input stall;\n    output reg [31:0] p_pc;\n    output [31:0] imem_addr;\n    input [31:0] iin;\n    output reg [31:0] p_inst;\n    output int_ack, int_flush;\n    input [31:0] int_pc;\n\n    reg [31:0] pc;\n    wire [31:0] next_pc;\n\n    wire flush = pc_b | pc_j;\n\n    reg [1:0] int_state = 2'b00;\n    wire cycle_wait = pc - int_pc != 8;\n    wire [1:0] next_int_state = \n        int_state == 2'b00 && int && cycle_wait ? 2'b01 : \n        int_state == 2'b00 && int && !cycle_wait ? 2'b10 : \n        int_state == 2'b01 && !cycle_wait ? 2'b10 : \n        int_state == 2'b10 ? 2'b11 :\n        int_state == 2'b11 ? 2'b00 : int_state;\n    wire [31:0] next_inst = \n        int_state == 2'b10 ? 32'h0380f009 : \n        int_state == 2'b11 ? 32'h00000000 : \n                         iin;\n    assign int_ack = int_state != 2'b00;\n    assign int_flush = next_int_state == 2'b10;\n\n    always @(posedge clk) begin\n        if (!cpu_stall) begin\n            if (rst) begin\n                p_pc <= 0;\n                pc <= 0;\n                p_inst <= 0;\n                int_state <= 0;\n            end else if (stall && !flush && !rst) begin\n                p_pc <= p_pc;\n                pc <= pc;\n                p_inst <= p_inst;\n                int_state <= next_int_state;\n            end else if ((flush || int_flush) && !rst && !stall) begin\n                p_pc <= 0;\n                p_inst <= 0;\n                pc <= next_pc;\n                int_state <= next_int_state;\n            end else begin\n                p_pc <= pc;\n                pc   <= next_pc;\n                p_inst <= next_inst;\n                int_state <= next_int_state;\n            end\n            $display(\"IF: PC: %x INST: %x\", p_pc, p_inst);\n        end\n    end\n\n    assign next_pc =\n        (next_int_state == 2'b10) ? int_pc - 8: \n        (pc_b & next_int_state != 2'b10) ? b_addr :\n        (pc_j & !pc_b & next_int_state != 2'b10) ? j_addr :\n        pc + 4;\n\n    assign imem_addr = pc;\nendmodule"}
{"task_id": 1417, "completion": "wire          clkCpu;\n    wire          clkIn     =  clk;\n    wire          rst_n     =  btnCpuReset;\n    wire          clkEnable =  sw [9] | btnU;\n    wire [  3:0 ] clkDevide =  sw [8:5];\n    wire [  4:0 ] regAddr   =  sw [4:0];\n    wire [ 31:0 ] regData;\n\n    sm_top sm_top\n    (\n        .clkIn      ( clkIn     ),\n        .rst_n      ( rst_n     ),\n        .clkDevide  ( clkDevide ),\n        .clkEnable  ( clkEnable ),\n        .clk        ( clkCpu    ),\n        .regAddr    ( regAddr   ),\n        .regData    ( regData   )\n    );\n\n    assign led[0]    = clkCpu;\n    assign led[15:1] = regData[14:0];\n\n    wire [ 31:0 ] h7segment = regData;\n    wire clkHex;\n\n    sm_clk_divider hex_clk_divider\n    (\n        .clkIn   ( clkIn  ),\n        .rst_n   ( rst_n  ),\n        .devide  ( 4'b1   ),\n        .enable  ( 1'b1   ),\n        .clkOut  ( clkHex )\n    );\n\n    sm_hex_display_8 sm_hex_display_8\n    (\n        .clock          ( clkHex    ),\n        .resetn         ( rst_n     ),\n        .number         ( h7segment ),\n\n        .seven_segments ( seg       ),\n        .dot            ( dp        ),\n        .anodes         ( an        )\n    );\n\n    assign RGB1_Red   = 1'b0; \n    assign RGB1_Green = 1'b0; \n    assign RGB1_Blue  = 1'b0; \n    assign RGB2_Red   = 1'b0; \n    assign RGB2_Green = 1'b0; \n    assign RGB2_Blue  = 1'b0;\n\nendmodule"}
{"task_id": 1412, "completion": "localparam EIOS_DET_IDL = 5'b00001;    localparam EIOS_DET_NO_STR0 = 5'b00010;    localparam EIOS_DET_STR0 = 5'b00100;    localparam EIOS_DET_STR1 = 5'b01000;    localparam EIOS_DET_DONE = 5'b10000;    localparam EIOS_COM = 8'hBC;    localparam EIOS_IDL = 8'h7C;    localparam FTSOS_COM = 8'hBC;    localparam FTSOS_FTS = 8'h3C;    reg [4:0] reg_state_eios_det;    wire [4:0] state_eios_det;    reg reg_eios_detected;    wire eios_detected;    reg reg_symbol_after_eios;    wire symbol_after_eios;    localparam USER_RXVLD_IDL = 4'b0001;    localparam USER_RXVLD_EI = 4'b0010;    localparam USER_RXVLD_EI_DB0 = 4'b0100;    localparam USER_RXVLD_EI_DB1 = 4'b1000;    reg [1:0] gt_rxcharisk_q;    reg [15:0] gt_rxdata_q;    reg gt_rxvalid_q;    reg gt_rxelecidle_q;    reg [2:0] gt_rx_status_q;    reg gt_rx_phy_status_q;    reg gt_rx_is_skp0_q;    reg gt_rx_is_skp1_q;    always @(posedge USER_CLK) begin      if (RESET) begin        reg_eios_detected <= #TCQ 1'b0;        reg_state_eios_det <= #TCQ EIOS_DET_IDL;        reg_symbol_after_eios <= #TCQ 1'b0;        gt_rxcharisk_q <= #TCQ 2'b00;        gt_rxdata_q <= #TCQ 16'h0;        gt_rxvalid_q <= #TCQ 1'b0;        gt_rxelecidle_q <= #TCQ 1'b0;        gt_rx_status_q <= #TCQ 3'b000;        gt_rx_phy_status_q <= #TCQ 1'b0;        gt_rx_is_skp0_q <= #TCQ 1'b0;        gt_rx_is_skp1_q <= #TCQ 1'b0;      end else begin        reg_eios_detected <= #TCQ 1'b0;        reg_symbol_after_eios <= #TCQ 1'b0;        gt_rxcharisk_q <= #TCQ GT_RXCHARISK;        gt_rxelecidle_q <= #TCQ GT_RXELECIDLE;        gt_rxdata_q <= #TCQ GT_RXDATA;        gt_rx_phy_status_q <= #TCQ GT_RX_PHY_STATUS;        if(((reg_state_eios_det == 5'b10000)) && (PLM_IN_L0)) begin          gt_rxvalid_q <= #TCQ 1'b0;        end else if (GT_RXELECIDLE && !gt_rxvalid_q) begin           gt_rxvalid_q <= #TCQ 1'b0;        end else begin         gt_rxvalid_q <= GT_RXVALID;        end        if (gt_rxvalid_q) begin          gt_rx_status_q <= #TCQ GT_RX_STATUS;        end else if (!gt_rxvalid_q && PLM_IN_L0) begin          gt_rx_status_q <= #TCQ 3'b0;        end else begin          gt_rx_status_q <= #TCQ GT_RX_STATUS;        end        if (GT_RXCHARISK[0] && GT_RXDATA[7:0] == FTSOS_FTS)          gt_rx_is_skp0_q <= #TCQ 1'b1;        else          gt_rx_is_skp0_q <= #TCQ 1'b0;        if (GT_RXCHARISK[1] && GT_RXDATA[15:8] == FTSOS_FTS)          gt_rx_is_skp1_q <= #TCQ 1'b1;        else          gt_rx_is_skp1_q <= #TCQ 1'b0;        case ( state_eios_det )          EIOS_DET_IDL : begin            if ((gt_rxcharisk_q[0]) && (gt_rxdata_q[7:0] == EIOS_COM) &&                (gt_rxcharisk_q[1]) && (gt_rxdata_q[15:8] == EIOS_IDL)) begin              reg_state_eios_det <= #TCQ EIOS_DET_NO_STR0;              reg_eios_detected <= #TCQ 1'b1;            end else if ((gt_rxcharisk_q[1]) && (gt_rxdata_q[15:8] == EIOS_COM))              reg_state_eios_det <= #TCQ EIOS_DET_STR0;            else              reg_state_eios_det <= #TCQ EIOS_DET_IDL;          end          EIOS_DET_NO_STR0 : begin            if ((gt_rxcharisk_q[0] && (gt_rxdata_q[7:0] == EIOS_IDL)) &&                (gt_rxcharisk_q[1] && (gt_rxdata_q[15:8] == EIOS_IDL))) begin              reg_state_eios_det <= #TCQ EIOS_DET_DONE;              gt_rxvalid_q <= #TCQ 1'b0;            end          else if (gt_rxcharisk_q[0] && (gt_rxdata_q[7:0] == EIOS_IDL)) begin            reg_state_eios_det <= #TCQ EIOS_DET_DONE;            gt_rxvalid_q <= #TCQ 1'b0;          end else            reg_state_eios_det <= #TCQ EIOS_DET_IDL;          end          EIOS_DET_STR0 : begin            if ((gt_rxcharisk_q[0] && (gt_rxdata_q[7:0] == EIOS_IDL)) &&                (gt_rxcharisk_q[1] && (gt_rxdata_q[15:8] == EIOS_IDL))) begin              reg_state_eios_det <= #TCQ EIOS_DET_STR1;              reg_eios_detected <= #TCQ 1'b1;              gt_rxvalid_q <= #TCQ 1'b0;              reg_symbol_after_eios <= #TCQ 1'b1;            end else              reg_state_eios_det <= #TCQ EIOS_DET_IDL;          end          EIOS_DET_STR1 : begin            if ((gt_rxcharisk_q[0]) && (gt_rxdata_q[7:0] == EIOS_IDL))            begin              reg_state_eios_det <= #TCQ EIOS_DET_DONE;              gt_rxvalid_q <= #TCQ 1'b0;            end else              reg_state_eios_det <= #TCQ EIOS_DET_IDL;          end          EIOS_DET_DONE : begin            reg_state_eios_det <= #TCQ EIOS_DET_IDL;          end        endcase      end    end    assign state_eios_det = reg_state_eios_det;    assign eios_detected = reg_eios_detected;    assign symbol_after_eios = reg_symbol_after_eios;    wire rst_l = ~RESET;    assign USER_RXVALID = gt_rxvalid_q;    assign USER_RXCHARISK[0] = gt_rxvalid_q ? gt_rxcharisk_q[0] : 1'b0;    assign USER_RXCHARISK[1] = (gt_rxvalid_q && !symbol_after_eios) ? gt_rxcharisk_q[1] : 1'b0;    assign USER_RXDATA[7:0] = gt_rxdata_q[7:0];    assign USER_RXDATA[15:8] = gt_rxdata_q[15:8];    assign USER_RX_STATUS = gt_rx_status_q;    assign USER_RX_PHY_STATUS = gt_rx_phy_status_q;    assign USER_RXELECIDLE = gt_rxelecidle_q;endmodule"}
{"task_id": 1421, "completion": "localparam [9:0] DISPLAY_W    = 10'h280,\n                 DISPLAY_H    = 10'h1E0;\nlocalparam [9:0] NES_W        = 10'h100,\n                 NES_H        = 10'h0F0;\nlocalparam [7:0] BORDER_COLOR = 8'h49;\nwire       sync_en;\nwire [9:0] sync_x;\nwire [9:0] sync_y;\nwire [9:0] sync_x_next;\nwire [9:0] sync_y_next;\nvga_sync vga_sync_blk(\n  .clk(clk_in),\n  .hsync(hsync_out),\n  .vsync(vsync_out),\n  .en(sync_en),\n  .x(sync_x),\n  .y(sync_y),\n  .x_next(sync_x_next),\n  .y_next(sync_y_next)\n);\nreg  [7:0] q_rgb;\nreg  [7:0] d_rgb;\nreg        q_vblank;\nwire       d_vblank;\nalways @(posedge clk_in)\n  begin\n    if (rst_in)\n      begin\n        q_rgb    <= 8'h00;\n        q_vblank <= 1'h0;\n      end\n    else\n      begin\n        q_rgb    <= d_rgb;\n        q_vblank <= d_vblank;\n      end\n  end\nwire [9:0] nes_x_next;\nwire       border;\nassign nes_x_out      = (sync_x - 10'h040) >> 1;\nassign nes_y_out      = sync_y >> 1;\nassign nes_x_next     = (sync_x_next - 10'h040) >> 1;\nassign nes_y_next_out = sync_y_next >> 1;\nassign border         = (nes_x_out >= NES_W) || (nes_y_out < 8) || (nes_y_out >= (NES_H - 8));\nalways @*\n  begin\n    if (!sync_en)\n      begin\n        d_rgb = 8'h00;\n      end\n    else if (border)\n      begin\n        d_rgb = BORDER_COLOR;\n      end\n    else\n      begin\n        case (sys_palette_idx_in)\n          6'h00:  d_rgb = { 3'h3, 3'h3, 2'h1 };\n          6'h01:  d_rgb = { 3'h1, 3'h0, 2'h2 };\n          6'h02:  d_rgb = { 3'h0, 3'h0, 2'h2 };\n          6'h03:  d_rgb = { 3'h2, 3'h0, 2'h2 };\n          6'h04:  d_rgb = { 3'h4, 3'h0, 2'h1 };\n          6'h05:  d_rgb = { 3'h5, 3'h0, 2'h0 };\n          6'h06:  d_rgb = { 3'h5, 3'h0, 2'h0 };\n          6'h07:  d_rgb = { 3'h3, 3'h0, 2'h0 };\n          6'h08:  d_rgb = { 3'h2, 3'h1, 2'h0 };\n          6'h09:  d_rgb = { 3'h0, 3'h2, 2'h0 };\n          6'h0a:  d_rgb = { 3'h0, 3'h2, 2'h0 };\n          6'h0b:  d_rgb = { 3'h0, 3'h1, 2'h0 };\n          6'h0c:  d_rgb = { 3'h0, 3'h1, 2'h1 };\n          6'h0d:  d_rgb = { 3'h0, 3'h0, 2'h0 };\n          6'h0e:  d_rgb = { 3'h0, 3'h0, 2'h0 };\n          6'h0f:  d_rgb = { 3'h0, 3'h0, 2'h0 };\n          6'h10:  d_rgb = { 3'h5, 3'h5, 2'h2 };\n          6'h11:  d_rgb = { 3'h0, 3'h3, 2'h3 };\n          6'h12:  d_rgb = { 3'h1, 3'h1, 2'h3 };\n          6'h13:  d_rgb = { 3'h4, 3'h0, 2'h3 };\n          6'h14:  d_rgb = { 3'h5, 3'h0, 2'h2 };\n          6'h15:  d_rgb = { 3'h7, 3'h0, 2'h1 };\n          6'h16:  d_rgb = { 3'h6, 3'h1, 2'h0 };\n          6'h17:  d_rgb = { 3'h6, 3'h2, 2'h0 };\n          6'h18:  d_rgb = { 3'h4, 3'h3, 2'h0 };\n          6'h19:  d_rgb = { 3'h0, 3'h4, 2'h0 };\n          6'h1a:  d_rgb = { 3'h0, 3'h5, 2'h0 };\n          6'h1b:  d_rgb = { 3'h0, 3'h4, 2'h0 };\n          6'h1c:  d_rgb = { 3'h0, 3'h4, 2'h2 };\n          6'h1d:  d_rgb = { 3'h0, 3'h0, 2'h0 };\n          6'h1e:  d_rgb = { 3'h0, 3'h0, 2'h0 };\n          6'h1f:  d_rgb = { 3'h0, 3'h0, 2'h0 };\n          6'h20:  d_rgb = { 3'h7, 3'h7, 2'h3 };\n          6'h21:  d_rgb = { 3'h1, 3'h5, 2'h3 };\n          6'h22:  d_rgb = { 3'h2, 3'h4, 2'h3 };\n          6'h23:  d_rgb = { 3'h5, 3'h4, 2'h3 };\n          6'h24:  d_rgb = { 3'h7, 3'h3, 2'h3 };\n          6'h25:  d_rgb = { 3'h7, 3'h3, 2'h2 };\n          6'h26:  d_rgb = { 3'h7, 3'h3, 2'h1 };\n          6'h27:  d_rgb = { 3'h7, 3'h4, 2'h0 };\n          6'h28:  d_rgb = { 3'h7, 3'h5, 2'h0 };\n          6'h29:  d_rgb = { 3'h4, 3'h6, 2'h0 };\n          6'h2a:  d_rgb = { 3'h2, 3'h6, 2'h1 };\n          6'h2b:  d_rgb = { 3'h2, 3'h7, 2'h2 };\n          6'h2c:  d_rgb = { 3'h0, 3'h7, 2'h3 };\n          6'h2d:  d_rgb = { 3'h0, 3'h0, 2'h0 };\n          6'h2e:  d_rgb = { 3'h0, 3'h0, 2'h0 };\n          6'h2f:  d_rgb = { 3'h0, 3'h0, 2'h0 };\n          6'h30:  d_rgb = { 3'h7, 3'h7, 2'h3 };\n          6'h31:  d_rgb = { 3'h5, 3'h7, 2'h3 };\n          6'h32:  d_rgb = { 3'h6, 3'h6, 2'h3 };\n          6'h33:  d_rgb = { 3'h6, 3'h6, 2'h3 };\n          6'h34:  d_rgb = { 3'h7, 3'h6, 2'h3 };\n          6'h35:  d_rgb = { 3'h7, 3'h6, 2'h3 };\n          6'h36:  d_rgb = { 3'h7, 3'h5, 2'h2 };\n          6'h37:  d_rgb = { 3'h7, 3'h6, 2'h2 };\n          6'h38:  d_rgb = { 3'h7, 3'h7, 2'h2 };\n          6'h39:  d_rgb = { 3'h7, 3'h7, 2'h2 };\n          6'h3a:  d_rgb = { 3'h5, 3'h7, 2'h2 };\n          6'h3b:  d_rgb = { 3'h5, 3'h7, 2'h3 };\n          6'h3c:  d_rgb = { 3'h4, 3'h7, 2'h3 };\n          6'h3d:  d_rgb = { 3'h0, 3'h0, 2'h0 };\n          6'h3e:  d_rgb = { 3'h0, 3'h0, 2'h0 };\n          6'h3f:  d_rgb = { 3'h0, 3'h0, 2'h0 };\n        endcase\n      end\n  end\nassign { r_out, g_out, b_out } = q_rgb;\nassign pix_pulse_out           = nes_x_next != nes_x_out;\nassign d_vblank = ((sync_x == 730) && (sync_y == 477)) ? 1'b1 :\n                  ((sync_x == 64) && (sync_y == 519))  ? 1'b0 : q_vblank;\nassign vblank_out = q_vblank;\nendmodule"}
{"task_id": 1435, "completion": "wire [9:0] and_outputs;\n    wire [4:0] or_outputs;\n\n    genvar i;\n    generate\n\tfor(i = 0; i < 8; i = i + 1)\n    begin: and_1st_row\n\t\tassign and_outputs[i] = x[i] & y[i];\n    end\n\t\n\tfor(i = 0; i < 4; i = i + 1)\n    begin: or_2nd_row\n\t\tassign or_outputs[i] = and_outputs[2 * i] | and_outputs[2 * i + 1];\n    end\n\n    assign and_outputs[8] = or_outputs[0] & or_outputs[1];\n    assign and_outputs[9] = or_outputs[2] & or_outputs[3];\n\t\n    assign or_outputs[4] = and_outputs[8] | and_outputs[9];\n\n    endgenerate\n\n    assign out = or_outputs[4];\nendmodule"}
{"task_id": 1437, "completion": "`define DLY #1\n\n\n\n    wire gen_ver_i;\n    wire reset_channel_i;\n    wire did_ver_i;\n\n    aurora_201_CHANNEL_INIT_SM channel_init_sm_i\n    (\n        .CH_BOND_DONE(CH_BOND_DONE),\n        .EN_CHAN_SYNC(EN_CHAN_SYNC),\n        .CHANNEL_BOND_LOAD(CHANNEL_BOND_LOAD),\n        .GOT_A(GOT_A),\n        .GOT_V(GOT_V),\n        .RESET_LANES(RESET_LANES),\n        .USER_CLK(USER_CLK),\n        .RESET(RESET),\n        .START_RX(START_RX),\n        .CHANNEL_UP(CHANNEL_UP),\n        .DID_VER(did_ver_i),\n        .GEN_VER(gen_ver_i),\n        .RESET_CHANNEL(reset_channel_i)\n    );\n\n    aurora_201_IDLE_AND_VER_GEN idle_and_ver_gen_i\n    (\n        .GEN_VER(gen_ver_i),\n        .DID_VER(did_ver_i),\n        .GEN_A(GEN_A),\n        .GEN_K(GEN_K),\n        .GEN_R(GEN_R),\n        .GEN_V(GEN_V),\n        .RESET(RESET),\n        .USER_CLK(USER_CLK)\n    );\n\n    aurora_201_CHANNEL_ERROR_DETECT channel_error_detect_i\n    (\n        .SOFT_ERROR(SOFT_ERROR),\n        .HARD_ERROR(HARD_ERROR),\n        .LANE_UP(LANE_UP),\n        .USER_CLK(USER_CLK),\n        .POWER_DOWN(POWER_DOWN),\n        .CHANNEL_SOFT_ERROR(CHANNEL_SOFT_ERROR),\n        .CHANNEL_HARD_ERROR(CHANNEL_HARD_ERROR),\n        .RESET_CHANNEL(reset_channel_i)\n    );\n\nendmodule"}
{"task_id": 1429, "completion": "parameter   DELAY_DATA_WIDTH = 16;\n  localparam  DW = DELAY_DATA_WIDTH - 1;\n  reg     [DW:0]  p1_ddata = 'd0;\n  reg     [24:0]  p1_data_1 = 'd0;\n  reg     [24:0]  p1_data_2 = 'd0;\n  reg     [24:0]  p1_data_3 = 'd0;\n  reg     [24:0]  p1_data_4 = 'd0;\n  reg     [DW:0]  p2_ddata = 'd0;\n  reg     [24:0]  p2_data_0 = 'd0;\n  reg     [24:0]  p2_data_1 = 'd0;\n  reg     [DW:0]  p3_ddata = 'd0;\n  reg     [24:0]  p3_data = 'd0;\n  reg     [DW:0]  ddata_out = 'd0;\n  reg     [ 7:0]  data_p = 'd0;\n  wire    [24:0]  p1_data_1_p_s;\n  wire    [24:0]  p1_data_1_n_s;\n  wire    [24:0]  p1_data_1_s;\n  wire    [24:0]  p1_data_2_p_s;\n  wire    [24:0]  p1_data_2_n_s;\n  wire    [24:0]  p1_data_2_s;\n  wire    [24:0]  p1_data_3_p_s;\n  wire    [24:0]  p1_data_3_n_s;\n  wire    [24:0]  p1_data_3_s;\n  wire    [24:0]  p1_data_4_p_s;\n  wire    [24:0]  p1_data_4_n_s;\n  wire    [24:0]  p1_data_4_s;\n  assign p1_data_1_p_s = {1'b0, data_1[23:0]};\n  assign p1_data_1_n_s = ~p1_data_1_p_s + 1'b1;\n  assign p1_data_1_s = (data_1[24] == 1'b1) ? p1_data_1_n_s : p1_data_1_p_s;\n  assign p1_data_2_p_s = {1'b0, data_2[23:0]};\n  assign p1_data_2_n_s = ~p1_data_2_p_s + 1'b1;\n  assign p1_data_2_s = (data_2[24] == 1'b1) ? p1_data_2_n_s : p1_data_2_p_s;\n  assign p1_data_3_p_s = {1'b0, data_3[23:0]};\n  assign p1_data_3_n_s = ~p1_data_3_p_s + 1'b1;\n  assign p1_data_3_s = (data_3[24] == 1'b1) ? p1_data_3_n_s : p1_data_3_p_s;\n  assign p1_data_4_p_s = {1'b0, data_4[23:0]};\n  assign p1_data_4_n_s = ~p1_data_4_p_s + 1'b1;\n  assign p1_data_4_s = (data_4[24] == 1'b1) ? p1_data_4_n_s : p1_data_4_p_s;\n  always @(posedge clk) begin\n    p1_ddata <= ddata_in;\n    p1_data_1 <= p1_data_1_s;\n    p1_data_2 <= p1_data_2_s;\n    p1_data_3 <= p1_data_3_s;\n    p1_data_4 <= p1_data_4_s;\n  end\n  always @(posedge clk) begin\n    p2_ddata <= p1_ddata;\n    p2_data_0 <= p1_data_1 + p1_data_2;\n    p2_data_1 <= p1_data_3 + p1_data_4;\n  end\n  always @(posedge clk) begin\n    p3_ddata <= p2_ddata;\n    p3_data <= p2_data_0 + p2_data_1;\n  end\n  always @(posedge clk) begin\n    ddata_out <= p3_ddata;\n    if (p3_data[24] == 1'b1) begin\n      data_p <= 8'h00;\n    end else if (p3_data[23:20] == 'd0) begin\n      data_p <= p3_data[19:12];\n    end else begin\n      data_p <= 8'hff;\n    end\n  end\nendmodule"}
{"task_id": 1423, "completion": "wire [`ADDER_WIDTH+3-1:0] sum0;\n    wire [`ADDER_WIDTH+2-1:0] sum0_0, sum0_1;\n    wire [`ADDER_WIDTH+1-1:0] sum0_0_0, sum0_0_1, sum0_1_0, sum0_1_1;\n    reg  [`ADDER_WIDTH+0-1:0] sum0_0_0_0, sum0_0_0_1, sum0_0_1_0, sum0_0_1_1, sum0_1_0_0, sum0_1_0_1, sum0_1_1_0, sum0_1_1_1;\n\n    adder_tree_branch L1_0(sum0_0,     sum0_1,     sum0    );\n    defparam L1_0.EXTRA_BITS = 2;\n\n    adder_tree_branch L2_0(sum0_0_0,   sum0_0_1,   sum0_0  );\n    adder_tree_branch L2_1(sum0_1_0,   sum0_1_1,   sum0_1  );\n    defparam L2_0.EXTRA_BITS = 1;\n    defparam L2_1.EXTRA_BITS = 1;\n\n    adder_tree_branch L3_0(sum0_0_0_0, sum0_0_0_1, sum0_0_0);\n    adder_tree_branch L3_1(sum0_0_1_0, sum0_0_1_1, sum0_0_1);\n    adder_tree_branch L3_2(sum0_1_0_0, sum0_1_0_1, sum0_1_0);\n    adder_tree_branch L3_3(sum0_1_1_0, sum0_1_1_1, sum0_1_1);\n    defparam L3_0.EXTRA_BITS = 0;\n    defparam L3_1.EXTRA_BITS = 0;\n    defparam L3_2.EXTRA_BITS = 0;\n    defparam L3_3.EXTRA_BITS = 0;\n\n    always @(posedge clk) begin\n        sum0_0_0_0 <= isum0_0_0_0;\n        sum0_0_0_1 <= isum0_0_0_1;\n        sum0_0_1_0 <= isum0_0_1_0;\n        sum0_0_1_1 <= isum0_0_1_1;\n        sum0_1_0_0 <= isum0_1_0_0;\n        sum0_1_0_1 <= isum0_1_0_1;\n        sum0_1_1_0 <= isum0_1_1_0;\n        sum0_1_1_1 <= isum0_1_1_1;\n\n        `ifdef 3_LEVEL_ADDER\n            sum <= sum0;\n        `endif\n        `ifdef 2_LEVEL_ADDER\n            sum <= sum0_0;\n        `endif\n    }\n\nendmodule\n\nmodule adder_tree_branch(a,b,sum);\n    parameter EXTRA_BITS = 0;\n\n    input [`ADDER_WIDTH+EXTRA_BITS-1:0] a;\n    input [`ADDER_WIDTH+EXTRA_BITS-1:0] b;\n    output [`ADDER_WIDTH+EXTRA_BITS:0] sum;\n\n    assign sum = a + b;\nendmodule"}
{"task_id": 1440, "completion": "`include \"VGA_Param.h\"\n\n    output reg [19:0] oAddress;\n    output reg [9:0] oCoord_X;\n    output reg [9:0] oCoord_Y;\n    input [3:0] iCursor_RGB_EN;\n    input [9:0] iCursor_X;\n    input [9:0] iCursor_Y;\n    input [9:0] iCursor_R;\n    input [9:0] iCursor_G;\n    input [9:0] iCursor_B;\n    input [9:0] iRed;\n    input [9:0] iGreen;\n    input [9:0] iBlue;\n    output [9:0] oVGA_R;\n    output [9:0] oVGA_G;\n    output [9:0] oVGA_B;\n    output reg oVGA_H_SYNC;\n    output reg oVGA_V_SYNC;\n    output oVGA_SYNC;\n    output oVGA_BLANK;\n    output oVGA_CLOCK;\n    input iCLK_25;\n    input iRST_N;\n    reg [9:0] H_Cont;\n    reg [9:0] V_Cont;\n    reg [9:0] Cur_Color_R;\n    reg [9:0] Cur_Color_G;\n    reg [9:0] Cur_Color_B;\n    wire mCLK;\n    wire mCursor_EN;\n    wire mRed_EN;\n    wire mGreen_EN;\n    wire mBlue_EN;\n\n    assign oVGA_BLANK = oVGA_H_SYNC & oVGA_V_SYNC;\n    assign oVGA_SYNC = 1'b0;\n    assign oVGA_CLOCK = ~iCLK_25;\n    assign mCursor_EN = iCursor_RGB_EN[3];\n    assign mRed_EN = iCursor_RGB_EN[2];\n    assign mGreen_EN = iCursor_RGB_EN[1];\n    assign mBlue_EN = iCursor_RGB_EN[0];\n    assign mCLK = iCLK_25;\n\n    assign oVGA_R = (H_Cont >= X_START + 9 && H_Cont < X_START + H_SYNC_ACT + 9 && V_Cont >= Y_START && V_Cont < Y_START + V_SYNC_ACT) ? (mRed_EN ? Cur_Color_R : 0) : 0;\n    assign oVGA_G = (H_Cont >= X_START + 9 && H_Cont < X_START + H_SYNC_ACT + 9 && V_Cont >= Y_START && V_Cont < Y_START + V_SYNC_ACT) ? (mGreen_EN ? Cur_Color_G : 0) : 0;\n    assign oVGA_B = (H_Cont >= X_START + 9 && H_Cont < X_START + H_SYNC_ACT + 9 && V_Cont >= Y_START && V_Cont < Y_START + V_SYNC_ACT) ? (mBlue_EN ? Cur_Color_B : 0) : 0;\n\n    always @(posedge mCLK or negedge iRST_N)\n    begin\n        if (!iRST_N)\n        begin\n            oCoord_X <= 0;\n            oCoord_Y <= 0;\n            oAddress <= 0;\n        end\n        else\n        begin\n            if (H_Cont >= X_START && H_Cont < X_START + H_SYNC_ACT && V_Cont >= Y_START && V_Cont < Y_START + V_SYNC_ACT)\n            begin\n                oCoord_X <= H_Cont - X_START;\n                oCoord_Y <= V_Cont - Y_START;\n                oAddress <= oCoord_Y * H_SYNC_ACT + oCoord_X - 3;\n            end\n        end\n    end\n\n    always @(posedge mCLK or negedge iRST_N)\n    begin\n        if (!iRST_N)\n        begin\n            Cur_Color_R <= 0;\n            Cur_Color_G <= 0;\n            Cur_Color_B <= 0;\n        end\n        else\n        begin\n            if (H_Cont >= X_START + 8 && H_Cont < X_START + H_SYNC_ACT + 8 && V_Cont >= Y_START && V_Cont < Y_START + V_SYNC_ACT)\n            begin\n                if ((H_Cont == X_START + 8 + iCursor_X || H_Cont == X_START + 8 + iCursor_X + 1 || H_Cont == X_START + 8 + iCursor_X - 1 || V_Cont == Y_START + iCursor_Y || V_Cont == Y_START + iCursor_Y + 1 || V_Cont == Y_START + iCursor_Y - 1) && mCursor_EN)\n                begin\n                    Cur_Color_R <= iCursor_R;\n                    Cur_Color_G <= iCursor_G;\n                    Cur_Color_B <= iCursor_B;\n                end\n                else\n                begin\n                    Cur_Color_R <= iRed;\n                    Cur_Color_G <= iGreen;\n                    Cur_Color_B <= iBlue;\n                end\n            end\n            else\n            begin\n                Cur_Color_R <= iRed;\n                Cur_Color_G <= iGreen;\n                Cur_Color_B <= iBlue;\n            end\n        end\n    end\n\n    always @(posedge mCLK or negedge iRST_N)\n    begin\n        if (!iRST_N)\n        begin\n            H_Cont <= 0;\n            oVGA_H_SYNC <= 0;\n        end\n        else\n        begin\n            if (H_Cont < H_SYNC_TOTAL)\n                H_Cont <= H_Cont + 1;\n            else\n                H_Cont <= 0;\n            if (H_Cont < H_SYNC_CYC)\n                oVGA_H_SYNC <= 0;\n            else\n                oVGA_H_SYNC <= 1;\n        end\n    end\n\n    always @(posedge mCLK or negedge iRST_N)\n    begin\n        if (!iRST_N)\n        begin\n            V_Cont <= 0;\n            oVGA_V_SYNC <= 0;\n        end\n        else\n        begin\n            if (H_Cont == 0)\n            begin\n                if (V_Cont < V_SYNC_TOTAL)\n                    V_Cont <= V_Cont + 1;\n                else\n                    V_Cont <= 0;\n                if (V_Cont < V_SYNC_CYC)\n                    oVGA_V_SYNC <= 0;\n                else\n                    oVGA_V_SYNC <= 1;\n            end\n        end\n    end\n\nendmodule"}
{"task_id": 1286, "completion": "assign s_axis_tready = 1'b1;\n\twire snext;\n\tassign snext = s_axis_tvalid & s_axis_tready;\n\n\treg [C_IMG_WW-1:0] wleft;\n\treg [C_IMG_WW-1:0] wright;\n\treg [C_IMG_HW-1:0] htop;\n\treg [C_IMG_HW-1:0] hbottom;\n\talways @ (posedge clk) begin\n\t\tif (resetn == 1'b0) begin\n\t\t\twleft <= 0;\n\t\t\twright <= 0;\n\t\t\thtop <= 0;\n\t\t\thbottom <= 0;\n\t\tend\n\t\telse if (snext && s_axis_tuser) begin\n\t\t\twleft <= win_left;\n\t\t\twright <= win_left + win_width;\n\t\t\thtop <= win_top;\n\t\t\thbottom <= win_top + win_height;\n\t\tend\n\tend\n\n\treg [C_PIXEL_WIDTH-1:0] tdata_p0;\n\treg wfirst_p0;\n\treg wlast_p0;\n\treg hfirst_p0;\n\treg [C_IMG_HW-1:0] y_p0;\n\talways @ (posedge clk) begin\n\t\tif (resetn == 1'b0) begin\n\t\t\trd_en       <= 0;\n\t\t\trd_addr     <= 0;\n\t\t\ttdata_p0    <= 0;\n\t\t\twfirst_p0   <= 0;\n\t\t\twlast_p0    <= 0;\n\t\t\thfirst_p0   <= 0;\n\t\t\ty_p0        <= 0;\n\t\tend\n\t\telse if (snext) begin\n\t\t\trd_en       <= 1;\n\t\t\tif (s_axis_tuser || wlast_p0) begin\n\t\t\t\twfirst_p0 <= 1;\n\t\t\t\trd_addr <= 0;\n\t\t\tend\n\t\t\telse begin\n\t\t\t\twfirst_p0 <= 0;\n\t\t\t\trd_addr <= rd_addr + 1;\n\t\t\tend\n\t\t\ttdata_p0    <= s_axis_tdata;\n\t\t\twlast_p0    <= s_axis_tlast;\n\t\t\tif (s_axis_tuser) begin\n\t\t\t\ty_p0 <= 0;\n\t\t\t\thfirst_p0 <= 1;\n\t\t\tend\n\t\t\telse if (wlast_p0) begin\n\t\t\t\ty_p0 <= y_p0 + 1;\n\t\t\t\thfirst_p0 <= 0;\n\t\t\tend\n\t\tend\n\t\telse begin\n\t\trd_en <= 0;\n\t\tend\n\tend\n\n\treg rd_en_d1;\n\treg [BR_AW-1:0] x_d1;\n\treg [C_PIXEL_WIDTH-1:0] tdata_p1;\n\treg wfirst_p1;\n\treg wlast_p1;\n\treg hfirst_p1;\n\treg hlast_p1;\n\treg hM3_p1;\n\treg hM2_p1;\n\treg [C_IMG_HW-1:0] y_p1;\n\talways @ (posedge clk) begin\n\t\tif (resetn == 1'b0) begin\n\t\t\trd_en_d1    <= 0;\n\t\t\tx_d1        <= 0;\n\t\t\ttdata_p1    <= 0;\n\t\t\twfirst_p1   <= 0;\n\t\t\twlast_p1    <= 0;\n\t\t\thfirst_p1   <= 0;\n\t\t\thlast_p1    <= 0;\n\t\t\thM2_p1      <= 0;\n\t\t\thM3_p1      <= 0;\n\t\t\ty_p1        <= 0;\n\t\tend\n\t\telse begin\n\t\t\trd_en_d1    <= rd_en;\n\t\t\tx_d1        <= rd_addr;\n\t\t\ttdata_p1    <= tdata_p0;\n\t\t\twfirst_p1   <= (rd_addr == wleft);\n\t\t\twlast_p1    <= (rd_addr == wright-1);\n\t\t\thfirst_p1   <= (y_p0 == htop);\n\t\t\thlast_p1    <= (y_p0 == hbottom-1);\n\t\t\thM2_p1      <= (y_p0 == hbottom-2);\n\t\t\thM3_p1      <= (y_p0 == hbottom-3);\n\t\t\ty_p1        <= y_p0;\n\t\tend\n\tend\n\n\treg wlast_p1_d1;\n\treg hlast_p1_d1;\n\talways @ (posedge clk) begin\n\t\tif (resetn == 1'b0) begin\n\t\t\twlast_p1_d1 <= 0;\n\t\t\thlast_p1_d1 <= 0;\n\t\tend\n\t\telse begin\n\t\t\twlast_p1_d1 <= wlast_p1;\n\t\t\thlast_p1_d1 <= hlast_p1;\n\t\tend\n\tend\n\n\treg w_valid_p2;\n\treg h_valid_p2;\n\talways @ (posedge clk) begin\n\t\tif (resetn == 1'b0) begin\n\t\t\tw_valid_p2 <= 0;\n\t\t\th_valid_p2 <= 0;\n\t\tend\n\t\telse begin\n\t\t\tif (wfirst_p1)\n\t\t\t\tw_valid_p2 <= 1;\n\t\t\telse if (wlast_p1_d1)\n\t\t\t\tw_valid_p2 <= 0;\n\n\t\t\tif (hfirst_p1 && wfirst_p1)\n\t\t\t\th_valid_p2 <= 1;\n\t\t\telse if (hlast_p1_d1 && wlast_p1_d1)\n\t\t\t\th_valid_p2 <= 0;\n\t\tend\n\tend\n\n\treg rd_en_d2;\n\treg [BR_AW-1:0] x_d2;\n\treg [C_PIXEL_WIDTH-1:0] tdata_p2;\n\treg wfirst_p2;\n\treg wlast_p2;\n\treg pfirst_p2;\n\treg plast_p2;\n\treg hfirst_p2;\n\treg hlast_p2;\n\treg hM2_p2;\n\treg hM3_p2;\n\treg [C_IMG_HW-1:0] y_p2;\n\talways @ (posedge clk) begin\n\t\tif (resetn == 1'b0) begin\n\t\t\trd_en_d2    <= 0;\n\t\t\tx_d2        <= 0;\n\t\t\ttdata_p2    <= 0;\n\t\t\twfirst_p2   <= 0;\n\t\t\twlast_p2    <= 0;\n\t\t\tpfirst_p2   <= 0;\n\t\t\tplast_p2    <= 0;\n\t\t\thfirst_p2   <= 0;\n\t\t\thlast_p2    <= 0;\n\t\t\thM2_p2      <= 0;\n\t\t\thM3_p2      <= 0;\n\t\t\ty_p2        <= 0;\n\t\tend\n\t\telse begin\n\t\t\trd_en_d2    <= rd_en_d1;\n\t\t\tx_d2        <= x_d1;\n\t\t\ttdata_p2    <= tdata_p1;\n\t\t\twfirst_p2   <= wfirst_p1;\n\t\t\twlast_p2    <= wlast_p1;\n\t\t\tpfirst_p2   <= (wfirst_p1 && hfirst_p1);\n\t\t\tplast_p2    <= (wlast_p1 && hlast_p1);\n\t\t\thfirst_p2   <= hfirst_p1;\n\t\t\thlast_p2    <= hlast_p1;\n\t\t\thM2_p2      <= hM2_p1;\n\t\t\thM3_p2      <= hM3_p1;\n\t\t\ty_p2        <= y_p1;\n\t\tend\n\tend\n\n\treg wr_sof_d3;\n\treg rd_en_d3;\n\treg [BR_AW-1:0] x_d3;\n\treg is_black_p3;\n\treg [C_PIXEL_WIDTH-1:0] tdata_p3;\n\treg wfirst_p3;\n\treg wlast_p3;\n\treg hfirst_p3;\n\treg hlast_p3;\n\treg hM2_p3;\n\treg hM3_p3;\n\treg [C_IMG_HW-1:0] y_p3;\n\talways @ (posedge clk) begin\n\t\tif (resetn == 1'b0) begin\n\t\t\twr_sof_d3   <= 0;\n\t\t\trd_en_d3    <= 0;\n\t\t\tx_d3        <= 0;\n\t\t\ttdata_p3    <= 0;\n\t\t\tis_black_p3 <= 0;\n\t\t\twfirst_p3   <= 0;\n\t\t\twlast_p3    <= 0;\n\t\t\thfirst_p3   <= 0;\n\t\t\thlast_p3    <= 0;\n\t\t\thM2_p3      <= 0;\n\t\t\thM3_p3      <= 0;\n\t\t\ty_p3        <= 0;\n\t\tend\n\t\telse begin\n\t\t\twr_sof_d3   <= rd_en_d2 && plast_p2;\n\t\t\trd_en_d3    <= rd_en_d2 && h_valid_p2;\n\t\t\tx_d3        <= x_d2;\n\t\t\ttdata_p3    <= tdata_p2;\n\t\t\tif (hfirst_p2 || hlast_p2)\n\t\t\t\tis_black_p3 <= 0;\n\t\t\telse\n\t\t\t\tis_black_p3 <= (tdata_p2 < ref_data);\n\t\t\twfirst_p3   <= wfirst_p2;\n\t\t\twlast_p3    <= wlast_p2;\n\t\t\thfirst_p3   <= hfirst_p2;\n\t\t\thlast_p3    <= hlast_p2;\n\t\t\thM2_p3      <= hM2_p2;\n\t\t\thM3_p3      <= hM3_p2;\n\t\t\ty_p3        <= y_p2;\n\t\tend\n\tend\n\tassign sof = wr_sof_d3;\n\n\talways @ (posedge clk) begin\n\t\tif (resetn == 1'b0) begin\n\t\t\twr_en   <= 0;\n\t\t\twr_addr <= 0;\n\t\t\twr_val_outer <= 0;\n\t\t\twr_black<= 0;\n\t\t\twr_top_outer <= 0;\n\t\t\twr_bot_outer <= 0;\n\t\t\twr_val_inner <= 0;\n\t\t\twr_top_inner <= 0;\n\t\t\twr_bot_inner <= 0;\n\t\tend\n\t\telse if (rd_en_d3) begin\n\t\t\twr_en   <= wr_bmp;\n\t\t\twr_addr <= x_d3;\n\t\t\twr_black <= is_black_p3;\n\n\t\t\tif (is_black_p3)\n\t\t\t\twr_val_outer <= 1;\n\t\t\telse if (hfirst_p3)\n\t\t\t\twr_val_outer <= 0;\n\t\t\telse\n\t\t\t\twr_val_outer <= rd_val_outer;\n\n\t\t\tif (hfirst_p3)\n\t\t\t\twr_top_outer <= 0;\n\t\t\telse if (is_black_p3 && ~rd_val_outer)\n\t\t\t\twr_top_outer <= y_p3;\n\t\t\telse\n\t\t\t\twr_top_outer <= rd_top_outer;\n\n\t\t\tif (is_black_p3)\n\t\t\t\twr_bot_outer <= y_p3;\n\t\t\telse if (hfirst_p3)\n\t\t\t\twr_bot_outer <= 0;\n\t\t\telse\n\t\t\t\twr_bot_outer <= rd_bot_outer;\n\n\t\t\tif (hfirst_p3)\n\t\t\t\twr_val_inner <= 0;\n\t\t\telse if (rd_val_outer && ~rd_black && is_black_p3)\n\t\t\t\twr_val_inner <= 1;\n\t\t\telse\n\t\t\t\twr_val_inner <= rd_val_inner;\n\n\t\t\tif (hfirst_p3)\n\t\t\t\twr_top_inner <= 0;\n\t\t\telse if (is_black_p3 && rd_black && ~rd_val_inner)\n\t\t\t\twr_top_inner <= y_p3;\n\t\t\telse\n\t\t\t\twr_top_inner <= rd_top_inner;\n\n\t\t\tif (hfirst_p3)\n\t\t\t\twr_bot_inner <= 0;\n\t\t\telse if (rd_val_outer && ~rd_black && is_black_p3)\n\t\t\t\twr_bot_inner <= y_p3;\n\t\t\telse\n\t\t\t\twr_bot_inner <= rd_bot_inner;\n\t\tend\n\t\telse begin\n\t\t\twr_en   <= 0;\n\t\tend\n\tend\n\n\tassign o_wr_sof_d3 = wr_sof_d3;\n\tassign o_rd_en_d3  = rd_en_d3;\n\tassign o_hM2_p3    = hM2_p3;\n\tassign o_hM3_p3    = hM3_p3;\n\tassign o_hfirst_p3 = hfirst_p3;\n\tassign o_hlast_p3  = hlast_p3;\n\tassign o_wfirst_p3 = wfirst_p3;\n\tassign o_wlast_p3  = wlast_p3;\n\tassign o_x_d3      = x_d3;\n\tassign o_rd_val_outer = rd_val_outer;\n\tassign o_rd_top_outer = rd_top_outer;\n\tassign o_rd_bot_outer = rd_bot_outer;\n\tassign o_rd_val_inner = rd_val_inner;\n\tassign o_rd_top_inner = rd_top_inner;\n\tassign o_rd_bot_inner = rd_bot_inner;\nendmodule"}
{"task_id": 1443, "completion": "generate\n    if(CLOCKS_ARE_SAME) \n        assign trigger_out = trigger_in;\n    else begin\n        reg trigger_in_reg;\n        reg toggle;\n        reg toggle_synched_reg;\n        wire toggle_synched;\n        \n        always @ (posedge input_rst or posedge input_clock) begin\n            if(input_rst) begin\n                trigger_in_reg <= 1'b0;\n                toggle <= 1'b0;\n            end else begin\n                trigger_in_reg <= trigger_in;\n                toggle <= toggle ^ (trigger_in & (~trigger_in_reg | ack_in));\n            end\n        end\n        \n        alt_vipitc131_common_sync #(CLOCKS_ARE_SAME) toggle_sync(\n            .rst(rst),\n            .sync_clock(sync_clock),\n            .data_in(toggle),\n            .data_out(toggle_synched));\n            \n        always @ (posedge rst or posedge sync_clock) begin\n            if(rst) begin\n                toggle_synched_reg <= 1'b0;\n            end else begin\n                toggle_synched_reg <= toggle_synched;\n            end\n        end\n        \n        assign trigger_out = toggle_synched ^ toggle_synched_reg;\n    end\nendgenerate\n\nendmodule"}
{"task_id": 1434, "completion": "class Proper (R : crelation A) (m : A) :=\n        proper_prf : R m m;\n\n    class ProperProxy (R : crelation A) (m : A) :=\n        proper_proxy : R m m;\n\n    Lemma eq_proper_proxy (x : A) : ProperProxy (@eq A) x.\n    Proof. firstorder. Qed;\n    \n    Lemma reflexive_proper_proxy `(Reflexive A R) (x : A) : ProperProxy R x.\n    Proof. firstorder. Qed.\n    \n    Lemma proper_proper_proxy x `(Proper R x) : ProperProxy R x.\n    Proof. firstorder. Qed.\n\n    Definition respectful_hetero\n    (A B : Type)\n    (C : A -> Type) (D : B -> Type)\n    (R : A -> B -> Type)\n    (R' : forall (x : A) (y : B), C x -> D y -> Type) :\n        (forall x : A, C x) -> (forall x : B, D x) -> Type :=\n        fun f g => forall x y, R x y -> R' x y (f x) (g y);\n\n    Definition respectful {B} (R : crelation A) (R' : crelation B) : crelation (A -> B) :=\n        Eval compute in @respectful_hetero A A (fun _ => B) (fun _ => B) R (fun _ _ => R').\n\nendmodule"}
{"task_id": 1442, "completion": "wire        prgrom_bram_we;\nwire [14:0] prgrom_bram_a;\nwire [7:0]  prgrom_bram_dout;\n\nsingle_port_ram_sync #(.ADDR_WIDTH(15),\n                       .DATA_WIDTH(8)) prgrom_bram(\n  .clk(clk_in),\n  .we(prgrom_bram_we),\n  .addr_a(prgrom_bram_a),\n  .din_a(prg_d_in),\n  .dout_a(prgrom_bram_dout)\n);\n\nassign prgrom_bram_we = (~prg_nce_in) ? ~prg_r_nw_in     : 1'b0;\nassign prg_d_out      = (~prg_nce_in) ? prgrom_bram_dout : 8'h00;\nassign prgrom_bram_a  = (cfg_in[33])  ? prg_a_in[14:0]   : { 1'b0, prg_a_in[13:0] };\n\nwire       chrrom_pat_bram_we;\nwire [7:0] chrrom_pat_bram_dout;\n\nsingle_port_ram_sync #(.ADDR_WIDTH(13),\n                       .DATA_WIDTH(8)) chrrom_pat_bram(\n  .clk(clk_in),\n  .we(chrrom_pat_bram_we),\n  .addr_a(chr_a_in[12:0]),\n  .din_a(chr_d_in),\n  .dout_a(chrrom_pat_bram_dout)\n);\n\nassign ciram_nce_out      = ~chr_a_in[13];\nassign ciram_a10_out      = (cfg_in[16])    ? chr_a_in[10] : chr_a_in[11];\nassign chrrom_pat_bram_we = (ciram_nce_out) ? ~chr_r_nw_in : 1'b0;\nassign chr_d_out          = (ciram_nce_out) ? chrrom_pat_bram_dout : 8'h00;\n\nendmodule"}
{"task_id": 1448, "completion": "altera_pll #(\n        .fractional_vco_multiplier(\"false\"),\n        .reference_clock_frequency(\"50.0 MHz\"),\n        .operation_mode(\"direct\"),\n        .number_of_clocks(2),\n        .output_clock_frequency0(\"65.000000 MHz\"),\n        .phase_shift0(\"0 ps\"),\n        .duty_cycle0(50),\n        .output_clock_frequency1(\"130.000000 MHz\"),\n        .phase_shift1(\"0 ps\"),\n        .duty_cycle1(50),\n        .output_clock_frequency2(\"0 MHz\"),\n        .phase_shift2(\"0 ps\"),\n        .duty_cycle2(50),\n        .output_clock_frequency3(\"0 MHz\"),\n        .phase_shift3(\"0 ps\"),\n        .duty_cycle3(50),\n        .output_clock_frequency4(\"0 MHz\"),\n        .phase_shift4(\"0 ps\"),\n        .duty_cycle4(50),\n        .output_clock_frequency5(\"0 MHz\"),\n        .phase_shift5(\"0 ps\"),\n        .duty_cycle5(50),\n        .output_clock_frequency6(\"0 MHz\"),\n        .phase_shift6(\"0 ps\"),\n        .duty_cycle6(50),\n        .output_clock_frequency7(\"0 MHz\"),\n        .phase_shift7(\"0 ps\"),\n        .duty_cycle7(50),\n        .output_clock_frequency8(\"0 MHz\"),\n        .phase_shift8(\"0 ps\"),\n        .duty_cycle8(50),\n        .output_clock_frequency9(\"0 MHz\"),\n        .phase_shift9(\"0 ps\"),\n        .duty_cycle9(50),\n        .output_clock_frequency10(\"0 MHz\"),\n        .phase_shift10(\"0 ps\"),\n        .duty_cycle10(50),\n        .output_clock_frequency11(\"0 MHz\"),\n        .phase_shift11(\"0 ps\"),\n        .duty_cycle11(50),\n        .output_clock_frequency12(\"0 MHz\"),\n        .phase_shift12(\"0 ps\"),\n        .duty_cycle12(50),\n        .output_clock_frequency13(\"0 MHz\"),\n        .phase_shift13(\"0 ps\"),\n        .duty_cycle13(50),\n        .output_clock_frequency14(\"0 MHz\"),\n        .phase_shift14(\"0 ps\"),\n        .duty_cycle14(50),\n        .output_clock_frequency15(\"0 MHz\"),\n        .phase_shift15(\"0 ps\"),\n        .duty_cycle15(50),\n        .output_clock_frequency16(\"0 MHz\"),\n        .phase_shift16(\"0 ps\"),\n        .duty_cycle16(50),\n        .output_clock_frequency17(\"0 MHz\"),\n        .phase_shift17(\"0 ps\"),\n        .duty_cycle17(50),\n        .pll_type(\"General\"),\n        .pll_subtype(\"General\")\n    ) altera_pll_i (\n        .rst (rst),\n        .outclk ({outclk_1, outclk_0}),\n        .locked (locked),\n        .fboutclk ( ),\n        .fbclk (1'b0),\n        .refclk (refclk)\n    );\nendmodule"}
{"task_id": 1454, "completion": "localparam [1:0]init_state  = 2'b00,start = 2'b01,data  = 2'b10,stop  = 2'b11;\n\n   reg [1:0] state, state_next;\n   reg [3:0] s, s_next;\n   reg [2:0] n, n_next;\n   reg [7:0] b, b_next;\n   reg tx_reg, tx_next;\n\n   always @(posedge clk)\n      if (reset)\n         begin\n            state <= init_state;\n            s <= 0;\n            n <= 0;\n            b <= 0;\n            tx_reg <= 1'b1;\n         end\n      else\n         begin\n            state <= state_next;\n            s <= s_next;\n            n <= n_next;\n            b <= b_next;\n            tx_reg <= tx_next;\n         end\n\n   always @*\n   begin\n      state_next = state;\n      tx_done_tck = 1'b0;\n      s_next = s;\n      n_next = n;\n      b_next = b;\n      tx_next = tx_reg ;\n      if(state==init_state)\n            begin\n               tx_next = 1'b1;\n               if (tx_start)\n                  begin\n                     state_next = start;\n                     s_next = 0;\n                     b_next = din;\n                  end\n            end\n        else if(state==start)\n            begin\n               tx_next = 1'b0;\n               if (s_tck)\n                  if (s==15)\n                     begin\n                        state_next = data;\n                        s_next = 0;\n                        n_next = 0;\n                     end\n                  else\n                     s_next = s + 1;\n            end\n         else if(state==data)\n            begin\n               tx_next = b[0];\n               if (s_tck)\n                  if (s==15)\n                     begin\n                        s_next = 0;\n                        b_next = b >> 1;\n                        if (n==(DBIT-1))\n                           state_next = stop ;\n                        else\n                           n_next = n + 1;\n                     end\n                  else\n                     s_next = s + 1;\n            end\n         else if(state==stop)\n            begin\n               tx_next = 1'b1;\n               if (s_tck)\n                  if (s==(SB_tck-1))\n                     begin\n                        state_next = init_state;\n                        tx_done_tck = 1'b1;\n                     end\n                  else\n                     s_next = s + 1;\n            end\n   end\n\n   assign tx = tx_reg;\n\nendmodule"}
{"task_id": 1455, "completion": "(*preserve*) reg [DEPTH-1:0] altera_reset_synchronizer_int_chain;\n    reg altera_reset_synchronizer_int_chain_out;\n\n    generate if (ASYNC_RESET) begin\n\n        always @(posedge clk or posedge reset_in) begin\n            if (reset_in) begin\n                altera_reset_synchronizer_int_chain <= {DEPTH{1'b1}};\n                altera_reset_synchronizer_int_chain_out <= 1'b1;\n            end\n            else begin\n                altera_reset_synchronizer_int_chain[DEPTH-2:0] <= altera_reset_synchronizer_int_chain[DEPTH-1:1];\n                altera_reset_synchronizer_int_chain[DEPTH-1] <= 0;\n                altera_reset_synchronizer_int_chain_out <= altera_reset_synchronizer_int_chain[0];\n            end\n        end\n\n        assign reset_out = altera_reset_synchronizer_int_chain_out;\n     \n    end else begin\n\n        always @(posedge clk) begin\n            altera_reset_synchronizer_int_chain[DEPTH-2:0] <= altera_reset_synchronizer_int_chain[DEPTH-1:1];\n            altera_reset_synchronizer_int_chain[DEPTH-1] <= reset_in;\n            altera_reset_synchronizer_int_chain_out <= altera_reset_synchronizer_int_chain[0];\n        end\n\n        assign reset_out = altera_reset_synchronizer_int_chain_out;\n \n    end\n    endgenerate\n\nendmodule"}
{"task_id": 1419, "completion": "input rst;\n    input clk;\n    input ie, de;\n    input [31:0] iaddr, daddr;\n    input [1:0] drw;\n    input [31:0] din;\n    output [31:0] iout, dout;\n    output cpu_stall;\n    output [31:0] mod_vga_sram_data;\n    input  [31:0] mod_vga_sram_addr;\n    input      mod_vga_sram_read;\n    output     mod_vga_sram_rdy;\n    output     sram_clk, sram_adv, sram_cre, sram_ce, sram_oe, sram_we, sram_lb, sram_ub;\n    output [23:1] sram_addr;\n    inout  [15:0] sram_data;\n\n    output pmc_cache_miss_I, pmc_cache_miss_D, pmc_cache_access_I, pmc_cache_access_D;\n\n    wire          cache_iwrite, cache_dwrite;\n    wire   [10:0] cache_iaddr, cache_daddr;\n    wire   [31:0] cache_iin, cache_din, cache_iout, cache_dout;\n    wire          sram_nrdy, sram_ie, sram_de;\n    wire   [1:0]  sram_drw;\n    wire   [31:0] sram_iaddr, sram_daddr, sram_din, sram_iout, sram_dout;\n    wire   [31:0] tag_iin, tag_din, tag_iout, tag_dout;\n\n    cache_memory #(11, 32) data_array(clk, cache_iwrite, cache_dwrite, cache_iaddr, cache_daddr, cache_iin, cache_din, cache_iout, cache_dout);\n    cache_memory #(11, 32) tag_array (clk, cache_iwrite, cache_dwrite, cache_iaddr, cache_daddr, tag_iin,   tag_din,   tag_iout,   tag_dout);\n\n    mod_sram sram_t(rst, clk, sram_ie, sram_de, sram_iaddr, sram_daddr, sram_drw, sram_din, sram_iout, sram_dout, sram_nrdy, sram_clk, sram_adv, sram_cre, sram_ce, sram_oe, sram_we, sram_lb, sram_ub, sram_data, sram_addr, mod_vga_sram_data, mod_vga_sram_addr, mod_vga_sram_read, mod_vga_sram_rdy);\n\n    reg  [3:0]  state = 4'b0000;\n    wire  [3:0]  next_state;\n    wire          ihit, dhit;\n    wire          conflict;\n\n    assign pmc_cache_miss_I   = state[3] & state[1];\n    assign pmc_cache_miss_D   = state[3] & state[0];\n    assign pmc_cache_access_I = ie && next_state == 4'b0000;\n    assign pmc_cache_access_D = de && drw != 2'b00 && next_state == 4'b0000;\n\n    assign cpu_stall    = next_state != 4'b0000;\n    assign cache_iwrite = state[1] && !conflict;\n    assign cache_dwrite = state[0];\n    assign cache_iaddr  = iaddr[12:2];\n    assign cache_daddr  = daddr[12:2];\n    assign cache_iin    = sram_iout;\n    assign cache_din    = state[2] ? din : sram_dout;\n    assign tag_iin      = {13'b0000000000001, iaddr[31:13]};\n    assign tag_din      = {13'b0000000000001, daddr[31:13]};\n    assign iout         = state[1] ? sram_iout : cache_iout;\n    assign dout         = state[0] ? sram_dout : cache_dout;\n    assign sram_ie      = state[1] && !state[3];\n    assign sram_de      = state[0] && !state[3];\n    assign sram_drw     = drw;\n    assign sram_iaddr   = iaddr;\n    assign sram_daddr   = daddr;\n    assign sram_din     = din;\n    assign ihit         = tag_iout == tag_iin && !conflict;\n    assign dhit         = tag_dout == tag_din;\n    assign conflict      = (cache_iaddr == cache_daddr) && ie && de && drw != 2'b00;\n    assign next_state   =\n        state == 4'b0000 && ((ihit && ie) || !ie) && !dhit && drw == 2'b10 && de ? 4'b0001 :\n        state == 4'b0000 && ((dhit && de && drw == 2'b10) || drw == 2'b00 || !de) && !ihit && ie ? 4'b0010 :\n        state == 4'b0000 && !ihit && !dhit && drw == 2'b10 && ie && de           ? 4'b0011 :\n        state == 4'b0000 && ((ihit && ie) || !ie) && drw == 2'b01 && de          ? 4'b0101 :\n        state == 4'b0000 && !ihit && drw == 2'b01 && de && ie                    ? 4'b0111 :\n        state != 4'b0000 && !state[3] && !sram_nrdy         ? {1'b1,state[2:0]} : \n        state[3]                               ? 4'b0000 : state;\n\n    always @(posedge clk) begin\n        if (rst) begin\n            state <= 4'b0000;\n        end else begin\n            state <= next_state;\n        end\n    end\nendmodule"}
{"task_id": 1458, "completion": "reg [WIDTH-1:0] input_a_i_reg_0 = 0;\n    reg [WIDTH-1:0] input_a_q_reg_0 = 0;\n    reg [WIDTH-1:0] input_a_i_reg_1 = 0;\n    reg [WIDTH-1:0] input_a_q_reg_1 = 0;\n    reg [WIDTH-1:0] input_b_i_reg_0 = 0;\n    reg [WIDTH-1:0] input_b_q_reg_0 = 0;\n    reg [WIDTH-1:0] input_b_i_reg_1 = 0;\n    reg [WIDTH-1:0] input_b_q_reg_1 = 0;\n    reg [(WIDTH*2)-1:0] output_i_reg_0 = 0;\n    reg [(WIDTH*2)-1:0] output_q_reg_0 = 0;\n    reg [(WIDTH*2)-1:0] output_i_reg_1 = 0;\n    reg [(WIDTH*2)-1:0] output_q_reg_1 = 0;\n    wire transfer = input_a_tvalid & input_b_tvalid & output_tready;\n    assign input_a_tready = input_b_tvalid & output_tready;\n    assign input_b_tready = input_a_tvalid & output_tready;\n    assign output_i_tdata = output_i_reg_1;\n    assign output_q_tdata = output_q_reg_1;\n    assign output_tvalid = input_a_tvalid & input_b_tvalid;\n    always @(posedge clk) begin\n        if (rst) begin\n            input_a_i_reg_0 <= 0;\n            input_a_q_reg_0 <= 0;\n            input_a_i_reg_1 <= 0;\n            input_a_q_reg_1 <= 0;\n            input_b_i_reg_0 <= 0;\n            input_b_q_reg_0 <= 0;\n            input_b_i_reg_1 <= 0;\n            input_b_q_reg_1 <= 0;\n            output_i_reg_0 <= 0;\n            output_q_reg_0 <= 0;\n            output_i_reg_1 <= 0;\n            output_q_reg_1 <= 0;\n        end else begin\n            if (transfer) begin\n                input_a_i_reg_0 <= input_a_i_tdata;\n                input_a_q_reg_0 <= input_a_q_tdata;\n                input_b_i_reg_0 <= input_b_i_tdata;\n                input_b_q_reg_0 <= input_b_q_tdata;\n                input_a_i_reg_1 <= input_a_i_reg_0;\n                input_a_q_reg_1 <= input_a_q_reg_0;\n                input_b_i_reg_1 <= input_b_i_reg_0;\n                input_b_q_reg_1 <= input_b_q_reg_0;\n                output_i_reg_0 <= $signed(input_a_i_reg_1) * $signed(input_b_i_reg_1);\n                output_q_reg_0 <= $signed(input_a_q_reg_1) * $signed(input_b_q_reg_1);\n                output_i_reg_1 <= output_i_reg_0;\n                output_q_reg_1 <= output_q_reg_0;\n            end\n        end\n    end\nendmodule"}
{"task_id": 1370, "completion": "wire [6:0] sub_wire0;\n    wire  sub_wire5;\n    wire  sub_wire8;\n    wire [0:0] sub_wire11 = 1'h0;\n    wire [4:4] sub_wire7 = sub_wire0[4:4];\n    wire [0:0] sub_wire6 = sub_wire0[0:0];\n    wire [3:3] sub_wire4 = sub_wire0[3:3];\n    wire [2:2] sub_wire3 = sub_wire0[2:2];\n    wire [5:5] sub_wire2 = sub_wire0[5:5];\n    wire [1:1] sub_wire1 = sub_wire0[1:1];\n    wire  c1 = sub_wire1;\n    wire  c5 = sub_wire2;\n    wire  c2 = sub_wire3;\n    wire  c3 = sub_wire4;\n    wire  locked = sub_wire5;\n    wire  c0 = sub_wire6;\n    wire  c4 = sub_wire7;\n    wire  phasedone = sub_wire8;\n    wire  sub_wire9 = inclk0;\n    wire [1:0] sub_wire10 = {sub_wire11, sub_wire9};\n\n    altpll    altpll_component (\n                .areset (areset),\n                .inclk (sub_wire10),\n                .phasecounterselect (phasecounterselect),\n                .phasestep (phasestep),\n                .scanclk (scanclk),\n                .phaseupdown (phaseupdown),\n                .clk (sub_wire0),\n                .locked (sub_wire5),\n                .phasedone (sub_wire8),\n                .activeclock (),\n                .clkbad (),\n                .clkena ({6{1'b1}}),\n                .clkloss (),\n                .clkswitch (1'b0),\n                .configupdate (1'b0),\n                .enable0 (),\n                .enable1 (),\n                .extclk (),\n                .extclkena ({4{1'b1}}),\n                .fbin (1'b1),\n                .fbmimicbidir (),\n                .fbout (),\n                .fref (),\n                .icdrclk (),\n                .pfdena (1'b1),\n                .pllena (1'b1),\n                .scanaclr (1'b0),\n                .scanclkena (1'b1),\n                .scandata (1'b0),\n                .scandataout (),\n                .scandone (),\n                .scanread (1'b0),\n                .scanwrite (1'b0),\n                .sclkout0 (),\n                .sclkout1 (),\n                .vcooverrange (),\n                .vcounderrange ());\n    defparam\n        altpll_component.bandwidth_type = \"AUTO\",\n        altpll_component.clk0_divide_by = 1,\n        altpll_component.clk0_duty_cycle = 50,\n        altpll_component.clk0_multiply_by = 1,\n        altpll_component.clk0_phase_shift = \"833\",\n        altpll_component.clk1_divide_by = 1,\n        altpll_component.clk1_duty_cycle = 50,\n        altpll_component.clk1_multiply_by = 2,\n        altpll_component.clk1_phase_shift = \"0\",\n        altpll_component.clk2_divide_by = 1,\n        altpll_component.clk2_duty_cycle = 50,\n        altpll_component.clk2_multiply_by = 2,\n        altpll_component.clk2_phase_shift = \"0\",\n        altpll_component.clk3_divide_by = 1,\n        altpll_component.clk3_duty_cycle = 50,\n        altpll_component.clk3_multiply_by = 2,\n        altpll_component.clk3_phase_shift = \"-1250\",\n        altpll_component.clk4_divide_by = 1,\n        altpll_component.clk4_duty_cycle = 50,\n        altpll_component.clk4_multiply_by = 2,\n        altpll_component.clk4_phase_shift = \"0\",\n        altpll_component.clk5_divide_by = 1,\n        altpll_component.clk5_duty_cycle = 50,\n        altpll_component.clk5_multiply_by = 2,\n        altpll_component.clk5_phase_shift = \"0\",\n        altpll_component.inclk0_input_frequency = 10000,\n        altpll_component.intended_device_family = \"Arria II GX\",\n        altpll_component.lpm_type = \"altpll\",\n        altpll_component.operation_mode = \"NO_COMPENSATION\",\n        altpll_component.pll_type = \"Left_Right\",\n        altpll_component.port_activeclock = \"PORT_UNUSED\",\n        altpll_component.port_areset = \"PORT_USED\",\n        altpll_component.port_clkbad0 = \"PORT_UNUSED\",\n        altpll_component.port_clkbad1 = \"PORT_UNUSED\",\n        altpll_component.port_clkloss = \"PORT_UNUSED\",\n        altpll_component.port_clkswitch = \"PORT_UNUSED\",\n        altpll_component.port_configupdate = \"PORT_UNUSED\",\n        altpll_component.port_fbin = \"PORT_UNUSED\",\n        altpll_component.port_fbout = \"PORT_UNUSED\",\n        altpll_component.port_inclk0 = \"PORT_USED\",\n        altpll_component.port_inclk1 = \"PORT_UNUSED\",\n        altpll_component.port_locked = \"PORT_USED\",\n        altpll_component.port_pfdena = \"PORT_UNUSED\",\n        altpll_component.port_phasecounterselect = \"PORT_USED\",\n        altpll_component.port_phasedone = \"PORT_USED\",\n        altpll_component.port_phasestep = \"PORT_USED\",\n        altpll_component.port_phaseupdown = \"PORT_USED\",\n        altpll_component.port_pllena = \"PORT_UNUSED\",\n        altpll_component.port_scanaclr = \"PORT_UNUSED\",\n        altpll_component.port_scanclk = \"PORT_USED\",\n        altpll_component.port_scanclkena = \"PORT_UNUSED\",\n        altpll_component.port_scandata = \"PORT_UNUSED\",\n        altpll_component.port_scandataout = \"PORT_UNUSED\",\n        altpll_component.port_scandone = \"PORT_UNUSED\",\n        altpll_component.port_scanread = \"PORT_UNUSED\",\n        altpll_component.port_scanwrite = \"PORT_UNUSED\",\n        altpll_component.port_clk0 = \"PORT_USED\",\n        altpll_component.port_clk1 = \"PORT_USED\",\n        altpll_component.port_clk2 = \"PORT_USED\",\n        altpll_component.port_clk3 = \"PORT_USED\",\n        altpll_component.port_clk4 = \"PORT_USED\",\n        altpll_component.port_clk5 = \"PORT_USED\",\n        altpll_component.port_clk6 = \"PORT_UNUSED\",\n        altpll_component.port_clk7 = \"PORT_UNUSED\",\n        altpll_component.port_clk8 = \"PORT_UNUSED\",\n        altpll_component.port_clk9 = \"PORT_UNUSED\",\n        altpll_component.port_clkena0 = \"PORT_UNUSED\",\n        altpll_component.port_clkena1 = \"PORT_UNUSED\",\n        altpll_component.port_clkena2 = \"PORT_UNUSED\",\n        altpll_component.port_clkena3 = \"PORT_UNUSED\",\n        altpll_component.port_clkena4 = \"PORT_UNUSED\",\n        altpll_component.port_clkena5 = \"PORT_UNUSED\",\n        altpll_component.self_reset_on_loss_lock = \"OFF\",\n        altpll_component.using_fbmimicbidir_port = \"OFF\",\n        altpll_component.vco_frequency_control = \"MANUAL_PHASE\",\n        altpll_component.vco_phase_shift_step = 78,\n        altpll_component.width_clock = 7;\n\nendmodule"}
{"task_id": 1450, "completion": "reg [25:0] cuenta_para_1hz = 0;    parameter [6:0] cero  =  ~7'h3F;    parameter [6:0] uno   =  ~7'h06;    parameter [6:0] dos   =  ~7'h5B;    parameter [6:0] tres  =  ~7'h4F;    parameter [6:0] cuatro = ~7'h66;    parameter [6:0] cinco = ~7'h6D;    parameter [6:0] seis  =  ~7'h7D;    parameter [6:0] siete = ~7'h07;    parameter [6:0] ocho  =  ~7'h7F;    parameter [6:0] nueve = ~7'h6F;    parameter [6:0] ha    = ~7'h77;    parameter [6:0] hb    = ~7'h7C;    parameter [6:0] hc    = ~7'h39;    parameter [6:0] hd    = ~7'h5E;    parameter [6:0] he    = ~7'h79;    parameter [6:0] hf    = ~7'h71;    always @(posedge clock_50mhz)    begin        cuenta_para_1hz = cuenta_para_1hz + 1;        if(cuenta_para_1hz == 25_000_000)        begin            clock_1hz = ~clock_1hz;            cuenta_para_1hz = 0;        end    end    always @(posedge clock_1hz)    begin        case(estado)            0: estado <= 1;            1: estado <= 2;            2: estado <= 3;            3: estado <= 4;            4: estado <= 5;            5: estado <= 6;            6: estado <= 7;            7: estado <= 8;            8: estado <= 9;            9: estado <= 10;            10: estado <= 11;            11: estado <= 12;            12: estado <= 13;            13: estado <= 14;            14: estado <= 15;            15: estado <= 0;        endcase    end    always @(estado)    begin        case(estado)            0: segmentos = cero;            1: segmentos = uno;            2: segmentos = dos;            3: segmentos = tres;            4: segmentos = cuatro;            5: segmentos = cinco;            6: segmentos = seis;            7: segmentos = siete;            8: segmentos = ocho;            9: segmentos = nueve;            10: segmentos = ha;            11: segmentos = hb;            12: segmentos = hc;            13: segmentos = hd;            14: segmentos = he;            15: segmentos = hf;        endcase    endendmodule"}
{"task_id": 1464, "completion": "reg [adr_width-1:0] flash_adr_r;\n    reg [15:0] flash_do;\n    reg lsb;\n\n    assign two_cycle_transfer = (wb_sel_i == 4'b1111);\n    assign flash_adr = {flash_adr_r[adr_width-1:1], (two_cycle_transfer) ? lsb : flash_adr_r[0]};\n    assign flash_d = flash_oe_n ? flash_do : 16'bz;\n\n    reg load;\n    reg store;\n\n    always @(posedge sys_clk) begin\n\tflash_oe_n <= 1'b1;\n\tflash_we_n <= 1'b1;\n\n\tif(wb_cyc_i & wb_stb_i) begin\n\t\tflash_adr_r <= wb_adr_i[adr_width:1];\n\t\tif(wb_we_i)\n\t\t\tcase(wb_sel_i)\n\t\t\t\t4'b0011: flash_do <= wb_dat_i[15:0];\n\t\t\t\t4'b1100: flash_do <= wb_dat_i[31:16];\n\t\t\t\tdefault: flash_do <= 16'hxxxx;\n\t\t\tendcase\n\t\telse\n\t\t\tflash_oe_n <= 1'b0;\n\tend\n\n\tif(load) begin\n\t\tcasex({wb_sel_i, lsb})\n\t\t\t5'b0001x: wb_dat_o <= {4{flash_d[7:0]}};\n\t\t\t5'b0010x: wb_dat_o <= {4{flash_d[15:8]}};\n\t\t\t5'b0100x: wb_dat_o <= {4{flash_d[7:0]}};\n\t\t\t5'b1000x: wb_dat_o <= {4{flash_d[15:8]}};\n\t\t\t5'b0011x: wb_dat_o <= {2{flash_d}};\n\t\t\t5'b1100x: wb_dat_o <= {2{flash_d}};\n\t\t\t5'b11110: begin wb_dat_o[31:16] <= flash_d; lsb <= ~lsb; end\n\t\t\t5'b11111: begin wb_dat_o[15:0]  <= flash_d; lsb <= ~lsb; end\n\t\t\tdefault:  wb_dat_o <= 32'hxxxxxxxx;\n\t\t\tendcase\n\tend\n\tif(store)\n\t\tflash_we_n <= 1'b0;\n\tif(sys_rst)\n\t\tlsb <= 1'b0;\nend\n\n    reg [3:0] counter;\n    reg counter_en;\n    reg counter_wr_mode;\n    wire counter_done = counter_wr_mode\n\t\t? (counter == wr_timing)\n\t\t: (counter == rd_timing);\n    always @(posedge sys_clk) begin\n\tif(sys_rst)\n\t\tcounter <= 4'd0;\n\telse begin\n\t\tif(counter_en & ~counter_done)\n\t\t\tcounter <= counter + 4'd1;\n\t\telse\n\t\t\tcounter <= 4'd0;\n\tend\nend\n\n    parameter IDLE\t\t\t= 2'd0;\n    parameter DELAYRD\t= 2'd1;\n    parameter DELAYWR\t= 2'd2;\n    parameter ACK\t\t= 2'd3;\n\n    reg [1:0] state;\n    reg [1:0] next_state;\n\n    always @(posedge sys_clk) begin\n\tif(sys_rst)\n\t\tstate <= IDLE;\n\telse\n\t\tstate <= next_state;\n    end\n\n    always @(*) begin\n\tnext_state = state;\n\tcounter_en = 1'b0;\n\tcounter_wr_mode = 1'b0;\n\tload = 1'b0;\n\tstore = 1'b0;\n\twb_ack_o = 1'b0;\n\n\tcase(state)\n\t\tIDLE: begin\n\t\t\tif(wb_cyc_i & wb_stb_i) begin\n\t\t\t\tif(wb_we_i)\n\t\t\t\t\tnext_state = DELAYWR;\n\t\t\t\telse\n\t\t\t\t\tnext_state = DELAYRD;\n\t\t\tend\n\t\tend\n\n\t\tDELAYRD: begin\n\t\t\tcounter_en = 1'b1;\n\t\t\tif(counter_done) begin\n\t\t\t\tload = 1'b1;\n\t\t\t\tif(~two_cycle_transfer | lsb)\n\t\t\t\t\tnext_state = ACK;\n\t\t\tend\n\t\tend\n\n\t\tDELAYWR: begin\n\t\t\tcounter_wr_mode = 1'b1;\n\t\t\tcounter_en = 1'b1;\n\t\t\tstore = 1'b1;\n\t\t\tif(counter_done)\n\t\t\t\tnext_state = ACK;\n\t\tend\n\n\t\tACK: begin\n\t\t\twb_ack_o = 1'b1;\n\t\t\tnext_state = IDLE;\n\t\tend\n\tendcase\nend\n\nendmodule"}
{"task_id": 1463, "completion": "// synthesis translate_off\n\n      FIFO_GENERATOR_V4_3 #(\n\t\t.C_COMMON_CLOCK(0),\n\t\t.C_COUNT_TYPE(0),\n\t\t.C_DATA_COUNT_WIDTH(10),\n\t\t.C_DEFAULT_VALUE(\"BlankString\"),\n\t\t.C_DIN_WIDTH(36),\n\t\t.C_DOUT_RST_VAL(\"0\"),\n\t\t.C_DOUT_WIDTH(36),\n\t\t.C_ENABLE_RLOCS(0),\n\t\t.C_FAMILY(\"spartan3\"),\n\t\t.C_FULL_FLAGS_RST_VAL(1),\n\t\t.C_HAS_ALMOST_EMPTY(0),\n\t\t.C_HAS_ALMOST_FULL(0),\n\t\t.C_HAS_BACKUP(0),\n\t\t.C_HAS_DATA_COUNT(0),\n\t\t.C_HAS_INT_CLK(0),\n\t\t.C_HAS_MEMINIT_FILE(0),\n\t\t.C_HAS_OVERFLOW(0),\n\t\t.C_HAS_RD_DATA_COUNT(1),\n\t\t.C_HAS_RD_RST(0),\n\t\t.C_HAS_RST(1),\n\t\t.C_HAS_SRST(0),\n\t\t.C_HAS_UNDERFLOW(0),\n\t\t.C_HAS_VALID(0),\n\t\t.C_HAS_WR_ACK(0),\n\t\t.C_HAS_WR_DATA_COUNT(1),\n\t\t.C_HAS_WR_RST(0),\n\t\t.C_IMPLEMENTATION_TYPE(2),\n\t\t.C_INIT_WR_PNTR_VAL(0),\n\t\t.C_MEMORY_TYPE(1),\n\t\t.C_MIF_FILE_NAME(\"BlankString\"),\n\t\t.C_MSGON_VAL(1),\n\t\t.C_OPTIMIZATION_MODE(0),\n\t\t.C_OVERFLOW_LOW(0),\n\t\t.C_PRELOAD_LATENCY(0),\n\t\t.C_PRELOAD_REGS(1),\n\t\t.C_PRIM_FIFO_TYPE(\"512x36\"),\n\t\t.C_PROG_EMPTY_THRESH_ASSERT_VAL(4),\n\t\t.C_PROG_EMPTY_THRESH_NEGATE_VAL(5),\n\t\t.C_PROG_EMPTY_TYPE(0),\n\t\t.C_PROG_FULL_THRESH_ASSERT_VAL(511),\n\t\t.C_PROG_FULL_THRESH_NEGATE_VAL(510),\n\t\t.C_PROG_FULL_TYPE(0),\n\t\t.C_RD_DATA_COUNT_WIDTH(10),\n\t\t.C_RD_DEPTH(512),\n\t\t.C_RD_FREQ(1),\n\t\t.C_RD_PNTR_WIDTH(9),\n\t\t.C_UNDERFLOW_LOW(0),\n\t\t.C_USE_DOUT_RST(1),\n\t\t.C_USE_ECC(0),\n\t\t.C_USE_EMBEDDED_REG(0),\n\t\t.C_USE_FIFO16_FLAGS(0),\n\t\t.C_USE_FWFT_DATA_COUNT(1),\n\t\t.C_VALID_LOW(0),\n\t\t.C_WR_ACK_LOW(0),\n\t\t.C_WR_DATA_COUNT_WIDTH(10),\n\t\t.C_WR_DEPTH(512),\n\t\t.C_WR_FREQ(1),\n\t\t.C_WR_PNTR_WIDTH(9),\n\t\t.C_WR_RESPONSE_LATENCY(1))\n\tinst (\n\t\t.DIN(din),\n\t\t.RD_CLK(rd_clk),\n\t\t.RD_EN(rd_en),\n\t\t.RST(rst),\n\t\t.WR_CLK(wr_clk),\n\t\t.WR_EN(wr_en),\n\t\t.DOUT(dout),\n\t\t.EMPTY(empty),\n\t\t.FULL(full),\n\t\t.RD_DATA_COUNT(rd_data_count),\n\t\t.WR_DATA_COUNT(wr_data_count),\n\t\t.CLK(),\n\t\t.INT_CLK(),\n\t\t.BACKUP(),\n\t\t.BACKUP_MARKER(),\n\t\t.PROG_EMPTY_THRESH(),\n\t\t.PROG_EMPTY_THRESH_ASSERT(),\n\t\t.PROG_EMPTY_THRESH_NEGATE(),\n\t\t.PROG_FULL_THRESH(),\n\t\t.PROG_FULL_THRESH_ASSERT(),\n\t\t.PROG_FULL_THRESH_NEGATE(),\n\t\t.RD_RST(),\n\t\t.SRST(),\n\t\t.WR_RST(),\n\t\t.ALMOST_EMPTY(),\n\t\t.ALMOST_FULL(),\n\t\t.DATA_COUNT(),\n\t\t.OVERFLOW(),\n\t\t.PROG_EMPTY(),\n\t\t.PROG_FULL(),\n\t\t.VALID(),\n\t\t.UNDERFLOW(),\n\t\t.WR_ACK(),\n\t\t.SBITERR(),\n\t\t.DBITERR());\n\n\n// synthesis translate_on\n\nendmodule"}
{"task_id": 1470, "completion": "parameter N  = 1;   parameter PW = 104;     //tie offs for Dv   assign dut_active   = 1'b1;   assign clkout       = clk2;       oh_fifo_cdc #(.DW(PW),           .DEPTH(16))   oh_fifo_cdc(.clk_in            (clk1),            .clk_out            (clk2),            /*AUTOINST*/            // Outputs            .wait_out        (wait_out),            .access_out      (access_out),            .packet_out      (packet_out[PW-1:0]),            // Inputs            .nreset            (nreset),            .access_in        (access_in),            .packet_in        (packet_in[PW-1:0]),            .wait_in            (wait_in));   endmodule"}
{"task_id": 1460, "completion": "// \u8ba1\u7b97\u5546\u548c\u4f59\u6570\n    assign q = a / b;\n    assign r = a % b;\n\n    // \u786e\u4fdd\u4f59\u6570\u5728\u6b63\u786e\u7684\u8303\u56f4\u5185\n    assert(b > 0);\n    assert(0 <= r && r < b);\nendmodule"}
{"task_id": 1452, "completion": "localparam stIdle       = 4'b0000;  localparam stWriteValue = 4'b0001;  localparam stWaitSent   = 4'b0010;  localparam stConsume1   = 4'b0011;  localparam stWait       = 4'b0100;  localparam stWriteDummy1= 4'b0101;  localparam stWriteDummy2= 4'b0110;  localparam stRead1      = 4'b0111;  localparam stRead2      = 4'b1000;  localparam stRead3      = 4'b1001;  localparam stPause      = 4'b1010;  reg  [3:0]             SPI_FSM_State;  reg  [3:0]             SPI_FSM_NextState;  wire                   SPI_FSM_TimerOvfl;  reg                    SPI_FSM_TimerPreset;  reg                    SPI_FSM_TimerEnable;  reg                    SPI_FSM_Wr1;  reg                    SPI_FSM_Wr0;  always @(negedge Reset_n_i or posedge Clk_i)  begin  if (!Reset_n_i)  begin  SPI_FSM_State <= stIdle;  end  else  begin  SPI_FSM_State <= SPI_FSM_NextState;  end  end  always @(SPI_FSM_State, Start_i, SPI_Transmission_i, SPI_FSM_TimerOvfl)  begin  SPI_FSM_NextState = SPI_FSM_State;  ADT7310CS_n_o       = 1'b1;  SPI_Data_o          = 8'bxxxxxxxx;  SPI_Write_o         = 1'b0;  SPI_ReadNext_o      = 1'b0;  SPI_FSM_TimerPreset = 1'b1;  SPI_FSM_TimerEnable = 1'b0;  SPI_FSM_Wr1         = 1'b0;  SPI_FSM_Wr0         = 1'b0;  Done_o              = 1'b1;  case (SPI_FSM_State)  stIdle: begin  if (Start_i == 1'b1)  begin  SPI_FSM_NextState = stWriteValue;  ADT7310CS_n_o     = 1'b0;  SPI_Data_o        = 8'h08;  SPI_Write_o       = 1'b1;  Done_o            = 1'b0;  end  end  stWriteValue: begin  SPI_FSM_NextState   = stWaitSent;  ADT7310CS_n_o       = 1'b0;  SPI_Data_o          = 8'h20;  SPI_Write_o         = 1'b1;  Done_o              = 1'b0;  end  stWaitSent: begin  ADT7310CS_n_o       = 1'b0;  Done_o              = 1'b0;  if (SPI_Transmission_i == 1'b0)  begin  SPI_FSM_NextState   = stConsume1;  SPI_ReadNext_o      = 1'b1;  end  end  stConsume1: begin  SPI_FSM_NextState   = stWait;  ADT7310CS_n_o       = 1'b0;  Done_o              = 1'b0;  SPI_ReadNext_o      = 1'b1;  SPI_FSM_TimerPreset = 1'b0;  SPI_FSM_TimerEnable = 1'b1;  end  stWait: begin  ADT7310CS_n_o       = 1'b1;  Done_o              = 1'b0;  if (SPI_FSM_TimerOvfl == 1'b0)  begin  SPI_FSM_TimerPreset = 1'b0;  SPI_FSM_TimerEnable = 1'b1;  end  else  begin  ADT7310CS_n_o       = 1'b0;  SPI_FSM_NextState   = stWriteDummy1;  SPI_Data_o          = 8'h50;  SPI_Write_o         = 1'b1;  end  end  stWriteDummy1: begin  SPI_FSM_NextState   = stWriteDummy2;  ADT7310CS_n_o       = 1'b0;  Done_o              = 1'b0;  SPI_Data_o          = 8'hFF;  SPI_Write_o         = 1'b1;  end  stWriteDummy2: begin  SPI_FSM_NextState   = stRead1;  ADT7310CS_n_o       = 1'b0;  Done_o              = 1'b0;  SPI_Data_o          = 8'hFF;  SPI_Write_o         = 1'b1;  end  stRead1: begin  ADT7310CS_n_o       = 1'b0;  Done_o              = 1'b0;  if (SPI_Transmission_i == 1'b0) begin  SPI_FSM_NextState = stRead2;  SPI_ReadNext_o    = 1'b1;  end  end  stRead2: begin  Done_o              = 1'b0;  SPI_ReadNext_o      = 1'b1;  SPI_FSM_Wr1         = 1'b1;  SPI_FSM_NextState   = stRead3;  end  stRead3: begin  Done_o              = 1'b0;  SPI_ReadNext_o      = 1'b1;  SPI_FSM_Wr0         = 1'b1;  SPI_FSM_NextState   = stPause;  end  stPause: begin  SPI_FSM_NextState = stIdle;  end  default: begin  end  endcase  end  always @(negedge Reset_n_i or posedge Clk_i)  begin  if (!Reset_n_i)  begin  Byte0_o <= 8'd0;  Byte1_o <= 8'd0;  end  else  begin  if (SPI_FSM_Wr0)  begin  Byte0_o <= SPI_Data_i;  end  if (SPI_FSM_Wr1)  begin  Byte1_o <= SPI_Data_i;  end  end  end  reg [15:0] SPI_FSM_Timer;  always @(negedge Reset_n_i or posedge Clk_i)  begin  if (!Reset_n_i)  begin  SPI_FSM_Timer <= 16'd0;  end  else  begin  if (SPI_FSM_TimerPreset)  begin  SPI_FSM_Timer <= ParamCounterPreset_i;  end  else if (SPI_FSM_TimerEnable)  begin  SPI_FSM_Timer <= SPI_FSM_Timer - 1'b1;  end  end  end  assign SPI_FSM_TimerOvfl = (SPI_FSM_Timer == 0) ? 1'b1 : 1'b0;  endmodule"}
{"task_id": 1478, "completion": "localparam IDLE = 1'b0;\n    localparam HRESPEXTEND = 1'b1;\n    reg defSlaveSMNextState;\n    reg defSlaveSMCurrentState;\n    always @ ( * )\n    begin\n        DEFSLAVEDATAREADY = 1'b1;\n        HRESP_DEFAULT = 1'b0;\n        case ( defSlaveSMCurrentState )\n        IDLE:\n        begin\n            if ( DEFSLAVEDATASEL )\n            begin\n                DEFSLAVEDATAREADY = 1'b0;\n                HRESP_DEFAULT = 1'b1;\n                defSlaveSMNextState = HRESPEXTEND;\n            end\n            else\n                defSlaveSMNextState = IDLE;\n        end\n        HRESPEXTEND:\n        begin\n            HRESP_DEFAULT = 1'b1;\n            defSlaveSMNextState = IDLE;\n        end\n        default:\n            defSlaveSMNextState = IDLE;\n        endcase\n    end\n    always @ ( posedge HCLK or negedge HRESETN )\n    begin\n        if ( !HRESETN )\n            defSlaveSMCurrentState <= IDLE;\n        else\n            defSlaveSMCurrentState <= defSlaveSMNextState;\n    end\nendmodule"}
{"task_id": 1360, "completion": "FIFO_GENERATOR_V9_3 #(\n    .C_ADD_NGC_CONSTRAINT(0),\n    .C_APPLICATION_TYPE_AXIS(0),\n    .C_APPLICATION_TYPE_RACH(0),\n    .C_APPLICATION_TYPE_RDCH(0),\n    .C_APPLICATION_TYPE_WACH(0),\n    .C_APPLICATION_TYPE_WDCH(0),\n    .C_APPLICATION_TYPE_WRCH(0),\n    .C_AXI_ADDR_WIDTH(32),\n    .C_AXI_ARUSER_WIDTH(1),\n    .C_AXI_AWUSER_WIDTH(1),\n    .C_AXI_BUSER_WIDTH(1),\n    .C_AXI_DATA_WIDTH(64),\n    .C_AXI_ID_WIDTH(4),\n    .C_AXI_RUSER_WIDTH(1),\n    .C_AXI_TYPE(0),\n    .C_AXIS_TDATA_WIDTH(64),\n    .C_AXIS_TDEST_WIDTH(4),\n    .C_AXIS_TID_WIDTH(8),\n    .C_AXIS_TKEEP_WIDTH(4),\n    .C_AXIS_TSTRB_WIDTH(4),\n    .C_AXIS_TUSER_WIDTH(4),\n    .C_AXIS_TYPE(0),\n    .C_COMMON_CLOCK(0),\n    .C_COUNT_TYPE(0),\n    .C_DATA_COUNT_WIDTH(9),\n    .C_DEFAULT_VALUE(\"BlankString\"),\n    .C_DIN_WIDTH(64),\n    .C_DOUT_RST_VAL(\"0\"),\n    .C_DOUT_WIDTH(64),\n    .C_ENABLE_RST_SYNC(1),\n    .C_FAMILY(\"zynq\"),\n    .C_FULL_FLAGS_RST_VAL(1),\n    .C_RD_DEPTH(512),\n    .C_RD_DATA_COUNT_WIDTH(9),\n    .C_WR_DEPTH(512),\n    .C_WR_DATA_COUNT_WIDTH(9)\n  )\n  inst (\n    .RST(rst),\n    .WR_CLK(wr_clk),\n    .RD_CLK(rd_clk),\n    .DIN(din),\n    .WR_EN(wr_en),\n    .RD_EN(rd_en),\n    .DOUT(dout),\n    .FULL(full),\n    .EMPTY(empty),\n    .RD_DATA_COUNT(rd_data_count),\n    .WR_DATA_COUNT(wr_data_count),\n    .BACKUP(),\n    .BACKUP_MARKER(),\n    .CLK(),\n    .SRST(),\n    .WR_RST(),\n    .RD_RST(),\n    .PROG_EMPTY_THRESH(),\n    .PROG_EMPTY_THRESH_ASSERT(),\n    .PROG_EMPTY_THRESH_NEGATE(),\n    .PROG_FULL_THRESH(),\n    .PROG_FULL_THRESH_ASSERT(),\n    .PROG_FULL_THRESH_NEGATE(),\n    .INT_CLK(),\n    .INJECTDBITERR(),\n    .INJECTSBITERR()\n  );\n\nendmodule"}
{"task_id": 1411, "completion": "RAMB16_S1 BRAM_PC_VGA_0 (\n\t.CLK(clk),\n\t.EN(1'b1),\n\t.WE(1'b0),\n\t.ADDR({ascii_code[6:1], ~ascii_code[0], row, ~col}),\n\t.SSR(1'b0),\n\t.DI(1'b0),\n\t.DO(row_of_pixels)\n\t);\n\t \ndefparam BRAM_PC_VGA_0.INIT_00 = 256'h00007c060c3c66c2c0c0c0c2663c00000000000076cccccccccccc0000cc0000;\ndefparam BRAM_PC_VGA_0.INIT_01 = 256'h000000007cc6c0c0fec67c0030180c000000000076cccccc7c0c78006c381000;\ndefparam BRAM_PC_VGA_0.INIT_02 = 256'h0000000076cccccc7c0c780000cc00000000000076cccccc7c0c780018306000;\ndefparam BRAM_PC_VGA_0.INIT_03 = 256'h0000000076cccccc7c0c7800386c38000000003c060c3c666060663c00000000;\ndefparam BRAM_PC_VGA_0.INIT_04 = 256'h000000007cc6c0c0fec67c006c381000000000007cc6c0c0fec67c0000c60000;\ndefparam BRAM_PC_VGA_0.INIT_05 = 256'h000000007cc6c0c0fec67c0018306000000000003c1818181818380000660000;\ndefparam BRAM_PC_VGA_0.INIT_06 = 256'h000000003c18181818183800663c1800000000003c1818181818380018306000;\ndefparam BRAM_PC_VGA_0.INIT_07 = 256'h00000000c6c6c6fec6c66c381000c60000000000c6c6c6fec6c66c3800386c38;\ndefparam BRAM_PC_VGA_0.INIT_08 = 256'h00000000fe6660607c6066fe006030180000000077dcd87e1b3b6e0000000000;\ndefparam BRAM_PC_VGA_0.INIT_09 = 256'h00000000ceccccccccfecccc6c3e0000000000007cc6c6c6c6c67c006c381000;\ndefparam BRAM_PC_VGA_0.INIT_0A = 256'h000000007cc6c6c6c6c67c0000c60000000000007cc6c6c6c6c67c0018306000;\ndefparam BRAM_PC_VGA_0.INIT_0B = 256'h0000000076cccccccccccc00cc7830000000000076cccccccccccc0018306000;\ndefparam BRAM_PC_VGA_0.INIT_0C = 256'h00780c067ec6c6c6c6c6c60000c60000000000007cc6c6c6c6c6c6c67c00c600;\ndefparam BRAM_PC_VGA_0.INIT_0D = 256'h000000007cc6c6c6c6c6c6c6c600c6000000000018187ec3c0c0c0c37e181800;\ndefparam BRAM_PC_VGA_0.INIT_0E = 256'h00000000fce660606060f060646c380000000000181818ff18ff183c66c30000;\ndefparam BRAM_PC_VGA_0.INIT_0F = 256'h00000000f36666666f66627c6666fc00000070d818181818187e1818181b0e00;\ndefparam BRAM_PC_VGA_0.INIT_10 = 256'h0000000076cccccc7c0c780060301800000000003c1818181818380030180c00;\ndefparam BRAM_PC_VGA_0.INIT_11 = 256'h000000007cc6c6c6c6c67c00603018000000000076cccccccccccc0060301800;\ndefparam BRAM_PC_VGA_0.INIT_12 = 256'h00000000666666666666dc00dc76000000000000c6c6c6cedefef6e6c600dc76;\ndefparam BRAM_PC_VGA_0.INIT_13 = 256'h0000000000000000007e003e6c6c3c000000000000000000007c00386c6c3800;\ndefparam BRAM_PC_VGA_0.INIT_14 = 256'h000000007cc6c6c060303000303000000000000000c0c0c0c0fe000000000000;\ndefparam BRAM_PC_VGA_0.INIT_15 = 256'h000000000006060606fe00000000000000001f0c069bce603018ccc6c2c0c000;\ndefparam BRAM_PC_VGA_0.INIT_16 = 256'h000006063e96ce663018ccc6c2c0c00000000000183c3c3c1818180018180000;\ndefparam BRAM_PC_VGA_0.INIT_17 = 256'h000000000000366cd86c360000000000000000000000d86c366cd80000000000;\ndefparam BRAM_PC_VGA_0.INIT_18 = 256'h44114411441144114411441144114411aa55aa55aa55aa55aa55aa55aa55aa55;\ndefparam BRAM_PC_VGA_0.INIT_19 = 256'h77dd77dd77dd77dd77dd77dd77dd77dd18181818181818181818181818181818;\ndefparam BRAM_PC_VGA_0.INIT_1A = 256'h1818181818181818f8181818181818181818181818181818f818f81818181818;\ndefparam BRAM_PC_VGA_0.INIT_1B = 256'h3636363636363636f6363636363636363636363636363636fe00000000000000;\ndefparam BRAM_PC_VGA_0.INIT_1C = 256'h1818181818181818f818f800000000003636363636363636f606f63636363636;\ndefparam BRAM_PC_VGA_0.INIT_1D = 256'h363636363636363636363636363636363636363636363636f606fe0000000000;\ndefparam BRAM_PC_VGA_0.INIT_1E = 256'h0000000000000000fe06f636363636360000000000000000fe36363636363636;\ndefparam BRAM_PC_VGA_0.INIT_1F = 256'h0000000000000000f818f818181818181818181818181818f800000000000000;\ndefparam BRAM_PC_VGA_0.INIT_20 = 256'h00000000000000001f181818181818180000000000000000ff18181818181818;\ndefparam BRAM_PC_VGA_0.INIT_21 = 256'h1818181818181818ff0000000000000018181818181818181f18181818181818;\ndefparam BRAM_PC_VGA_0.INIT_22 = 256'h0000000000000000ff000000000000001818181818181818ff18181818181818;\ndefparam BRAM_PC_VGA_0.INIT_23 = 256'h18181818181818181f181f181818181836363636363636363736363636363636;\ndefparam BRAM_PC_VGA_0.INIT_24 = 256'h00000000000000003f30373636363636363636363636363637303f0000000000;\ndefparam BRAM_PC_VGA_0.INIT_25 = 256'h0000000000000000ff00f736363636363636363636363636f700ff0000000000;\ndefparam BRAM_PC_VGA_0.INIT_26 = 256'h363636363636363637303736363636360000000000000000ff00ff0000000000;\ndefparam BRAM_PC_VGA_0.INIT_27 = 256'h3636363636363636f700f736363636360000000000000000ff00ff1818181818;\ndefparam BRAM_PC_VGA_0.INIT_28 = 256'h0000000000000000ff363636363636361818181818181818ff00ff0000000000;\ndefparam BRAM_PC_VGA_0.INIT_29 = 256'h3636363636363636ff0000000000000000000000000000003f36363636363636;\ndefparam BRAM_PC_VGA_0.INIT_2A = 256'h00000000000000001f181f181818181818181818181818181f181f0000000000;\ndefparam BRAM_PC_VGA_0.INIT_2B = 256'h36363636363636363f000000000000003636363636363636ff36363636363636;\ndefparam BRAM_PC_VGA_0.INIT_2C = 256'h1818181818181818ff18ff18181818180000000000000000f818181818181818;\ndefparam BRAM_PC_VGA_0.INIT_2D = 256'h18181818181818181f00000000000000ffffffffffffffffffffffffffffffff;\ndefparam BRAM_PC_VGA_0.INIT_2E = 256'hffffffffffffffffff00000000000000f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0;\ndefparam BRAM_PC_VGA_0.INIT_2F = 256'h0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f000000000000000000ffffffffffffff;\ndefparam BRAM_PC_VGA_0.INIT_30 = 256'h0000000076dcd8d8d8dc76000000000000000000ccc6c6c6ccd8cccccc780000;\ndefparam BRAM_PC_VGA_0.INIT_31 = 256'h00000000c0c0c0c0c0c0c0c6c6fe0000000000006c6c6c6c6c6c6cfe00000000;\ndefparam BRAM_PC_VGA_0.INIT_32 = 256'h00000000fec66030183060c6fe0000000000000070d8d8d8d8d87e0000000000;\ndefparam BRAM_PC_VGA_0.INIT_33 = 256'h000000c060607c66666666660000000000000000181818181818dc7600000000;\ndefparam BRAM_PC_VGA_0.INIT_34 = 256'h000000007e183c6666663c187e00000000000000386cc6c6fec6c66c38000000;\ndefparam BRAM_PC_VGA_0.INIT_35 = 256'h00000000ee6c6c6c6cc6c6c66c380000000000003c666666663e0c18301e0000;\ndefparam BRAM_PC_VGA_0.INIT_36 = 256'h0000000000007edbdbdb7e000000000000000000c0607ef3dbdb7e0603000000;\ndefparam BRAM_PC_VGA_0.INIT_37 = 256'h000000001c306060607c6060301c000000000000c6c6c6c6c6c6c6c67c000000;\ndefparam BRAM_PC_VGA_0.INIT_38 = 256'h0000000000fe0000fe0000fe0000000000000000ff000018187e181800000000;\ndefparam BRAM_PC_VGA_0.INIT_39 = 256'h000000007e0030180c060c1830000000000000007e000c18306030180c000000;\ndefparam BRAM_PC_VGA_0.INIT_3A = 256'h181818181818181818181b1b1b0e00000000000070d8d8d81818181818181818;\ndefparam BRAM_PC_VGA_0.INIT_3B = 256'h00000000001818007e00181800000000000000000000dc7600dc760000000000;\ndefparam BRAM_PC_VGA_0.INIT_3C = 256'h0000000000000000000000386c6c380000000000000000181800000000000000;\ndefparam BRAM_PC_VGA_0.INIT_3D = 256'h00000000000000180000000000000000000000001c3c6c6cec0c0c0c0c0c0f00;\ndefparam BRAM_PC_VGA_0.INIT_3E = 256'h0000000000000000006c6c6c6c6cd800000000000000000000f8c86030d87000;\ndefparam BRAM_PC_VGA_0.INIT_3F = 256'h00000000007c7c7c7c7c7c7c0000000000000000000000000000000000000000;\n\t \nendmodule"}
{"task_id": 1481, "completion": "function integer alt_clogb2;      input [31:0] value;      integer i;      begin        alt_clogb2 = 32;        for (i=31; i>0; i=i-1) begin          if (2**i>=value)            alt_clogb2 = i;        end      end    endfunction    parameter DATA_WIDTH = 20;    parameter FIFO_DEPTH = 1920;    parameter CLOCKS_ARE_SAME = 0;    parameter DATA_WIDTHU = alt_clogb2(FIFO_DEPTH);    input wrclk;    input rdreq;    input aclr;    input rdclk;    input wrreq;    input [DATA_WIDTH-1:0] data;    output [DATA_WIDTHU-1:0] rdusedw;    output rdempty;    output [DATA_WIDTHU-1:0] wrusedw;    output wrfull;    output [DATA_WIDTH-1:0] q;    generate        if(CLOCKS_ARE_SAME) begin            assign rdusedw = wrusedw;                        scfifo input_fifo(                .rdreq(rdreq),                .aclr(aclr),                .clock(wrclk),                .wrreq(wrreq),                .data(data),                .empty(rdempty),                .full(wrfull),                .usedw(wrusedw),                .q(q));            defparam                input_fifo.add_ram_output_register = \"OFF\",                input_fifo.lpm_hint = \"MAXIMIZE_SPEED=7,\",                  input_fifo.lpm_numwords = FIFO_DEPTH,                input_fifo.lpm_showahead = \"OFF\",                input_fifo.lpm_type = \"scfifo\",                input_fifo.lpm_width = DATA_WIDTH,                input_fifo.lpm_widthu = DATA_WIDTHU,                input_fifo.overflow_checking = \"OFF\",                input_fifo.underflow_checking = \"OFF\",                input_fifo.use_eab = \"ON\";        end else begin            dcfifo input_fifo(                .wrclk(wrclk),                .rdreq(rdreq),                .aclr(aclr),                .rdclk(rdclk),                .wrreq(wrreq),                .data(data),                .rdusedw(rdusedw),                .rdempty(rdempty),                .wrfull(wrfull),                .wrusedw(wrusedw),                .q(q));            defparam                input_fifo.lpm_hint = \"MAXIMIZE_SPEED=7,\",                input_fifo.lpm_numwords = FIFO_DEPTH,                input_fifo.lpm_showahead = \"OFF\",                input_fifo.lpm_type = \"dcfifo\",                input_fifo.lpm_width = DATA_WIDTH,                input_fifo.lpm_widthu = DATA_WIDTHU,                input_fifo.overflow_checking = \"OFF\",                input_fifo.rdsync_delaypipe = 5,                input_fifo.underflow_checking = \"OFF\",                input_fifo.use_eab = \"ON\",                input_fifo.wrsync_delaypipe = 5,                input_fifo.read_aclr_synch = \"ON\";        end    endgenerate    endmodule"}
{"task_id": 1480, "completion": "input clk;\ninput reset;\ninput [DW: 0] stream_in_data;\ninput stream_in_startofpacket;\ninput stream_in_endofpacket;\ninput stream_in_valid;\noutput stream_in_ready;\ninput stream_out_ready;\noutput reg [DW: 0] stream_out_data;\noutput reg stream_out_startofpacket;\noutput reg stream_out_endofpacket;\noutput reg stream_out_valid;\n\nwire [DW: 0] converted_data;\n\nalways @(posedge clk) begin\n\tif (reset) begin\n\t\tstream_out_data <= 'b0;\n\t\tstream_out_startofpacket <= 1'b0;\n\t\tstream_out_endofpacket <= 1'b0;\n\t\tstream_out_valid <= 1'b0;\n\tend else if (stream_out_ready | ~stream_out_valid) begin\n\t\tstream_out_data <= converted_data;\n\t\tstream_out_startofpacket <= stream_in_startofpacket;\n\t\tstream_out_endofpacket <= stream_in_endofpacket;\n\t\tstream_out_valid <= stream_in_valid;\n\tend\nend\n\nassign stream_in_ready = stream_out_ready | ~stream_out_valid;\nassign converted_data = (stream_in_data[CW:0] == COLOR) ? {ALPHA, stream_in_data[CW:0]} : stream_in_data;\n\nendmodule"}
{"task_id": 1485, "completion": "reg [31:0] o_data0;\n    reg [31:0] i_data0_reg;\n    wire [30:0] o_data0_from_mult;\n\n    always @(posedge clk) begin\n        i_data0_reg <= i_data0;\n        o_data0 <= o_data0_from_mult;\n    end\n\n    multiplier_block mult_blk(\n        .i_data0(i_data0_reg),\n        .o_data0(o_data0_from_mult)\n    );\n\nendmodule"}
{"task_id": 1467, "completion": "input clk;\n  input rst;\n  function integer clogb2 (input integer size);\n    begin\n      size = size - 1;\n      for (clogb2=1; size>1; clogb2=clogb2+1)\n            size = size >> 1;\n    end\n  endfunction\n  input [nBANK_MACHS-1:0] sending_row;\n  input [RANK_BM_BV_WIDTH-1:0] act_this_rank_r;\n  reg act_this_rank;\n  integer i;\n  always @(/*AS*/act_this_rank_r or sending_row) begin\n    act_this_rank = 1'b0;\n    for (i=0; i<nBANK_MACHS; i=i+1)\n      act_this_rank =\n         act_this_rank || (sending_row[i] && act_this_rank_r[(i*RANKS)+ID]);\n  end\n  localparam nADD_RRD = nRRD - ((nCK_PER_CLK == 1) ? 2 : 4);\n  localparam nRRD_CLKS = (nCK_PER_CLK == 1)\n                            ? nADD_RRD\n                            : ((nADD_RRD/2) + (nADD_RRD%2));\n  localparam ADD_RRD_CNTR_WIDTH = clogb2(nRRD_CLKS + /*idle state*/ 1);\n  reg add_rrd_inhbt = 1'b0;\n  generate\n    if (nADD_RRD > 0) begin :add_rdd\n      reg[ADD_RRD_CNTR_WIDTH-1:0] add_rrd_ns;\n      reg[ADD_RRD_CNTR_WIDTH-1:0] add_rrd_r;\n      always @(/*AS*/act_this_rank or add_rrd_r or rst) begin\n        add_rrd_ns = add_rrd_r;\n        if (rst) add_rrd_ns = {ADD_RRD_CNTR_WIDTH{1'b0}};\n        else\n          if (act_this_rank)\n            add_rrd_ns = nRRD_CLKS[0+:ADD_RRD_CNTR_WIDTH];\n          else if (|add_rrd_r) add_rrd_ns =\n                            add_rrd_r - {{ADD_RRD_CNTR_WIDTH-1{1'b0}}, 1'b1};\n      end\n      always @(posedge clk) add_rrd_r <= #TCQ add_rrd_ns;\n      always @(/*AS*/add_rrd_ns) add_rrd_inhbt = |add_rrd_ns;\n    end\n  endgenerate\n  localparam nFAW_CLKS = (nCK_PER_CLK == 1)\n                           ? nFAW\n                           : ((nFAW/2) + (nFAW%2));\n  output reg inhbt_act_faw_r;\n  generate\n    begin : inhbt_act_faw\n      wire act_delayed;\n      wire [4:0] shift_depth = nFAW_CLKS[4:0] - 5'd3;\n      SRLC32E #(.INIT(32'h00000000) ) SRLC32E0\n        (.Q(act_delayed), // SRL data output\n         .Q31(), // SRL cascade output pin\n         .A(shift_depth), // 5-bit shift depth select input\n         .CE(1'b1), // Clock enable input\n         .CLK(clk), // Clock input\n         .D(act_this_rank) // SRL data input\n        );\n      reg [2:0] faw_cnt_ns;\n      reg [2:0] faw_cnt_r;\n      reg inhbt_act_faw_ns;\n      always @(/*AS*/act_delayed or act_this_rank or add_rrd_inhbt\n               or faw_cnt_r or rst) begin\n        if (rst) faw_cnt_ns = 3'b0;\n        else begin\n          faw_cnt_ns = faw_cnt_r;\n          if (act_this_rank) faw_cnt_ns = faw_cnt_r + 3'b1;\n          if (act_delayed) faw_cnt_ns = faw_cnt_ns - 3'b1;\n        end\n        inhbt_act_faw_ns = (faw_cnt_ns == 3'h4) || add_rrd_inhbt;\n      end\n      always @(posedge clk) faw_cnt_r <= #TCQ faw_cnt_ns;\n      always @(posedge clk) inhbt_act_faw_r <= #TCQ inhbt_act_faw_ns;\n    end // block: inhbt_act_faw\n  endgenerate\n  localparam ONE = 1;\n  localparam CASWR2CASRD = ((BURST_MODE == \"4\") ? 2 : 4) + nWTR + CL;\n  localparam CASWR2CASRD_CLKS = (nCK_PER_CLK == 1)\n                                    ? CASWR2CASRD\n                                    : ((CASWR2CASRD / 2) + (CASWR2CASRD %2));\n  localparam WTR_CNT_WIDTH = clogb2(CASWR2CASRD_CLKS - /*-2 max cnt*/ 1);\n  localparam TWO = 2;\n  input [nBANK_MACHS-1:0] sending_col;\n  input [RANK_BM_BV_WIDTH-1:0] wr_this_rank_r;\n  output reg inhbt_rd_r;\n  output reg wtr_inhbt_config_r;\n  generate\n    begin : wtr_timer\n      reg write_this_rank;\n      always @(/*AS*/sending_col or wr_this_rank_r) begin\n        write_this_rank = 1'b0;\n        for (i = 0; i < nBANK_MACHS; i = i + 1)\n        write_this_rank =\n           write_this_rank || (sending_col[i] && wr_this_rank_r[(i*RANKS)+ID]);\n      end\n      reg [WTR_CNT_WIDTH-1:0] wtr_cnt_r;\n      reg [WTR_CNT_WIDTH-1:0] wtr_cnt_ns;\n      always @(/*AS*/rst or write_this_rank or wtr_cnt_r)\n        if (rst) wtr_cnt_ns = {WTR_CNT_WIDTH{1'b0}};\n        else begin\n          wtr_cnt_ns = wtr_cnt_r;\n          if (write_this_rank) wtr_cnt_ns =\n                 CASWR2CASRD_CLKS[WTR_CNT_WIDTH-1:0] - TWO[WTR_CNT_WIDTH-1:0];\n          else if (|wtr_cnt_r) wtr_cnt_ns = wtr_cnt_r - ONE[WTR_CNT_WIDTH-1:0];\n        end\n      wire inhbt_rd_ns = |wtr_cnt_ns;\n      wire wtr_inhbt_config_ns = wtr_cnt_ns >= TWO[WTR_CNT_WIDTH-1:0];\n      always @(posedge clk) wtr_cnt_r <= #TCQ wtr_cnt_ns;\n      always @(posedge clk) inhbt_rd_r <= #TCQ inhbt_rd_ns;\n      always @(posedge clk) wtr_inhbt_config_r <= #TCQ wtr_inhbt_config_ns;\n    end\n  endgenerate\n  localparam REFRESH_BANK_WIDTH = clogb2(nREFRESH_BANK + 1);\n  input app_ref_req;\n  input dfi_init_complete;\n  input [(RANKS*nBANK_MACHS)-1:0] rank_busy_r;\n  input refresh_tick;\n  input insert_maint_r1;\n  input maint_zq_r;\n  input [RANK_WIDTH-1:0] maint_rank_r;\n  output wire refresh_request;\n  generate begin : refresh_generation\n      reg my_rank_busy;\n      always @(/*AS*/rank_busy_r) begin\n        my_rank_busy = 1'b0;\n        for (i=0; i < nBANK_MACHS; i=i+1)\n          my_rank_busy = my_rank_busy || rank_busy_r[(i*RANKS)+ID];\n      end\n      wire my_refresh =\n        insert_maint_r1 && ~maint_zq_r && (maint_rank_r == ID[RANK_WIDTH-1:0]);\n      reg [REFRESH_BANK_WIDTH-1:0] refresh_bank_r;\n      reg [REFRESH_BANK_WIDTH-1:0] refresh_bank_ns;\n      always @(/*AS*/app_ref_req or dfi_init_complete or my_refresh\n               or refresh_bank_r or refresh_tick)\n        if (~dfi_init_complete)\n          if (REFRESH_TIMER_DIV == 0)\n                refresh_bank_ns = nREFRESH_BANK[0+:REFRESH_BANK_WIDTH];\n          else refresh_bank_ns = {REFRESH_BANK_WIDTH{1'b0}};\n        else\n          case ({my_refresh, refresh_tick, app_ref_req})\n            3'b000, 3'b110, 3'b101, 3'b111 : refresh_bank_ns = refresh_bank_r;\n            3'b010, 3'b001, 3'b011 : refresh_bank_ns =\n                                          (|refresh_bank_r)?\n                                          refresh_bank_r - ONE[0+:REFRESH_BANK_WIDTH]:\n                                          refresh_bank_r;\n            3'b100                 : refresh_bank_ns =\n                                   refresh_bank_r + ONE[0+:REFRESH_BANK_WIDTH];\n          endcase // case ({my_refresh, refresh_tick})\n      always @(posedge clk) refresh_bank_r <= #TCQ refresh_bank_ns;\n      `ifdef MC_SVA\n      refresh_bank_overflow: assert property (@(posedge clk)\n               (rst || (refresh_bank_r <= nREFRESH_BANK)));\n      refresh_bank_underflow: assert property (@(posedge clk)\n               (rst || ~(~|refresh_bank_r && ~my_refresh && refresh_tick)));\n      refresh_hi_priority: cover property (@(posedge clk)\n               (rst && ~|refresh_bank_ns && (refresh_bank_r ==\n                       ONE[0+:REFRESH_BANK_WIDTH])));\n      refresh_bank_full: cover property (@(posedge clk)\n               (rst && (refresh_bank_r ==\n                        nREFRESH_BANK[0+:REFRESH_BANK_WIDTH])));\n      `endif\n      assign refresh_request = dfi_init_complete &&\n              (~|refresh_bank_r ||\n  ((refresh_bank_r != nREFRESH_BANK[0+:REFRESH_BANK_WIDTH]) && ~my_rank_busy));\n    end\n  endgenerate\n  localparam PERIODIC_RD_TIMER_WIDTH = clogb2(PERIODIC_RD_TIMER_DIV + /*idle state*/ 1);\n  input app_periodic_rd_req;\n  input maint_prescaler_tick_r;\n  output periodic_rd_request;\n  input clear_periodic_rd_request;\n  input [RANK_BM_BV_WIDTH-1:0] rd_this_rank_r;\n  generate begin : periodic_rd_generation\n    if ( PHASE_DETECT != \"OFF\" ) begin //to enable periodic reads\n      reg read_this_rank;\n      always @(/*AS*/rd_this_rank_r or sending_col) begin\n        read_this_rank = 1'b0;\n        for (i = 0; i < nBANK_MACHS; i = i + 1)\n        read_this_rank =\n           read_this_rank || (sending_col[i] && rd_this_rank_r[(i*RANKS)+ID]);\n      end\n      reg [PERIODIC_RD_TIMER_WIDTH-1:0] periodic_rd_timer_r;\n      reg [PERIODIC_RD_TIMER_WIDTH-1:0] periodic_rd_timer_ns;\n      always @(/*AS*/dfi_init_complete or maint_prescaler_tick_r\n               or periodic_rd_timer_r or read_this_rank) begin\n        periodic_rd_timer_ns = periodic_rd_timer_r;\n        if (~dfi_init_complete)\n          periodic_rd_timer_ns = {PERIODIC_RD_TIMER_WIDTH{1'b0}};\n        else if (read_this_rank)\n                periodic_rd_timer_ns =\n                   PERIODIC_RD_TIMER_DIV[0+:PERIODIC_RD_TIMER_WIDTH];\n             else if (|periodic_rd_timer_r && maint_prescaler_tick_r)\n                 periodic_rd_timer_ns =\n                   periodic_rd_timer_r - ONE[0+:PERIODIC_RD_TIMER_WIDTH];\n      end\n      always @(posedge clk) periodic_rd_timer_r <= #TCQ periodic_rd_timer_ns;\n      wire periodic_rd_timer_one = maint_prescaler_tick_r &&\n                 (periodic_rd_timer_r == ONE[0+:PERIODIC_RD_TIMER_WIDTH]);\n      reg periodic_rd_request_r;\n      wire periodic_rd_request_ns = ~rst &&\n                     ((app_periodic_rd_req && dfi_init_complete) ||\n                      ((PERIODIC_RD_TIMER_DIV != 0) && ~dfi_init_complete) ||\n                      (~(read_this_rank || clear_periodic_rd_request) &&\n                      (periodic_rd_request_r || periodic_rd_timer_one)));\n      always @(posedge clk) periodic_rd_request_r <=\n                              #TCQ periodic_rd_request_ns;\n      `ifdef MC_SVA\n      read_clears_periodic_rd_request: cover property (@(posedge clk)\n               (rst && (periodic_rd_request_r && read_this_rank)));\n      `endif\n      assign periodic_rd_request = dfi_init_complete && periodic_rd_request_r;\n    end else\n      assign periodic_rd_request = 1'b0; //to disable periodic reads\n  end\n  endgenerate\nendmodule"}
{"task_id": 1457, "completion": "wire [8:0] S_AXI_1_ARADDR;\n  wire S_AXI_1_ARREADY;\n  wire S_AXI_1_ARVALID;\n  wire [8:0] S_AXI_1_AWADDR;\n  wire S_AXI_1_AWREADY;\n  wire S_AXI_1_AWVALID;\n  wire S_AXI_1_BREADY;\n  wire [1:0] S_AXI_1_BRESP;\n  wire S_AXI_1_BVALID;\n  wire [31:0] S_AXI_1_RDATA;\n  wire S_AXI_1_RREADY;\n  wire [1:0] S_AXI_1_RRESP;\n  wire S_AXI_1_RVALID;\n  wire [31:0] S_AXI_1_WDATA;\n  wire S_AXI_1_WREADY;\n  wire [3:0] S_AXI_1_WSTRB;\n  wire S_AXI_1_WVALID;\n  wire [7:0] axi_gpio_0_gpio_io_o;\n  wire [7:0] axi_gpio_0_gpio_io_t;\n  wire pmod_bridge_0_Pmod_out_PIN10_I;\n  wire pmod_bridge_0_Pmod_out_PIN10_O;\n  wire pmod_bridge_0_Pmod_out_PIN10_T;\n  wire pmod_bridge_0_Pmod_out_PIN1_I;\n  wire pmod_bridge_0_Pmod_out_PIN1_O;\n  wire pmod_bridge_0_Pmod_out_PIN1_T;\n  wire pmod_bridge_0_Pmod_out_PIN2_I;\n  wire pmod_bridge_0_Pmod_out_PIN2_O;\n  wire pmod_bridge_0_Pmod_out_PIN2_T;\n  wire pmod_bridge_0_Pmod_out_PIN3_I;\n  wire pmod_bridge_0_Pmod_out_PIN3_O;\n  wire pmod_bridge_0_Pmod_out_PIN3_T;\n  wire pmod_bridge_0_Pmod_out_PIN4_I;\n  wire pmod_bridge_0_Pmod_out_PIN4_O;\n  wire pmod_bridge_0_Pmod_out_PIN4_T;\n  wire pmod_bridge_0_Pmod_out_PIN7_I;\n  wire pmod_bridge_0_Pmod_out_PIN7_O;\n  wire pmod_bridge_0_Pmod_out_PIN7_T;\n  wire pmod_bridge_0_Pmod_out_PIN8_I;\n  wire pmod_bridge_0_Pmod_out_PIN8_O;\n  wire pmod_bridge_0_Pmod_out_PIN8_T;\n  wire pmod_bridge_0_Pmod_out_PIN9_I;\n  wire pmod_bridge_0_Pmod_out_PIN9_O;\n  wire pmod_bridge_0_Pmod_out_PIN9_T;\n  wire [3:0] pmod_bridge_0_in_bottom_bus_I;\n  wire [3:0] pmod_bridge_0_in_top_bus_I;\n  wire s_axi_aclk_1;\n  wire s_axi_aresetn_1;\n  wire [7:0] xlconcat_0_dout;\n  wire [3:0] xlslice_o_0_Dout;\n  wire [3:0] xlslice_o_1_Dout;\n  wire [3:0] xlslice_t_0_Dout;\n  wire [3:0] xlslice_t_1_Dout;\n\n  assign AXI_LITE_GPIO_arready = S_AXI_1_ARREADY;\n  assign AXI_LITE_GPIO_awready = S_AXI_1_AWREADY;\n  assign AXI_LITE_GPIO_bresp[1:0] = S_AXI_1_BRESP;\n  assign AXI_LITE_GPIO_bvalid = S_AXI_1_BVALID;\n  assign AXI_LITE_GPIO_rdata[31:0] = S_AXI_1_RDATA;\n  assign AXI_LITE_GPIO_rresp[1:0] = S_AXI_1_RRESP;\n  assign AXI_LITE_GPIO_rvalid = S_AXI_1_RVALID;\n  assign AXI_LITE_GPIO_wready = S_AXI_1_WREADY;\n  assign Pmod_out_pin10_o = pmod_bridge_0_Pmod_out_PIN10_O;\n  assign Pmod_out_pin10_t = pmod_bridge_0_Pmod_out_PIN10_T;\n  assign Pmod_out_pin1_o = pmod_bridge_0_Pmod_out_PIN1_O;\n  assign Pmod_out_pin1_t = pmod_bridge_0_Pmod_out_PIN1_T;\n  assign Pmod_out_pin2_o = pmod_bridge_0_Pmod_out_PIN2_O;\n  assign Pmod_out_pin2_t = pmod_bridge_0_Pmod_out_PIN2_T;\n  assign Pmod_out_pin3_o = pmod_bridge_0_Pmod_out_PIN3_O;\n  assign Pmod_out_pin3_t = pmod_bridge_0_Pmod_out_PIN3_T;\n  assign Pmod_out_pin4_o = pmod_bridge_0_Pmod_out_PIN4_O;\n  assign Pmod_out_pin4_t = pmod_bridge_0_Pmod_out_PIN4_T;\n  assign Pmod_out_pin7_o = pmod_bridge_0_Pmod_out_PIN7_O;\n  assign Pmod_out_pin7_t = pmod_bridge_0_Pmod_out_PIN7_T;\n  assign Pmod_out_pin8_o = pmod_bridge_0_Pmod_out_PIN8_O;\n  assign Pmod_out_pin8_t = pmod_bridge_0_Pmod_out_PIN8_T;\n  assign Pmod_out_pin9_o = pmod_bridge_0_Pmod_out_PIN9_O;\n  assign Pmod_out_pin9_t = pmod_bridge_0_Pmod_out_PIN9_T;\n  assign S_AXI_1_ARADDR = AXI_LITE_GPIO_araddr[8:0];\n  assign S_AXI_1_ARVALID = AXI_LITE_GPIO_arvalid;\n  assign S_AXI_1_AWADDR = AXI_LITE_GPIO_awaddr[8:0];\n  assign S_AXI_1_AWVALID = AXI_LITE_GPIO_awvalid;\n  assign S_AXI_1_BREADY = AXI_LITE_GPIO_bready;\n  assign S_AXI_1_RREADY = AXI_LITE_GPIO_rready;\n  assign S_AXI_1_WDATA = AXI_LITE_GPIO_wdata[31:0];\n  assign S_AXI_1_WSTRB = AXI_LITE_GPIO_wstrb[3:0];\n  assign S_AXI_1_WVALID = AXI_LITE_GPIO_wvalid;\n  assign pmod_bridge_0_Pmod_out_PIN10_I = Pmod_out_pin10_i;\n  assign pmod_bridge_0_Pmod_out_PIN1_I = Pmod_out_pin1_i;\n  assign pmod_bridge_0_Pmod_out_PIN2_I = Pmod_out_pin2_i;\n  assign pmod_bridge_0_Pmod_out_PIN3_I = Pmod_out_pin3_i;\n  assign pmod_bridge_0_Pmod_out_PIN4_I = Pmod_out_pin4_i;\n  assign pmod_bridge_0_Pmod_out_PIN7_I = Pmod_out_pin7_i;\n  assign pmod_bridge_0_Pmod_out_PIN8_I = Pmod_out_pin8_i;\n  assign pmod_bridge_0_Pmod_out_PIN9_I = Pmod_out_pin9_i;\n  assign s_axi_aclk_1 = s_axi_aclk;\n  assign s_axi_aresetn_1 = s_axi_aresetn;\n  PmodR2R_axi_gpio_0_0 axi_gpio_0\n       (.gpio_io_i(xlconcat_0_dout),\n        .gpio_io_o(axi_gpio_0_gpio_io_o),\n        .gpio_io_t(axi_gpio_0_gpio_io_t),\n        .s_axi_aclk(s_axi_aclk_1),\n        .s_axi_araddr(S_AXI_1_ARADDR),\n        .s_axi_aresetn(s_axi_aresetn_1),\n        .s_axi_arready(S_AXI_1_ARREADY),\n        .s_axi_arvalid(S_AXI_1_ARVALID),\n        .s_axi_awaddr(S_AXI_1_AWADDR),\n        .s_axi_awready(S_AXI_1_AWREADY),\n        .s_axi_awvalid(S_AXI_1_AWVALID),\n        .s_axi_bready(S_AXI_1_BREADY),\n        .s_axi_bresp(S_AXI_1_BRESP),\n        .s_axi_bvalid(S_AXI_1_BVALID),\n        .s_axi_rdata(S_AXI_1_RDATA),\n        .s_axi_rready(S_AXI_1_RREADY),\n        .s_axi_rresp(S_AXI_1_RRESP),\n        .s_axi_rvalid(S_AXI_1_RVALID),\n        .s_axi_wdata(S_AXI_1_WDATA),\n        .s_axi_wready(S_AXI_1_WREADY),\n        .s_axi_wstrb(S_AXI_1_WSTRB),\n        .s_axi_wvalid(S_AXI_1_WVALID));\n  PmodR2R_pmod_bridge_0_0 pmod_bridge_0\n       (.in_bottom_bus_I(pmod_bridge_0_in_bottom_bus_I),\n        .in_bottom_bus_O(xlslice_o_1_Dout),\n        .in_bottom_bus_T(xlslice_t_1_Dout),\n        .in_top_bus_I(pmod_bridge_0_in_top_bus_I),\n        .in_top_bus_O(xlslice_o_0_Dout),\n        .in_top_bus_T(xlslice_t_0_Dout),\n        .out0_I(pmod_bridge_0_Pmod_out_PIN1_I),\n        .out0_O(pmod_bridge_0_Pmod_out_PIN1_O),\n        .out0_T(pmod_bridge_0_Pmod_out_PIN1_T),\n        .out1_I(pmod_bridge_0_Pmod_out_PIN2_I),\n        .out1_O(pmod_bridge_0_Pmod_out_PIN2_O),\n        .out1_T(pmod_bridge_0_Pmod_out_PIN2_T),\n        .out2_I(pmod_bridge_0_Pmod_out_PIN3_I),\n        .out2_O(pmod_bridge_0_Pmod_out_PIN3_O),\n        .out2_T(pmod_bridge_0_Pmod_out_PIN3_T),\n        .out3_I(pmod_bridge_0_Pmod_out_PIN4_I),\n        .out3_O(pmod_bridge_0_Pmod_out_PIN4_O),\n        .out3_T(pmod_bridge_0_Pmod_out_PIN4_T),\n        .out4_I(pmod_bridge_0_Pmod_out_PIN7_I),\n        .out4_O(pmod_bridge_0_Pmod_out_PIN7_O),\n        .out4_T(pmod_bridge_0_Pmod_out_PIN7_T),\n        .out5_I(pmod_bridge_0_Pmod_out_PIN8_I),\n        .out5_O(pmod_bridge_0_Pmod_out_PIN8_O),\n        .out5_T(pmod_bridge_0_Pmod_out_PIN8_T),\n        .out6_I(pmod_bridge_0_Pmod_out_PIN9_I),\n        .out6_O(pmod_bridge_0_Pmod_out_PIN9_O),\n        .out6_T(pmod_bridge_0_Pmod_out_PIN9_T),\n        .out7_I(pmod_bridge_0_Pmod_out_PIN10_I),\n        .out7_O(pmod_bridge_0_Pmod_out_PIN10_O),\n        .out7_T(pmod_bridge_0_Pmod_out_PIN10_T));\n  PmodR2R_xlconcat_0_0 xlconcat_0\n       (.In0(pmod_bridge_0_in_top_bus_I),\n        .In1(pmod_bridge_0_in_bottom_bus_I),\n        .dout(xlconcat_0_dout));\n  PmodR2R_xlslice_0_0 xlslice_o_0\n       (.Din(axi_gpio_0_gpio_io_o),\n        .Dout(xlslice_o_0_Dout));\n  PmodR2R_xlslice_0_1 xlslice_o_1\n       (.Din(axi_gpio_0_gpio_io_o),\n        .Dout(xlslice_o_1_Dout));\n  PmodR2R_xlslice_0_2 xlslice_t_0\n       (.Din(axi_gpio_0_gpio_io_t),\n        .Dout(xlslice_t_0_Dout));\n  PmodR2R_xlslice_t_0_0 xlslice_t_1\n       (.Din(axi_gpio_0_gpio_io_t),\n        .Dout(xlslice_t_1_Dout));\nendmodule"}
{"task_id": 1473, "completion": "wire      ck_p_odelay;\n  wire      ck_p_oq;\n  wire      ck_p_out;\n\n  OBUFDS u_obuf_ck\n    (\n     .O  (ddr_ck_p),\n     .OB (ddr_ck_n),\n     .I  (ck_p_out)\n     );\n       \n  OSERDESE1 #\n    (\n     .DATA_RATE_OQ   (\"DDR\"),\n     .DATA_RATE_TQ   (\"BUF\"),\n     .DATA_WIDTH     (4),\n     .DDR3_DATA      (0),\n     .INIT_OQ        (1'b0),\n     .INIT_TQ        (1'b0),\n     .INTERFACE_TYPE (\"DEFAULT\"),\n     .ODELAY_USED    (0),\n     .SERDES_MODE    (\"MASTER\"),\n     .SRVAL_OQ       (1'b0),\n     .SRVAL_TQ       (1'b0),\n     .TRISTATE_WIDTH (1)\n     )\n    u_oserdes_ck_p\n      (\n       .OCBEXTEND           (),\n       .OFB                 (),\n       .OQ                  (ck_p_oq),\n       .SHIFTOUT1           (),\n       .SHIFTOUT2           (),\n       .TQ                  (),\n       .CLK                 (clk_mem),\n       .CLKDIV              (clk),\n       .CLKPERF             (),\n       .CLKPERFDELAY        (),\n       .D1                  (1'b0),\n       .D2                  (1'b1),\n       .D3                  (1'b0),\n       .D4                  (1'b1),\n       .D5                  (),\n       .D6                  (),\n       .ODV                 (1'b0),\n       .OCE                 (1'b1),\n       .RST                 (rst),\n       .SHIFTIN1            (1'b0),   \n       .SHIFTIN2            (1'b0),\n       .T1                  (1'b0),\n       .T2                  (1'b0),\n       .T3                  (1'b0),\n       .T4                  (1'b0),\n       .TFB                 (),\n       .TCE                 (1'b1),\n       .WC                  (1'b0)\n       );\n\n  generate\n    if ((DRAM_TYPE == \"DDR3\") && (WRLVL == \"ON\")) begin: gen_ck_wrlvl\n      assign ck_p_out = ck_p_oq;\n    end else begin: gen_ck_nowrlvl\n      assign ck_p_out = ck_p_odelay;\n      (* IODELAY_GROUP = IODELAY_GRP *) IODELAYE1 #\n        (\n         .CINVCTRL_SEL          (\"FALSE\"),\n         .DELAY_SRC             (\"O\"),\n         .HIGH_PERFORMANCE_MODE (\"TRUE\"),\n         .IDELAY_TYPE           (\"FIXED\"), \n         .IDELAY_VALUE          (0),       \n         .ODELAY_TYPE           (\"FIXED\"),\n         .ODELAY_VALUE          (0),\n         .REFCLK_FREQUENCY      (REFCLK_FREQ),\n         .SIGNAL_PATTERN        (\"CLOCK\")\n         )\n        u_iodelay_ck_p\n          (\n           .DATAOUT     (ck_p_odelay),\n           .C           (1'b0),\n           .CE          (1'b0),\n           .DATAIN      (),\n           .IDATAIN     (),\n           .INC         (1'b0),\n           .ODATAIN     (ck_p_oq),\n           .RST         (1'b0),\n           .T           (),\n           .CNTVALUEIN  (),\n           .CNTVALUEOUT (),\n           .CLKIN       (),\n           .CINVCTRL    (1'b0)\n           );\n    end\n  endgenerate\nendmodule"}
{"task_id": 916, "completion": "always @ (ir) { ir0, ir1, ir2, ir3, ir4, ir5, ir6, ir7, ir8, ir9, ir10, ir11, ir12, ir13, ir14, ir15 } = ir; always @ (toff_0_0, toff_1_1, toff_2_2, toff_3_3, toff_4_4, toff_5_5, toff_6_6, toff_7_7, toff_8_8, toff_9_9, toff_10_10, toff_11_11, toff_12_12, toff_13_13, toff_14_14) begin toff_0_0 = toff_0_0 + toff_0_0; toff_1_1 = toff_1_1 + toff_1_1; toff_2_2 = toff_2_2 + toff_2_2; toff_3_3 = toff_3_3 + toff_3_3; toff_4_4 = toff_4_4 + toff_4_4; toff_5_5 = toff_5_5 + toff_5_5; toff_6_6 = toff_6_6 + toff_6_6; toff_7_7 = toff_7_7 + toff_7_7; toff_8_8 = toff_8_8 + toff_8_8; toff_9_9 = toff_9_9 + toff_9_9; toff_10_10 = toff_10_10 + toff_10_10; toff_11_11 = toff_11_11 + toff_11_11; toff_12_12 = toff_12_12 + toff_12_12; toff_13_13 = toff_13_13 + toff_13_13; toff_14_14 = toff_14_14 + toff_14_14; end endmodule"}
{"task_id": 1490, "completion": "reg  [31:0] o_data0;    reg [31:0] i_data0_reg;    wire [30:0] o_data0_from_mult;    always @(posedge clk) begin        i_data0_reg <= i_data0;        o_data0 <= o_data0_from_mult;    end    multiplier_block mult_blk(        .i_data0(i_data0_reg),        .o_data0(o_data0_from_mult)    );    endmodule"}
{"task_id": 134, "completion": "endmodule"}
{"task_id": 538, "completion": "output Y   ;\n    input  A1  ;\n    input  A2  ;\n    input  A3  ;\n    input  B1  ;\n    input  VPWR;\n    input  VGND;\n    sky130_fd_sc_hs__a31oi base (\n        .Y(Y),\n        .A1(A1),\n        .A2(A2),\n        .A3(A3),\n        .B1(B1),\n        .VPWR(VPWR),\n        .VGND(VGND)\n    );\n\nendmodule"}
{"task_id": 594, "completion": "output Y  ;\n    input  A  ;\n    input  B_N;\n\n    // Voltage supply signals\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    sky130_fd_sc_ls__nor2b base (\n        .Y(Y),\n        .A(A),\n        .B_N(B_N)\n    );\n\nendmodule"}
{"task_id": 201, "completion": "endmodule"}
{"task_id": 577, "completion": "logic [np-1:0][nv-1:0] b, current_pl_blocked;    genvar ip,pl,op;    generate       for (ip=0; ip<np; ip++) begin:il         for (pl=0; pl<nv; pl++) begin:vl            unary_select_pair #(ip, np, nv) blocked_mux              (output_port[ip][pl],               allocated_pl[ip][pl],               pl_status,               current_pl_blocked[ip][pl]);            assign b[ip][pl] = current_pl_blocked[ip][pl];            assign pl_blocked[ip][pl] = (LAG_route_valid_input_pl (ip,pl)) ? b[ip][pl] : 1'b0;         end       end     endgenerate   endmodule"}
{"task_id": 489, "completion": "endmodule"}
{"task_id": 490, "completion": "input VPWR;\n    input VGND;\n    input VPB ;\n    input VNB ;\n     // No contents.\nendmodule"}
{"task_id": 143, "completion": "wire pwrgood_pp0_out_A;    wire buf0_out_X;    sky130_fd_sc_lp__udp_pwrgood_pp$PG pwrgood_pp0 (pwrgood_pp0_out_A, A, VPWR, VGND);    buf buf0 (buf0_out_X, pwrgood_pp0_out_A);    sky130_fd_sc_lp__udp_pwrgood_pp$PG pwrgood_pp1 (X, buf0_out_X, DESTPWR, VGND);    endmodule"}
{"task_id": 184, "completion": "sky130_fd_sc_lp__nand2b base (\n        .Y(Y),\n        .A_N(A_N),\n        .B(B),\n        .VPWR(VPWR),\n        .VGND(VGND),\n        .VPB(VPB),\n        .VNB(VNB)\n    );\n\nendmodule"}
{"task_id": 4, "completion": "localparam integer P_SRLASIZE = 5;\n  localparam integer P_SRLDEPTH = 32;\n  localparam integer P_NUMSRLS  = (C_A_WIDTH>P_SRLASIZE) ? (2**(C_A_WIDTH-P_SRLASIZE)) : 1;\n  localparam integer P_SHIFT_DEPTH  = 2**C_A_WIDTH;\n  wire [P_NUMSRLS:0]   d_i;\n  wire [P_NUMSRLS-1:0] q_i;\n  wire [(C_A_WIDTH>P_SRLASIZE) ? (C_A_WIDTH-1) : (P_SRLASIZE-1) : 0] a_i;\n  genvar i;\n  assign d_i[0] = D;\n  assign a_i = A;\n  generate\n    if (C_FAMILY == \"rtl\") begin : gen_rtl_shifter\n      if (C_A_WIDTH <= P_SRLASIZE) begin : gen_inferred_srl\n        reg [P_SRLDEPTH-1:0] shift_reg = {P_SRLDEPTH{1'b0}};\n        always @(posedge CLK)\n          if (CE)\n            shift_reg <= {shift_reg[P_SRLDEPTH-2:0], D};\n        assign Q = shift_reg[a_i];\n      end else begin : gen_logic_shifter  // Very wasteful\n        reg [P_SHIFT_DEPTH-1:0] shift_reg = {P_SHIFT_DEPTH{1'b0}};\n        always @(posedge CLK)\n          if (CE)\n            shift_reg <= {shift_reg[P_SHIFT_DEPTH-2:0], D};\n        assign Q = shift_reg[a_i];\n      end\n    end else begin : gen_primitive_shifter\n      for (i=0;i<P_NUMSRLS;i=i+1) begin : gen_srls\n        SRLC32E\n          srl_inst\n            (\n             .CLK (CLK),\n             .A   (a_i[P_SRLASIZE-1:0]),\n             .CE  (CE),\n             .D   (d_i[i]),\n             .Q   (q_i[i]),\n             .Q31 (d_i[i+1])\n             );\n      end\n      if (C_A_WIDTH>P_SRLASIZE) begin : gen_srl_mux\n        generic_baseblocks_v2_1_nto1_mux #\n        (\n          .C_RATIO         (2**(C_A_WIDTH-P_SRLASIZE)),\n          .C_SEL_WIDTH     (C_A_WIDTH-P_SRLASIZE),\n          .C_DATAOUT_WIDTH (1),\n          .C_ONEHOT        (0)\n        )\n        srl_q_mux_inst\n        (\n          .SEL_ONEHOT ({2**(C_A_WIDTH-P_SRLASIZE){1'b0}}),\n          .SEL        (a_i[C_A_WIDTH-1:P_SRLASIZE]),\n          .IN         (q_i),\n          .OUT        (Q)\n        );\n      end else begin : gen_no_srl_mux\n        assign Q = q_i[0];\n      end\n    end\n  endgenerate\nendmodule"}
{"task_id": 514, "completion": "parameter [2:0]\n  FEAT_MSU1 = 3,\n  FEAT_213F = 4\n;\n\nwire [23:0] SRAM_SNES_ADDR;\n\nassign IS_ROM = ((!SNES_ADDR[22] & SNES_ADDR[15])\n                 |(SNES_ADDR[22]));\n\nassign IS_SAVERAM = |SAVERAM_MASK & (&SNES_ADDR[22:20] & ~SNES_ADDR[15] & (SNES_ADDR[19:16] < 4'b1110));\n\nassign SRAM_SNES_ADDR = IS_SAVERAM\n                        ? (24'hE00000 | ({SNES_ADDR[19:16], SNES_ADDR[14:0]}\n                         & SAVERAM_MASK))\n                        : ({2'b00, SNES_ADDR[22:16], SNES_ADDR[14:0]}\n                         & ROM_MASK);\n\nassign ROM_ADDR = SRAM_SNES_ADDR;\n\nassign IS_WRITABLE = IS_SAVERAM;\n\nassign ROM_HIT = IS_ROM | IS_WRITABLE;\n\nwire msu_enable_w = featurebits[FEAT_MSU1] & (!SNES_ADDR[22] && ((SNES_ADDR[15:0] & 16'hfff8) == 16'h2000));\nassign msu_enable = msu_enable_w;\n\nwire cx4_enable_w = (!SNES_ADDR[22] && (SNES_ADDR[15:13] == 3'b011));\nassign cx4_enable = cx4_enable_w;\n\nassign cx4_vect_enable = &SNES_ADDR[15:5];\n\nassign r213f_enable = featurebits[FEAT_213F] & (SNES_PA == 9'h3f);\n\nassign snescmd_enable = ({SNES_ADDR[22], SNES_ADDR[15:9]} == 8'b0_0010101);\nassign nmicmd_enable = (SNES_ADDR == 24'h002BF2);\nassign return_vector_enable = (SNES_ADDR == 24'h002A5A);\nassign branch1_enable = (SNES_ADDR == 24'h002A13);\nassign branch2_enable = (SNES_ADDR == 24'h002A4D);\nendmodule"}
{"task_id": 561, "completion": "BLK_MEM_GEN_V6_2 #(\n    .C_ADDRA_WIDTH(12),\n    .C_ADDRB_WIDTH(12),\n    .C_ALGORITHM(1),\n    .C_AXI_ID_WIDTH(4),\n    .C_AXI_SLAVE_TYPE(0),\n    .C_AXI_TYPE(1),\n    .C_BYTE_SIZE(9),\n    .C_COMMON_CLK(0),\n    .C_DEFAULT_DATA(\"0\"),\n    .C_DISABLE_WARN_BHV_COLL(1),\n    .C_DISABLE_WARN_BHV_RANGE(1),\n    .C_FAMILY(\"spartan6\"),\n    .C_HAS_AXI_ID(0),\n    .C_HAS_ENA(1),\n    .C_HAS_ENB(0),\n    .C_HAS_INJECTERR(0),\n    .C_HAS_MEM_OUTPUT_REGS_A(0),\n    .C_HAS_MEM_OUTPUT_REGS_B(0),\n    .C_HAS_MUX_OUTPUT_REGS_A(0),\n    .C_HAS_MUX_OUTPUT_REGS_B(0),\n    .C_HAS_REGCEA(0),\n    .C_HAS_REGCEB(0),\n    .C_HAS_RSTA(0),\n    .C_HAS_RSTB(0),\n    .C_HAS_SOFTECC_INPUT_REGS_A(0),\n    .C_HAS_SOFTECC_OUTPUT_REGS_B(0),\n    .C_INIT_FILE_NAME(\"RAM_4K.mif\"),\n    .C_INITA_VAL(\"0\"),\n    .C_INITB_VAL(\"0\"),\n    .C_INTERFACE_TYPE(0),\n    .C_LOAD_INIT_FILE(1),\n    .C_MEM_TYPE(0),\n    .C_MUX_PIPELINE_STAGES(0),\n    .C_PRIM_TYPE(1),\n    .C_READ_DEPTH_A(4096),\n    .C_READ_DEPTH_B(4096),\n    .C_READ_WIDTH_A(16),\n    .C_READ_WIDTH_B(16),\n    .C_RST_PRIORITY_A(\"CE\"),\n    .C_RST_PRIORITY_B(\"CE\"),\n    .C_RST_TYPE(\"SYNC\"),\n    .C_RSTRAM_A(0),\n    .C_RSTRAM_B(0),\n    .C_SIM_COLLISION_CHECK(\"ALL\"),\n    .C_USE_BYTE_WEA(0),\n    .C_USE_BYTE_WEB(0),\n    .C_USE_DEFAULT_DATA(1),\n    .C_USE_ECC(0),\n    .C_USE_SOFTECC(0),\n    .C_WEA_WIDTH(1),\n    .C_WEB_WIDTH(1),\n    .C_WRITE_DEPTH_A(4096),\n    .C_WRITE_DEPTH_B(4096),\n    .C_WRITE_MODE_A(\"WRITE_FIRST\"),\n    .C_WRITE_MODE_B(\"WRITE_FIRST\"),\n    .C_WRITE_WIDTH_A(16),\n    .C_WRITE_WIDTH_B(16),\n    .C_XDEVICEFAMILY(\"spartan6\")\n  )\n  inst (\n    .CLKA(clka),\n    .ENA(ena),\n    .WEA(wea),\n    .ADDRA(addra),\n    .DINA(dina),\n    .DOUTA(douta),\n    .RSTA(),\n    .REGCEA(),\n    .CLKB(),\n    .RSTB(),\n    .ENB(),\n    .REGCEB(),\n    .WEB(),\n    .ADDRB(),\n    .DINB(),\n    .DOUTB(),\n    .INJECTSBITERR(),\n    .INJECTDBITERR(),\n    .SBITERR(),\n    .DBITERR(),\n    .RDADDRECC(),\n    .S_ACLK(),\n    .S_ARESETN(),\n    .S_AXI_AWID(),\n    .S_AXI_AWADDR(),\n    .S_AXI_AWLEN(),\n    .S_AXI_AWSIZE(),\n    .S_AXI_AWBURST(),\n    .S_AXI_AWVALID(),\n    .S_AXI_AWREADY(),\n    .S_AXI_WDATA(),\n    .S_AXI_WSTRB(),\n    .S_AXI_WLAST(),\n    .S_AXI_WVALID(),\n    .S_AXI_WREADY(),\n    .S_AXI_BID(),\n    .S_AXI_BRESP(),\n    .S_AXI_BVALID(),\n    .S_AXI_BREADY(),\n    .S_AXI_ARID(),\n    .S_AXI_ARADDR(),\n    .S_AXI_ARLEN(),\n    .S_AXI_ARSIZE(),\n    .S_AXI_ARBURST(),\n    .S_AXI_ARVALID(),\n    .S_AXI_ARREADY(),\n    .S_AXI_RID(),\n    .S_AXI_RDATA(),\n    .S_AXI_RRESP(),\n    .S_AXI_RLAST(),\n    .S_AXI_RVALID(),\n    .S_AXI_RREADY(),\n    .S_AXI_INJECTSBITERR(),\n    .S_AXI_INJECTDBITERR(),\n    .S_AXI_SBITERR(),\n    .S_AXI_DBITERR(),\n    .S_AXI_RDADDRECC()\n  );\n\nendmodule"}
{"task_id": 0, "completion": "localparam [C_AWIDTH-1:0] C_EMPTY = ~(0);  \n    localparam [C_AWIDTH-1:0] C_EMPTY_PRE =  (0);  \n    localparam [C_AWIDTH-1:0] C_FULL  = C_EMPTY-1;  \n    localparam [C_AWIDTH-1:0] C_FULL_PRE  = (C_DEPTH < 8) ? C_FULL-1 : C_FULL-(C_DEPTH/8);  \n    reg [C_WIDTH-1:0]  memory [C_DEPTH-1:0];  \n    reg [C_AWIDTH-1:0] cnt_read;  \n    always @(posedge clk) begin : BLKSRL  \n      integer i;  \n      if (wr_en) begin  \n        for (i = 0; i < C_DEPTH-1; i = i + 1) begin  \n          memory[i+1] <= memory[i];  \n        end  \n        memory[0] <= din;  \n      end  \n    end  \n    always @(posedge clk) begin  \n      if (rst) cnt_read <= C_EMPTY;  \n      else if ( wr_en & !rd_en) cnt_read <= cnt_read + 1'b1;  \n      else if (!wr_en &  rd_en) cnt_read <= cnt_read - 1'b1;  \n    end  \n    assign full  = (cnt_read == C_FULL);  \n    assign empty = (cnt_read == C_EMPTY);  \n    assign a_full  = ((cnt_read >= C_FULL_PRE) && (cnt_read != C_EMPTY));  \n    assign a_empty = (cnt_read == C_EMPTY_PRE);  \n    assign dout  = (C_DEPTH == 1) ? memory[0] : memory[cnt_read];  \nendmodule"}
{"task_id": 628, "completion": "// Your implementation of the display module should go here\nendmodule"}
{"task_id": 199, "completion": "wire [TYPE_WIDTH-1:0] ordered_reg;\n    assign ordered_output = ordered_reg;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            ordered_reg <= 0;\n        end else begin\n            ordered_reg <= input_data;\n        end\n    end\n\nendmodule"}
{"task_id": 330, "completion": "assign out[0] = a[31];\n\tassign out[1] = a[0];\n\tassign out[2] = a[1];\n\tassign out[3] = a[2];\n\tassign out[4] = a[3];\n\tassign out[5] = a[4];\n\tassign out[6] = a[5];\n\tassign out[7] = a[6];\n\tassign out[8] = a[7];\n\tassign out[9] = a[8];\n\tassign out[10] = a[9];\n\tassign out[11] = a[10];\n\tassign out[12] = a[11];\n\tassign out[13] = a[12];\n\tassign out[14] = a[13];\n\tassign out[15] = a[14];\n\tassign out[16] = a[15];\n\tassign out[17] = a[16];\n\tassign out[18] = a[17];\n\tassign out[19] = a[18];\n\tassign out[20] = a[19];\n\tassign out[21] = a[20];\n\tassign out[22] = a[21];\n\tassign out[23] = a[22];\n\tassign out[24] = a[23];\n\tassign out[25] = a[24];\n\tassign out[26] = a[25];\n\tassign out[27] = a[26];\n\tassign out[28] = a[27];\n\tassign out[29] = a[28];\n\tassign out[30] = a[29];\n\tassign out[31] = a[30];\n\nendmodule"}
{"task_id": 596, "completion": "reg [31:0] cnt;\n\n    always @(posedge clk_cog)\n    if (nres)\n        cnt <= cnt + 1'b1;\n\n    reg ena_bus;\n\n    always @(posedge clk_cog or negedge nres)\n    if (!nres)\n        ena_bus <= 1'b0;\n    else\n        ena_bus <= !ena_bus;\n\n    reg [7:0] bus_sel;\n\n    always @(posedge clk_cog or negedge nres)\n    if (!nres)\n        bus_sel <= 8'b0;\n    else if (ena_bus)\n        bus_sel <= {bus_sel[6:0], ~|bus_sel[6:0]};\n\n    wire [7:0] bus_r;\n    wire [7:0] bus_e;\n    wire [7:0] bus_w;\n    wire [7:0] [1:0] bus_s;\n    wire [7:0] [15:0] bus_a;\n    wire [7:0] [31:0] bus_d;\n    wire [7:0] pll;\n    wire [7:0] [31:0] outx;\n    wire [7:0] [31:0] dirx;\n\n    genvar i;\n    generate\n        for (i=0; i<8; i++)\n        begin : coggen\n            cog cog_(   .nres       (nres),\n                        .clk_cog    (clk_cog),\n                        .clk_pll    (clk_pll),\n                        .ena_bus    (ena_bus),\n                        .ptr_w      (ptr_w[i]),\n                        .ptr_d      (ptr_d),\n                        .ena        (cog_ena[i]),\n                        .bus_sel    (bus_sel[i]),\n                        .bus_r      (bus_r[i]),\n                        .bus_e      (bus_e[i]),\n                        .bus_w      (bus_w[i]),\n                        .bus_s      (bus_s[i]),\n                        .bus_a      (bus_a[i]),\n                        .bus_d      (bus_d[i]),\n                        .bus_q      (bus_q),\n                        .bus_c      (bus_c),\n                        .bus_ack    (bus_ack[i]),\n                        .cnt        (cnt),\n                        .pll_in     (pll),\n                        .pll_out    (pll[i]),\n                        .pin_in     (pin_in),\n                        .pin_out    (outx[i]),\n                        .pin_dir    (dirx[i])   );\n        end\n    endgenerate\n\n    wire hub_bus_r = |bus_r;\n    wire hub_bus_e = |bus_e;\n    wire hub_bus_w = |bus_w;\n    wire [1:0] hub_bus_s = bus_s[7] | bus_s[6] | bus_s[5] | bus_s[4] | bus_s[3] | bus_s[2] | bus_s[1] | bus_s[0];\n    wire [15:0] hub_bus_a = bus_a[7] | bus_a[6] | bus_a[5] | bus_a[4] | bus_a[3] | bus_a[2] | bus_a[1] | bus_a[0];\n    wire [31:0] hub_bus_d = bus_d[7] | bus_d[6] | bus_d[5] | bus_d[4] | bus_d[3] | bus_d[2] | bus_d[1] | bus_d[0];\n    wire [31:0] bus_q;\n    wire bus_c;\n    wire [7:0] bus_ack;\n    wire [7:0] cog_ena;\n    wire [7:0] ptr_w;\n    wire [27:0] ptr_d;\n\n    hub hub_        (   .clk_cog    (clk_cog),\n                        .ena_bus    (ena_bus),\n                        .nres       (nres),\n                        .bus_sel    (bus_sel),\n                        .bus_r      (hub_bus_r),\n                        .bus_e      (hub_bus_e),\n                        .bus_w      (hub_bus_w),\n                        .bus_s      (hub_bus_s),\n                        .bus_a      (hub_bus_a),\n                        .bus_d      (hub_bus_d),\n                        .bus_q      (bus_q),\n                        .bus_c      (bus_c),\n                        .bus_ack    (bus_ack),\n                        .cog_ena    (cog_ena),\n                        .ptr_w      (ptr_w),\n                        .ptr_d      (ptr_d),\n                        .cfg        (cfg)   );\n\n    assign pin_out      = outx[7] | outx[6] | outx[5] | outx[4] | outx[3] | outx[2] | outx[1] | outx[0];\n    assign pin_dir      = dirx[7] | dirx[6] | dirx[5] | dirx[4] | dirx[3] | dirx[2] | dirx[1] | dirx[0];\n    assign cog_led      = cog_ena;\nendmodule"}
{"task_id": 112, "completion": "assign y = {x[1:0],x[31:2]} ^ {x[12:0],x[31:13]} ^ {x[21:0],x[31:22]};\nendmodule\n\n    assign y = {x[5:0],x[31:6]} ^ {x[10:0],x[31:11]} ^ {x[24:0],x[31:25]};\nendmodule\n\n    assign o = z ^ (x & (y ^ z));\nendmodule\n\n    assign o = (x & y) | (z & (x | y));\nendmodule\n\n    assign y[31:29] = x[6:4] ^ x[17:15];\n    assign y[28:0] = {x[3:0], x[31:7]} ^ {x[14:0],x[31:18]} ^ x[31:3];\nendmodule\n\n    assign y[31:22] = x[16:7] ^ x[18:9];\n    assign y[21:0] = {x[6:0],x[31:17]} ^ {x[8:0],x[31:19]} ^ x[31:10];\nendmodule"}
{"task_id": 48, "completion": "always @(Data_Dec_i)\n\tbegin\n\tData_Bin_o=6'b000000;\n\t\tif(~Data_Dec_i[54]) begin Data_Bin_o = 6'b000000;//0\n\t\tend else if(~Data_Dec_i[53]) begin Data_Bin_o = 6'b000001;//1\n\t\tend else if(~Data_Dec_i[52]) begin Data_Bin_o = 6'b000010;//2\n\t\tend else if(~Data_Dec_i[51]) begin Data_Bin_o = 6'b000011;//3\n\t\tend else if(~Data_Dec_i[50]) begin Data_Bin_o = 6'b000100;//4\n\t\tend else if(~Data_Dec_i[49]) begin Data_Bin_o = 6'b000101;//5\n\t\tend else if(~Data_Dec_i[48]) begin Data_Bin_o = 6'b000110;//6\n\t\tend else if(~Data_Dec_i[47]) begin Data_Bin_o = 6'b000111;//7\n\t\tend else if(~Data_Dec_i[46]) begin Data_Bin_o = 6'b001000;//8\n\t\tend else if(~Data_Dec_i[45]) begin Data_Bin_o = 6'b001001;//9\n\t\tend else if(~Data_Dec_i[44]) begin Data_Bin_o = 6'b001010;//10\n\t\tend else if(~Data_Dec_i[43]) begin Data_Bin_o = 6'b001011;//11\n\t\tend else if(~Data_Dec_i[42]) begin Data_Bin_o = 6'b001100;//12\n\t\tend else if(~Data_Dec_i[41]) begin Data_Bin_o = 6'b001101;//13\n\t\tend else if(~Data_Dec_i[40]) begin Data_Bin_o = 6'b001110;//14\n\t\tend else if(~Data_Dec_i[39]) begin Data_Bin_o = 6'b001111;//15\n\t\tend else if(~Data_Dec_i[38]) begin Data_Bin_o = 6'b010000;//16\n\t\tend else if(~Data_Dec_i[37]) begin Data_Bin_o = 6'b010001;//17\n\t\tend else if(~Data_Dec_i[36]) begin Data_Bin_o = 6'b010010;//18\n\t\tend else if(~Data_Dec_i[35]) begin Data_Bin_o = 6'b010011;//19\n\t\tend else if(~Data_Dec_i[34]) begin Data_Bin_o = 6'b010100;//20\n\t\tend else if(~Data_Dec_i[33]) begin Data_Bin_o = 6'b010101;//21\n\t\tend else if(~Data_Dec_i[32]) begin Data_Bin_o = 6'b010110;//22\n\t\tend else if(~Data_Dec_i[31]) begin Data_Bin_o = 6'b010111;//23\n\t\tend else if(~Data_Dec_i[30]) begin Data_Bin_o = 6'b011000;//24\n\t\tend else if(~Data_Dec_i[29]) begin Data_Bin_o = 6'b010101;//25\n\t\tend else if(~Data_Dec_i[28]) begin Data_Bin_o = 6'b010110;//26\n\t\tend else if(~Data_Dec_i[27]) begin Data_Bin_o = 6'b010111;//27\n\t\tend else if(~Data_Dec_i[26]) begin Data_Bin_o = 6'b011000;//28\n\t\tend else if(~Data_Dec_i[25]) begin Data_Bin_o = 6'b011001;//29\n\t\tend else if(~Data_Dec_i[24]) begin Data_Bin_o = 6'b011010;//30\n\t\tend else if(~Data_Dec_i[23]) begin Data_Bin_o = 6'b011011;//31\n\t\tend else if(~Data_Dec_i[22]) begin Data_Bin_o = 6'b011100;//32\n\t\tend else if(~Data_Dec_i[21]) begin Data_Bin_o = 6'b011101;//33\n\t\tend else if(~Data_Dec_i[20]) begin Data_Bin_o = 6'b011110;//34\n\t\tend else if(~Data_Dec_i[19]) begin Data_Bin_o = 6'b011111;//35\n\t\tend else if(~Data_Dec_i[18]) begin Data_Bin_o = 6'b100000;//36\n\t\tend else if(~Data_Dec_i[17]) begin Data_Bin_o = 6'b100001;//37\n\t\tend else if(~Data_Dec_i[16]) begin Data_Bin_o = 6'b100010;//38\n\t\tend else if(~Data_Dec_i[15]) begin Data_Bin_o = 6'b100011;//39\n\t\tend else if(~Data_Dec_i[14]) begin Data_Bin_o = 6'b100100;//40\n\t\tend else if(~Data_Dec_i[13]) begin Data_Bin_o = 6'b100101;//41\n\t\tend else if(~Data_Dec_i[12]) begin Data_Bin_o = 6'b100110;//42\n\t\tend else if(~Data_Dec_i[11]) begin Data_Bin_o = 6'b100111;//43\n\t\tend else if(~Data_Dec_i[10]) begin Data_Bin_o = 6'b101000;//44\n\t\tend else if(~Data_Dec_i[9]) begin Data_Bin_o = 6'b101001;//45\n\t\tend else if(~Data_Dec_i[8]) begin Data_Bin_o = 6'b101010;//46\n\t\tend else if(~Data_Dec_i[7]) begin Data_Bin_o = 6'b101011;//47\n\t\tend else if(~Data_Dec_i[6]) begin Data_Bin_o = 6'b101100;//48\n\t\tend else if(~Data_Dec_i[5]) begin Data_Bin_o = 6'b101101;//49\n\t\tend else if(~Data_Dec_i[4]) begin Data_Bin_o = 6'b101110;//50\n\t\tend else if(~Data_Dec_i[3]) begin Data_Bin_o = 6'b101111;//51\n\t\tend else if(~Data_Dec_i[2]) begin Data_Bin_o = 6'b110000;//52\n\t\tend else if(~Data_Dec_i[1]) begin Data_Bin_o = 6'b110001;//53\n\t\tend else if(~Data_Dec_i[0]) begin Data_Bin_o = 6'b110010;//54\n\t\tend else begin Data_Bin_o = 6'b000000;//zero value\n\t\tend\n\tend\nendmodule"}
{"task_id": 385, "completion": "SB_PLL40_CORE #(\n      .FEEDBACK_PATH(\"SIMPLE\"),\n      .PLLOUT_SELECT(\"GENCLK\"),\n      .DIVF(7'b1000010),\n      .DIVQ(3'b101),\n      .DIVR(4'b0000),\n      .FILTER_RANGE(3'b001)\n    ) uut (\n      .REFERENCECLK(in_clk_12_mhz),\n      .PLLOUTCORE(out_clk_25_175_mhz),\n      .RESETB(1'b1),\n      .BYPASS(1'b0)\n    );\n\n    SB_PLL40_CORE #(\n        .FEEDBACK_PATH(\"SIMPLE\"),\n        .DIVR(4'b0000),        // DIVR =  0\n        .DIVF(7'b0110110),     // DIVF = 54\n        .DIVQ(3'b010),         // DIVQ =  2\n        .FILTER_RANGE(3'b001)  // FILTER_RANGE = 1\n      ) sdram (\n        .RESETB(1'b1),\n        .BYPASS(1'b0),\n        .REFERENCECLK(in_clk_12_mhz),\n        .PLLOUTCORE(out_clk_166_mhz)\n      );\n\n    // TODO : Any other clocks needed elsewhere in the system..\n    // (PPU Clock, APU Clock, CPU Clock, RS-232)\n\nendmodule"}
{"task_id": 635, "completion": "supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    wire GATE ;\n    wire buf_Q ;\n    wire GATE_N_delayed;\n    wire D_delayed ;\n    reg notifier ;\n    wire awake ;\n\n    not not0 (GATE , GATE_N_delayed );\n    sky130_fd_sc_hdll__udp_dlatch$P_pp$PG$N dlatch0 (buf_Q , D_delayed, GATE, notifier, VPWR, VGND);\n    buf buf0 (Q , buf_Q );\n    assign awake = ( VPWR === 1'b1 );\nendmodule"}
{"task_id": 693, "completion": "endmodule"}
{"task_id": 204, "completion": "reg [PC_DATA_WIDTH-1:0] pc;\n    reg [PC_DATA_WIDTH-1:0] pc_mux_data;\n    reg [PC_DATA_WIDTH-1:0] pc_adder_data;\n\n    always@(*)\n    begin\n      case(select_new_pc_in)\n        0 : pc_mux_data = pc_adder_data;\n        1 : pc_mux_data = new_pc_in;\n      endcase\n    end\n\n    always@(*)\n    begin\n      pc_adder_data = pc + 20'd4;\n    end\n\n    assign inst_mem_addr_out = pc;\n\n    always@(posedge clk or negedge rst_n) begin\n        if(!rst_n) begin\n            pc <= PC_INITIAL_ADDRESS;\n        end \n        else if (boot_mode) begin\n            pc <= PC_INITIAL_ADDRESS;\n        end\n        else if((!stall)&en) begin\n            pc <= pc_mux_data;\n        end\n    end\n\n    assign pc_out = pc;\nendmodule"}
{"task_id": 669, "completion": "output Q      ;\n    input  RESET_B;\n    input  D      ;\n    input  GATE   ;\n    input  SLEEP_B;\n\n    supply1 KAPWR;\n    supply1 VPWR ;\n    supply0 VGND ;\n    supply1 VPB  ;\n    supply0 VNB  ;\n\n    wire buf_Q          ;\n    wire RESET          ;\n    reg  notifier       ;\n    wire D_delayed      ;\n    wire GATE_delayed   ;\n    wire RESET_delayed  ;\n    wire RESET_B_delayed;\n    wire awake          ;\n    wire cond0          ;\n    wire cond1          ;\n\n    not                                      not0    (RESET , RESET_B_delayed                                                     );\n    sky130_fd_sc_lp__udp_dlatch$PR_pp$PKG$sN dlatch0 (buf_Q , D_delayed, GATE_delayed, RESET, SLEEP_B, notifier, KAPWR, VGND, VPWR);\n    assign awake = ( SLEEP_B === 1'b1 );\n    assign cond0 = ( awake && ( RESET_B_delayed === 1'b1 ) );\n    assign cond1 = ( awake && ( RESET_B === 1'b1 ) );\n    bufif1                                   bufif10 (Q     , buf_Q, VPWR                                                         );\nendmodule"}
{"task_id": 717, "completion": "output Y;\n    input  A;\n    input  B;\n    input  C;\n    input  D;\n    input  VPWR;\n    input  VGND;\n    sky130_fd_sc_hs__nand4 base (\n        .Y(Y),\n        .A(A),\n        .B(B),\n        .C(C),\n        .D(D),\n        .VPWR(VPWR),\n        .VGND(VGND)\n    );\n\nendmodule"}
{"task_id": 507, "completion": "always @*\n    begin\n    case(hex)\n        4'h0: sseg[6:0] = 7'b0000001;\n        4'h1: sseg[6:0] = 7'b1001111;\n        4'h2: sseg[6:0] = 7'b0010010;\n        4'h3: sseg[6:0] = 7'b0000110;\n        4'h4: sseg[6:0] = 7'b1001100;\n        4'h5: sseg[6:0] = 7'b0100100;\n        4'h6: sseg[6:0] = 7'b0100000;\n        4'h7: sseg[6:0] = 7'b0001111;\n        4'h8: sseg[6:0] = 7'b0000000;\n        4'h9: sseg[6:0] = 7'b0000100;\n        4'ha: sseg[6:0] = 7'b0000010;\n        4'hb: sseg[6:0] = 7'b1100000;\n        4'hc: sseg[6:0] = 7'b0110001;\n        4'hd: sseg[6:0] = 7'b1000010;\n        4'he: sseg[6:0] = 7'b0010000;\n        4'hf: sseg[6:0] = 7'b0111000;\n        default: sseg[6:0] = 7'b111111; \n    endcase\n    sseg[7] = dp;\n    end\n    \nendmodule"}
{"task_id": 85, "completion": "always @(*) begin        case(opcode)            8'h00: op_decoder_out = `MC_OFFSET_WIDTH'h0a;            8'h01: op_decoder_out = `MC_OFFSET_WIDTH'h08;            8'h02: op_decoder_out = `MC_OFFSET_WIDTH'h04;            8'h03: op_decoder_out = `MC_OFFSET_WIDTH'h0e;            8'h04: op_decoder_out =            flags[`NEGATIVE_FLAG] ?                `MC_OFFSET_WIDTH'h0e                : `MC_OFFSET_WIDTH'h0f;            8'h05: op_decoder_out = `MC_OFFSET_WIDTH'h16;            8'h06: op_decoder_out = `MC_OFFSET_WIDTH'h1a;            8'h07: op_decoder_out = `MC_OFFSET_WIDTH'h1e;            8'h08: op_decoder_out = `MC_OFFSET_WIDTH'h22;            8'h09: op_decoder_out =            flags[`NEGATIVE_FLAG] ?                `MC_OFFSET_WIDTH'h0f                : `MC_OFFSET_WIDTH'h0e;            8'h0a: op_decoder_out =            flags[`ZERO_FLAG] ?                `MC_OFFSET_WIDTH'h0e                : `MC_OFFSET_WIDTH'h0f;            8'h0b: op_decoder_out = `MC_OFFSET_WIDTH'h26;            8'h0d: op_decoder_out = `MC_OFFSET_WIDTH'h29;            8'h0e: op_decoder_out = `MC_OFFSET_WIDTH'h28;            8'h70: op_decoder_out =            flags[`CARRY_FLAG] ?                `MC_OFFSET_WIDTH'h0e                : `MC_OFFSET_WIDTH'h0f;            8'h71: op_decoder_out =            flags[`OVERFLOW_FLAG] ?                `MC_OFFSET_WIDTH'h0e                : `MC_OFFSET_WIDTH'h0f;            8'h72: op_decoder_out = `MC_OFFSET_WIDTH'h10;            8'h73: op_decoder_out = `MC_OFFSET_WIDTH'h11;            8'h74: op_decoder_out = `MC_OFFSET_WIDTH'h12;            8'h75: op_decoder_out = `MC_OFFSET_WIDTH'h27;            8'h7e: op_decoder_out = `MC_OFFSET_WIDTH'h02;            8'h7f: op_decoder_out = `MC_OFFSET_WIDTH'h03;            default: op_decoder_out = {`MC_OFFSET_WIDTH{1'b1}};        endcase    endendmodule"}
{"task_id": 103, "completion": "wire [15:0] reg_1_std;\n\n   master_control master_control_standard\n     ( .master_clk(master_clk),.usbclk(usbclk),\n       .serial_addr(serial_addr),.serial_data(serial_data),.serial_strobe(serial_strobe),\n       .tx_bus_reset(tx_bus_reset),.rx_bus_reset(rx_bus_reset),\n       .tx_dsp_reset(tx_dsp_reset),.rx_dsp_reset(rx_dsp_reset),\n       .enable_tx(enable_tx),.enable_rx(enable_rx),\n       .interp_rate(interp_rate),.decim_rate(decim_rate),\n       .tx_sample_strobe(tx_sample_strobe),.strobe_interp(strobe_interp),\n       .rx_sample_strobe(rx_sample_strobe),.strobe_decim(strobe_decim),\n       .tx_empty(tx_empty),\n       .debug_0(debug_0),.debug_1(debug_1),\n       .debug_2(debug_2),.debug_3(debug_3),\n       .reg_0(reg_0),.reg_1(reg_1_std),.reg_2(reg_2),.reg_3(reg_3) );\n\n   wire [7:0] rx_master_slave_controls;\n   setting_reg_masked #(`FR_RX_MASTER_SLAVE) sr_rx_mstr_slv_ctrl(.clock(master_clk),.reset(1'b0),.strobe(serial_strobe),.addr(serial_addr),.in(serial_data),.out(rx_master_slave_controls));\n \n   assign     sync_rx = rx_master_slave_controls[`bitnoFR_RX_SYNC] | (rx_master_slave_controls[`bitnoFR_RX_SYNC_SLAVE] & rx_slave_sync);\nassign reg_1 ={(rx_master_slave_controls[`bitnoFR_RX_SYNC_MASTER])? sync_rx:reg_1_std[15],reg_1_std[14:0]};\n\nendmodule"}
{"task_id": 723, "completion": "output X;\n    input  A;\n\n    // Voltage supply signals\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    sky130_fd_sc_hd__buf base (\n        .X(X),\n        .A(A)\n    );\n\nendmodule"}
{"task_id": 706, "completion": "output Q;    input  D;    input  GATE;    input  RESET;    input  NOTIFIER;    input  VPWR;    input  VGND;endmodule"}
{"task_id": 270, "completion": "input aclk;\n  input aresetn;\n  input [31:0]s_axi_awaddr;\n  input [2:0]s_axi_awprot;\n  input [0:0]s_axi_awvalid;\n  output [0:0]s_axi_awready;\n  input [31:0]s_axi_wdata;\n  input [3:0]s_axi_wstrb;\n  input [0:0]s_axi_wvalid;\n  output [0:0]s_axi_wready;\n  output [1:0]s_axi_bresp;\n  output [0:0]s_axi_bvalid;\n  input [0:0]s_axi_bready;\n  input [31:0]s_axi_araddr;\n  input [2:0]s_axi_arprot;\n  input [0:0]s_axi_arvalid;\n  output [0:0]s_axi_arready;\n  output [31:0]s_axi_rdata;\n  output [1:0]s_axi_rresp;\n  output [0:0]s_axi_rvalid;\n  input [0:0]s_axi_rready;\n  output [191:0]m_axi_awaddr;\n  output [17:0]m_axi_awprot;\n  output [5:0]m_axi_awvalid;\n  input [5:0]m_axi_awready;\n  output [191:0]m_axi_wdata;\n  output [23:0]m_axi_wstrb;\n  output [5:0]m_axi_wvalid;\n  input [5:0]m_axi_wready;\n  input [11:0]m_axi_bresp;\n  input [5:0]m_axi_bvalid;\n  output [5:0]m_axi_bready;\n  output [191:0]m_axi_araddr;\n  output [17:0]m_axi_arprot;\n  output [5:0]m_axi_arvalid;\n  input [5:0]m_axi_arready;\n  input [191:0]m_axi_rdata;\n  input [11:0]m_axi_rresp;\n  input [5:0]m_axi_rvalid;\n  output [5:0]m_axi_rready;\nendmodule"}
{"task_id": 183, "completion": "output Q      ;\n    output Q_N    ;\n    input  CLK    ;\n    input  D      ;\n    input  SCD    ;\n    input  SCE    ;\n    input  RESET_B;\n\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    wire buf_Q          ;\n    wire RESET          ;\n    wire mux_out        ;\n    reg  notifier       ;\n    wire D_delayed      ;\n    wire SCD_delayed    ;\n    wire SCE_delayed    ;\n    wire RESET_B_delayed;\n    wire CLK_delayed    ;\n    wire awake          ;\n    wire cond0          ;\n    wire cond1          ;\n    wire cond2          ;\n    wire cond3          ;\n    wire cond4          ;\n\n    not                                 not0      (RESET  , RESET_B_delayed                                  );\n    sky130_fd_sc_ls__udp_mux_2to1       mux_2to10 (mux_out, D_delayed, SCD_delayed, SCE_delayed              );\n    sky130_fd_sc_ls__udp_dff$PR_pp$PG$N dff0      (buf_Q  , mux_out, CLK_delayed, RESET, notifier, VPWR, VGND);\n    assign awake = ( VPWR === 1'b1 );\n    assign cond0 = ( ( RESET_B_delayed === 1'b1 ) && awake );\n    assign cond1 = ( ( SCE_delayed === 1'b0 ) && cond0 );\n    assign cond2 = ( ( SCE_delayed === 1'b1 ) && cond0 );\n    assign cond3 = ( ( D_delayed !== SCD_delayed ) && cond0 );\n    assign cond4 = ( ( RESET_B === 1'b1 ) && awake );\n    buf                                 buf0      (Q      , buf_Q                                            );\n    not                                 not1      (Q_N    , buf_Q                                            );\n\nendmodule"}
{"task_id": 730, "completion": "wire and_output;\n    wire nor_input;\n\n    assign nor_input = !(and_output | (!B1_N));\n    assign and_output = A1 & A2;\n    assign Y = nor_input;\nendmodule"}
{"task_id": 735, "completion": "wire [63:0] wire_mgl_prim1_quotient; wire [24:0] wire_mgl_prim1_remain; lpm_divide mgl_prim1( .clken(clken), .clock(clock), .denom(denom), .numer(numer), .quotient(wire_mgl_prim1_quotient), .remain(wire_mgl_prim1_remain)); defparam mgl_prim1.lpm_drepresentation = \"UNSIGNED\", mgl_prim1.lpm_nrepresentation = \"UNSIGNED\", mgl_prim1.lpm_pipeline = 5, mgl_prim1.lpm_type = \"LPM_DIVIDE\", mgl_prim1.lpm_widthd = 25, mgl_prim1.lpm_widthn = 64, mgl_prim1.lpm_hint = \"LPM_REMAINDERPOSITIVE=TRUE\"; assign quotient = wire_mgl_prim1_quotient, remain = wire_mgl_prim1_remain; endmodule"}
{"task_id": 778, "completion": "endmodule"}
{"task_id": 118, "completion": "localparam [2-1:0] C_RESP_OKAY = 2'b00;\n  localparam [2-1:0] C_RESP_EXOKAY = 2'b01;\n  localparam [2-1:0] C_RESP_SLVERROR = 2'b10;\n  localparam [2-1:0] C_RESP_DECERR = 2'b11;\n\n  wire cmd_ready_i;\n  wire pop_mi_data;\n  wire mi_stalling;\n  reg [4-1:0] repeat_cnt_pre;\n  reg [4-1:0] repeat_cnt;\n  wire [4-1:0] next_repeat_cnt;\n  reg first_mi_word;\n  wire last_word;\n  wire load_bresp;\n  wire need_to_update_bresp;\n  reg [2-1:0] S_AXI_BRESP_ACC;\n  wire M_AXI_BREADY_I;\n  wire [C_AXI_ID_WIDTH-1:0] S_AXI_BID_I;\n  reg [2-1:0] S_AXI_BRESP_I;\n  wire [C_AXI_BUSER_WIDTH-1:0] S_AXI_BUSER_I;\n  wire S_AXI_BVALID_I;\n  wire S_AXI_BREADY_I;\n  assign M_AXI_BREADY_I = M_AXI_BVALID & ~mi_stalling;\n  assign M_AXI_BREADY = M_AXI_BREADY_I;\n  assign S_AXI_BVALID_I = M_AXI_BVALID & last_word;\n  assign pop_mi_data = M_AXI_BVALID & M_AXI_BREADY_I;\n  assign cmd_ready_i = cmd_valid & pop_mi_data & last_word;\n  assign cmd_ready = cmd_ready_i;\n  assign mi_stalling = (~S_AXI_BREADY_I & last_word);\n  assign load_bresp = (cmd_split & first_mi_word);\n  assign need_to_update_bresp = (M_AXI_BRESP > S_AXI_BRESP_ACC);\n  always @ *\n  begin\n    if (cmd_split) begin\n      if (load_bresp || need_to_update_bresp) begin\n        S_AXI_BRESP_I = M_AXI_BRESP;\n      end else begin\n        S_AXI_BRESP_I = S_AXI_BRESP_ACC;\n      end\n    end else begin\n      S_AXI_BRESP_I = M_AXI_BRESP;\n    end\n  end\n  always @ (posedge ACLK) begin\n    if (ARESET) begin\n      S_AXI_BRESP_ACC <= C_RESP_OKAY;\n    end else begin\n      if (pop_mi_data) begin\n        S_AXI_BRESP_ACC <= S_AXI_BRESP_I;\n      end\n    end\n  end\n  assign last_word = ((repeat_cnt == 4'b0) & ~first_mi_word) | ~cmd_split;\n  always @ *\n  begin\n    if (first_mi_word) begin\n      repeat_cnt_pre = cmd_repeat;\n    end else begin\n      repeat_cnt_pre = repeat_cnt;\n    end\n  end\n  assign next_repeat_cnt = repeat_cnt_pre - 1'b1;\n  always @ (posedge ACLK) begin\n    if (ARESET) begin\n      repeat_cnt <= 4'b0;\n      first_mi_word <= 1'b1;\n    end else begin\n      if (pop_mi_data) begin\n        repeat_cnt <= next_repeat_cnt;\n        first_mi_word <= last_word;\n      end\n    end\n  end\n  assign S_AXI_BID_I = M_AXI_BID;\n  assign S_AXI_BUSER_I = {C_AXI_BUSER_WIDTH{1'b0}};\n  assign S_AXI_BID = S_AXI_BID_I;\n  assign S_AXI_BRESP = S_AXI_BRESP_I;\n  assign S_AXI_BUSER = S_AXI_BUSER_I;\n  assign S_AXI_BVALID = S_AXI_BVALID_I;\n  assign S_AXI_BREADY_I = S_AXI_BREADY;\nendmodule"}
{"task_id": 802, "completion": "endmodule"}
{"task_id": 363, "completion": "tri0 areset; wire [4:0] sub_wire0; wire [0:0] sub_wire8 = 1'h0; wire [4:4] sub_wire5 = sub_wire0[4:4]; wire [3:3] sub_wire4 = sub_wire0[3:3]; wire [2:2] sub_wire3 = sub_wire0[2:2]; wire [1:1] sub_wire2 = sub_wire0[1:1]; wire [0:0] sub_wire1 = sub_wire0[0:0]; wire c0 = sub_wire1; wire c1 = sub_wire2; wire c2 = sub_wire3; wire c3 = sub_wire4; wire c4 = sub_wire5; wire sub_wire6 = inclk0; wire [1:0] sub_wire7 = {sub_wire8, sub_wire6}; altpll altpll_component (.areset (areset), .inclk (sub_wire7), .clk (sub_wire0), .activeclock (), .clkbad (), .clkena ({6{1'b1}}), .clkloss (), .clkswitch (1'b0), .configupdate (1'b0), .enable0 (), .enable1 (), .extclk (), .extclkena ({4{1'b1}}), .fbin (1'b1), .fbmimicbidir (), .fbout (), .fref (), .icdrclk (), .locked (), .pfdena (1'b1), .phasecounterselect ({4{1'b1}}), .phasedone (), .phasestep (1'b1), .phaseupdown (1'b1), .pllena (1'b1), .scanaclr (1'b0), .scanclk (1'b0), .scanclkena (1'b1), .scandata (1'b0), .scandataout (), .scandone (), .scanread (1'b0), .scanwrite (1'b0), .sclkout0 (), .sclkout1 (), .vcooverrange (), .vcounderrange ()); defparam altpll_component.bandwidth_type = \"AUTO\", altpll_component.clk0_divide_by = 1, altpll_component.clk0_duty_cycle = 50, altpll_component.clk0_multiply_by = 1, altpll_component.clk0_phase_shift = \"0\", altpll_component.clk1_divide_by = 1, altpll_component.clk1_duty_cycle = 50, altpll_component.clk1_multiply_by = 1, altpll_component.clk1_phase_shift = \"0\", altpll_component.clk2_divide_by = 1, altpll_component.clk2_duty_cycle = 50, altpll_component.clk2_multiply_by = 1, altpll_component.clk2_phase_shift = \"0\", altpll_component.clk3_divide_by = 1, altpll_component.clk3_duty_cycle = 50, altpll_component.clk3_multiply_by = 1, altpll_component.clk3_phase_shift = \"0\", altpll_component.clk4_divide_by = 1, altpll_component.clk4_duty_cycle = 50, altpll_component.clk4_multiply_by = 1, altpll_component.clk4_phase_shift = \"0\", altpll_component.compensate_clock = \"CLK0\", altpll_component.inclk0_input_frequency = 20000, altpll_component.intended_device_family = \"Cyclone IV E\", altpll_component.lpm_hint = \"CBX_MODULE_PREFIX=tes_pll\", altpll_component.lpm_type = \"altpll\", altpll_component.operation_mode = \"NORMAL\", altpll_component.pll_type = \"AUTO\", altpll_component.port_activeclock = \"PORT_UNUSED\", altpll_component.port_areset = \"PORT_USED\", altpll_component.port_clkbad0 = \"PORT_UNUSED\", altpll_component.port_clkbad1 = \"PORT_UNUSED\", altpll_component.port_clkloss = \"PORT_UNUSED\", altpll_component.port_clkswitch = \"PORT_UNUSED\", altpll_component.port_configupdate = \"PORT_UNUSED\", altpll_component.port_fbin = \"PORT_UNUSED\", altpll_component.port_inclk0 = \"PORT_USED\", altpll_component.port_inclk1 = \"PORT_UNUSED\", altpll_component.port_locked = \"PORT_UNUSED\", altpll_component.port_pfdena = \"PORT_UNUSED\", altpll_component.port_phasecounterselect = \"PORT_UNUSED\", altpll_component.port_phasedone = \"PORT_UNUSED\", altpll_component.port_phasestep = \"PORT_UNUSED\", altpll_component.port_phaseupdown = \"PORT_UNUSED\", altpll_component.port_pllena = \"PORT_UNUSED\", altpll_component.port_scanaclr = \"PORT_UNUSED\", altpll_component.port_scanclk = \"PORT_UNUSED\", altpll_component.port_scanclkena = \"PORT_UNUSED\", altpll_component.port_scandata = \"PORT_UNUSED\", altpll_component.port_scandataout = \"PORT_UNUSED\", altpll_component.port_scandone = \"PORT_UNUSED\", altpll_component.port_scanread = \"PORT_UNUSED\", altpll_component.port_scanwrite = \"PORT_UNUSED\", altpll_component.port_clk0 = \"PORT_USED\", altpll_component.port_clk1 = \"PORT_USED\", altpll_component.port_clk2 = \"PORT_USED\", altpll_component.port_clk3 = \"PORT_USED\", altpll_component.port_clk4 = \"PORT_USED\", altpll_component.port_clk5 = \"PORT_UNUSED\", altpll_component.port_clkena0 = \"PORT_UNUSED\", altpll_component.port_clkena1 = \"PORT_UNUSED\", altpll_component.port_clkena2 = \"PORT_UNUSED\", altpll_component.port_clkena3 = \"PORT_UNUSED\", altpll_component.port_clkena4 = \"PORT_UNUSED\", altpll_component.port_clkena5 = \"PORT_UNUSED\", altpll_component.port_extclk0 = \"PORT_UNUSED\", altpll_component.port_extclk1 = \"PORT_UNUSED\", altpll_component.port_extclk2 = \"PORT_UNUSED\", altpll_component.port_extclk3 = \"PORT_UNUSED\", altpll_component.width_clock = 5; endmodule"}
{"task_id": 620, "completion": "wire             clk_en;  reg     [ 63: 0] event_counter_0;  reg     [ 63: 0] event_counter_1;  wire             global_enable;  wire             global_reset;  wire             go_strobe_0;  wire             go_strobe_1;  wire    [ 31: 0] read_mux_out;  reg     [ 31: 0] readdata;  wire             stop_strobe_0;  wire             stop_strobe_1;  reg     [ 63: 0] time_counter_0;  reg     [ 63: 0] time_counter_1;  reg              time_counter_enable_0;  reg              time_counter_enable_1;  wire             write_strobe;  assign clk_en = -1;  assign write_strobe = write & begintransfer;  always @(posedge clk or negedge reset_n)  begin    if (reset_n == 0)        time_counter_0 <= 0;    else if ((time_counter_enable_0 & global_enable) | global_reset)        if (global_reset)            time_counter_0 <= 0;        else         time_counter_0 <= time_counter_0 + 1;  end  always @(posedge clk or negedge reset_n)  begin    if (reset_n == 0)        event_counter_0 <= 0;    else if ((go_strobe_0 & global_enable) | global_reset)        if (global_reset)            event_counter_0 <= 0;        else         event_counter_0 <= event_counter_0 + 1;  end  assign stop_strobe_0 = (address == 0) && write_strobe;  assign go_strobe_0 = (address == 1) && write_strobe;  always @(posedge clk or negedge reset_n)  begin    if (reset_n == 0)        time_counter_enable_0 <= 0;    else if (clk_en)        if (stop_strobe_0 | global_reset)            time_counter_enable_0 <= 0;        else if (go_strobe_0)            time_counter_enable_0 <= -1;  end  assign global_enable = time_counter_enable_0 | go_strobe_0;  assign global_reset = stop_strobe_0 && writedata[0];  always @(posedge clk or negedge reset_n)  begin    if (reset_n == 0)        time_counter_1 <= 0;    else if ((time_counter_enable_1 & global_enable) | global_reset)        if (global_reset)            time_counter_1 <= 0;        else         time_counter_1 <= time_counter_1 + 1;  end  always @(posedge clk or negedge reset_n)  begin    if (reset_n == 0)        event_counter_1 <= 0;    else if ((go_strobe_1 & global_enable) | global_reset)        if (global_reset)            event_counter_1 <= 0;        else         event_counter_1 <= event_counter_1 + 1;  end  assign stop_strobe_1 = (address == 4) && write_strobe;  assign go_strobe_1 = (address == 5) && write_strobe;  always @(posedge clk or negedge reset_n)  begin    if (reset_n == 0)        time_counter_enable_1 <= 0;    else if (clk_en)        if (stop_strobe_1 | global_reset)            time_counter_enable_1 <= 0;        else if (go_strobe_1)            time_counter_enable_1 <= -1;  end  assign read_mux_out = ({32 {(address == 0)}} & time_counter_0[31 : 0]) |    ({32 {(address == 1)}} & time_counter_0[63 : 32]) |    ({32 {(address == 2)}} & event_counter_0) |    ({32 {(address == 4)}} & time_counter_1[31 : 0]) |    ({32 {(address == 5)}} & time_counter_1[63 : 32]) |    ({32 {(address == 6)}} & event_counter_1);  always @(posedge clk or negedge reset_n)  begin    if (reset_n == 0)        readdata <= 0;    else if (clk_en)        readdata <= read_mux_out;  endendmodule"}
{"task_id": 822, "completion": "output X   ;\n    input  A   ;\n    input  B   ;\n    input  VPWR;\n    input  VGND;\n    sky130_fd_sc_hs__and2 base (\n        .X(X),\n        .A(A),\n        .B(B),\n        .VPWR(VPWR),\n        .VGND(VGND)\n    );\n\nendmodule"}
{"task_id": 358, "completion": "wire [15:0] instruction; \n    wire [31:0] pc; \n    wire [31:0] ssp; \n    // \u5176\u4ed6\u4fe1\u53f7\u5b9a\u4e49\n\n    // \u5904\u7406\u5668\u5185\u90e8\u903b\u8f91\n   always @(posedge CLK_I or negedge reset_n) begin\n       if (!reset_n) begin\n           // \u521d\u59cb\u5316\u903b\u8f91\n       end else begin\n           // \u5de5\u4f5c\u903b\u8f91\n       end\n   end\n\n   // \u5730\u5740\u8ba1\u7b97\u3001\u6570\u636e\u5b58\u53d6\u7b49\u529f\u80fd\u5b9e\u73b0\n\nendmodule"}
{"task_id": 740, "completion": "input\tclock;\n\tinput\t[38:0] data;\n\tinput\trdreq;\n\tinput\twrreq;\n\toutput\talmost_full;\n\toutput\tempty;\n\toutput\tfull;\n\toutput\t[38:0] q;\n\toutput\t[7:0] usedw;\n\n\twire sub_wire0;\n\twire [7:0] sub_wire1;\n\twire sub_wire2;\n\twire [38:0] sub_wire3;\n\twire sub_wire4;\n\twire almost_full = sub_wire0;\n\twire [7:0] usedw = sub_wire1[7:0];\n\twire empty = sub_wire2;\n\twire [38:0] q = sub_wire3[38:0];\n\twire full = sub_wire4;\n\n\tscfifo scfifo_component (\n\t\t.rdreq (rdreq),\n\t\t.clock (clock),\n\t\t.wrreq (wrreq),\n\t\t.data (data),\n\t\t.almost_full (sub_wire0),\n\t\t.usedw (sub_wire1),\n\t\t.empty (sub_wire2),\n\t\t.q (sub_wire3),\n\t\t.full (sub_wire4)\n\t);\n\tdefparam\n\t\tscfifo_component.add_ram_output_register = \"OFF\",\n\t\tscfifo_component.almost_full_value = 240,\n\t\tscfifo_component.intended_device_family = \"Cyclone III\",\n\t\tscfifo_component.lpm_numwords = 256,\n\t\tscfifo_component.lpm_showahead = \"OFF\",\n\t\tscfifo_component.lpm_type = \"scfifo\",\n\t\tscfifo_component.lpm_width = 39,\n\t\tscfifo_component.lpm_widthu = 8,\n\t\tscfifo_component.overflow_checking = \"OFF\",\n\t\tscfifo_component.underflow_checking = \"OFF\",\n\t\tscfifo_component.use_eab = \"ON\";\n\nendmodule"}
{"task_id": 835, "completion": "always @(path or mount) begin\n        if (can_handle(path)) begin\n            archive_out = load(path, mount);\n            success = 1;\n        end else begin\n            success = 0;\n        end\n    end\nendmodule"}
{"task_id": 839, "completion": "clk_gen_clk_wiz inst\n  (\n  .clk_in1(clk_in1),\n  .clk_out1(clk_out1),\n  .reset(reset) \n  );\n\nendmodule"}
{"task_id": 468, "completion": "// synthesis translate_off\n\n  BLK_MEM_GEN_V6_2 #(\n    .C_ADDRA_WIDTH(12),\n    .C_ADDRB_WIDTH(12),\n    .C_ALGORITHM(1),\n    .C_AXI_ID_WIDTH(4),\n    .C_AXI_SLAVE_TYPE(0),\n    .C_AXI_TYPE(1),\n    .C_BYTE_SIZE(9),\n    .C_COMMON_CLK(0),\n    .C_DEFAULT_DATA(\"0\"),\n    .C_DISABLE_WARN_BHV_COLL(1),\n    .C_DISABLE_WARN_BHV_RANGE(1),\n    .C_FAMILY(\"spartan6\"),\n    .C_HAS_AXI_ID(0),\n    .C_HAS_ENA(0),\n    .C_HAS_ENB(0),\n    .C_HAS_INJECTERR(0),\n    .C_HAS_MEM_OUTPUT_REGS_A(0),\n    .C_HAS_MEM_OUTPUT_REGS_B(0),\n    .C_HAS_MUX_OUTPUT_REGS_A(0),\n    .C_HAS_MUX_OUTPUT_REGS_B(0),\n    .C_HAS_REGCEA(0),\n    .C_HAS_REGCEB(0),\n    .C_HAS_RSTA(0),\n    .C_HAS_RSTB(0),\n    .C_HAS_SOFTECC_INPUT_REGS_A(0),\n    .C_HAS_SOFTECC_OUTPUT_REGS_B(0),\n    .C_INIT_FILE_NAME(\"blk_mem_gen_v6_2.mif\"),\n    .C_INITA_VAL(\"0\"),\n    .C_INITB_VAL(\"0\"),\n    .C_INTERFACE_TYPE(0),\n    .C_LOAD_INIT_FILE(1),\n    .C_MEM_TYPE(3),\n    .C_MUX_PIPELINE_STAGES(0),\n    .C_PRIM_TYPE(1),\n    .C_READ_DEPTH_A(4096),\n    .C_READ_DEPTH_B(4096),\n    .C_READ_WIDTH_A(16),\n    .C_READ_WIDTH_B(16),\n    .C_RST_PRIORITY_A(\"CE\"),\n    .C_RST_PRIORITY_B(\"CE\"),\n    .C_RST_TYPE(\"SYNC\"),\n    .C_RSTRAM_A(0),\n    .C_RSTRAM_B(0),\n    .C_SIM_COLLISION_CHECK(\"ALL\"),\n    .C_USE_BYTE_WEA(0),\n    .C_USE_BYTE_WEB(0),\n    .C_USE_DEFAULT_DATA(0),\n    .C_USE_ECC(0),\n    .C_USE_SOFTECC(0),\n    .C_WEA_WIDTH(1),\n    .C_WEB_WIDTH(1),\n    .C_WRITE_DEPTH_A(4096),\n    .C_WRITE_DEPTH_B(4096),\n    .C_WRITE_MODE_A(\"WRITE_FIRST\"),\n    .C_WRITE_MODE_B(\"WRITE_FIRST\"),\n    .C_WRITE_WIDTH_A(16),\n    .C_WRITE_WIDTH_B(16),\n    .C_XDEVICEFAMILY(\"spartan6\")\n  )\n  inst (\n    .CLKA(clka),\n    .ADDRA(addra),\n    .DOUTA(douta),\n    .RSTA(),\n    .ENA(),\n    .REGCEA(),\n    .WEA(),\n    .DINA(),\n    .CLKB(),\n    .RSTB(),\n    .ENB(),\n    .REGCEB(),\n    .WEB(),\n    .ADDRB(),\n    .DINB(),\n    .DOUTB(),\n    .INJECTSBITERR(),\n    .INJECTDBITERR(),\n    .SBITERR(),\n    .DBITERR(),\n    .RDADDRECC(),\n    .S_ACLK(),\n    .S_ARESETN(),\n    .S_AXI_AWID(),\n    .S_AXI_AWADDR(),\n    .S_AXI_AWLEN(),\n    .S_AXI_AWSIZE(),\n    .S_AXI_AWBURST(),\n    .S_AXI_AWVALID(),\n    .S_AXI_AWREADY(),\n    .S_AXI_WDATA(),\n    .S_AXI_WSTRB(),\n    .S_AXI_WLAST(),\n    .S_AXI_WVALID(),\n    .S_AXI_WREADY(),\n    .S_AXI_BID(),\n    .S_AXI_BRESP(),\n    .S_AXI_BVALID(),\n    .S_AXI_BREADY(),\n    .S_AXI_ARID(),\n    .S_AXI_ARADDR(),\n    .S_AXI_ARLEN(),\n    .S_AXI_ARSIZE(),\n    .S_AXI_ARBURST(),\n    .S_AXI_ARVALID(),\n    .S_AXI_ARREADY(),\n    .S_AXI_RID(),\n    .S_AXI_RDATA(),\n    .S_AXI_RRESP(),\n    .S_AXI_RLAST(),\n    .S_AXI_RVALID(),\n    .S_AXI_RREADY(),\n    .S_AXI_INJECTSBITERR(),\n    .S_AXI_INJECTDBITERR(),\n    .S_AXI_SBITERR(),\n    .S_AXI_DBITERR(),\n    .S_AXI_RDADDRECC()\n  );\n\n  // synthesis translate_on\n\nendmodule"}
{"task_id": 787, "completion": "wire or0_out;\n    wire and0_out_X;\n    wire pwrgood_pp0_out_X;\n\n    or or0 (or0_out, A2, A1);\n    and and0 (and0_out_X, or0_out, B1);\n    sky130_fd_sc_hdll__udp_pwrgood_pp$PG pwrgood_pp0 (pwrgood_pp0_out_X, and0_out_X, VPWR, VGND);\n    buf buf0 (X, pwrgood_pp0_out_X);\n\nendmodule"}
{"task_id": 874, "completion": "output X    ;\n    input  A    ;\n    input  SLEEP;\n    input  KAPWR;\n    input  VGND ;\n    input  VPB  ;\n    input  VNB  ;\n\n    wire sleepn;\n    wire pwrgood_pp0_out_A;\n    wire pwrgood_pp1_out_sleepn;\n\n    not not0 (sleepn, SLEEP);\n    sky130_fd_sc_lp__udp_pwrgood_pp$PG pwrgood_pp0 (pwrgood_pp0_out_A, A, KAPWR, VGND);\n    sky130_fd_sc_lp__udp_pwrgood_pp$PG pwrgood_pp1 (pwrgood_pp1_out_sleepn, sleepn, KAPWR, VGND);\n    and and0 (X, pwrgood_pp0_out_A, pwrgood_pp1_out_sleepn);\n\nendmodule"}
{"task_id": 32, "completion": "function integer clogb2 (input integer bit_depth);\n integer i;\n integer temp_log;\n begin\n  temp_log = 0;\n  for(i=bit_depth; i > 0; i = i>>1)\n  clogb2 = temp_log;\n  temp_log=temp_log+1;\n end\nendfunction\n\nlocalparam DEPTH  = clogb2(FIFO_SIZE-1);\n\nwire [31:0] reset_zeros;\nreg  [31:0] trace_pedge;\nreg  [31:0] ti;\nreg  [31:0] tom;\n\nreg  [3:0] atid;\n\nreg [31:0] trace_fifo [FIFO_SIZE-1:0];\n\nreg  [4:0]  dly_ctr;\nreg  [DEPTH-1:0]  fifo_wp;\nreg  [DEPTH-1:0]  fifo_rp;\n\nreg         fifo_re;\nwire        fifo_empty;\nwire        fifo_full;\nreg         fifo_full_reg;\n\nassign reset_zeros = 32'h0;\n\nalways @(posedge TRACE_CLK) begin\n    if((RST == 1'b1)) begin\n      atid <= reset_zeros;\n    end\n    else begin\n      atid <= TRACE_ATID_IN;\n    end\n  end\n\nassign TRACE_ATID_OUT = atid;\n  \ngenerate\n    if (USE_TRACE_DATA_EDGE_DETECTOR == 0) begin : gen_no_data_edge_detector\n      always @(posedge TRACE_CLK) begin\n          if (TRACE_VALID_IN == 1'b1 && fifo_full_reg != 1'b1) begin\n              trace_fifo[fifo_wp]  <= TRACE_DATA_IN;\n          end\n      end\n\n      always @(posedge TRACE_CLK) begin\n          if(RST == 1'b1) begin\n            fifo_wp <= {DEPTH{1'b0}};\n          end\n          else if(TRACE_VALID_IN ) begin\n            if(fifo_wp == (FIFO_SIZE - 1)) begin\n              if (fifo_empty) begin\n                 fifo_wp <= {DEPTH{1'b0}};\n              end\n            end\n            else begin\n              fifo_wp <= fifo_wp + 1;\n            end\n          end\n      end\n    end else begin : gen_data_edge_detector\n      always @(posedge TRACE_CLK) begin\n        if((RST == 1'b1)) begin\n          ti          <= reset_zeros;\n          trace_pedge <= reset_zeros;\n        end\n        else begin\n          ti          <= TRACE_DATA_IN;\n          trace_pedge <= (~ti & TRACE_DATA_IN);\n        end\n      end\n\n      always @(posedge TRACE_CLK) begin\n         if(|(trace_pedge)  == 1'b1 && fifo_full_reg != 1'b1) begin\n            trace_fifo[fifo_wp]  <= trace_pedge;\n         end\n      end\n\n      always @(posedge TRACE_CLK) begin\n          if(RST == 1'b1) begin\n            fifo_wp <= {DEPTH{1'b0}};\n          end\n          else if(|(trace_pedge)  == 1'b1) begin\n            if(fifo_wp == (FIFO_SIZE - 1)) begin\n              if (fifo_empty) begin\n                 fifo_wp <= {DEPTH{1'b0}};\n              end\n            end\n            else begin\n              fifo_wp <= fifo_wp + 1;\n            end\n          end\n      end\n    end\n  endgenerate\n\n  always @(posedge TRACE_CLK) begin\n    tom <= trace_fifo[fifo_rp];\n  end\n\n  always @(posedge TRACE_CLK) begin\n    if(RST == 1'b1) begin\n      fifo_rp <= {DEPTH{1'b0}};\n      fifo_re <= 1'b0;\n    end\n    else if(fifo_empty != 1'b1 && dly_ctr == 5'b00000 && fifo_re == 1'b0) begin\n      fifo_re <= 1'b1;\n      if(fifo_rp == (FIFO_SIZE - 1)) begin\n        fifo_rp <= {DEPTH{1'b0}};\n      end\n      else begin\n        fifo_rp <= fifo_rp + 1;\n      end\n    end\n    else begin\n      fifo_re <= 1'b0;\n    end\n  end\n  \n  always @(posedge TRACE_CLK) begin\n    if(RST == 1'b1) begin\n      dly_ctr <= 5'h0;\n    end\n    else if (fifo_re == 1'b1) begin\n      dly_ctr <= C_DELAY_CLKS-1;\n    end\n    else if(dly_ctr != 5'h0) begin\n      dly_ctr <= dly_ctr - 1;\n    end\n  end\n\n  assign fifo_empty = (fifo_wp == fifo_rp) ? 1'b1 : 1'b0;\n\n  assign fifo_full = (fifo_wp == FIFO_SIZE-1)? 1'b1 : 1'b0;\n\n  always @(posedge TRACE_CLK) begin\n    if(RST == 1'b1) begin\n      fifo_full_reg <= 1'b0;\n    end\n    else if (fifo_empty) begin\n      fifo_full_reg <= 1'b0;\n    end else begin\n      fifo_full_reg <= fifo_full;\n    end\n  end  \n\n  assign TRACE_DATA_OUT     = tom;\n  \n  assign TRACE_VALID_OUT    = fifo_re;  \n\nendmodule"}
{"task_id": 86, "completion": "input [1-1:0] clk;\n    input [1-1:0] rstn;\n\n    input ctrl_launch_i;\n    input ctrl_launch_sel_i;\n    output ctrl_done_o;\n\n    output [1-1:0] mv_rden_o;\n    output [6-1:0] mv_rdaddr_o;\n    input [2*`FMV_WIDTH-1:0] mv_data_i;\n\n    output [1-1:0] ref_rden_o;\n    output [6-1:0] ref_idx_x_o;\n    output [6-1:0] ref_idx_y_o;\n    output [1-1:0] ref_sel_o;\n    input [8*`PIXEL_WIDTH-1:0] ref_pel_i;\n\n    output [32*`PIXEL_WIDTH-1:0] pred_pixel_o;\n    output [4-1:0] pred_wren_o;\n    output [7-1:0] pred_addr_o;\n\n    parameter IDLE = 2'b00;\n    parameter PRE = 2'b01;\n    parameter MC = 2'b10;\n    parameter DONE = 2'b11;\n\n    reg [2-1:0] current_state, next_state;\n    wire [`FMV_WIDTH-1:0] fmv_y, fmv_x;\n    wire [3-1:0] frac_y, frac_x;\n    reg [1-1:0] mv_valid;\n    reg [2-1:0] mv_cnt32;\n    reg [2-1:0] mv_cnt16;\n    reg [2-1:0] mv_cnt08;\n    reg [3-1:0] ref_cnt;\n    reg [2-1:0] ref_cnt32;\n    reg [2-1:0] ref_cnt16;\n    reg [2-1:0] ref_cnt08;\n    wire [3-1:0] fetch_row;\n    wire [3-1:0] fetch_row_minute;\n    reg [1-1:0] refuv_valid;\n    reg [2-1:0] pred_cnt32;\n    reg [2-1:0] pred_cnt16;\n    reg [2-1:0] pred_cnt08;\n    reg [32*`PIXEL_WIDTH-1:0] pred_pixel_o;\n    reg [4-1:0] pred_wren_o;\n    wire [1-1:0] end_oneblk_ip;\n    wire [1-1:0] frac_valid;\n    reg [2-1:0] frac_idx;\n    reg [6-1:0] frac;\n\n    wire [4*`PIXEL_WIDTH-1:0] fracuv;\n    wire [`PIXEL_WIDTH-1:0] refuv_p0;\n    wire [`PIXEL_WIDTH-1:0] refuv_p1;\n    wire [`PIXEL_WIDTH-1:0] refuv_p2;\n    wire [`PIXEL_WIDTH-1:0] refuv_p3;\n    wire [`PIXEL_WIDTH-1:0] refuv_p4;\n    wire [`PIXEL_WIDTH-1:0] refuv_p5;\n    wire [`PIXEL_WIDTH-1:0] refuv_p6;\n\n    always @(*) begin\n        case(current_state) \n            IDLE : begin\n                if ( ctrl_launch_i)\n                    next_state = PRE;\n                else\n                    next_state = IDLE;\n            end\n            PRE : begin\n                next_state = MC;\n            end\n            MC  : begin\n                if((&ref_cnt32) & (&ref_cnt16) & (&ref_cnt08) & (ref_cnt == fetch_row)) \n                    next_state = DONE;\n                else\n                    next_state = MC;\n            end\n            DONE : begin\n                if((&pred_cnt32) & (&pred_cnt16) & (&pred_cnt08) & end_oneblk_ip)\n                    next_state = IDLE;\n                else\n                    next_state = DONE;\n            end\n        endcase\n    end\n\n    always @ (posedge clk or negedge rstn) begin\n        if(~rstn) begin\n            current_state <= IDLE;\n        end\n        else begin\n            current_state <= next_state;\n        end\n    end\n\n    assign ctrl_done_o = (current_state == DONE) && ((&pred_cnt32) & (&pred_cnt16) & (&pred_cnt08) & end_oneblk_ip);\n\n    always @ (posedge clk or negedge rstn) begin\n        if(~rstn) begin\n            mv_cnt32 <= 2'd0; \n        end\n        else if (mv_cnt16 == 2'b11 && mv_cnt08 == 2'b11 && ref_cnt == fetch_row_minute) begin\n            mv_cnt32 <= mv_cnt32 + 'd1; \n        end\n    end\n\n    always @ (posedge clk or negedge rstn) begin\n        if(~rstn) begin\n            mv_cnt16 <= 2'd0; \n        end\n        else if (mv_cnt08 == 2'b11 && ref_cnt == fetch_row_minute) begin\n            mv_cnt16 <= mv_cnt16 + 'd1; \n        end\n    end\n\n    always @ (posedge clk or negedge rstn) begin\n        if(~rstn) begin\n            mv_cnt08 <= 2'd0; \n        end\n        else if (ref_cnt == fetch_row_minute) begin\n            mv_cnt08 <= mv_cnt08 + 'd1; \n        end\n    end\n\n    assign mv_rden_o = current_state == PRE || (current_state == MC && ref_cnt == fetch_row );\n    assign mv_rdaddr_o = {mv_cnt32[1], mv_cnt16[1], mv_cnt08[1], mv_cnt32[0], mv_cnt16[0], mv_cnt08[0]};\n    assign {fmv_x,fmv_y} = mv_data_i;\n\n    assign frac_y = fmv_y[2:0];\n    assign frac_x = fmv_x[2:0];\n    assign fetch_row = (frac_y == 'd0) ? 'd3 : 'd6;\n    assign fetch_row_minute = (frac_y == 'd0) ? 'd2 : 'd5;\n\n    always @ (posedge clk or negedge rstn) begin\n        if(~rstn) begin\n            ref_cnt32 <= 3'd0; \n            ref_cnt16 <= 3'd0; \n            ref_cnt08 <= 3'd0; \n            mv_valid  <= 1'd0;\n        end\n        else begin\n            ref_cnt32 <= mv_cnt32; \n            ref_cnt16 <= mv_cnt16; \n            ref_cnt08 <= mv_cnt08; \n            mv_valid  <= mv_rden_o;\n        end\n    end\n\n    always @ (posedge clk or negedge rstn) begin\n        if(~rstn) begin\n            ref_cnt <= 3'd0; \n        end\n        else if (ref_rden_o) begin\n            if( ref_cnt == fetch_row)\n                ref_cnt <= 'd0;\n            else\n                ref_cnt <= ref_cnt + 'd1;\n        end\n    end\n    always @ (posedge clk or negedge rstn) begin\n        if(~rstn) begin\n            refuv_valid <= 1'b0; \n        end\n        else begin\n            refuv_valid <= ref_rden_o;\n        end\n    end\n\n    assign ref_rden_o = (current_state == MC); \n    assign ref_idx_x_o = fmv_x[`FMV_WIDTH-1:3] + {1'b0,ref_cnt32[0],ref_cnt16[0],ref_cnt08[0],2'b0} + 'd7;\n    assign ref_idx_y_o = fmv_y[`FMV_WIDTH-1:3] + {1'b0,ref_cnt32[1],ref_cnt16[1],ref_cnt08[1],2'b0} + {3'b0,ref_cnt} + ((frac_y=='d0)? 'd8: 'd7);\n    assign ref_sel_o = ctrl_launch_sel_i;\n\n    always @ (posedge clk or negedge rstn) begin\n        if(~rstn) begin\n            pred_cnt32 <= 2'd0; \n        end\n        else if (pred_cnt16 == 2'b11 && pred_cnt08 == 2'b11 && end_oneblk_ip) begin\n            pred_cnt32 <= pred_cnt32 + 'd1; \n        end\n    end\n    always @ (posedge clk or negedge rstn) begin\n        if(~rstn) begin\n            pred_cnt16 <= 2'd0; \n        end\n        else if (pred_cnt08 == 2'b11 && end_oneblk_ip) begin\n            pred_cnt16 <= pred_cnt16 + 'd1; \n        end\n    end\n    always @ (posedge clk or negedge rstn) begin\n        if(~rstn) begin\n            pred_cnt08 <= 2'd0; \n        end\n        else if (end_oneblk_ip) begin\n            pred_cnt08 <= pred_cnt08 + 'd1; \n        end\n    end\n\n    always @ (*) begin\n        case({pred_cnt16[0],pred_cnt08[0]})\n        2'b00: begin pred_pixel_o = { {fracuv,32'b0} , 64'b0, 64'b0, 64'b0 }; pred_wren_o = 4'b1000 & {4{frac_valid}}; end \n        2'b01: begin pred_pixel_o = {  64'b0, {fracuv,32'b0}, 64'b0, 64'b0 }; pred_wren_o = 4'b0100 & {4{frac_valid}}; end \n        2'b10: begin pred_pixel_o = {  64'b0, 64'b0, {fracuv,32'b0} ,64'b0 }; pred_wren_o = 4'b0010 & {4{frac_valid}}; end \n        2'b11: begin pred_pixel_o = {  64'b0, 64'b0, 64'b0, {fracuv,32'b0} }; pred_wren_o = 4'b0001 & {4{frac_valid}}; end \n        endcase\n    end\n\n    assign pred_addr_o = {pred_cnt32[1], pred_cnt32[0], pred_cnt16[1], pred_cnt08[1], 1'b0, frac_idx};\n\n    assign refuv_p0 = ref_pel_i[8*`PIXEL_WIDTH-1:7*`PIXEL_WIDTH];\n    assign refuv_p1 = ref_pel_i[7*`PIXEL_WIDTH-1:6*`PIXEL_WIDTH];\n    assign refuv_p2 = ref_pel_i[6*`PIXEL_WIDTH-1:5*`PIXEL_WIDTH];\n    assign refuv_p3 = ref_pel_i[5*`PIXEL_WIDTH-1:4*`PIXEL_WIDTH];\n    assign refuv_p4 = ref_pel_i[4*`PIXEL_WIDTH-1:3*`PIXEL_WIDTH];\n    assign refuv_p5 = ref_pel_i[3*`PIXEL_WIDTH-1:2*`PIXEL_WIDTH];\n    assign refuv_p6 = ref_pel_i[2*`PIXEL_WIDTH-1:1*`PIXEL_WIDTH];\n\n    always @ (posedge clk or negedge rstn) begin\n        if(~rstn) begin\n            frac_idx <= 2'd0; \n        end\n        else if (frac_valid) begin\n            frac_idx <= frac_idx + 'd1;\n        end\n    end\n\n    always @ (posedge clk or negedge rstn) begin\n        if(~rstn) begin\n            frac <= 'd0; \n        end\n        else if (mv_valid) begin\n            frac <= {frac_y,frac_x};\n        end\n    end\n\n    mc_chroma_ip4x4 mc_chroma_ip(\n              .clk            (clk            ),\n              .rstn           (rstn           ),\n                                           \n              .frac_i         (frac           ),\n                                           \n              .blk_start_i    (ctrl_launch_i  ),\n                                           \n              .refuv_valid_i  (refuv_valid    ),\n              .refuv_p0_i     (refuv_p0       ),\n              .refuv_p1_i     (refuv_p1       ),\n              .refuv_p2_i     (refuv_p2       ),\n              .refuv_p3_i     (refuv_p3       ),\n              .refuv_p4_i     (refuv_p4       ),\n              .refuv_p5_i     (refuv_p5       ),\n              .refuv_p6_i     (refuv_p6       ),\n                                           \n              .frac_valid_o   (frac_valid     ),\n              .end_oneblk_ip_o(end_oneblk_ip  ),\n              .fracuv_o       (fracuv         )\n    );\n\nendmodule"}
{"task_id": 859, "completion": "reg fifo_rd_en, empty_nxt;\n\n   small_fifo\n     #(.WIDTH (WIDTH),\n       .MAX_DEPTH_BITS (MAX_DEPTH_BITS),\n       .PROG_FULL_THRESHOLD (PROG_FULL_THRESHOLD))\n       fifo\n        (.din           (din),\n         .wr_en         (wr_en),\n         .rd_en         (fifo_rd_en),\n         .dout          (dout),\n         .full          (full),\n         .nearly_full   (nearly_full),\n         .prog_full     (prog_full),\n         .empty         (fifo_empty),\n         .reset         (reset),\n         .clk           (clk)\n         );\n\n   always @(*) begin\n      empty_nxt  = empty;\n      fifo_rd_en = 0;\n      case (empty)\n         1'b1: begin\n            if(!fifo_empty) begin\n               fifo_rd_en = 1;\n               empty_nxt  = 0;\n            end\n         end\n\n         1'b0: begin\n            if(rd_en) begin\n               if(fifo_empty) begin\n                  empty_nxt = 1;\n               end\n               else begin\n                  fifo_rd_en = 1;\n               end\n            end\n         end\n      endcase\n   end\n\n   always @(posedge clk) begin\n      if(reset) begin\n         empty <= 1'b1;\n      end\n      else begin\n         empty <= empty_nxt;\n      end\n   end\n\n   always @(posedge clk)\n   begin\n      if (wr_en && full) begin\n         $display(\"%t ERROR: Attempt to write to full FIFO: %m\", $time);\n      end\n      if (rd_en && empty) begin\n         $display(\"%t ERROR: Attempt to read an empty FIFO: %m\", $time);\n      end\n   end\nendmodule"}
{"task_id": 769, "completion": "wire                  null_rx_tvalid;\nwire                  null_rx_tlast;\nwire [KEEP_WIDTH-1:0] null_rx_tkeep;\nwire                  null_rdst_rdy;\nwire            [4:0] null_is_eof;\n\npcie_7x_v1_3_axi_basic_rx_pipeline #(\n.C_DATA_WIDTH( C_DATA_WIDTH ),\n.C_FAMILY( C_FAMILY ),\n.TCQ( TCQ ),\n.REM_WIDTH( REM_WIDTH ),\n.KEEP_WIDTH( KEEP_WIDTH )\n) rx_pipeline_inst (\n.m_axis_rx_tdata( m_axis_rx_tdata ),\n.m_axis_rx_tvalid( m_axis_rx_tvalid ),\n.m_axis_rx_tready( m_axis_rx_tready ),\n.m_axis_rx_tkeep( m_axis_rx_tkeep ),\n.m_axis_rx_tlast( m_axis_rx_tlast ),\n.m_axis_rx_tuser( m_axis_rx_tuser ),\n.trn_rd( trn_rd ),\n.trn_rsof( trn_rsof ),\n.trn_reof( trn_reof ),\n.trn_rsrc_rdy( trn_rsrc_rdy ),\n.trn_rdst_rdy( trn_rdst_rdy ),\n.trn_rsrc_dsc( trn_rsrc_dsc ),\n.trn_rrem( trn_rrem ),\n.trn_rerrfwd( trn_rerrfwd ),\n.trn_rbar_hit( trn_rbar_hit ),\n.trn_recrc_err( trn_recrc_err ),\n.null_rx_tvalid( null_rx_tvalid ),\n.null_rx_tlast( null_rx_tlast ),\n.null_rx_tkeep( null_rx_tkeep ),\n.null_rdst_rdy( null_rdst_rdy ),\n.null_is_eof( null_is_eof ),\n.np_counter( np_counter ),\n.user_clk( user_clk ),\n.user_rst( user_rst )\n);\n\npcie_7x_v1_3_axi_basic_rx_null_gen #(\n.C_DATA_WIDTH( C_DATA_WIDTH ),\n.TCQ( TCQ ),\n.KEEP_WIDTH( KEEP_WIDTH )\n) rx_null_gen_inst (\n.m_axis_rx_tdata( m_axis_rx_tdata ),\n.m_axis_rx_tvalid( m_axis_rx_tvalid ),\n.m_axis_rx_tready( m_axis_rx_tready ),\n.m_axis_rx_tlast( m_axis_rx_tlast ),\n.m_axis_rx_tuser( m_axis_rx_tuser ),\n.null_rx_tvalid( null_rx_tvalid ),\n.null_rx_tlast( null_rx_tlast ),\n.null_rx_tkeep( null_rx_tkeep ),\n.null_rdst_rdy( null_rdst_rdy ),\n.null_is_eof( null_is_eof ),\n.user_clk( user_clk ),\n.user_rst( user_rst )\n);\n\nendmodule"}
{"task_id": 928, "completion": "CLA_16Bits     BITS15_0(PP[0],GP[0],S[15:0],A[15:0],B[15:0],CI),\n                 BITS31_16(PP[1],GP[1],S[31:16],A[31:16],B[31:16],C16);\n\n  CLA_Gen_2Bits  GEN31_0(PPP,GPP,C16,PP[1:0],GP[1:0],CI);\n  assign         CO =  GPP | PPP&CI;\n\nendmodule"}
{"task_id": 504, "completion": "assign and_result = b1 & b2;\n    assign or_result = b1 | b2;\n    assign nand_result = ~(b1 & b2);\n\n    assign and3_result = b1 & b2 & b3;\nendmodule"}
{"task_id": 959, "completion": "input clock, reset;\n    input [1:0] write_data_selector;\n    output wire clock2, led_write, led_read, led_success, led_fail, WE;\n    output wire [3:0] estado, mem_data;\n    output wire [6:0] addr, dato;\n\n    wire [1:0] write_data_selector_sync;\n    wire reset_sync;\n    wire div_clock;\n    wire [3:0] write_value, read_value, data;\n    wire enable_cuenta, write_value_reg_en, read_value_reg_en;\n    wire [3:0] mem_address;\n\n    Clock_Divider mod_divisor(\n        .clock(clock), \n        .reset(reset_sync), \n        .clock_out(div_clock)\n    );\n    Debounce mod_debounce(\n        .clock(clock), \n        .reset(reset), \n        .div_clock(div_clock),\n        .write_data_selector(write_data_selector), \n        .reset_sync(reset_sync), \n        .write_data_selector_sync(write_data_selector_sync)\n    );    \n    FSM mod_fsm(\n        .div_clock(div_clock),\n        .reset(reset_sync),\n        .enable_cuenta(enable_cuenta), \n        .write_enable(WE), \n       .write_value_reg_en(write_value_reg_en),\n        .read_value_reg_en(read_value_reg_en), \n        .led_write(led_write), \n        .led_read(led_read),\n        .estado(estado)\n    );\n    assign clock2 = div_clock;\n    Contador mod_contador(\n        .enable_cuenta(enable_cuenta),\n        .reset(reset_sync),\n        .mem_address(mem_address)\n    );\n    assign addr = mem_address;\n    Data_Parameters mod_data(\n        .clock(clock),\n        .reset(reset_sync),\n        .mem_address(mem_address), \n        .write_value_reg_en(write_value_reg_en), \n        .write_data_selector(write_data_selector_sync), \n        .write_value(write_value)\n    );\n    Buffer mod_buffer(\n        .WE(WE),\n        .write_value(write_value),\n        .read_value(read_value), \n        .data(data)\n    );\n    assign dato = data;\n    Memoria mod_memoria(\n        .WE(WE),\n        .ADDR(mem_address),\n        .DATA(data),\n        .mem_data(mem_data)\n    );\n    Comparador mod_compara(\n        .clock(clock),\n        .reset(reset_sync), \n        .write_value(write_value), \n        .read_value(read_value), \n        .read_value_reg_en(read_value_reg_en), \n        .led_success(led_success), \n        .led_fail(led_fail)\n    );\nendmodule"}
{"task_id": 838, "completion": "ZedboardOLED_v1_0_S00_AXI # ( \n\t.C_S_AXI_DATA_WIDTH(C_S00_AXI_DATA_WIDTH),\n\t.C_S_AXI_ADDR_WIDTH(C_S00_AXI_ADDR_WIDTH)\n) ZedboardOLED_v1_0_S00_AXI_inst (\n\t.S_AXI_ACLK(s00_axi_aclk),\n\t.S_AXI_ARESETN(s00_axi_aresetn),\n\t.S_AXI_AWADDR(s00_axi_awaddr),\n\t.S_AXI_AWPROT(s00_axi_awprot),\n\t.S_AXI_AWVALID(s00_axi_awvalid),\n\t.S_AXI_AWREADY(s00_axi_awready),\n\t.S_AXI_WDATA(s00_axi_wdata),\n\t.S_AXI_WSTRB(s00_axi_wstrb),\n\t.S_AXI_WVALID(s00_axi_wvalid),\n\t.S_AXI_WREADY(s00_axi_wready),\n\t.S_AXI_BRESP(s00_axi_bresp),\n\t.S_AXI_BVALID(s00_axi_bvalid),\n\t.S_AXI_BREADY(s00_axi_bready),\n\t.S_AXI_ARADDR(s00_axi_araddr),\n\t.S_AXI_ARPROT(s00_axi_arprot),\n\t.S_AXI_ARVALID(s00_axi_arvalid),\n\t.S_AXI_ARREADY(s00_axi_arready),\n\t.S_AXI_RDATA(s00_axi_rdata),\n\t.S_AXI_RRESP(s00_axi_rresp),\n\t.S_AXI_RVALID(s00_axi_rvalid),\n\t.SDIN(SDIN),\n\t.SCLK(SCLK),\n\t.DC(DC),\n\t.RES(RES),\n\t.VBAT(VBAT),\n\t.VDD(VDD),   \n\t.S_AXI_RREADY(s00_axi_rready)\n);\n\nendmodule"}
{"task_id": 975, "completion": "wire signed [31:0] Constant1_out1;\n  wire signed [31:0] Reset_Switch1_out1;\n  reg signed [31:0] In_Delay_out1;\n  wire signed [31:0] Constant_out1;\n  wire signed [31:0] Reset_Switch_out1;\n\n  assign Constant1_out1 = 32'sb00000000000000000000000000000000;\n\n  assign Reset_Switch1_out1 = (Reset_1 == 1'b0 ? In : Constant1_out1);\n\n  always @(posedge CLK_IN) begin : In_Delay_process\n    if (reset == 1'b1) begin\n      In_Delay_out1 <= 32'sb00000000000000000000000000000000;\n    end else if (enb_1_2000_0) begin\n      In_Delay_out1 <= Reset_Switch1_out1;\n    end\n  end\n\n  assign Constant_out1 = 32'sb00000000000000000000000000000000;\n\n  assign Reset_Switch_out1 = (Reset_1 == 1'b0 ? In_Delay_out1 : Constant_out1);\n\n  assign Out = Reset_Switch_out1;\nendmodule"}
{"task_id": 1015, "completion": "output Y   ;    input  A1  ;    input  A2  ;    input  B1  ;    input  B2  ;    input  VPWR;    input  VGND;endmodule"}
{"task_id": 443, "completion": "input wire DX;\n    input wire D1;\n    input wire D2;\n    input wire D3;\n    input wire D4;\n    input wire D5;\n    input wire D6;\n    output wire DMUX;\n    output wire D;\n    output wire DQ;\n\n    parameter D5FF_SRVAL = \"SRLOW\";\n    parameter D5FF_INIT = D5FF_SRVAL;\n    parameter DFF_SRVAL = \"SRLOW\";\n    parameter DFF_INIT = D5FF_SRVAL;\n\n    input wire CX;\n    input wire C1;\n    input wire C2;\n    input wire C3;\n    input wire C4;\n    input wire C5;\n    input wire C6;\n    output wire CMUX;\n    output wire C;\n    output wire CQ;\n\n    input wire BX;\n    input wire B1;\n    input wire B2;\n    input wire B3;\n    input wire B4;\n    input wire B5;\n    input wire B6;\n    output wire BMUX;\n    output wire B;\n    output wire BQ;\n\n    input wire AX;\n    input wire A1;\n    input wire A2;\n    input wire A3;\n    input wire A4;\n    input wire A5;\n    input wire A6;\n    output wire AMUX;\n    output wire A;\n    output wire AQ;\n\n    input wire CLK;\n    input wire SR;\n    input wire CE;\n\n    parameter SR_TYPE = \"SYNC\";\n    parameter FF_MODE = \"FLIPFLOP\";\n\n    input wire CIN;\n    input wire CYINIT;\n    output wire COUT;\n\n    wire A5LUT_O5;\n    wire B5LUT_O5;\n    wire C5LUT_O5;\n    wire D5LUT_O5;\n    wire D6LUT_O6;\n    wire C6LUT_O6;\n    wire B6LUT_O6;\n    wire A6LUT_O6;\n\n    ALUT alut (.A1(A1), .A2(A2), .A3(A3), .A4(A4), .A5(A5), .A6(A6), .O6(A6LUT_O6), .O5(A5LUT_O5));\n    BLUT blut (.A1(B1), .A2(B2), .A3(B3), .A4(B4), .A5(B5), .A6(B6), .O6(B6LUT_O6), .O5(B5LUT_O5));\n    CLUT clut (.A1(C1), .A2(C2), .A3(C3), .A4(C4), .A5(C5), .A6(C6), .O6(C6LUT_O6), .O5(C5LUT_O5));\n    DLUT dlut (.A1(D1), .A2(D2), .A3(D3), .A4(D4), .A5(D5), .A6(D6), .O6(D6LUT_O6), .O5(D5LUT_O5));\n\n    wire F7AMUX_OUT;\n    wire F8MUX_OUT;\n\n    wire A5FFMUX_OUT;\n    wire B5FFMUX_OUT;\n    wire C5FFMUX_OUT;\n    wire D5FFMUX_OUT;\n\n    A5FFMUX a5ffmux (.IN_B(AX), .IN_A(A5LUT_O5), .O(A5FFMUX_OUT));\n    B5FFMUX b5ffmux (.IN_B(BX), .IN_A(B5LUT_O5), .O(B5FFMUX_OUT));\n    C5FFMUX c5ffmux (.IN_B(CX), .IN_A(C5LUT_O5), .O(C5FFMUX_OUT));\n    D5FFMUX d5ffmux (.IN_B(DX), .IN_A(D5LUT_O5), .O(D5FFMUX_OUT));\n\n    wire ACY0_OUT;\n    wire BCY0_OUT;\n    wire CCY0_OUT;\n    wire DCY0_OUT;\n\n    ACY0 acy0 (.O5(A5LUT_O5), .AX(AX), .O(ACY0_OUT));\n    BCY0 bcy0 (.O5(B5LUT_O5), .BX(BX), .O(BCY0_OUT));\n    CCY0 ccy0 (.O5(C5LUT_O5), .CX(CX), .O(CCY0_OUT));\n    DCY0 dcy0 (.O5(D5LUT_O5), .DX(DX), .O(DCY0_OUT));\n\n    wire F7BMUX_OUT;\n    F7BMUX f7bmux (.I0(D6LUT_O6), .I1(C6LUT_O6), .OUT(F7BMUX_OUT), .S0(CX));\n    wire F7AMUX_OUT;\n    F7BMUX f7amux (.I0(B6LUT_O6), .I1(A6LUT_O6), .OUT(F7AMUX_OUT), .S0(AX));\n    wire F8MUX_OUT;\n    F8MUX f8mux (.I0(F7BMUX_OUT), .I1(F7AMUX_OUT), .OUT(F8MUX_OUT), .S0(BX));\n\n    wire PRECYINIT_OUT;\n    PRECYINIT_MUX precyinit_mux (.C0(0), .C1(1), .CI(CIN), .CYINIT(CYINIT), .OUT(PRECYINIT_OUT));\n\n    wire [3:0] CARRY4_CO;\n    wire [3:0] CARRY4_O;\n\n    CARRY4_MODES carry4 (\n        .CO(CARRY4_CO),\n        .O(CARRY4_O),\n        .DI({ACY0_OUT, BCY0_OUT, CCY0_OUT, DCY0_OUT}),\n        .S({A6LUT_O6, B6LUT_O6, C6LUT_O6, D6LUT_O6}),\n        .CIN(PRECYINIT_OUT));\n\n    COUTUSED coutused (.IN(CARRY4_O[3]), .OUT(COUT));\n\n    wire A5FF_Q;\n    wire B5FF_Q;\n    wire C5FF_Q;\n    wire D5FF_Q;\n\n    AOUTMUX aoutmux (\n        .A5Q(A5FF_Q), .XOR(CARRY4_O[0]), .O6(A6LUT_O6), .O5(A5LUT_O5), .CY(CARRY4_CO[0]), .F7(F7AMUX_OUT),\n        .OUT(AMUX));\n    BOUTMUX boutmux (\n        .B5Q(B5FF_Q), .XOR(CARRY4_O[1]), .O6(B6LUT_O6), .O5(B5LUT_O5), .CY(CARRY4_CO[1]), .F8(F8MUX_OUT),\n        .OUT(BMUX));\n    COUTMUX coutmux (\n        .C5Q(C5FF_Q), .XOR(CARRY4_O[2]), .O6(C6LUT_O6), .O5(C5LUT_O5), .CY(CARRY4_CO[2]), .F7(F7BMUX_OUT),\n        .OUT(CMUX));\n    DOUTMUX doutmux (\n        .D5Q(D5FF_Q), .XOR(CARRY4_O[3]), .O6(D6LUT_O6), .O5(D5LUT_O5), .CY(CARRY4_CO[3]),\n        .OUT(DMUX));\n\n    wire AFFMUX_OUT;\n    wire BFFMUX_OUT;\n    wire CFFMUX_OUT;\n    wire DFFMUX_OUT;\n\n    AFFMUX affmux (\n        .AX(AX), .XOR(CARRY4_O[0]), .O6(A6LUT_O6), .O5(A5LUT_O5), .CY(CARRY4_CO[0]), .F7(F7AMUX_OUT),\n        .OUT(AFFMUX_OUT));\n    BFFMUX bffmux (\n        .BX(BX), .XOR(CARRY4_O[1]), .O6(B6LUT_O6), .O5(B5LUT_O5), .CY(CARRY4_CO[1]), .F8(F8MUX_OUT),\n        .OUT(BFFMUX_OUT));\n    CFFMUX cffmux (\n        .CX(CX), .XOR(CARRY4_O[2]), .O6(C6LUT_O6), .O5(C5LUT_O5), .CY(CARRY4_CO[2]), .F7(F7BMUX_OUT),\n        .OUT(CFFMUX_OUT));\n    DFFMUX dffmux (\n        .DX(DX), .XOR(CARRY4_O[3]), .O6(D6LUT_O6), .O5(D5LUT_O5), .CY(CARRY4_CO[3]),\n        .OUT(DFFMUX_OUT));\n\n    wire CEUSEDMUX_OUT;\n    wire SRUSEDMUX_OUT;\n    wire CLKINV_OUT;\n\n    CLKINV clkinv (.CLK(CLK), .OUT(CLKINV_OUT));\n\n    A5FF a5ff (.CE(CEUSEDMUX_OUT), .CK(CLKINV_OUT), .SR(SRUSEDMUX_OUT), .D(A5FFMUX_OUT), .Q(A5FF_Q));\n    B5FF b5ff (.CE(CEUSEDMUX_OUT), .CK(CLKINV_OUT), .SR(SRUSEDMUX_OUT), .D(B5FFMUX_OUT), .Q(B5FF_Q));\n    C5FF c5ff (.CE(CEUSEDMUX_OUT), .CK(CLKINV_OUT), .SR(SRUSEDMUX_OUT), .D(C5FFMUX_OUT), .Q(C5FF_Q));\n    D5FF d5ff (.CE(CEUSEDMUX_OUT), .CK(CLKINV_OUT), .SR(SRUSEDMUX_OUT), .D(D5FFMUX_OUT), .Q(D5FF_Q));\n\n    A5FF aff  (.CE(CEUSEDMUX_OUT), .CK(CLKINV_OUT), .SR(SRUSEDMUX_OUT), .D(AFFMUX_OUT),  .Q(AQ));\n    B5FF bff  (.CE(CEUSEDMUX_OUT), .CK(CLKINV_OUT), .SR(SRUSEDMUX_OUT), .D(BFFMUX_OUT),  .Q(BQ));\n    C5FF cff  (.CE(CEUSEDMUX_OUT), .CK(CLKINV_OUT), .SR(SRUSEDMUX_OUT), .D(CFFMUX_OUT),  .Q(CQ));\n    D5FF dff  (.CE(CEUSEDMUX_OUT), .CK(CLKINV_OUT), .SR(SRUSEDMUX_OUT), .D(DFFMUX_OUT),  .Q(DQ));\n\n    AUSED aused (.I0(A6LUT_O6), .O(A));\n    BUSED bused (.I0(B6LUT_O6), .O(B));\n    CUSED cused (.I0(C6LUT_O6), .O(C));\n    DUSED dused (.I0(D6LUT_O6), .O(D));\n\n    CEUSEDMUX ceusedmux (.IN(CE), .OUT(CEUSEDMUX_OUT));\n    SRUSEDMUX srusedmux (.IN(SR), .OUT(SRUSEDMUX_OUT));\n\nendmodule"}
{"task_id": 1028, "completion": "output Q;\n    input  D;\n    input  SLEEP_B;\n    input  VPWR;\n    input  VGND;\n    input  VPB;\n    input  VNB;\nendmodule"}
{"task_id": 283, "completion": "reg scan_mode;  reg input_wasvalid;  reg input_wasready;  reg input_hasdata;  reg [511:0] input_datareg;  reg config_valid;  reg [CHAR_COUNT*8-1:0] config_chars;  reg [CHAR_COUNT/2-1:0] config_ranges;  reg [CHAR_COUNT-1:0] config_conds;  reg [STATE_COUNT*(CHAR_COUNT)-1:0] config_state_pred;  reg [STATE_COUNT*STATE_COUNT-1:0] config_state_act;  reg restart;  reg wait_new;  reg wait_conf;  wire pred_valid;  wire [CHAR_COUNT-1:0] pred_bits;  wire [15:0] pred_index;  wire pred_last;  reg need_purge;  reg pred_valid_D;  reg pred_last_D;  reg [15:0] pred_index_D;  reg [STATE_COUNT*(CHAR_COUNT)-1:0] state_pred_masks;  reg [STATE_COUNT*STATE_COUNT-1:0] state_act_masks;  wire [STATE_COUNT-1:0] state_match_bits;  wire [STATE_COUNT-1:0] state_inact_bits;  wire [STATE_COUNT-1:0] state_outact_bits;  reg [STATE_COUNT*4-1:0] state_inact_delays;  reg [STATE_COUNT-1:0] always_activated;  reg [STATE_COUNT-1:0] state_act_sticky;  reg [15:0] string_length;  reg [7:0] length_remaining;  reg [5:0] byte_addr;  reg waiting_pred;  reg dec_valid;  reg dec_last;  reg [7:0] dec_char;  reg rstBuf;  localparam STATE_ACT_SIZE = (STATE_COUNT*STATE_COUNT % 8 ==0) ? STATE_COUNT*STATE_COUNT : STATE_COUNT*STATE_COUNT+8-(STATE_COUNT*STATE_COUNT%8);  rem_decoder  #( .CHAR_COUNT(CHAR_COUNT), .DELIMITER(DELIMITER) ) decoder_inst ( .clk(clk), .rst(rstBuf), .config_valid(config_valid), .config_chars(config_chars), .config_ranges(config_ranges), .config_conds(config_conds), .input_valid(dec_valid), .input_last(dec_last), .input_char(dec_char), .index_rewind(wait_new), .output_valid(pred_valid), .output_data(pred_bits), .output_index(pred_index), .output_last(pred_last) );  genvar X;  generate for (X=0; X<STATE_COUNT; X=X+1) begin: gen_states rem_onestate onestate_inst ( .clk(clk), .rst(rstBuf | wait_new), .is_sticky(state_act_sticky), .delay_valid(config_valid), .delay_cycles(state_inact_delays[X*4 +: 4]), .pred_valid(pred_valid), .pred_match(state_match_bits[X]), .act_input(state_inact_bits[X]), .act_output(state_outact_bits[X]) ); assign state_match_bits[X] = ((state_pred_masks[(X+1)*(CHAR_COUNT)-1:X*(CHAR_COUNT)] & pred_bits) == 0 && state_pred_masks[(X+1)*(CHAR_COUNT)-1:X*(CHAR_COUNT)]!=0) ? 0 : 1; assign state_inact_bits[X] = ((state_act_masks[(X+1)*STATE_COUNT-1:X*STATE_COUNT] & state_outact_bits) != 0) ? 1 : always_activated[X]; end endgenerate integer ind; always @(posedge clk) begin pred_valid_D <= pred_valid; pred_last_D <= pred_last; pred_index_D <= pred_index; rstBuf <= rst; if (rst) begin output_valid <= 0; always_activated <= 0; string_length <= 0; wait_new <= 1; wait_conf <= 1; restart <= 0; need_purge <= 0; input_ready <= 1; config_valid <= 0; dec_valid <= 0; dec_last <= 0; input_wasready <= input_ready; input_wasvalid <= input_valid; input_hasdata <= 0; state_inact_delays <= 0; waiting_pred <= 0; scan_mode <= 0; end else begin if (restart) begin wait_conf <= 1 & (~scan_mode); wait_new <= 1; restart <= 0; end if (softRst) begin wait_conf <= 1; wait_new <= 1; restart <= 0; end input_wasvalid <= input_valid; input_wasready <= input_ready; output_valid <= 0; config_valid <= 0; dec_valid <= 0; dec_last <= 0; if (input_valid==1) begin input_ready <= 0; end input_hasdata <= input_ready==1 ? 0 : input_hasdata; if (input_ready && input_valid) begin input_datareg <= input_data; input_hasdata <= 1; end if (input_hasdata==1 && wait_conf==1) begin config_valid <= 1; config_chars <= input_datareg[CHAR_COUNT*8-1:0]; config_ranges <= input_datareg[CHAR_COUNT/2 + CHAR_COUNT*8-1 : CHAR_COUNT*8]; config_conds <= input_datareg[CHAR_COUNT-1+CHAR_COUNT/2 + CHAR_COUNT*8:CHAR_COUNT/2 + CHAR_COUNT*8]; config_state_pred <= input_datareg[STATE_COUNT*CHAR_COUNT+CHAR_COUNT+CHAR_COUNT/2 + CHAR_COUNT*8-1:CHAR_COUNT/2 + CHAR_COUNT*8+CHAR_COUNT]; config_state_act <= input_datareg[STATE_COUNT*STATE_COUNT+STATE_COUNT*CHAR_COUNT+CHAR_COUNT+CHAR_COUNT/2 + CHAR_COUNT*8-1:STATE_COUNT*CHAR_COUNT+CHAR_COUNT+CHAR_COUNT/2 + CHAR_COUNT*8]; state_pred_masks <= input_datareg[STATE_COUNT*CHAR_COUNT+CHAR_COUNT+CHAR_COUNT/2 + CHAR_COUNT*8-1:CHAR_COUNT/2 + CHAR_COUNT*8+CHAR_COUNT]; state_act_masks <= input_datareg[STATE_COUNT*STATE_COUNT+STATE_COUNT*CHAR_COUNT+CHAR_COUNT+CHAR_COUNT/2 + CHAR_COUNT*8-1:STATE_COUNT*CHAR_COUNT+CHAR_COUNT+CHAR_COUNT/2 + CHAR_COUNT*8]; state_inact_delays <= input_datareg[STATE_COUNT*4-1+STATE_ACT_SIZE+STATE_COUNT*CHAR_COUNT+CHAR_COUNT+CHAR_COUNT/2 + CHAR_COUNT*8 : STATE_ACT_SIZE+STATE_COUNT*CHAR_COUNT+CHAR_COUNT+CHAR_COUNT/2 + CHAR_COUNT*8]; state_act_sticky <= input_datareg[STATE_COUNT-1+STATE_COUNT*4+STATE_ACT_SIZE+STATE_COUNT*CHAR_COUNT+CHAR_COUNT+CHAR_COUNT/2 + CHAR_COUNT*8 : STATE_COUNT*4+STATE_ACT_SIZE+STATE_COUNT*CHAR_COUNT+CHAR_COUNT+CHAR_COUNT/2 + CHAR_COUNT*8]; for (ind=0; ind<STATE_COUNT; ind=ind+1) begin always_activated[ind]=0; if (input_datareg[(ind)*STATE_COUNT+STATE_COUNT*CHAR_COUNT+CHAR_COUNT+CHAR_COUNT/2 + CHAR_COUNT*8 +: STATE_COUNT]==0) always_activated[ind]=1; end wait_conf <= 0; input_ready <= 1; scan_mode <= input_datareg[511]; end if (restart==0 && wait_conf==0) begin if (!input_ready && input_hasdata==1 && wait_new==1) begin byte_addr <= 2; string_length <= input_datareg[15:0]; length_remaining <= (input_datareg[15:0]+63)/64; wait_new <= 0; if (input_datareg[15:0]==0) begin wait_new <=1; input_ready <= 1; end end if (!input_ready && input_hasdata==1 && wait_new==0) begin if (byte_addr<=63) begin dec_valid <= 1; dec_char <= input_datareg[byte_addr[5:0]*8 +: 8]; byte_addr <= byte_addr+1; if (byte_addr==63 && length_remaining==1) begin dec_last <= 1; end else begin dec_last <= 0; end end if (byte_addr==63 && length_remaining>1) begin byte_addr <= 0; input_ready <= 1; length_remaining <= length_remaining-1; end else if (byte_addr==63 && length_remaining==1 && !need_purge) begin byte_addr <= 0; input_hasdata <= 0; waiting_pred <= 1; length_remaining <= 0; end if (need_purge==1) begin if (length_remaining>1) begin byte_addr <= 64; length_remaining <= length_remaining-1; input_ready <= 1; end else begin byte_addr <= 0; restart <= 1; input_ready <= 1; need_purge <= 0; end end if (!need_purge && !wait_new && pred_valid_D==1 && (state_outact_bits[STATE_COUNT-1]==1 || pred_last_D==1)) begin output_valid <= 1; output_match <= state_outact_bits[STATE_COUNT-1]==1; output_index <= pred_index_D; if (!waiting_pred) begin need_purge<=1; end else begin waiting_pred <= 0; byte_addr <= 0; restart <= 1; input_ready <= 1; need_purge <= 0; end end if (!input_hasdata && output_valid==1 && waiting_pred==1) begin waiting_pred <= 0; byte_addr <= 0; restart <= 1; input_ready <= 1; need_purge <= 0; end if (!need_purge && waiting_pred==1 && pred_valid_D==0 && length_remaining==0) begin output_valid <= 1; output_match <= 0; output_index <= 0; waiting_pred <= 0; byte_addr <= 0; restart <= 1; input_ready <= 1; need_purge <= 0; end end end end end; endmodule"}
{"task_id": 1081, "completion": "input clk;\n  output clk_vga;\n  output clk_cpu;\n  output clk_2cpu;\nendmodule"}
{"task_id": 964, "completion": "pcie3_7x_0_pcie_bram_7vx_8k # (.IMPL_TARGET(IMPL_TARGET), .NO_DECODE_LOGIC(NO_DECODE_LOGIC), .INTERFACE_SPEED(INTERFACE_SPEED), .COMPLETION_SPACE(COMPLETION_SPACE)) U0 (.clk_i(clk_i), .reset_i(reset_i), .waddr0_i(waddr0_i[8:0]), .waddr1_i(waddr1_i[8:0]), .wdata_i(wdata_i[127:0]), .wdip_i(wdip_i[15:0]), .wen_i({wen3_i, wen2_i, wen1_i, wen0_i}), .raddr0_i(raddr0_i[8:0]), .raddr1_i(raddr1_i[8:0]), .rdata_o(rdata_o[127:0]), .rdop_o(rdop_o[15:0]), .ren_i({ren3_i, ren2_i, ren1_i, ren0_i})); endmodule"}
{"task_id": 279, "completion": "endmodule"}
{"task_id": 1073, "completion": "wire or0_out;\n    wire nand0_out_Y;\n    wire pwrgood_pp0_out_Y;\n\n    or or0 (or0_out, A4, A3, A2, A1);\n    nand nand0 (nand0_out_Y, B1, or0_out);\n    sky130_fd_sc_ls__udp_pwrgood_pp$PG pwrgood_pp0 (pwrgood_pp0_out_Y, nand0_out_Y, VPWR, VGND);\n    buf buf0 (Y, pwrgood_pp0_out_Y);\n\nendmodule"}
{"task_id": 917, "completion": "parameter           IDLE                  = 4'h0;\n    parameter           WAIT_FOR_NO_RESET     = 4'h1;\n    parameter           SEND_INIT             = 4'h2;\n    parameter           WAIT_FOR_WAKE         = 4'h3;\n    parameter           WAIT_FOR_NO_WAKE      = 4'h4;\n    parameter           SEND_WAKE             = 4'h5;\n    parameter           STOP_SEND_WAKE        = 4'h6;\n    parameter           SEND_CONFIGURE_END    = 4'h7;\n    parameter           WAIT_FOR_DIALTONE     = 4'h8;\n    parameter           SEND_ALIGN            = 4'h9;\n    parameter           WAIT_FOR_ALIGN        = 4'hA;\n    parameter           READY                 = 4'hB;\n    parameter           SEND_FIRST_ALIGNMENT   = 4'hC;\n    parameter           SEND_SECOND_ALIGNMENT  = 4'hD;\n\n    parameter           INITIALIZE_TIMEOUT         = 100;\n\n    reg         [3:0]   state = IDLE;\n    reg         [31:0]  timer;\n    reg         [7:0]   align_count;\n    wire                align_detected;\n    wire                dialtone_detected;\n    wire                timeout;\n\n    assign              lax_state         = state;\n    assign              align_detected    = ((rx_isk > 0) && (rx_din == `PRIM_ALIGN));\n    assign              dialtone_detected = ((rx_isk == 0) && (rx_din == `DIALTONE));\n    assign              timeout           = (timer == 0);\n    assign              phy_ready         = (state == READY);\n\n    always @ (posedge clk) begin\n      if (rst) begin\n        state                   <=  IDLE;\n        tx_dout                 <=  0;\n        tx_isk                  <=  0;\n        tx_set_elec_idle        <=  1;\n        timer                   <=  0;\n        hd_ready                <=  0;\n        rx_byte_is_aligned      <=  0;\n        align_count             <=  0;\n      end\n      else begin\n        tx_comm_reset           <=  0;\n        tx_comm_wake            <=  0;\n        rx_byte_is_aligned      <=  0;\n\n        if (state == READY) begin\n          align_count           <=  align_count + 1;\n        end\n        if (timer > 0) begin\n          timer                 <=  timer - 1;\n        end\n\n        if ((comm_reset_detect) && (state > WAIT_FOR_NO_RESET)) begin\n          $display(\"faux_sata_hd: Asynchronous RESET detected\");\n          state                 <=  IDLE;\n        end\n\n        case (state)\n          IDLE: begin\n            align_count   <=  0;\n            hd_ready            <=  0;\n            tx_set_elec_idle    <=  1;\n            if (comm_reset_detect) begin\n              $display(\"faux_sata_hd: RESET detected\");\n              state             <=  WAIT_FOR_NO_RESET;\n            end\n          end\n          WAIT_FOR_NO_RESET: begin\n            if (!comm_reset_detect) begin\n              $display(\"faux_sata_hd: RESET deasserted\");\n              hd_ready            <=  0;\n              tx_set_elec_idle    <=  1;\n              state             <=  SEND_INIT;\n            end\n          end\n          SEND_INIT: begin\n            $display(\"faux_sata_hd: send INIT\");\n            tx_comm_reset       <=  1;\n            state               <=  WAIT_FOR_WAKE;\n          end\n          WAIT_FOR_WAKE: begin\n            if (comm_wake_detect) begin\n              $display (\"faux_sata_hd: WAKE detected\");\n              state             <=  WAIT_FOR_NO_WAKE;\n            end\n          end\n          WAIT_FOR_NO_WAKE: begin\n            if (!comm_wake_detect) begin\n              $display (\"faux_sata_hd: WAKE deasserted\");\n              state             <=  SEND_WAKE;\n            end\n          end\n          SEND_WAKE: begin\n            $display (\"faux_sata_hd: send WAKE\");\n            tx_comm_wake        <=  1;\n            state               <=  STOP_SEND_WAKE;\n          end\n          STOP_SEND_WAKE: begin\n            $display (\"faux_sata_hd: stop sending WAKE\");\n            state               <=  WAIT_FOR_DIALTONE;\n          end\n          WAIT_FOR_DIALTONE: begin\n            if (dialtone_detected) begin\n              $display (\"faul_sata_hd: detected dialtone\");\n              state             <=  SEND_ALIGN;\n            end\n          end\n          SEND_ALIGN: begin\n            $display (\"faul_sata_hd: send aligns\");\n            tx_set_elec_idle    <=  0;\n            tx_dout             <=  `PRIM_ALIGN;\n            tx_isk              <=  1;\n            state               <=  WAIT_FOR_ALIGN;\n            timer               <=  32'h`INITIALIZE_TIMEOUT;\n            rx_byte_is_aligned  <=  1;\n          end\n          WAIT_FOR_ALIGN: begin\n            rx_byte_is_aligned  <=  1;\n            if (align_detected) begin\n              $display (\"faux_sata_hd: detected ALIGN primitive from host\");\n              $display (\"faux_sata_hd: Ready\");\n              tx_dout           <=  `PRIM_ALIGN;\n              tx_isk            <=  1;\n              timer             <=  0;\n              state             <=  READY;\n            end\n            else if (timeout) begin\n              $display (\"faux_sata_hd: Timeout while waiting for an alignment from the host\");\n              state             <=  IDLE;\n            end\n          end\n          READY: begin\n            hd_ready            <=  1;\n            rx_byte_is_aligned  <=  1;\n            tx_isk              <=  1;\n            tx_dout             <=  `PRIM_SYNC;\n            if (align_count == 255) begin\n              tx_dout           <=  `PRIM_ALIGN;\n              state             <=  SEND_FIRST_ALIGNMENT;\n            end\n          end\n          SEND_FIRST_ALIGNMENT: begin\n            rx_byte_is_aligned  <=  1;\n            tx_isk              <=  1;\n            tx_dout             <=  `PRIM_ALIGN;\n            state               <=  SEND_SECOND_ALIGNMENT;\n          end\n          SEND_SECOND_ALIGNMENT: begin\n            rx_byte_is_aligned  <=  1;\n            tx_isk              <=  1;\n            tx_dout             <=  `PRIM_ALIGN;\n            state               <=  READY;\n          end\n          default: begin\n            $display (\"faux_sata_hd: In undefined state!\");\n            state               <=  IDLE;\n          end\n        endcase\n      end\n    end\n\nendmodule"}
{"task_id": 1078, "completion": "output [1:0] m_bus_pc_in;\n    input [1:0] w_bus_addr, w_bus_data;\n    input w_jno, w_sr_out, w_clock, w_reset;\n    \n    wire w_tmp_ovrflw, w_tmp_carry, w_tmp_add_in0, w_tmp_add_in1, w_tmp_sum0, w_tmp_sum1, w_demux_channel;\n    \n    nand (w_tmp_add_in0, w_jno, w_sr_out);\n    and (w_tmp_add_in1, w_jno, w_sr_out);\n\n    and (w_tmp_ovrflw, w_jno, ~w_sr_out);\n    \n    m_d_flip_flop dff_0 (w_demux_channel, w_tmp_ovrflw, w_clock, w_reset);\n    m_two_bit_adder two_bit_add_0 (w_tmp_carry, w_tmp_sum1, w_tmp_sum0, w_tmp_add_in1, w_tmp_add_in0, w_bus_addr[1], w_bus_addr[0]);\n    m_demux demux_0 (m_bus_pc_in[1], m_bus_pc_in[0], w_tmp_sum1, w_tmp_sum0, w_bus_data[1], w_bus_data[0], w_demux_channel);\nendmodule"}
{"task_id": 1077, "completion": "supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    wire xor0_out_X;\n\n    xor xor0 (xor0_out_X, B, A           );\n    buf buf0 (X         , xor0_out_X     );\n\nendmodule"}
{"task_id": 1091, "completion": "`ifndef ALTERA_RESERVED_QIS\n// synopsys translate_off\n`endif\n\ttri1\t  clock;\n`ifndef ALTERA_RESERVED_QIS\n// synopsys translate_on\n`endif\n\nendmodule"}
{"task_id": 726, "completion": "wire PCS_rx_reset;  wire PCS_tx_reset;  wire PCS_reset;  wire gige_pma_reset;  wire [7:0] gmii_rx_d;  wire gmii_rx_dv;  wire gmii_rx_err;  wire hd_ena;  wire led_an;  wire led_char_err;  wire led_char_err_gx;  wire led_col;  wire led_crs;  wire led_disp_err;  wire led_link;  wire link_status;  wire mii_col;  wire mii_crs;  wire [3:0] mii_rx_d;  wire mii_rx_dv;  wire mii_rx_err;  wire rx_pcs_clk;  wire tx_pcs_clk;  wire [7:0] pcs_rx_frame;  wire pcs_rx_kchar;  wire [15:0] readdata;  wire rx_char_err_gx;  wire rx_clk;  wire rx_disp_err;  wire [7:0] rx_frame;  wire rx_syncstatus;  wire rx_kchar;  wire set_10;  wire set_100;  wire set_1000;  wire tx_clk;  wire rx_clkena;  wire tx_clkena;  wire [7:0] tx_frame;  wire tx_kchar;  wire txp;  wire waitrequest;  wire sd_loopback;  wire pcs_pwrdn_out_sig;  wire gxb_pwrdn_in_sig;  wire rx_runlengthviolation;  wire rx_patterndetect;  wire rx_runningdisp;  wire rx_rmfifodatadeleted;  wire rx_rmfifodatainserted;  wire pcs_rx_rmfifodatadeleted;  wire pcs_rx_rmfifodatainserted;  wire [16:0] reconfig_fromgxb;  wire reset_ref_clk;  wire reset_rx_pcs_clk_int;  wire pll_powerdown_sqcnr,tx_digitalreset_sqcnr,rx_analogreset_sqcnr,rx_digitalreset_sqcnr,gxb_powerdown_sqcnr,pll_locked;  wire rx_digitalreset_sqcnr_rx_clk,tx_digitalreset_sqcnr_tx_clk,rx_digitalreset_sqcnr_clk;  wire rx_freqlocked;  wire locked_signal;  altera_tse_reset_synchronizer reset_sync_2 (.clk(rx_clk), .reset_in(rx_digitalreset_sqcnr), .reset_out(rx_digitalreset_sqcnr_rx_clk));  altera_tse_reset_synchronizer reset_sync_3 (.clk(tx_clk), .reset_in(tx_digitalreset_sqcnr), .reset_out(tx_digitalreset_sqcnr_tx_clk));  altera_tse_reset_synchronizer reset_sync_4 (.clk(clk), .reset_in(rx_digitalreset_sqcnr), .reset_out(rx_digitalreset_sqcnr_clk));  assign PCS_rx_reset = reset_rx_clk | rx_digitalreset_sqcnr_rx_clk;  assign PCS_tx_reset = reset_tx_clk | tx_digitalreset_sqcnr_tx_clk;  assign PCS_reset = reset;  assign led_char_err = led_char_err_gx;  assign led_link = link_status;  altera_tse_top_1000_base_x_strx_gx altera_tse_top_1000_base_x_strx_gx_inst (.rx_carrierdetected(pcs_rx_carrierdetected), .rx_rmfifodatadeleted(pcs_rx_rmfifodatadeleted), .rx_rmfifodatainserted(pcs_rx_rmfifodatainserted), .gmii_rx_d (gmii_rx_d), .gmii_rx_dv (gmii_rx_dv), .gmii_rx_err (gmii_rx_err), .gmii_tx_d (gmii_tx_d), .gmii_tx_en (gmii_tx_en), .gmii_tx_err (gmii_tx_err), .hd_ena (hd_ena), .led_an (led_an), .led_char_err (led_char_err_gx), .led_col (led_col), .led_crs (led_crs), .led_link (link_status), .mii_col (mii_col), .mii_crs (mii_crs), .mii_rx_d (mii_rx_d), .mii_rx_dv (mii_rx_dv), .mii_rx_err (mii_rx_err), .mii_tx_d (mii_tx_d), .mii_tx_en (mii_tx_en), .mii_tx_err (mii_tx_err), .powerdown (pcs_pwrdn_out_sig), .reg_addr (address), .reg_busy (waitrequest), .reg_clk (clk), .reg_data_in (writedata), .reg_data_out (readdata), .reg_rd (read), .reg_wr (write), .reset_reg_clk (PCS_reset), .reset_rx_clk (PCS_rx_reset), .reset_tx_clk (PCS_tx_reset), .rx_clk (rx_clk), .rx_clkout (rx_pcs_clk), .rx_frame (pcs_rx_frame), .rx_kchar (pcs_rx_kchar), .sd_loopback (sd_loopback), .set_10 (set_10), .set_100 (set_100), .set_1000 (set_1000), .tx_clk (tx_clk), .rx_clkena(rx_clkena), .tx_clkena(tx_clkena), .ref_clk(1'b0), .tx_clkout (tx_pcs_clk), .tx_frame (tx_frame), .tx_kchar (tx_kchar));  defparam altera_tse_top_1000_base_x_strx_gx_inst.PHY_IDENTIFIER = PHY_IDENTIFIER, altera_tse_top_1000_base_x_strx_gx_inst.DEV_VERSION = DEV_VERSION, altera_tse_top_1000_base_x_strx_gx_inst.ENABLE_SGMII = ENABLE_SGMII;  reg reset_p1, reset_p2;  reg reset_posedge;  always@(posedge clk) begin reset_p1 <= reset; reset_p2 <= reset_p1; reset_posedge <= reset_p1 & ~reset_p2; end  reg data_in_d1,gxb_pwrdn_in_sig_clk;  generate if (EXPORT_PWRDN == 1) begin always @(posedge clk or posedge gxb_pwrdn_in) begin if (gxb_pwrdn_in == 1) begin data_in_d1 <= 1; gxb_pwrdn_in_sig_clk <= 1; end else begin data_in_d1 <= 1'b0; gxb_pwrdn_in_sig_clk <= data_in_d1; end end assign gxb_pwrdn_in_sig = gxb_pwrdn_in; assign pcs_pwrdn_out = pcs_pwrdn_out_sig; end else begin assign gxb_pwrdn_in_sig = pcs_pwrdn_out_sig; assign pcs_pwrdn_out = 1'b0; always@(*) begin gxb_pwrdn_in_sig_clk = gxb_pwrdn_in_sig; end end endgenerate  altera_tse_reset_sequencer altera_tse_reset_sequencer_inst(.clock(clk), .reset_all(reset | gxb_pwrdn_in_sig_clk), .powerdown_all(reset_posedge), .tx_ready(), .rx_ready(), .pll_powerdown(pll_powerdown_sqcnr), .tx_digitalreset(tx_digitalreset_sqcnr), .rx_analogreset(rx_analogreset_sqcnr), .rx_digitalreset(rx_digitalreset_sqcnr), .gxb_powerdown(gxb_powerdown_sqcnr), .pll_is_locked(locked_signal), .rx_is_lockedtodata(rx_freqlocked), .manual_mode(1'b0), .rx_oc_busy(reconfig_busy));  assign locked_signal = (reset? 1'b0: pll_locked);  altera_tse_reset_synchronizer ch_0_reset_sync_0 (.clk(rx_pcs_clk), .reset_in(rx_digitalreset_sqcnr), .reset_out(reset_rx_pcs_clk_int));  altera_tse_gxb_aligned_rxsync the_altera_tse_gxb_aligned_rxsync(.clk(rx_pcs_clk), .reset(reset_rx_pcs_clk_int), .alt_dataout(rx_frame), .alt_sync(rx_syncstatus), .alt_disperr(rx_disp_err), .alt_ctrldetect(rx_kchar), .alt_errdetect(rx_char_err_gx), .alt_rmfifodatadeleted(rx_rmfifodatadeleted), .alt_rmfifodatainserted(rx_rmfifodatainserted), .alt_runlengthviolation(rx_runlengthviolation), .alt_patterndetect(rx_patterndetect), .alt_runningdisp(rx_runningdisp), .altpcs_dataout(pcs_rx_frame), .altpcs_sync(link_status), .altpcs_disperr(led_disp_err), .altpcs_ctrldetect(pcs_rx_kchar), .altpcs_errdetect(led_char_err_gx), .altpcs_rmfifodatadeleted(pcs_rx_rmfifodatadeleted), .altpcs_rmfifodatainserted(pcs_rx_rmfifodatainserted), .altpcs_carrierdetect(pcs_rx_carrierdetected)); defparam the_altera_tse_gxb_aligned_rxsync.DEVICE_FAMILY = DEVICE_FAMILY;  altera_tse_gxb_gige_inst the_altera_tse_gxb_gige_inst(.cal_blk_clk (gxb_cal_blk_clk), .gxb_powerdown (gxb_pwrdn_in_sig), .pll_inclk (ref_clk), .reconfig_clk(reconfig_clk), .reconfig_togxb(reconfig_togxb), .reconfig_fromgxb(reconfig_fromgxb), .rx_analogreset (rx_analogreset_sqcnr), .rx_cruclk (ref_clk), .rx_ctrldetect (rx_kchar), .rx_clkout (rx_pcs_clk), .rx_datain (rxp), .rx_dataout (rx_frame), .rx_digitalreset (rx_digitalreset_sqcnr), .rx_disperr (rx_disp_err), .rx_errdetect (rx_char_err_gx), .rx_patterndetect (rx_patterndetect), .rx_rlv (rx_runlengthviolation), .rx_seriallpbken (sd_loopback), .rx_syncstatus (rx_syncstatus), .rx_recovclkout(rx_recovclkout), .tx_clkout (tx_pcs_clk), .tx_ctrlenable (tx_kchar), .tx_datain (tx_frame), .rx_freqlocked (rx_freqlocked), .tx_dataout (txp), .tx_digitalreset (tx_digitalreset_sqcnr_tx_clk), .rx_rmfifodatadeleted(rx_rmfifodatadeleted), .rx_rmfifodatainserted(rx_rmfifodatainserted), .rx_runningdisp(rx_runningdisp), .pll_powerdown(gxb_pwrdn_in_sig), .pll_locked(pll_locked)); defparam the_altera_tse_gxb_gige_inst.ENABLE_ALT_RECONFIG = ENABLE_ALT_RECONFIG, the_altera_tse_gxb_gige_inst.STARTING_CHANNEL_NUMBER = STARTING_CHANNEL_NUMBER, the_altera_tse_gxb_gige_inst.DEVICE_FAMILY = DEVICE_FAMILY, the_altera_tse_gxb_gige_inst.ENABLE_SGMII = ENABLE_SGMII;  endmodule"}
{"task_id": 87, "completion": "/////////////////////////////////////////////////////////////////////////////\n  // Functions\n  /////////////////////////////////////////////////////////////////////////////\n  /////////////////////////////////////////////////////////////////////////////\n  // Local params\n  /////////////////////////////////////////////////////////////////////////////\n  localparam C_FIFO_DEPTH_LOG            = 4;\n  /////////////////////////////////////////////////////////////////////////////\n  // Internal signals\n  /////////////////////////////////////////////////////////////////////////////\n  reg                                   ARESET;\n  wire                                  cmd_w_valid;\n  wire                                  cmd_w_check;\n  wire [C_AXI_ID_WIDTH-1:0]             cmd_w_id;\n  wire                                  cmd_w_ready;\n  wire                                  cmd_b_push;\n  wire                                  cmd_b_error;\n  wire [C_AXI_ID_WIDTH-1:0]             cmd_b_id;\n  wire                                  cmd_b_full;\n  wire [C_FIFO_DEPTH_LOG-1:0]           cmd_b_addr;\n  wire                                  cmd_b_ready;\n  always @ (posedge ACLK) begin\n    ARESET <= !ARESETN;\n  end\n  processing_system7_v5_5_aw_atc #\n  (\n   .C_FAMILY                    (C_FAMILY),\n   .C_AXI_ID_WIDTH              (C_AXI_ID_WIDTH),\n   .C_AXI_ADDR_WIDTH            (C_AXI_ADDR_WIDTH),\n   .C_AXI_AWUSER_WIDTH          (C_AXI_AWUSER_WIDTH),\n   .C_FIFO_DEPTH_LOG            (C_FIFO_DEPTH_LOG)\n    ) write_addr_inst\n   (\n    .ARESET                     (ARESET),\n    .ACLK                       (ACLK),\n    .cmd_w_valid                (cmd_w_valid),\n    .cmd_w_check                (cmd_w_check),\n    .cmd_w_id                   (cmd_w_id),\n    .cmd_w_ready                (cmd_w_ready),\n    .cmd_b_addr                 (cmd_b_addr),\n    .cmd_b_ready                (cmd_b_ready),\n    .S_AXI_AWID                 (S_AXI_AWID),\n    .S_AXI_AWADDR               (S_AXI_AWADDR),\n    .S_AXI_AWLEN                (S_AXI_AWLEN),\n    .S_AXI_AWSIZE               (S_AXI_AWSIZE),\n    .S_AXI_AWBURST              (S_AXI_AWBURST),\n    .S_AXI_AWLOCK               (S_AXI_AWLOCK),\n    .S_AXI_AWCACHE              (S_AXI_AWCACHE),\n    .S_AXI_AWPROT               (S_AXI_AWPROT),\n    .S_AXI_AWUSER               (S_AXI_AWUSER),\n    .S_AXI_AWVALID              (S_AXI_AWVALID),\n    .S_AXI_AWREADY              (S_AXI_AWREADY)\n   );\n  processing_system7_v5_5_w_atc #\n  (\n   .C_FAMILY                    (C_FAMILY),\n   .C_AXI_ID_WIDTH              (C_AXI_ID_WIDTH),\n   .C_AXI_DATA_WIDTH            (C_AXI_DATA_WIDTH),\n   .C_AXI_WUSER_WIDTH           (C_AXI_WUSER_WIDTH)\n    ) write_data_inst\n   (\n    .ARESET                     (ARESET),\n    .ACLK                       (ACLK),\n    .cmd_w_valid                (cmd_w_valid),\n    .cmd_w_check                (cmd_w_check),\n    .cmd_w_id                   (cmd_w_id),\n    .cmd_w_ready                (cmd_w_ready),\n    .cmd_b_push                 (cmd_b_push),\n    .cmd_b_error                (cmd_b_error),\n    .cmd_b_id                   (cmd_b_id),\n    .cmd_b_full                 (cmd_b_full),\n    .S_AXI_WID                  (S_AXI_WID),\n    .S_AXI_WDATA                (S_AXI_WDATA),\n    .S_AXI_WSTRB                (S_AXI_WSTRB),\n    .S_AXI_WLAST                (S_AXI_WLAST),\n    .S_AXI_WUSER                (S_AXI_WUSER),\n    .S_AXI_WVALID               (S_AXI_WVALID),\n    .S_AXI_WREADY               (S_AXI_WREADY)\n   );\n  processing_system7_v5_5_b_atc #\n  (\n   .C_FAMILY                    (C_FAMILY),\n   .C_AXI_ID_WIDTH              (C_AXI_ID_WIDTH),\n   .C_AXI_BUSER_WIDTH           (C_AXI_BUSER_WIDTH),\n   .C_FIFO_DEPTH_LOG            (C_FIFO_DEPTH_LOG)\n    ) write_response_inst\n   (\n    .ARESET                     (ARESET),\n    .ACLK                       (ACLK),\n    .cmd_b_push                 (cmd_b_push),\n    .cmd_b_error                (cmd_b_error),\n    .cmd_b_id                   (cmd_b_id),\n    .cmd_b_full                 (cmd_b_full),\n    .cmd_b_addr                 (cmd_b_addr),\n    .cmd_b_ready                (cmd_b_ready),\n    .S_AXI_BID                  (S_AXI_BID),\n    .S_AXI_BRESP                (S_AXI_BRESP),\n    .S_AXI_BUSER                (S_AXI_BUSER),\n    .S_AXI_BVALID               (S_AXI_BVALID),\n    .S_AXI_BREADY               (S_AXI_BREADY),\n    .M_AXI_BID                  (M_AXI_BID),\n    .M_AXI_BRESP                (M_AXI_BRESP),\n    .M_AXI_BUSER                (M_AXI_BUSER),\n    .M_AXI_BVALID               (M_AXI_BVALID),\n    .M_AXI_BREADY               (M_AXI_BREADY),\n    .ERROR_TRIGGER              (ERROR_TRIGGER),\n    .ERROR_TRANSACTION_ID       (ERROR_TRANSACTION_ID)\n   );\n  assign M_AXI_ARID     = S_AXI_ARID;\n  assign M_AXI_ARADDR   = S_AXI_ARADDR;\n  assign M_AXI_ARLEN    = S_AXI_ARLEN;\n  assign M_AXI_ARSIZE   = S_AXI_ARSIZE;\n  assign M_AXI_ARBURST  = S_AXI_ARBURST;\n  assign M_AXI_ARLOCK   = S_AXI_ARLOCK;\n  assign M_AXI_ARCACHE  = S_AXI_ARCACHE;\n  assign M_AXI_ARPROT   = S_AXI_ARPROT;\n  assign M_AXI_ARUSER   = S_AXI_ARUSER;\n  assign M_AXI_ARVALID  = S_AXI_ARVALID;\n  assign S_AXI_ARREADY  = M_AXI_ARREADY;\n  assign S_AXI_RID      = M_AXI_RID;\n  assign S_AXI_RDATA    = M_AXI_RDATA;\n  assign S_AXI_RRESP    = M_AXI_RRESP;\n  assign S_AXI_RLAST    = M_AXI_RLAST;\n  assign S_AXI_RUSER    = M_AXI_RUSER;\n  assign S_AXI_RVALID   = M_AXI_RVALID;\n  assign M_AXI_RREADY   = S_AXI_RREADY;\nendmodule"}
{"task_id": 1176, "completion": "xlslice #(\n    .DIN_WIDTH(40),\n    .DIN_FROM(32),\n    .DIN_TO(17)\n  ) inst (\n    .Din(Din),\n    .Dout(Dout)\n  );\nendmodule"}
{"task_id": 1007, "completion": "usb_gpif_ctrl   usb_gpif_ctrl_inst(        .I_sys_clk           (I_sys_clk             ),        .I_usb_clk           (I_usb_clk             ),        .I_sys_rst           (I_sys_rst             ),        .I_usb_rst           (I_usb_rst             ),        .I_usb_wfifo_aclr    (I_usb_wfifo_aclr      ),        .I_usb_wrreq         (I_usb_wrreq           ),        .I_usb_din           (I_usb_din             ),        .O_usb_wrfull        (O_usb_wrfull          ),        .O_usb_wruesdw       (O_usb_wruesdw         ),        .I_usb_rdreq         (I_usb_rdreq           ),        .O_usb_dout          (O_usb_dout            ),        .O_usb_rdempty       (O_usb_rdempty         ),        .O_usb_pclk          (O_usb_pclk            ),        .O_usb_clk           (O_usb_clk             ),        .I_usb_flga          (I_usb_flga            ),        .I_usb_flgb          (I_usb_flgb            ),        .O_usb_cs            (O_usb_cs              ),         .O_usb_wr            (O_usb_wr              ),         .O_usb_rd            (O_usb_rd              ),         .O_usb_oe            (O_usb_oe              ),         .O_usb_a0            (O_usb_a0              ),         .O_usb_a1            (O_usb_a1              ),         .O_usb_pkt           (O_usb_pkt             ),         .O_usb_reset         (O_usb_reset           ),         .IO_usb_dq           (IO_usb_dq             ),        .I_usb_dir           (I_usb_dir             )    );    usb_uart  usb_uart_inst(         .I_sys_clk           (I_sys_clk             ),        .I_usb_clk           (I_usb_clk             ),        .I_sys_rst           (I_sys_rst             ),        .I_usb_rst           (I_usb_rst             ),        .I_usb_uart_tx_req   (I_usb_uart_tx_req     ),        .I_usb_uart_tx_data  (I_usb_uart_tx_data    ),        .O_usb_uart_tx_full  (O_usb_uart_tx_full    ),        .I_usb_uart_rx_req   (I_usb_uart_rx_req     ),        .O_usb_uart_rx_data  (O_usb_uart_rx_data    ),        .O_usb_uart_rx_empty (O_usb_uart_rx_empty   ),        .O_usb_uart_txd      (O_usb_uart_txd        ),         .I_usb_uart_rxd      (I_usb_uart_rxd        )    );    endmodule"}
{"task_id": 148, "completion": "wire    sata_300mhz_clk;wire    sata_75mhz_clk;wire    [1:0] sata_gtp_clkout;wire    sata_dcm_clkin;wire    sata_dcm_reset;wire    [1:0] pcie_gtp_clkout;wire    pcie_dcm_clkin;wire    pcie_dcm_reset;wire    pcie_250mhz_clk;wire    pcie_rx_reset;wire    tile0_gtp0_refclk_i;wire    tile0_gtp1_refclk_i;aps#(.WRAPPER_SIM_GTPRESET_SPEEDUP   (0                       ),      .WRAPPER_SIMULATION             (0                       ),     .WRAPPER_CLK25_DIVIDER_0        (6                       ),    .WRAPPER_CLK25_DIVIDER_1        (4                       ),    .WRAPPER_PLL_DIVSEL_FB_0        (2                       ),     .WRAPPER_PLL_DIVSEL_REF_0       (1                       ),    .WRAPPER_PLL_DIVSEL_FB_1        (5                       ),     .WRAPPER_PLL_DIVSEL_REF_1       (2                       ))artemis_pcie_sata_i(    .TILE0_RXPOWERDOWN1_IN          (2'b0                    ),    .TILE0_TXPOWERDOWN1_IN          (2'b0                    ),    .TILE0_CLK00_IN                 (tile0_gtp0_refclk_i     ),    .TILE0_CLK01_IN                 (tile0_gtp1_refclk_i     ),    .TILE0_GTPRESET0_IN             (i_sata_reset            ),    .TILE0_GTPRESET1_IN             (i_pcie_reset            ),    .TILE0_PLLLKDET0_OUT            (o_sata_pll_detect_k     ),    .TILE0_PLLLKDET1_OUT            (o_pcie_pll_detect_k     ),    .TILE0_RESETDONE0_OUT           (o_sata_reset_done       ),    .TILE0_RESETDONE1_OUT           (o_pcie_reset_done       ),    .TILE0_RXCHARISCOMMA0_OUT       (o_sata_rx_char_is_comma ),    .TILE0_RXCHARISK0_OUT           (o_sata_rx_char_is_k     ),    .TILE0_RXCHARISK1_OUT           (o_pcie_rx_char_is_k     ),    .TILE0_RXDISPERR0_OUT           (o_sata_disparity_error  ),    .TILE0_RXDISPERR1_OUT           (o_pcie_disparity_error  ),    .TILE0_RXNOTINTABLE0_OUT        (o_sata_rx_not_in_table  ),    .TILE0_RXNOTINTABLE1_OUT        (o_pcie_rx_not_in_table  ),    .TILE0_RXCLKCORCNT0_OUT         (o_sata_clk_correct_count),    .TILE0_RXCLKCORCNT1_OUT         (o_pcie_clk_correct_count),    .TILE0_RXENMCOMMAALIGN0_IN      (1'b1                    ),    .TILE0_RXENMCOMMAALIGN1_IN      (1'b1                    ),    .TILE0_RXENPCOMMAALIGN0_IN      (1'b1                    ),    .TILE0_RXENPCOMMAALIGN1_IN      (1'b1                    ),    .TILE0_RXDATA0_OUT              (o_sata_rx_data          ),    .TILE0_RXDATA1_OUT              (o_pcie_rx_data          ),    .TILE0_RXRECCLK0_OUT            (                        ),    .TILE0_RXRESET1_IN              (pcie_rx_reset           ),    .TILE0_RXUSRCLK0_IN             (sata_300mhz_clk         ),    .TILE0_RXUSRCLK1_IN             (pcie_250mhz_clk         ),    .TILE0_RXUSRCLK20_IN            (sata_75mhz_clk          ),    .TILE0_RXUSRCLK21_IN            (o_pcie_62p5mhz_clk      ),    .TILE0_GATERXELECIDLE0_IN       (1'b0                    ),    .TILE0_GATERXELECIDLE1_IN       (1'b0                    ),    .TILE0_IGNORESIGDET0_IN         (1'b0                    ),    .TILE0_IGNORESIGDET1_IN         (1'b0                    ),    .TILE0_RXELECIDLE0_OUT          (o_sata_rx_elec_idle     ),    .TILE0_RXELECIDLE1_OUT          (o_pcie_rx_elec_idle     ),    .TILE0_RXEQMIX0_IN              (i_sata_rx_pre_amp       ),    .TILE0_RXP0_IN                  (i_sata_phy_rx_p         ),    .TILE0_RXN0_IN                  (i_sata_phy_rx_n         ),    .TILE0_RXP1_IN                  (i_pcie_phy_rx_p         ),    .TILE0_RXN1_IN                  (i_pcie_phy_rx_n         ),    .TILE0_RXBYTEALIGNED0_OUT       (o_sata_rx_byte_is_aligned ),    .TILE0_RXBYTEALIGNED1_OUT       (o_pcie_rx_byte_is_aligned ),    .TILE0_RXSTATUS0_OUT            (o_sata_rx_status        ),    .TILE0_RXSTATUS1_OUT            (o_pcie_rx_status        ),    .TILE0_RXLOSSOFSYNC0_OUT        (o_sata_loss_of_sync     ),    .TILE0_RXLOSSOFSYNC1_OUT        (o_pcie_loss_of_sync     ),    .TILE0_PHYSTATUS1_OUT           (o_pcie_phy_status       ),    .TILE0_RXVALID1_OUT             (o_pcie_phy_rx_valid     ),    .TILE0_RXPOLARITY1_IN           (i_pcie_rx_polarity      ),    .TILE0_GTPCLKOUT0_OUT           (sata_gtp_clkout         ),    .TILE0_GTPCLKOUT1_OUT           (pcie_gtp_clkout         ),    .TILE0_TXCHARDISPMODE1_IN       (i_pcie_disparity_mode   ),    .TILE0_TXCHARISK0_IN            ({1'b0, 1'b0, 1'b0, i_sata_tx_char_is_k}),    .TILE0_TXCHARISK1_IN            (i_pcie_tx_char_is_k     ),    .TILE0_TXDATA0_IN               (i_sata_tx_data          ),    .TILE0_TXDATA1_IN               (i_pcie_tx_data          ),    .TILE0_TXOUTCLK0_OUT            (                        ),    .TILE0_TXOUTCLK1_OUT            (                        ),    .TILE0_TXUSRCLK0_IN             (sata_300mhz_clk         ),    .TILE0_TXUSRCLK1_IN             (pcie_250mhz_clk         ),    .TILE0_TXUSRCLK20_IN            (sata_75mhz_clk          ),    .TILE0_TXUSRCLK21_IN            (o_pcie_62p5mhz_clk      ),    .TILE0_TXDIFFCTRL0_IN           (i_tx_diff_swing         ),    .TILE0_TXP0_OUT                 (o_sata_phy_tx_p         ),    .TILE0_TXN0_OUT                 (o_sata_phy_tx_n         ),    .TILE0_TXP1_OUT                 (o_pcie_phy_tx_p         ),    .TILE0_TXN1_OUT                 (o_pcie_phy_tx_n         ),    .TILE0_TXDETECTRX1_IN           (i_pcie_tx_detect_rx     ),    .TILE0_TXELECIDLE0_IN           (i_sata_tx_elec_idle     ),    .TILE0_TXELECIDLE1_IN           (i_pcie_tx_elec_idle     ),    .TILE0_TXCOMSTART0_IN           (i_sata_tx_comm_start    ),    .TILE0_TXCOMTYPE0_IN            (i_sata_tx_comm_type     ));IBUFDS tile0_gtp0_refclk_ibufds_i(    .O                              (tile0_gtp0_refclk_i     ),    .I                              (i_gtp0_clk_p            ),    .IB                             (i_gtp0_clk_n            ));BUFIO2 #(.DIVIDE                         (1),    .DIVIDE_BYPASS                  (\"TRUE\")) i_sata_pll_buf (    .I                              (sata_gtp_clkout[0]),    .DIVCLK                         (sata_dcm_clkin),    .IOCLK                          (),    .SERDESSTROBE                   ());assign  sata_dcm_reset                = !o_sata_pll_detect_k;wire    sata_75mhz_bufg_in;wire    sata_300mhz_bufg_in;wire    sata_pll_feedback;PLL_BASE #(  .CLKFBOUT_MULT                    (4                    ),  .DIVCLK_DIVIDE                    (1                    ),  .CLK_FEEDBACK                     (\"CLKFBOUT\"           ),  .COMPENSATION                     (\"SYSTEM_SYNCHRONOUS\" ),  .CLKIN_PERIOD                     (6.666                ),  .CLKOUT0_DIVIDE                   (2                    ),  .CLKOUT0_PHASE                    (0                    ),  .CLKOUT1_DIVIDE                   (8                    ),  .CLKOUT1_PHASE                    (0                    ))SATA_PLL(  .CLKIN                            (sata_dcm_clkin       ),  .CLKOUT0                          (sata_300mhz_bufg_in  ),  .CLKOUT1                          (sata_75mhz_bufg_in   ),  .CLKFBOUT                         (sata_pll_feedback    ),  .CLKFBIN                          (sata_pll_feedback    ),  .LOCKED                           (o_sata_dcm_locked    ),  .RST                              (sata_dcm_reset       ));BUFG  SATA_75MHZ_BUFG (  .I                                (sata_75mhz_bufg_in   ),  .O                                (sata_75mhz_clk       ));BUFG SATA_300MHZ_BUFG (  .I                                (sata_300mhz_bufg_in  ),  .O                                (sata_300mhz_clk      ));assign  o_sata_75mhz_clk            = sata_75mhz_clk;assign  o_sata_300mhz_clk           = sata_300mhz_clk;IBUFDS tile0_gtp1_refclk_ibufds_i(    .O                              (tile0_gtp1_refclk_i),    .I                              (i_gtp1_clk_p),    .IB                             (i_gtp1_clk_n));BUFIO2 #(.DIVIDE                         (1),    .DIVIDE_BYPASS                  (\"TRUE\")) i_pcie_pll_buf (    .I                              (pcie_gtp_clkout[0]),    .DIVCLK                         (pcie_dcm_clkin),    .IOCLK                          (),    .SERDESSTROBE                   ());assign  pcie_dcm_reset              = !o_pcie_pll_detect_k;wire    pcie_62p5mhz_bufg_in;wire    pcie_250mhz_bufg_in;wire    pcie_pll_feedback_out;PLL_BASE #(  .CLKFBOUT_MULT                    (10                   ),  .DIVCLK_DIVIDE                    (1                    ),  .CLK_FEEDBACK                     (\"CLKFBOUT\"           ),  .COMPENSATION                     (\"SYSTEM_SYNCHRONOUS\" ),  .CLKIN_PERIOD                     (10.000               ),  .CLKOUT0_DIVIDE                   (4                    ),  .CLKOUT1_DIVIDE                   (16                   ))PCIE_PLL(  .CLKIN                            (pcie_dcm_clkin       ),  .CLKOUT0                          (pcie_250mhz_bufg_in  ),  .CLKOUT1                          (pcie_62p5mhz_bufg_in ),  .CLKFBOUT                         (pcie_pll_feedback_out),  .CLKFBIN                          (pcie_pll_feedback_out),  .LOCKED                           (o_pcie_dcm_locked    ),  .RST                              (pcie_dcm_reset       ));BUFG  PCIE_62P5MHZ_BUFG (  .I                                (pcie_62p5mhz_bufg_in ),  .O                                (o_pcie_62p5mhz_clk   ));BUFG PCIE_250MHZ_BUFG (  .I                                (pcie_250mhz_bufg_in  ),  .O                                (pcie_250mhz_clk      ));assign pcie_rx_reset  = !(o_pcie_dcm_locked && o_pcie_pll_detect_k);endmodule"}
{"task_id": 1143, "completion": "output X ;\n    input  A1;\n    input  A2;\n    input  B1;\n    input  C1;\n    input  D1;\n\n    // Voltage supply signals\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    sky130_fd_sc_ls__o2111a base (\n        .X(X),\n        .A1(A1),\n        .A2(A2),\n        .B1(B1),\n        .C1(C1),\n        .D1(D1)\n    );\n\nendmodule"}
{"task_id": 247, "completion": "parameter LC_RF_DATA_WIDTH =24;\n    parameter LC_RF_ADDR_WIDTH =`DATA_WIDTH-LC_RF_DATA_WIDTH;\n    parameter LC_RF_DEPTH = 128;        // 1 ~ 2^8\n\n    parameter LC_MEM_ADDR_WIDTH = 32;    // should ALWAYS less than DATA_WIDTH\n    parameter LC_MEM_DATA_WIDTH = 32;    // should ALWAYS less than DATA_WIDTH\n    parameter LC_MEM_DEPTH = 65536;    // 1 ~ 2^30\n\n    parameter LC_INT_DEPTH = 8;\n\n    input        CLK;\n    input        RESETn;\n\n    // Interface with MBus\n    output reg    [`ADDR_WIDTH-1:0] TX_ADDR;\n    output reg    [`DATA_WIDTH-1:0] TX_DATA; \n    output reg    TX_PEND; \n    output reg    TX_REQ;\n    input        TX_ACK; \n    output reg    TX_PRIORITY;\n\n    input        [`ADDR_WIDTH-1:0] RX_ADDR;\n    input        [`DATA_WIDTH-1:0] RX_DATA; \n    input        RX_PEND;\n    input        RX_REQ;\n    output reg    RX_ACK; \n    input        RX_BROADCAST;\n\n    input        RX_FAIL;\n    input        TX_FAIL;\n    input        TX_SUCC; \n    output reg    TX_RESP_ACK;\n\n    input         RELEASE_RST_FROM_MBUS;\n    // End of interface\n    \n    // Interface with Registers\n    input        [(LC_RF_DATA_WIDTH*LC_RF_DEPTH)-1:0] REG_RD_DATA;\n    output reg    [LC_RF_DATA_WIDTH-1:0] REG_WR_DATA;\n    output reg    [LC_RF_DEPTH-1:0] REG_WR_EN;\n    // End of interface\n    \n    // Interface with MEM\n    output         MEM_REQ_OUT;\n    output         MEM_WRITE;\n    input        MEM_ACK_IN;\n    output reg    [LC_MEM_DATA_WIDTH-1:0] MEM_WR_DATA;\n    input        [LC_MEM_DATA_WIDTH-1:0] MEM_RD_DATA;\n    output reg    [LC_MEM_ADDR_WIDTH-3:0] MEM_ADDR;\n    // End of interface\n    \n    // Interrupt\n    input        [LC_INT_DEPTH-1:0] INT_VECTOR;\n    output reg    [LC_INT_DEPTH-1:0] CLR_INT;\n    input        [`FUNC_WIDTH*LC_INT_DEPTH-1:0] INT_FU_ID;\n    input        [(`DATA_WIDTH<<1)*LC_INT_DEPTH-1:0] INT_CMD;\n\n    `include \"include/mbus_func.v\"\n\n    wire    RESETn_local = (RESETn & (~RELEASE_RST_FROM_MBUS));\n\n    parameter MAX_DMA_LENGTH = 24; // cannot greater than `DATA_WIDTH - `SHORT_ADDR_WIDTH\n\n    parameter LC_STATE_IDLE        = 4'd0;\n    parameter LC_STATE_RF_READ        = 4'd1;\n    parameter LC_STATE_RF_WRITE    = 4'd2;\n    parameter LC_STATE_MEM_READ    = 4'd3;\n    parameter LC_STATE_MEM_WRITE    = 4'd4;\n    parameter LC_STATE_BUS_TX        = 4'd5;\n    parameter LC_STATE_WAIT_CPL    = 4'd6;\n    parameter LC_STATE_ERROR        = 4'd7;\n    parameter LC_STATE_INT_ARBI    = 4'd8;\n    parameter LC_STATE_INT_HANDLED    = 4'd9;\n\n    // Double latching registers\n    reg        TX_ACK_DL1, TX_ACK_DL2;\n    reg        RX_REQ_DL1, RX_REQ_DL2;\n\n    // General registers\n    reg        [3:0]    lc_state, next_lc_state, lc_return_state, next_lc_return_state;\n    reg        rx_pend_reg, next_rx_pend_reg;\n    reg        [2:0]    mem_sub_state, next_mem_sub_state;\n    reg        [MAX_DMA_LENGTH-1:0] dma_counter, next_dma_counter;\n\n    // rx buffers\n    reg        [`DATA_WIDTH-1:0]    rx_dat_buffer, next_rx_dat_buffer;\n\n    // Mbus interface\n    reg        [`ADDR_WIDTH-1:0]    next_tx_addr;\n    reg        [`DATA_WIDTH-1:0]    next_tx_data;\n    reg        next_tx_pend;\n    reg        next_tx_req;\n    reg        next_priority;\n    reg        next_rx_ack;\n    reg        next_tx_resp_ack;\n\n    // RF interface\n    wire    [LC_RF_DATA_WIDTH-1:0] rf_in_array [0:LC_RF_DEPTH-1];\n    genvar unpk_idx; \n    generate \n        for (unpk_idx=0; unpk_idx<(LC_RF_DEPTH); unpk_idx=unpk_idx+1)\n        begin: UNPACK\n            assign rf_in_array[unpk_idx] = REG_RD_DATA[((LC_RF_DATA_WIDTH)*(unpk_idx+1)-1):((LC_RF_DATA_WIDTH)*unpk_idx)]; \n        end\n    endgenerate\n    reg        [LC_RF_DEPTH-1:0] next_rf_load;\n    wire    [LC_RF_DEPTH-1:0] rf_load_temp = (1'b1<<(rx_dat_buffer[`DATA_WIDTH-1:LC_RF_DATA_WIDTH]));\n    reg        [LC_RF_DATA_WIDTH-1:0] next_rf_dout;\n    wire    [LC_RF_ADDR_WIDTH-1:0] rf_dma_length = rx_dat_buffer[LC_RF_DATA_WIDTH-1:LC_RF_DATA_WIDTH-LC_RF_ADDR_WIDTH];\n    wire    [log2(LC_RF_DEPTH-1)-1:0] rf_idx_temp = rx_dat_buffer[(LC_RF_DATA_WIDTH+log2(LC_RF_DEPTH-1)-1):LC_RF_DATA_WIDTH];\n    wire    [`SHORT_ADDR_WIDTH-1:0] rf_relay_addr = rx_dat_buffer[LC_RF_DATA_WIDTH-LC_RF_ADDR_WIDTH-1:LC_RF_DATA_WIDTH-LC_RF_ADDR_WIDTH-`SHORT_ADDR_WIDTH];\n    reg        [log2(LC_RF_DEPTH-1)-1:0] rf_idx, next_rf_idx;\n\n    // Mem interface\n    reg        mem_write, next_mem_write, mem_read, next_mem_read;\n    assign    MEM_REQ_OUT = (mem_write | mem_read);\n    assign    MEM_WRITE = mem_write;\n    reg        [LC_MEM_ADDR_WIDTH-3:0] next_mem_aout;\n    reg        [LC_MEM_DATA_WIDTH-1:0] next_mem_dout;\n\n    // Interrupt register\n    reg        [LC_INT_DEPTH-1:0] next_clr_int, int_vector_copied, next_int_vector_copied;\n    reg        [log2(LC_INT_DEPTH-1)-1:0] int_idx, next_int_idx;\n    reg        next_layer_interrupted, layer_interrupted;\n    wire    [`FUNC_WIDTH-1:0] interrupt_functional_id [0:LC_INT_DEPTH-1];\n    wire    [(`DATA_WIDTH<<1)-1:0] interrupt_payload [0:LC_INT_DEPTH-1];\n    generate\n        for (unpk_idx=0; unpk_idx<(LC_INT_DEPTH); unpk_idx=unpk_idx+1)\n        begin: UNPACK_INT\n            assign interrupt_functional_id[unpk_idx] = INT_FU_ID[((`FUNC_WIDTH)*(unpk_idx+1)-1):((`FUNC_WIDTH)*unpk_idx)]; \n            assign interrupt_payload[unpk_idx] = INT_CMD[((`DATA_WIDTH<<1)*(unpk_idx+1)-1):((`DATA_WIDTH<<1)*unpk_idx)]; \n        end\n    endgenerate\n\n    always @ (posedge CLK or negedge RESETn_local)\n    begin\n        if (~RESETn_local)\n        begin\n            TX_ACK_DL1 <= 0;\n            TX_ACK_DL2 <= 0;\n            RX_REQ_DL1 <= 0;\n            RX_REQ_DL2 <= 0;\n        end\n        else\n        begin\n            TX_ACK_DL1 <= TX_ACK;\n            TX_ACK_DL2 <= TX_ACK_DL1;\n            RX_REQ_DL1 <= RX_REQ;\n            RX_REQ_DL2 <= RX_REQ_DL1;\n        end\n    end\n\n    always @ (posedge CLK or negedge RESETn_local)\n    begin\n        if (~RESETn_local)\n        begin\n            // General registers\n            lc_state <= LC_STATE_IDLE;\n            lc_return_state <= LC_STATE_IDLE;\n            rx_pend_reg <= 0;\n            mem_sub_state <= 0;\n            dma_counter <= 0;\n            // rx buffers\n            rx_dat_buffer <= 0;\n            // MBus interface\n            TX_ADDR <= 0;\n            TX_DATA <= 0;\n            TX_REQ <= 0;\n            TX_PEND <= 0;\n            TX_PRIORITY<= 0;\n            RX_ACK    <= 0;\n            TX_RESP_ACK <= 0;\n            // Register file interface\n            REG_WR_EN <= 0;\n            REG_WR_DATA <= 0;\n            rf_idx <= 0;\n            // Memory interface\n            mem_write    <= 0;\n            mem_read    <= 0;\n            MEM_ADDR <= 0;\n            MEM_WR_DATA <= 0;\n            // Interrupt interface\n            CLR_INT <= 0;\n            int_idx <= 0;\n            int_vector_copied <= 0;\n            layer_interrupted <= 0;\n        end\n        else\n        begin\n            // General registers\n            lc_state <= next_lc_state;\n            lc_return_state <= next_lc_return_state;\n            rx_pend_reg <= next_rx_pend_reg;\n            mem_sub_state <= next_mem_sub_state;\n            dma_counter <= next_dma_counter;\n            // rx buffers\n            rx_dat_buffer <= next_rx_dat_buffer;\n            // MBus interface\n            TX_ADDR <= next_tx_addr;\n            TX_DATA <= next_tx_data;\n            TX_REQ <= next_tx_req;\n            TX_PEND <= next_tx_pend;\n            TX_PRIORITY <= next_priority;\n            RX_ACK    <= next_rx_ack;\n            TX_RESP_ACK <= next_tx_resp_ack;\n            // Register file interface\n            REG_WR_EN <= next_rf_load;\n            REG_WR_DATA <= next_rf_dout;\n            rf_idx <= next_rf_idx;\n            // Memory interface\n            mem_write    <= next_mem_write;\n            mem_read    <= next_mem_read;\n            MEM_ADDR <= next_mem_aout;\n            MEM_WR_DATA <= next_mem_dout;\n            // Interrupt interface\n            CLR_INT <= next_clr_int;\n            int_idx <= next_int_idx;\n            int_vector_copied <= next_int_vector_copied;\n            layer_interrupted <= next_layer_interrupted;\n        end\n    end\n\n    always @ *\n    begin\n        // General registers\n        next_lc_state     = lc_state;\n        next_lc_return_state = lc_return_state;\n        next_rx_pend_reg= rx_pend_reg;\n        next_mem_sub_state = mem_sub_state;\n        next_dma_counter = dma_counter;\n        // rx buffers\n        next_rx_dat_buffer = rx_dat_buffer;\n        // MBus registers\n        next_tx_addr     = TX_ADDR;\n        next_tx_data     = TX_DATA;\n        next_tx_pend     = TX_PEND;\n        next_tx_req      = TX_REQ;\n        next_priority     = TX_PRIORITY;\n        next_rx_ack        = RX_ACK;\n        next_tx_resp_ack= TX_RESP_ACK;\n        // RF registers\n        next_rf_load     = 0;\n        next_rf_dout     = REG_WR_DATA;\n        next_rf_idx        = rf_idx;\n        // MEM registers\n        next_mem_aout    = MEM_ADDR;\n        next_mem_dout    = MEM_WR_DATA;\n        next_mem_write    = mem_write;\n        next_mem_read    = mem_read;\n        // Interrupt registers\n        next_clr_int = CLR_INT;\n        next_int_idx = int_idx;\n        next_int_vector_copied = int_vector_copied;\n        next_layer_interrupted = layer_interrupted;\n\n        // Asynchronized interface\n        if ((~(RX_REQ_DL2 | RX_FAIL)) & RX_ACK)\n            next_rx_ack = 0;\n        \n        if (CLR_INT & (~INT_VECTOR))\n            next_clr_int = 0;\n\n        if (TX_ACK_DL2 & TX_REQ)\n            next_tx_req = 0;\n\n        if (TX_SUCC | TX_FAIL)\n            next_tx_resp_ack = 1;\n\n        if ((~(TX_SUCC | TX_FAIL)) & TX_RESP_ACK)\n            next_tx_resp_ack = 0;\n        \n        if (MEM_ACK_IN & MEM_REQ_OUT)\n        begin\n            next_mem_read = 0;\n            next_mem_write = 0;\n        end\n        // End of asynchronized interface\n\n        case (lc_state)\n            LC_STATE_IDLE:\n            begin\n                next_mem_sub_state = 0;\n                next_layer_interrupted = 0;\n                if ((INT_VECTOR>0) && (CLR_INT==0))\n                begin\n                    next_int_vector_copied = INT_VECTOR;\n                    next_lc_state = LC_STATE_INT_ARBI;\n                    next_int_idx = 0;\n                end\n                else\n                begin\n                    if (RX_REQ_DL2 | RX_FAIL)\n                        next_rx_ack = 1;\n\n                    if (RX_REQ_DL2 & (~RX_ACK))    // prevent double trigger\n                    begin\n                        next_rx_dat_buffer = RX_DATA;\n                        next_rx_pend_reg = RX_PEND;\n                        case (RX_ADDR[`FUNC_WIDTH-1:0])\n                            `LC_CMD_RF_READ: begin next_lc_state = LC_STATE_RF_READ; end\n                            `LC_CMD_RF_WRITE: begin next_lc_state = LC_STATE_RF_WRITE; end\n                            `LC_CMD_MEM_READ: begin next_lc_state = LC_STATE_MEM_READ; end\n                            `LC_CMD_MEM_WRITE: begin next_lc_state = LC_STATE_MEM_WRITE; end\n                            default: begin if (RX_PEND) next_lc_state = LC_STATE_ERROR; end    // Invalid message\n                        endcase\n                    end\n                end\n            end\n\n            LC_STATE_RF_READ:\n            begin\n                case (mem_sub_state)\n                    0:\n                    begin\n                        if ((~rx_pend_reg)&&((rx_dat_buffer[`DATA_WIDTH-1:LC_RF_DATA_WIDTH]) < LC_RF_DEPTH))    // prevent aliasing\n                        begin \n                            next_dma_counter = {{(MAX_DMA_LENGTH-LC_RF_ADDR_WIDTH){1'b0}}, rf_dma_length};\n                            next_rf_idx = rf_idx_temp;\n                            next_mem_sub_state = 1;\n                            next_tx_addr = {{(`ADDR_WIDTH-`SHORT_ADDR_WIDTH){1'b0}}, rf_relay_addr};\n                        end\n                        else if (rx_pend_reg)    // invalid message\n                        begin\n                            next_lc_state = LC_STATE_ERROR;\n                            next_mem_sub_state = 0;\n                        end\n                        else                    // invalid address\n                            next_lc_state = LC_STATE_IDLE;\n                    end\n\n                    1:\n                    begin\n                        if (~TX_REQ)\n                        begin\n                            next_tx_data = {{(LC_RF_ADDR_WIDTH){1'b0}}, rf_in_array[rf_idx]};\n                            next_tx_req = 1;\n                            next_lc_state = LC_STATE_BUS_TX;\n                            next_mem_sub_state = 2;\n                            next_lc_return_state = LC_STATE_RF_READ;\n                            if ((dma_counter)&&(rf_idx < (LC_RF_DEPTH-1'b1)))\n                            begin\n                                next_tx_pend = 1;\n                                next_dma_counter = dma_counter - 1'b1;\n                            end\n                            else\n                                next_tx_pend = 0;\n                        end\n                    end\n\n                    2:\n                    begin\n                        next_rf_idx = rf_idx + 1'b1;\n                        next_mem_sub_state = 1;\n                    end\n                endcase\n            end\n\n            LC_STATE_RF_WRITE:\n            begin\n                case (mem_sub_state)\n                    0:\n                    begin\n                        if ((rx_dat_buffer[`DATA_WIDTH-1:LC_RF_DATA_WIDTH]) < LC_RF_DEPTH)\n                        begin\n                            next_rf_dout = rx_dat_buffer[LC_RF_DATA_WIDTH-1:0];\n                            next_mem_sub_state = 1;\n                        end\n                        else if (rx_pend_reg)    // Invalid address\n                        begin\n                            next_lc_state = LC_STATE_ERROR;\n                            next_mem_sub_state = 0;\n                        end\n                        else\n                            next_lc_state = LC_STATE_IDLE;\n                    end\n\n                    1:\n                    begin\n                        next_rf_load = rf_load_temp;\n                        if (rx_pend_reg)\n                            next_mem_sub_state = 2;\n                        else\n                            next_lc_state = LC_STATE_IDLE;\n                    end\n\n                    2:\n                    begin\n                        if (RX_REQ_DL2 & (~RX_ACK))\n                        begin\n                            next_rx_ack = 1;\n                            next_mem_sub_state = 0;\n                            next_rx_dat_buffer = RX_DATA;\n                            next_rx_pend_reg = RX_PEND;\n                        end\n                        else if ((RX_FAIL) & (~RX_ACK))\n                        begin\n                            next_rx_ack = 1;\n                            next_lc_state = LC_STATE_IDLE;\n                        end\n                    end\n                endcase\n\n            end\n\n            LC_STATE_MEM_READ:\n            begin\n                case (mem_sub_state)\n                    0:\n                    begin\n                        if ((rx_pend_reg)&&(rx_dat_buffer[LC_MEM_ADDR_WIDTH-1:2] < LC_MEM_DEPTH))\n                        begin\n                            next_mem_aout = rx_dat_buffer[LC_MEM_ADDR_WIDTH-1:2];\n                            next_dma_counter = 0;\n                            next_mem_sub_state = 1;\n                        end\n                        else if (rx_pend_reg & (~layer_interrupted))    // Invalid address\n                        begin\n                            next_lc_state = LC_STATE_ERROR;\n                            next_mem_sub_state = 0;\n                        end\n                        else                     // Invalid message\n                            next_lc_state = LC_STATE_IDLE;\n                    end\n\n                    1:\n                    begin\n                        if (layer_interrupted)\n                        begin\n                            next_rx_pend_reg = 0;\n                            next_mem_sub_state = 2;\n                            next_dma_counter = interrupt_payload[int_idx][MAX_DMA_LENGTH-1:0];\n                            next_tx_addr = {{(`ADDR_WIDTH-`SHORT_ADDR_WIDTH){1'b0}}, interrupt_payload[int_idx][`DATA_WIDTH-1:`DATA_WIDTH-`SHORT_ADDR_WIDTH]};\n                        end\n                        else\n                        begin\n                            if (RX_REQ_DL2 & (~RX_ACK))\n                            begin\n                                next_rx_ack = 1;\n                                next_rx_pend_reg = RX_PEND;\n                                next_mem_sub_state = 2;\n                                next_dma_counter = RX_DATA[MAX_DMA_LENGTH-1:0];\n                                next_tx_addr = {{(`ADDR_WIDTH-`SHORT_ADDR_WIDTH){1'b0}}, RX_DATA[`DATA_WIDTH-1:`DATA_WIDTH-`SHORT_ADDR_WIDTH]};\n                            end\n                            else if (RX_FAIL & (~RX_ACK))\n                            begin\n                                next_rx_ack = 1;\n                                next_lc_state = LC_STATE_IDLE;\n                            end\n                        end\n                    end\n\n                    2:\n                    begin\n                        if (~MEM_REQ_OUT)\n                        begin\n                            next_mem_read = 1;\n                            next_mem_sub_state = 3;\n                        end\n                    end\n\n                    3:\n                    begin\n                        // Read complete\n                        if (MEM_ACK_IN & (~TX_REQ))\n                        begin\n                            next_tx_req = 1;\n                            next_tx_data[LC_MEM_DATA_WIDTH-1:0] = MEM_RD_DATA;\n                            next_lc_state = LC_STATE_BUS_TX;\n                            next_lc_return_state = LC_STATE_MEM_READ;\n                            next_mem_sub_state = 4;\n                            if ((dma_counter)&&(MEM_ADDR < (LC_MEM_DEPTH-1'b1)))\n                            begin\n                                next_tx_pend = 1;\n                                next_dma_counter = dma_counter - 1'b1;\n                            end\n                            else\n                                next_tx_pend = 0;\n                        end\n                    end\n\n                    4:    // increment address\n                    begin\n                        next_mem_aout = MEM_ADDR + 1'b1;\n                        next_mem_sub_state = 2;\n                    end\n                endcase\n            end\n\n            LC_STATE_MEM_WRITE:\n            begin\n                case (mem_sub_state)\n                    0:\n                    begin\n                        if ((rx_pend_reg)&&(rx_dat_buffer[LC_MEM_ADDR_WIDTH-1:2] < LC_MEM_DEPTH))\n                        begin\n                            next_mem_aout = rx_dat_buffer[LC_MEM_ADDR_WIDTH-1:2];\n                            next_mem_sub_state = 1;\n                        end\n                        else if (rx_pend_reg)    // Invalid Address\n                        begin\n                            next_lc_state = LC_STATE_ERROR;\n                            next_mem_sub_state = 0;\n                        end\n                        else                     // Invalid message\n                            next_lc_state = LC_STATE_IDLE;\n                    end\n\n                    1:\n                    begin\n                        if (RX_REQ_DL2 & (~RX_ACK))\n                        begin\n                            next_rx_ack = 1;\n                            next_mem_sub_state = 2;\n                            next_mem_dout = RX_DATA[LC_MEM_DATA_WIDTH-1:0];\n                            next_rx_pend_reg = RX_PEND;\n                        end\n                        else if (RX_FAIL & (~RX_ACK))\n                        begin\n                            next_rx_ack = 1;\n                            next_lc_state = LC_STATE_IDLE;\n                        end\n                    end\n\n                    2:\n                    begin\n                        if (~MEM_REQ_OUT)\n                        begin\n                            next_mem_write = 1;\n                            next_mem_sub_state = 3;\n                        end\n                    end\n\n                    3:\n                    begin\n                        // write complete\n                        if (MEM_ACK_IN)\n                        begin\n                            if ((rx_pend_reg)&&(MEM_ADDR<(LC_MEM_DEPTH-1'b1)))\n                            begin\n                                next_mem_aout = MEM_ADDR + 1'b1;\n                                next_mem_sub_state = 1;\n                            end\n                            else if (rx_pend_reg)    // Invalid Address\n                            begin\n                                next_lc_state = LC_STATE_ERROR;\n                                next_mem_sub_state = 0;\n                            end\n                            else\n                                next_lc_state = LC_STATE_IDLE;\n                        end\n                    end\n                endcase\n            end\n\n            LC_STATE_BUS_TX:\n            begin // cannot modify mem_sub_state here\n                if (TX_ACK_DL2)\n                begin\n                    if (TX_PEND)\n                        next_lc_state = lc_return_state;\n                    else\n                        next_lc_state = LC_STATE_WAIT_CPL;\n                end\n                else if (TX_FAIL)\n                    next_lc_state = LC_STATE_WAIT_CPL;\n            end\n\n            LC_STATE_WAIT_CPL:\n            begin\n                if (TX_SUCC | TX_FAIL)\n                    next_lc_state = LC_STATE_IDLE;\n            end\n\n            LC_STATE_INT_ARBI:\n            begin\n                if (int_vector_copied[0])\n                begin\n                    next_lc_state = LC_STATE_INT_HANDLED;\n                end\n                else\n                begin\n                    next_int_vector_copied = (int_vector_copied>>1);\n                    next_int_idx = int_idx + 1;\n                end\n            end\n\n            LC_STATE_INT_HANDLED:\n            begin\n                next_clr_int = (1'b1 << int_idx);    // clear interrupt\n                next_rx_dat_buffer = interrupt_payload[int_idx][(`DATA_WIDTH<<1)-1:`DATA_WIDTH];\n                next_layer_interrupted = 1;\n                case (interrupt_functional_id[int_idx])\n                    `LC_CMD_RF_READ: begin next_lc_state = LC_STATE_RF_READ; next_rx_pend_reg = 0; end\n                    `LC_CMD_MEM_READ: begin next_lc_state = LC_STATE_MEM_READ; next_rx_pend_reg = 1; end\n                    default: begin next_lc_state = LC_STATE_IDLE; end    // Invalid interrupt message\n                endcase\n            end\n\n            // This state handles errors, junk message coming in. disgarding all\n            // the message before return idle state\n            LC_STATE_ERROR:\n            begin\n                case (mem_sub_state)\n                    0:\n                    begin\n                        if (RX_REQ_DL2 & (~RX_ACK))\n                        begin\n                            next_rx_pend_reg = RX_PEND;\n                            next_mem_sub_state = 1;\n                        end\n                    end\n\n                    1:\n                    begin\n                        if (rx_pend_reg & RX_FAIL)\n                        begin\n                            next_rx_ack = 1;\n                            next_lc_state = LC_STATE_IDLE;\n                        end\n                        else if (~rx_pend_reg)\n                        begin\n                            next_rx_ack = 1;\n                            next_lc_state = LC_STATE_IDLE;\n                        end\n                    end\n                endcase\n            end\n\n        endcase\n    end\n\nendmodule"}
{"task_id": 1148, "completion": "wire  sub_wire0;\n\twire [6:0] sub_wire1;\n\twire  sub_wire2;\n\twire  sub_wire3;\n\twire [300:0] sub_wire4;\n\twire  rdempty = sub_wire0;\n\twire [6:0] wrusedw = sub_wire1[6:0];\n\twire  wrfull = sub_wire2;\n\twire  wrempty = sub_wire3;\n\twire [300:0] q = sub_wire4[300:0];\n\tdcfifo dcfifo_component (\n\t\t\t.wrclk (wrclk),\n\t\t\t.rdreq (rdreq),\n\t\t\t.rdclk (rdclk),\n\t\t\t.wrreq (wrreq),\n\t\t\t.data (data),\n\t\t\t.rdempty (sub_wire0),\n\t\t\t.wrusedw (sub_wire1),\n\t\t\t.wrfull (sub_wire2),\n\t\t\t.wrempty (sub_wire3),\n\t\t\t.q (sub_wire4)\n\t\t\t// synopsys translate_off\n\t\t\t,\n\t\t\t.aclr (),\n\t\t\t.rdfull (),\n\t\t\t.rdusedw ()\n\t\t\t// synopsys translate_on\n\t\t);\n\tdefparam\n\t\tdcfifo_component.intended_device_family = \"Cyclone II\",\n\t\tdcfifo_component.lpm_hint = \"MAXIMIZE_SPEED=5,\",\n\t\tdcfifo_component.lpm_numwords = 128,\n\t\tdcfifo_component.lpm_showahead = \"OFF\",\n\t\tdcfifo_component.lpm_type = \"dcfifo\",\n\t\tdcfifo_component.lpm_width = 301,\n\t\tdcfifo_component.lpm_widthu = 7,\n\t\tdcfifo_component.overflow_checking = \"OFF\",\n\t\tdcfifo_component.rdsync_delaypipe = 4,\n\t\tdcfifo_component.underflow_checking = \"OFF\",\n\t\tdcfifo_component.use_eab = \"ON\",\n\t\tdcfifo_component.wrsync_delaypipe = 4;\n\nendmodule"}
{"task_id": 939, "completion": "input  clk;\ninput  rst_n;\ninput  vid_time;\ninput  wire[8:0] x;\ninput  wire[7:0] y;\ninput  wire[7:0] padl0;\ninput  wire[7:0] padl1;\ninput  DEMO_MODE;\ninput  serv_ball;\ninput  game_rst;\ninput  wire[1:0] ball_speed;\noutput reg vid;\noutput     audio_o;\nlocalparam  X_L = 27;\nlocalparam  X_R = 219;\nlocalparam  Y_T = 17;\nlocalparam  Y_B = 243;\nlocalparam  BAR      = 124;\nlocalparam  NUM0_POS = BAR-10;\nlocalparam  NUM1_POS = BAR+7;\nlocalparam  MISS     = 2'b01;\nlocalparam  BOUNCE   = 2'b10;\nlocalparam  HIT      = 2'b11;\nwire      num0,num1;\nreg       ball;\nreg [2:0] new_dir;\nreg [2:0] newy_dir;\nreg       p0,p1,bar,xlr8;\nreg [7:0] padl0_l;\nreg [7:0] padl0_m0;\nreg [7:0] padl0_m1;\nreg [7:0] padl0_h;\nreg       p0_hit;\nreg       stop_game;\nreg [7:0] padl1_l;\nreg [7:0] padl1_m0;\nreg [7:0] padl1_m1;\nreg [7:0] padl1_h;\nreg       p1_hit;\nreg [1:0] snd_sel;\nreg [1:0] pad_snd_sel;\nreg [1:0] wall_snd_sel;\nreg      GO_GAME;\nreg      winner;\nreg[3:0] score0;\nreg[3:0] score1;\nreg       frame0;\nreg       frame0_dly;\nwire      sof;\nreg[7:0] ballx;\nreg[7:0] ballx_step;\nreg[1:0] ballx_dir;\nreg[7:0] bally;\nreg[7:0] bally_step;\nreg[1:0] bally_dir;\nreg rst_n1;\nreg rst_n2;\nreg rst_n3;\nreg rst_n4;\nalways @(posedge clk) begin\n   if(!rst_n) begin\n       GO_GAME <= 0;\n   end else begin\n       case( {serv_ball, stop_game})\n          2'b00: GO_GAME <= GO_GAME;\n          2'b01: GO_GAME <= 1'b0;\n          2'b10: GO_GAME <= 1'b1;\n          2'b11: GO_GAME <= 1'b1;\n       endcase\n   end\nend\nalways @(posedge clk) begin\n   if(!rst_n) begin\n      vid <=0;\n   end else begin\n      vid <= ( p0   ||   //Paddle 0\n               p1   ||   //Paddle 1\n               num0 ||   //Num 0\n               num1 ||   //Num 1\n               ball ||   //Ball\n               xlr8 ||\n               bar ) ? 1'b1 : 1'b0;\n   end\nend\nalways @(posedge clk) begin\n    p0  <= ( vid_time==1 && (x>=25  && x<=26)  && (y>=padl0_l && y<=padl0_h) );\n    p1  <= ( vid_time==1 && (x>=221 && x<=222) && (y>=padl1_l && y<=padl1_h) );\n    bar <= ( vid_time==1 && (x==BAR) && (y>=18 && y<=243) );\nend\nreg xx;\nreg xl;\nreg xr;\nreg x8;\nalways @(posedge clk) begin\n   xlr8 <= (vid_time==1 && winner==1 && (xx || xl || xr || x8) );\n   xx   <= ( y==80 &&                              (x>=79 && x<=90 )) ||\n           ((y==81 || y==82 || y==101|| y==102) && (x==91 || x==102)) ||\n           ((y==83 || y==84 || y==99 || y==100) && (x==92 || x==101)) ||\n           ((y==85 || y==86 || y==97 || y==98 ) && (x==93 || x==100)) ||\n           ((y==87 || y==88 || y==95 || y==96 ) && (x==94 || x==99)) ||\n           ((y==89 || y==90 || y==93 || y==94 ) && (x==95 || x==98)) ||\n           ((y==91 || y==92)                    && (x==96 || x==97) );\n   xl   <= (x>=110 && x<=119 && y==102) || (x==110 && y >=80 && y<= 102) ;\n   xr   <= (x>=130 && x<=138 && y==80)   || (x==130 && y >=80 && y<=102) ||\n           (x>=130 && x<=138 && y==91)   || (x==139 && y >=81 && y<= 90) ||\n           (x==133 && (y==91  || y==92)) || (x==134 && (y==93 || y==94)) ||\n           (x==135 && (y==95  || y==96)) || (x==136 && (y==97 || y==98)) ||\n           (x==137 && (y==99  || y==100))|| (x==138 && (y==101 || y==102)) ||\n           ((x>=139 && x<=151) && y==102);\n   x8   <= ((x>=144 && x<=150)  && (y==85 || y==92 || y==99)) ||\n           ((x==143 || x==151)  && y>=86 && y<=91) ||\n           ((x==143 || x==151)  && y>=93 && y<=98) ;\nend\nalways @(posedge clk) begin\n   if (sof==1) begin\n      if(padl0 <= 17 ) begin\n         padl0_l  <= 17;\n         padl0_m0 <= 17+5;\n         padl0_m1 <= 17+10;\n         padl0_h  <= 17+14;\n      end \n      if(padl0 > 17 && padl0<= 228) begin \n         padl0_l  <= padl0;\n         padl0_m0 <= padl0+5;\n         padl0_m1 <= padl0+10;\n         padl0_h  <= padl0+15;\n      end\n      if(padl0 >  228) begin\n         padl0_l  <= 229;\n         padl0_m0 <= 229+5;\n         padl0_m1 <= 229+10;\n         padl0_h  <= 243;\n      end \n   end \nend\nalways @(posedge clk) begin\n   if (sof==1) begin\n       if(padl1 <= 17 ) begin\n         padl1_l  <= 17;\n         padl1_m0 <= 17+5;\n         padl1_m1 <= 17+10;\n         padl1_h  <= 17+14;\n      end \n      if(padl1 > 17 && padl1<= 228) begin \n         padl1_l  <= padl1;\n         padl1_m0 <= padl1+5;\n         padl1_m1 <= padl1+10;\n         padl1_h  <= padl1+15;\n      end\n      if(padl1 > 228) begin\n         padl1_l  <= 229;\n         padl1_m0 <= 229+5;\n         padl1_m1 <= 229+10;\n         padl1_h  <= 243;\n      end \n   end \nend\nreg[25:0] cnt;\nalways @(posedge clk) begin\n   if(~rst_n) begin\n      cnt <= 50000000;\n   end else begin\n      cnt <= (cnt!=0) ? cnt-1 : 50000000;\n   end\nend\nalways @(posedge clk) begin\n   if(!rst_n) begin\n       snd_sel <= 2'b00;\n   end else begin\n       snd_sel <= (pad_snd_sel!=0) ? pad_snd_sel : (wall_snd_sel != 0) ? wall_snd_sel : 2'b00;\n   end\nend\nalways @(posedge clk) begin\n   if(~rst_n || game_rst) begin\n      score0    <= 0;\n      score1    <= 0;\n      p0_hit    <= 0;\n      p1_hit    <= 0;\n      new_dir   <= 3'b100;\n      stop_game <= 0;\n      winner    <= 0;\n      pad_snd_sel <= 2'b00;\n   end else begin\n      new_dir <= 3'b100;\n      pad_snd_sel <= 2'b00;\n      if( ! DEMO_MODE ) begin\n         if(serv_ball) begin\n            stop_game <= 1'b0;\n         end\n         if( ballx <= X_L ) begin\n            if( (bally >= padl0_l)  &&  (bally <= padl0_h)) begin\n               p0_hit    <= 1'b1;\n               stop_game <= 1'b0;\n               pad_snd_sel   <= HIT;\n               casez( { (bally >= padl0_l && bally < padl0_m0), (bally > padl0_m1 && bally <= padl0_h)} )\n                  2'b01:   new_dir <= 3'b110;\n                  2'b10:   new_dir <= 3'b101;\n                  default: new_dir <= 3'b111;\n               endcase\n            end else begin\n               if(stop_game==0 && winner==0) score1 <= (score1==9) ? 9 : score1+1;\n               if(score1==9) winner <= 1;\n               p0_hit <=0;\n               stop_game <= 1'b1;\n               pad_snd_sel   <= MISS;\n            end\n         end\n         if( ballx >= X_R ) begin\n            if( (bally >= padl1_l)  &&  (bally <= padl1_h)) begin\n               p1_hit    <= 1'b1;\n               stop_game <= 1'b0;\n               pad_snd_sel   <= HIT;\n               casez( { (bally >= padl1_l && bally < padl1_m0), (bally > padl1_m1 && bally <= padl1_h)} )\n                  2'b01:   new_dir <= 3'b110;\n                  2'b10:   new_dir <= 3'b101;\n                  default: new_dir <= 3'b111;\n               endcase\n            end else begin\n               if(stop_game == 0 && winner==0) score0 <= (score0==9) ? 9 : score0+1;\n               if(score0 == 9) winner <=1;\n               p1_hit <=0;\n               stop_game <= 1'b1;\n               pad_snd_sel   <= MISS;\n            end\n         end \n      end else begin\n         stop_game <= 1'b0;\n      end\n   end\nend\nvid_score #(.POSITION (NUM0_POS))\n      p0_score (.clk      (clk),\n                .rst_n    (rst_n),\n                .score    (score0),\n                .vid_time (vid_time),\n                .x        (x),\n                .y        (y),\n                .num      (num0)\n               );\nvid_score #(.POSITION (NUM1_POS))\n      p1_score (.clk      (clk),\n                .rst_n    (rst_n),\n                .score    (score1),\n                .vid_time (vid_time),\n                .x        (x),\n                .y        (y),\n                .num      (num1)\n               );\nalways @(posedge clk) begin\n    frame0_dly <= frame0;\n    frame0     <= (vid_time==1 && x==0 && y==0);\nend\nassign sof = frame0 && ~frame0_dly;\nreg[31:0]  new_sd;\nwire[31:0] rnd_data;\nalways @(posedge clk) begin\n  if(rst_n==0 && rst_n4==1) begin\n     new_sd <= 82582568;\n  end else begin\n     new_sd <= {rnd_data[30:0], rnd_data[31]};\n  end\nend\nmy_rand gen_rnd(.clk (clk),\n                 .rst ( ((~rst_n) && (rst_n1))),\n                 .seed0 (new_sd),\n                 .num   (rnd_data)\n                );\naudio_driver audio(.clk     (clk),\n                   .rst_n   (rst_n),\n                   .snd_sel (snd_sel),\n                   .audio_o (audio_o)\n                  );\nwire end_rst = (rst_n3==1) && (rst_n4==0);\nwire [3:0] x_state = {end_rst, sof==1 , ballx_dir};\nwire [3:0] y_state = {end_rst, sof==1 , bally_dir};\nalways @(posedge clk) begin\n  if(~rst_n) begin\n     bally_dir <= 2'b00;\n  end else begin\n     if(new_dir == 3'b111 || newy_dir == 3'b111) bally_dir <= 2'b00;\n     if(new_dir == 3'b110 || newy_dir == 3'b110) bally_dir <= 2'b10;\n     if(new_dir == 3'b101 || newy_dir == 3'b101) bally_dir <= 2'b01;\n  end \nend\nalways @(posedge clk) begin\n if(~rst_n) begin\n    ball <= 0;\n    newy_dir <= 3'b100;\n    wall_snd_sel <= 2'b00;\n end else begin\n    ball <= (vid_time==1 && (GO_GAME||DEMO_MODE) && (x==ballx ) && (y==bally || y==bally+1 )) ? 1'b1 : 1'b0;\n    wall_snd_sel <= 2'b00;\n    casez( {(DEMO_MODE && end_rst),(GO_GAME|| DEMO_MODE), sof==1 , ballx_dir}) \n      5'b010??: ballx <= ballx;\n      5'b01100: ballx <= ballx;\n      5'b01101: begin\n                 if(ballx <= X_L ) begin\n                    ballx <= ballx + ballx_step;\n                    ballx_dir <= 2;\n                    wall_snd_sel <= BOUNCE;\n                 end else begin\n                    ballx <= ballx - ballx_step;\n                 end            \n              end\n      5'b01110: begin//X incr  Ball Right\n                 if(ballx >= X_R ) begin\n                    ballx <= ballx - ballx_step;\n                    ballx_dir <= 1;\n                    wall_snd_sel <= BOUNCE;\n                 end else begin\n                    ballx <= ballx + ballx_step;\n                 end            \n              end\n      5'b01111: ballx <= ballx;\n      5'b00???: begin\n                  ballx      <= 124;\n                  ballx_step <= ball_speed;\n                  ballx_dir  <=  (rnd_data[13]==1) ? 2'b01 : 2'b10;\n                end\n      5'b1????: begin\n                  ballx      <= 124;\n                  ballx_step <= ball_speed;\n                  ballx_dir  <=  (rnd_data[13]==1) ? 2'b01 : 2'b10;\n               end\n    endcase\n    casez( {(DEMO_MODE && end_rst),(GO_GAME || DEMO_MODE), sof==1 , bally_dir}) \n      5'b010??: begin \n                   bally <= bally;\n                   newy_dir <= 3'b000;\n                end\n      5'b01100: begin\n                   bally <= bally;\n                   newy_dir <= 3'b000;\n                end\n      5'b01101: begin\n                   if( bally <= Y_T ) begin\n                      bally <= bally + bally_step;\n                      newy_dir <= 3'b110;\n                      wall_snd_sel <= BOUNCE;\n                   end else begin\n                      bally <= bally - bally_step;\n                      newy_dir <= 3'b000;\n                   end            \n                end\n      5'b01110: begin\n                   if( bally >= Y_B ) begin\n                      bally <= bally - bally_step;\n                      newy_dir <= 3'b101;\n                      wall_snd_sel <= BOUNCE;\n                   end else begin\n                      bally <= bally + bally_step;\n                      newy_dir <= 3'b000;\n                   end            \n                end\n      5'b01111: begin\n                   bally <= bally;\n                   newy_dir <= 3'b000;\n                end\n      5'b00???: begin\n                  bally      <=  rnd_data[6:0]+67;\n                  case(rnd_data[9:8])\n                     2'b00: newy_dir <= 3'b100;\n                     2'b01: newy_dir <= 3'b101;\n                     2'b10: newy_dir <= 3'b110;\n                     2'b11: newy_dir <= 3'b111;\n                  endcase\n                  bally_step <= {6'h0, ball_speed};\n                end\n      5'b1????: begin\n                  bally      <=  rnd_data[6:0]+67;\n                  case(rnd_data[9:8])\n                     2'b00: newy_dir <= 3'b100;\n                     2'b01: newy_dir <= 3'b101;\n                     2'b10: newy_dir <= 3'b110;\n                     2'b11: newy_dir <= 3'b111;\n                  endcase\n                  bally_step <= {6'h0,ball_speed};\n                end\n    endcase\n end\nend\nalways @(posedge clk) begin\n  rst_n4 <= rst_n3;\n  rst_n3 <= rst_n2;\n  rst_n2 <= rst_n1;\n  rst_n1 <= rst_n;\nend\nendmodule"}
{"task_id": 1270, "completion": "reg [DATA_WIDTH-1:0]         reg_data;\n   assign data_out = reg_data;\nendmodule\n\nmodule tvm_vpi_write_mmap\n  #(\n    parameter DATA_WIDTH = 8,\n    parameter ADDR_WIDTH = 8,\n    parameter BASE_ADDR_WIDTH = 32\n    )\n   (\n    input                       clk,\n    input                       rst,\n    input [ADDR_WIDTH-1:0]      addr,\n    input [DATA_WIDTH-1:0]      data_in,\n    input                       en,\n    input [BASE_ADDR_WIDTH-1:0] mmap_addr\n    );\nendmodule"}
{"task_id": 1205, "completion": "function A strong_rec(input A a, input function f, input N n) begin\n        return recursion(a, f, S(n), n);\n    end\n\n    function A strong_rec0(input A a, input function f) begin\n        return recursion(a, f);\n    end\n\n    lemma strong_rec_alt(input A a, input function f, input N n) begin\n        return strong_rec(a, f, n) = strong_rec0(a, f, S(n), n);\n    end\n\n    instance strong_rec0_wd input A a, function f begin\n        return Proper(strong_rec0);\n    end\n\n    instance strong_rec_wd input A a, function f begin\n        return Proper(strong_rec);\n    end\n\n    function A strong_rec0_0(input A a, input N m) begin\n        return strong_rec0(a, f, 0, m) = a;\n    end\n\n    function A strong_rec0_succ(input A a, input N n, input N m) begin\n        return Aeq(strong_rec0(a, f, S(n), m), f(strong_rec0(a, f, n), m));\n    end\n\n    theorem strong_rec_0(input A a) begin\n        return Aeq(strong_rec(a, f, 0), f(fun _ => a, 0));\n    end\n\n    hypothesis step_good(input N n, input function h1, input function h2) begin\n        return Aeq(f(h1, n), f(h2, n));\n    end\n\n    lemma strong_rec0_more_steps(input A a, input N k, input N n, input N m) begin\n        return Aeq(strong_rec0(a, f, n, m), strong_rec0(a, f, n+k, m));\n    end\n\n    lemma strong_rec0_fixpoint(input A a, input N n) begin\n        return Aeq(strong_rec0(a, f, S(n), n), f(fun n => strong_rec0(a, f, S(n), n), n));\n    end\n\n    theorem strong_rec_fixpoint(input A a, input N n) begin\n        return Aeq(strong_rec(a, f, n), f(strong_rec(a, f), n));\n    end\n\n    theorem strong_rec_0_any(input A a, input function any) begin\n        return Aeq(strong_rec(a, f, 0), f(any, 0));\n    end\n\n    lemma strong_rec_any_fst_arg(input A a, input A a', input N n) begin\n        return Aeq(strong_rec(a, f, n), strong_rec(a', f, n));\n    end\nendmodule"}
{"task_id": 862, "completion": "(* ASYNC_REG = \"TRUE\", SHIFT_EXTRACT = \"NO\" *)    reg                 ovrd_reg1;\n    (* ASYNC_REG = \"TRUE\", SHIFT_EXTRACT = \"NO\" *)    reg                 gen3_reg1;\n    (* ASYNC_REG = \"TRUE\", SHIFT_EXTRACT = \"NO\" *)    reg                 qplllock_reg1;\n    (* ASYNC_REG = \"TRUE\", SHIFT_EXTRACT = \"NO\" *)    reg                 start_reg1;\n    (* ASYNC_REG = \"TRUE\", SHIFT_EXTRACT = \"NO\" *)    reg         [15:0]  do_reg1;\n    (* ASYNC_REG = \"TRUE\", SHIFT_EXTRACT = \"NO\" *)    reg                 rdy_reg1;\n    (* ASYNC_REG = \"TRUE\", SHIFT_EXTRACT = \"NO\" *)    reg                 ovrd_reg2;\n    (* ASYNC_REG = \"TRUE\", SHIFT_EXTRACT = \"NO\" *)    reg                 gen3_reg2;\n    (* ASYNC_REG = \"TRUE\", SHIFT_EXTRACT = \"NO\" *)    reg                 qplllock_reg2;\n    (* ASYNC_REG = \"TRUE\", SHIFT_EXTRACT = \"NO\" *)    reg                 start_reg2;\n    (* ASYNC_REG = \"TRUE\", SHIFT_EXTRACT = \"NO\" *)    reg         [15:0]  do_reg2;\n    (* ASYNC_REG = \"TRUE\", SHIFT_EXTRACT = \"NO\" *)    reg                 rdy_reg2;\n    reg         [ 1:0]  load_cnt =  2'd0;\n    reg         [ 2:0]  index    =  3'd0;\n    reg                 mode     =  1'd0;\n    reg         [ 5:0]  crscode  =  6'd0;\n    reg         [ 7:0]  addr    =  8'd0;\n    reg         [15:0]  di      = 16'd0;\n    reg                 done    =  1'd0;\n    reg         [ 8:0]  fsm     =  7'd1;\n    localparam          ADDR_QPLL_FBDIV               = 8'h36;\n    localparam          ADDR_QPLL_CFG                 = 8'h32;\n    localparam          ADDR_QPLL_LPF                 = 8'h31;\n    localparam          ADDR_CRSCODE                  = 8'h88;\n    localparam          ADDR_QPLL_COARSE_FREQ_OVRD    = 8'h35;\n    localparam          ADDR_QPLL_COARSE_FREQ_OVRD_EN = 8'h36;\n    localparam          ADDR_QPLL_LOCK_CFG            = 8'h34;\n    localparam          MASK_QPLL_FBDIV               = 16'b1111110000000000;\n    localparam          MASK_QPLL_CFG                 = 16'b1111111110111111;\n    localparam          MASK_QPLL_LPF                 = 16'b1000011111111111;\n    localparam          MASK_QPLL_COARSE_FREQ_OVRD    = 16'b0000001111111111;\n    localparam          MASK_QPLL_COARSE_FREQ_OVRD_EN = 16'b1111011111111111;\n    localparam          MASK_QPLL_LOCK_CFG            = 16'b1110011111111111;\n    localparam          NORM_QPLL_COARSE_FREQ_OVRD    = 16'b0000000000000000;\n    localparam          NORM_QPLL_COARSE_FREQ_OVRD_EN = 16'b0000000000000000;\n    localparam          NORM_QPLL_LOCK_CFG            = 16'b0000000000000000;\n    localparam          OVRD_QPLL_COARSE_FREQ_OVRD    = 16'b0000000000000000;\n    localparam          OVRD_QPLL_COARSE_FREQ_OVRD_EN = 16'b0000100000000000;\n    localparam          OVRD_QPLL_LOCK_CFG            = 16'b0000000000000000;\n    localparam          QPLL_FBDIV = (PCIE_REFCLK_FREQ == 2) && (PCIE_PLL_SEL == \"QPLL\") ? 16'b0000000010000000 : \n                                     (PCIE_REFCLK_FREQ == 1) && (PCIE_PLL_SEL == \"QPLL\") ? 16'b0000000100100000 : \n                                     (PCIE_REFCLK_FREQ == 0) && (PCIE_PLL_SEL == \"QPLL\") ? 16'b0000000101110000 : \n                                     (PCIE_REFCLK_FREQ == 2) && (PCIE_PLL_SEL == \"CPLL\") ? 16'b0000000001100000 : \n                                     (PCIE_REFCLK_FREQ == 1) && (PCIE_PLL_SEL == \"CPLL\") ? 16'b0000000011100000 : 16'b0000000100100000;\n    localparam          GEN12_QPLL_FBDIV = (PCIE_REFCLK_FREQ == 2) ? 16'b0000000010000000 : \n                                           (PCIE_REFCLK_FREQ == 1) ? 16'b0000000100100000 : 16'b0000000101110000;\n    localparam          GEN3_QPLL_FBDIV  = (PCIE_REFCLK_FREQ == 2) ? 16'b0000000001100000 : \n                                           (PCIE_REFCLK_FREQ == 1) ? 16'b0000000011100000 : 16'b0000000100100000;\n    localparam          GEN12_QPLL_CFG = (PCIE_PLL_SEL == \"QPLL\") ? 16'b0000000000000000 : 16'b0000000001000000;\n    localparam          GEN3_QPLL_CFG  = 16'b0000000001000000;\n    localparam          GEN12_QPLL_LPF = (PCIE_PLL_SEL == \"QPLL\") ? 16'b0_0100_00000000000 : 16'b0_1101_00000000000;\n    localparam          GEN3_QPLL_LPF  = 16'b0_1101_00000000000;\n    wire        [15:0]  data_qpll_fbdiv;\n    wire        [15:0]  data_qpll_cfg;\n    wire        [15:0]  data_qpll_lpf;\n    wire        [15:0]  data_qpll_coarse_freq_ovrd;\n    wire        [15:0]  data_qpll_coarse_freq_ovrd_en;\n    wire        [15:0]  data_qpll_lock_cfg;\n    localparam          FSM_IDLE      = 9'b000000001;\n    localparam          FSM_LOAD      = 9'b000000010;\n    localparam          FSM_READ      = 9'b000000100;\n    localparam          FSM_RRDY      = 9'b000001000;\n    localparam          FSM_WRITE     = 9'b000010000;\n    localparam          FSM_WRDY      = 9'b000100000;\n    localparam          FSM_DONE      = 9'b001000000;\n    localparam          FSM_QPLLRESET = 9'b010000000;\n    localparam          FSM_QPLLLOCK  = 9'b100000000;\n    always @ (posedge DRP_CLK)\n    begin\n        if (!DRP_RST_N)\n            begin\n                ovrd_reg1     <=  1'd0;\n                gen3_reg1     <=  1'd0;\n                qplllock_reg1 <=  1'd0;\n                start_reg1    <=  1'd0;\n                do_reg1       <= 16'd0;\n                rdy_reg1      <=  1'd0;\n                ovrd_reg2     <=  1'd0;\n                gen3_reg2     <=  1'd0;\n                qplllock_reg2 <=  1'd0;\n                start_reg2    <=  1'd0;\n                do_reg2       <= 16'd0;\n                rdy_reg2      <=  1'd0;\n            end\n        else\n            begin\n                ovrd_reg1     <= DRP_OVRD;\n                gen3_reg1     <= DRP_GEN3;\n                qplllock_reg1 <= DRP_QPLLLOCK;\n                start_reg1    <= DRP_START;\n                do_reg1       <= DRP_DO;\n                rdy_reg1      <= DRP_RDY;\n                ovrd_reg2     <= ovrd_reg1;\n                gen3_reg2     <= gen3_reg1;\n                qplllock_reg2 <= qplllock_reg1;\n                start_reg2    <= start_reg1;\n                do_reg2       <= do_reg1;\n                rdy_reg2      <= rdy_reg1;\n            end\n    end\n    assign data_qpll_fbdiv               = (gen3_reg2) ? GEN3_QPLL_FBDIV : GEN12_QPLL_FBDIV;\n    assign data_qpll_cfg                 = (gen3_reg2) ? GEN3_QPLL_CFG   : GEN12_QPLL_CFG;\n    assign data_qpll_lpf                 = (gen3_reg2) ? GEN3_QPLL_LPF   : GEN12_QPLL_LPF;\n    assign data_qpll_coarse_freq_ovrd    =  NORM_QPLL_COARSE_FREQ_OVRD;\n    assign data_qpll_coarse_freq_ovrd_en = (ovrd_reg2) ? OVRD_QPLL_COARSE_FREQ_OVRD_EN : NORM_QPLL_COARSE_FREQ_OVRD_EN;\n    assign data_qpll_lock_cfg            = (ovrd_reg2) ? OVRD_QPLL_LOCK_CFG            : NORM_QPLL_LOCK_CFG;\n    always @ (posedge DRP_CLK)\n    begin\n        if (!DRP_RST_N)\n            load_cnt <= 2'd0;\n        else\n            if ((fsm == FSM_LOAD) && (load_cnt < LOAD_CNT_MAX))\n                load_cnt <= load_cnt + 2'd1;\n            else if ((fsm == FSM_LOAD) && (load_cnt == LOAD_CNT_MAX))\n                load_cnt <= load_cnt;\n            else\n                load_cnt <= 2'd0;\n    end\n    always @ (posedge DRP_CLK)\n    begin\n        if (!DRP_RST_N)\n            begin\n                addr    <=  8'd0;\n                di      <= 16'd0;\n                crscode <=  6'd0;\n            end\n        else\n            begin\n                case (index)\n                3'd0 :\n                    begin\n                        addr    <= ADDR_QPLL_FBDIV;\n                        di      <= (do_reg2 & MASK_QPLL_FBDIV) | (mode ? data_qpll_fbdiv : QPLL_FBDIV);\n                        crscode <= crscode;\n                    end   \n                3'd1 :\n                    begin\n                        addr    <= ADDR_QPLL_CFG;\n                        if (PCIE_GT_DEVICE == \"GTX\") \n                            di <= (do_reg2 & MASK_QPLL_CFG) | data_qpll_cfg;\n                        else\n                            di <= (do_reg2 & 16'hFFFF) | data_qpll_cfg;\n                        crscode <= crscode;\n                    end       \n                3'd2 :\n                    begin\n                        addr    <= ADDR_QPLL_LPF;\n                        if (PCIE_GT_DEVICE == \"GTX\") \n                            di <= (do_reg2 & MASK_QPLL_LPF) | data_qpll_lpf;\n                        else\n                            di <= (do_reg2 & 16'hFFFF) | data_qpll_lpf;\n                        crscode <= crscode;\n                    end     \n                3'd3 :\n                    begin\n                        addr <= ADDR_CRSCODE;\n                        di   <= do_reg2;\n                        if (ovrd_reg2)\n                            crscode <= do_reg2[6:1];                 \n                        else\n                            crscode <= crscode;   \n                    end\n                3'd4 :\n                    begin\n                        addr    <= ADDR_QPLL_COARSE_FREQ_OVRD;\n                        di      <= (do_reg2 & MASK_QPLL_COARSE_FREQ_OVRD) | {(crscode - 6'd1), data_qpll_coarse_freq_ovrd[9:0]};\n                        crscode <= crscode;\n                    end    \n                3'd5 :\n                    begin\n                        addr    <= ADDR_QPLL_COARSE_FREQ_OVRD_EN;\n                        di      <= (do_reg2 & MASK_QPLL_COARSE_FREQ_OVRD_EN) | data_qpll_coarse_freq_ovrd_en;\n                        crscode <= crscode;\n                    end    \n                3'd6 :\n                    begin\n                        addr    <= ADDR_QPLL_LOCK_CFG;\n                        di      <= (do_reg2 & MASK_QPLL_LOCK_CFG) | data_qpll_lock_cfg;\n                        crscode <= crscode;\n                    end       \n                default : \n                    begin\n                        addr    <=  8'd0;\n                        di      <= 16'd0;\n                        crscode <=  6'd0;\n                    end\n                endcase\n            end\n    end\n    always @ (posedge DRP_CLK)\n    begin\n        if (!DRP_RST_N)\n            begin\n                fsm   <= FSM_IDLE;\n                index <= 3'd0;\n                mode  <= 1'd0;\n                done  <= 1'd0;\n            end\n        else\n            begin\n                case (fsm)\n                FSM_IDLE :  \n                    begin\n                        if (start_reg2)\n                            begin\n                                fsm   <= FSM_LOAD;\n                                index <= 3'd0;\n                                mode  <= 1'd0;\n                                done  <= 1'd0;\n                            end\n                        else if ((gen3_reg2 != gen3_reg1) && (PCIE_PLL_SEL == \"QPLL\"))\n                            begin\n                                fsm   <= FSM_LOAD;\n                                index <= 3'd0;\n                                mode  <= 1'd1;\n                                done  <= 1'd0;\n                            end\n                        else\n                            begin\n                                fsm   <= FSM_IDLE;\n                                index <= 3'd0;\n                                mode  <= 1'd0;\n                                done  <= 1'd1;\n                            end\n                    end    \n                FSM_LOAD :\n                    begin\n                        fsm   <= (load_cnt == LOAD_CNT_MAX) ? FSM_READ : FSM_LOAD;\n                        index <= index;\n                        mode  <= mode;\n                        done  <= 1'd0;\n                    end  \n                FSM_READ :\n                    begin\n                        fsm   <= FSM_RRDY;\n                        index <= index;\n                        mode  <= mode;\n                        done  <= 1'd0;\n                    end\n                FSM_RRDY :    \n                    begin\n                        fsm   <= (rdy_reg2 ? FSM_WRITE : FSM_RRDY);\n                        index <= index;\n                        mode  <= mode;\n                        done  <= 1'd0;\n                    end  \n                FSM_WRITE :    \n                    begin\n                        fsm   <= FSM_WRDY;\n                        index <= index;\n                        mode  <= mode;\n                        done  <= 1'd0;\n                    end       \n                FSM_WRDY :    \n                    begin\n                        fsm   <= (rdy_reg2 ? FSM_DONE : FSM_WRDY);\n                        index <= index;\n                        mode  <= mode;\n                        done  <= 1'd0;\n                    end        \n                FSM_DONE :\n                    begin\n                        if ((index == INDEX_MAX) || (mode && (index == 3'd2)))\n                            begin\n                                fsm   <= mode ? FSM_QPLLRESET : FSM_IDLE;\n                                index <= 3'd0;\n                                mode  <= mode;\n                                done  <= 1'd0;\n                            end\n                        else       \n                            begin\n                                fsm   <= FSM_LOAD;\n                                index <= index + 3'd1;\n                                mode  <= mode;\n                                done  <= 1'd0;\n                            end\n                    end     \n                FSM_QPLLRESET :\n                    begin\n                        fsm   <= !qplllock_reg2 ? FSM_QPLLLOCK : FSM_QPLLRESET;\n                        index <= 3'd0;\n                        mode  <= mode;\n                        done  <= 1'd0;\n                    end\n                FSM_QPLLLOCK :\n                    begin\n                        fsm   <= qplllock_reg2 ? FSM_IDLE : FSM_QPLLLOCK;\n                        index <= 3'd0;\n                        mode  <= mode;\n                        done  <= 1'd0;\n                    end\n                default :\n                    begin      \n                        fsm   <= FSM_IDLE;\n                        index <= 3'd0;\n                        mode  <= 1'd0;\n                        done  <= 1'd0;\n                    end\n                endcase\n            end\n    end\n    assign DRP_ADDR      = addr;\n    assign DRP_EN        = (fsm == FSM_READ) || (fsm == FSM_WRITE);\n    assign DRP_DI        = di;\n    assign DRP_WE        = (fsm == FSM_WRITE);\n    assign DRP_DONE      = done;\n    assign DRP_QPLLRESET = (fsm == FSM_QPLLRESET);\n    assign DRP_CRSCODE   = crscode;\n    assign DRP_FSM       = fsm;\nendmodule"}
{"task_id": 1118, "completion": "reg [31:0]  crc;\nwire[31:0]  crc_bit;\nreg [31:0]  new_bit;\n\nalways @ (posedge clk)\n    crc <= rst ? 32'h52325032 : val_in ? new_bit : crc;\n\nassign  crc_bit = crc ^ data_in;\nassign  crc_out = crc;\n\nalways @ (*))\nbegin\n    new_bit[31] = crc_bit[31] ^ crc_bit[30] ^ crc_bit[29] ^ crc_bit[28] ^ crc_bit[27] ^ crc_bit[25] ^ crc_bit[24] ^\n                  crc_bit[23] ^ crc_bit[15] ^ crc_bit[11] ^ crc_bit[9]  ^ crc_bit[8]  ^ crc_bit[5];\n    new_bit[30] = crc_bit[30] ^ crc_bit[29] ^ crc_bit[28] ^ crc_bit[27] ^ crc_bit[26] ^ crc_bit[24] ^ crc_bit[23] ^\n                  crc_bit[22] ^ crc_bit[14] ^ crc_bit[10] ^ crc_bit[8]  ^ crc_bit[7]  ^ crc_bit[4];\n    new_bit[29] = crc_bit[31] ^ crc_bit[29] ^ crc_bit[28] ^ crc_bit[27] ^ crc_bit[26] ^ crc_bit[25] ^ crc_bit[23] ^\n                  crc_bit[22] ^ crc_bit[21] ^ crc_bit[13] ^ crc_bit[9]  ^ crc_bit[7]  ^ crc_bit[6]  ^ crc_bit[3];\n    new_bit[28] = crc_bit[30] ^ crc_bit[28] ^ crc_bit[27] ^ crc_bit[26] ^ crc_bit[25] ^ crc_bit[24] ^ crc_bit[22] ^\n                  crc_bit[21] ^ crc_bit[20] ^ crc_bit[12] ^ crc_bit[8]  ^ crc_bit[6]  ^ crc_bit[5]  ^ crc_bit[2];\n    new_bit[27] = crc_bit[29] ^ crc_bit[27] ^ crc_bit[26] ^ crc_bit[25] ^ crc_bit[24] ^ crc_bit[23] ^ crc_bit[21] ^\n                  crc_bit[20] ^ crc_bit[19] ^ crc_bit[11] ^ crc_bit[7]  ^ crc_bit[5]  ^ crc_bit[4]  ^ crc_bit[1];\n    new_bit[26] = crc_bit[31] ^ crc_bit[28] ^ crc_bit[26] ^ crc_bit[25] ^ crc_bit[24] ^ crc_bit[23] ^ crc_bit[22] ^\n                  crc_bit[20] ^ crc_bit[19] ^ crc_bit[18] ^ crc_bit[10] ^ crc_bit[6]  ^ crc_bit[4]  ^ crc_bit[3]  ^\n                  crc_bit[0];\n    new_bit[25] = crc_bit[31] ^ crc_bit[29] ^ crc_bit[28] ^ crc_bit[22] ^ crc_bit[21] ^ crc_bit[19] ^ crc_bit[18] ^\n                  crc_bit[17] ^ crc_bit[15] ^ crc_bit[11] ^ crc_bit[8]  ^ crc_bit[3]  ^ crc_bit[2];\n    new_bit[24] = crc_bit[30] ^ crc_bit[28] ^ crc_bit[27] ^ crc_bit[21] ^ crc_bit[20] ^ crc_bit[18] ^ crc_bit[17] ^\n                  crc_bit[16] ^ crc_bit[14] ^ crc_bit[10] ^ crc_bit[7]  ^ crc_bit[2]  ^ crc_bit[1];\n    new_bit[23] = crc_bit[31] ^ crc_bit[29] ^ crc_bit[27] ^ crc_bit[26] ^ crc_bit[20] ^ crc_bit[19] ^ crc_bit[17] ^\n                  crc_bit[16] ^ crc_bit[15] ^ crc_bit[13] ^ crc_bit[9]  ^ crc_bit[6]  ^ crc_bit[1]  ^ crc_bit[0];\n    new_bit[22] = crc_bit[31] ^ crc_bit[29] ^ crc_bit[27] ^ crc_bit[26] ^ crc_bit[24] ^ crc_bit[23] ^ crc_bit[19] ^\n                  crc_bit[18] ^ crc_bit[16] ^ crc_bit[14] ^ crc_bit[12] ^ crc_bit[11] ^ crc_bit[9]  ^ crc_bit[0];\n    new_bit[21] = crc_bit[31] ^ crc_bit[29] ^ crc_bit[27] ^ crc_bit[26] ^ crc_bit[24] ^ crc_bit[22] ^ crc_bit[18] ^\n                  crc_bit[17] ^ crc_bit[13] ^ crc_bit[10] ^ crc_bit[9]  ^ crc_bit[5];\n    new_bit[20] = crc_bit[30] ^ crc_bit[28] ^ crc_bit[26] ^ crc_bit[25] ^ crc_bit[23] ^ crc_bit[21] ^ crc_bit[17] ^\n                  crc_bit[16] ^ crc_bit[12] ^ crc_bit[9]  ^ crc_bit[8]  ^ crc_bit[4];\n    new_bit[19] = crc_bit[29] ^ crc_bit[27] ^ crc_bit[25] ^ crc_bit[24] ^ crc_bit[22] ^ crc_bit[20] ^ crc_bit[16] ^\n                  crc_bit[15] ^ crc_bit[11] ^ crc_bit[8]  ^ crc_bit[7]  ^ crc_bit[3];\n    new_bit[18] = crc_bit[31] ^ crc_bit[28] ^ crc_bit[26] ^ crc_bit[24] ^ crc_bit[23] ^ crc_bit[21] ^ crc_bit[19] ^\n                  crc_bit[15] ^ crc_bit[14] ^ crc_bit[10] ^ crc_bit[7]  ^ crc_bit[6]  ^ crc_bit[2];\n    new_bit[17] = crc_bit[31] ^ crc_bit[30] ^ crc_bit[27] ^ crc_bit[25] ^ crc_bit[23] ^ crc_bit[22] ^ crc_bit[20] ^\n                  crc_bit[18] ^ crc_bit[14] ^ crc_bit[13] ^ crc_bit[9]  ^ crc_bit[6]  ^ crc_bit[5]  ^ crc_bit[1];\n    new_bit[16] = crc_bit[30] ^ crc_bit[29] ^ crc_bit[26] ^ crc_bit[24] ^ crc_bit[22] ^ crc_bit[21] ^ crc_bit[19] ^\n                  crc_bit[17] ^ crc_bit[13] ^ crc_bit[12] ^ crc_bit[8]  ^ crc_bit[5]  ^ crc_bit[4]  ^ crc_bit[0];\n    new_bit[15] = crc_bit[30] ^ crc_bit[27] ^ crc_bit[24] ^ crc_bit[21] ^ crc_bit[20] ^ crc_bit[18] ^ crc_bit[16] ^\n                  crc_bit[15] ^ crc_bit[12] ^ crc_bit[9]  ^ crc_bit[8]  ^ crc_bit[7]  ^ crc_bit[5]  ^ crc_bit[4]  ^\n                  crc_bit[3];\n    new_bit[14] = crc_bit[29] ^ crc_bit[26] ^ crc_bit[23] ^ crc_bit[20] ^ crc_bit[19] ^ crc_bit[17] ^ crc_bit[15] ^\n                  crc_bit[14] ^ crc_bit[11] ^ crc_bit[8]  ^ crc_bit[7]  ^ crc_bit[6]  ^ crc_bit[4]  ^ crc_bit[3]  ^\n                  crc_bit[2];\n    new_bit[13] = crc_bit[31] ^ crc_bit[28] ^ crc_bit[25] ^ crc_bit[22] ^ crc_bit[19] ^ crc_bit[18] ^ crc_bit[16] ^\n                  crc_bit[14] ^ crc_bit[13] ^ crc_bit[10] ^ crc_bit[7]  ^ crc_bit[6]  ^ crc_bit[5]  ^ crc_bit[3]  ^\n                  crc_bit[2]  ^ crc_bit[1];\n    new_bit[12] = crc_bit[31] ^ crc_bit[30] ^ crc_bit[27] ^ crc_bit[24] ^ crc_bit[21] ^ crc_bit[18] ^ crc_bit[17] ^\n                  crc_bit[15] ^ crc_bit[13] ^ crc_bit[12] ^ crc_bit[9]  ^ crc_bit[6]  ^ crc_bit[5]  ^ crc_bit[4]  ^\n                  crc_bit[2]  ^ crc_bit[1]  ^ crc_bit[0];\n    new_bit[11] = crc_bit[31] ^ crc_bit[28] ^ crc_bit[27] ^ crc_bit[26] ^ crc_bit[25] ^ crc_bit[24] ^ crc_bit[20] ^\n                  crc_bit[17] ^ crc_bit[16] ^ crc_bit[15] ^ crc_bit[14] ^ crc_bit[12] ^ crc_bit[9]  ^ crc_bit[4]  ^\n                  crc_bit[3]  ^ crc_bit[1]  ^ crc_bit[0];\n    new_bit[10] = crc_bit[31] ^ crc_bit[29] ^ crc_bit[28] ^ crc_bit[26] ^ crc_bit[19] ^ crc_bit[16] ^ crc_bit[14] ^\n                  crc_bit[13] ^ crc_bit[9]  ^ crc_bit[5]  ^ crc_bit[3]  ^ crc_bit[2]  ^ crc_bit[0];\n    new_bit[9]  = crc_bit[29] ^ crc_bit[24] ^ crc_bit[23] ^ crc_bit[18] ^ crc_bit[13] ^ crc_bit[12] ^ crc_bit[11] ^\n                  crc_bit[9]  ^ crc_bit[5]  ^ crc_bit[4]  ^ crc_bit[2]  ^ crc_bit[1];\n    new_bit[8]  = crc_bit[31] ^ crc_bit[28] ^ crc_bit[23] ^ crc_bit[22] ^ crc_bit[17] ^ crc_bit[12] ^ crc_bit[11] ^\n                  crc_bit[10] ^ crc_bit[8]  ^ crc_bit[4]  ^ crc_bit[3]  ^ crc_bit[1]  ^ crc_bit[0];\n    new_bit[7]  = crc_bit[29] ^ crc_bit[28] ^ crc_bit[25] ^ crc_bit[24] ^ crc_bit[23] ^ crc_bit[22] ^ crc_bit[21] ^\n                  crc_bit[16] ^ crc_bit[15] ^ crc_bit[10] ^ crc_bit[8]  ^ crc_bit[7]  ^ crc_bit[5]  ^ crc_bit[3]  ^\n                  crc_bit[2]  ^ crc_bit[0];\n    new_bit[6]  = crc_bit[30] ^ crc_bit[29] ^ crc_bit[25] ^ crc_bit[22] ^ crc_bit[21] ^ crc_bit[20] ^ crc_bit[14] ^\n                  crc_bit[11] ^ crc_bit[8]  ^ crc_bit[7]  ^ crc_bit[6]  ^ crc_bit[5]  ^ crc_bit[4]  ^ crc_bit[2]  ^\n                  crc_bit[1];\n    new_bit[5]  = crc_bit[29] ^ crc_bit[28] ^ crc_bit[24] ^ crc_bit[21] ^ crc_bit[20] ^ crc_bit[19] ^ crc_bit[13] ^\n                  crc_bit[10] ^ crc_bit[7]  ^ crc_bit[6]  ^ crc_bit[5]  ^ crc_bit[4]  ^ crc_bit[3]  ^ crc_bit[1]  ^\n                  crc_bit[0];\n    new_bit[4]  = crc_bit[31] ^ crc_bit[30] ^ crc_bit[29] ^ crc_bit[25] ^ crc_bit[24] ^ crc_bit[20] ^ crc_bit[19] ^\n                  crc_bit[18] ^ crc_bit[15] ^ crc_bit[12] ^ crc_bit[11] ^ crc_bit[8]  ^ crc_bit[6]  ^ crc_bit[4]  ^\n                  crc_bit[3]  ^ crc_bit[2]  ^ crc_bit[0];\n    new_bit[3]  = crc_bit[31] ^ crc_bit[27] ^ crc_bit[25] ^ crc_bit[19] ^ crc_bit[18] ^ crc_bit[17] ^ crc_bit[15] ^\n                  crc_bit[14] ^ crc_bit[10] ^ crc_bit[9]  ^ crc_bit[8]  ^ crc_bit[7]  ^ crc_bit[3]  ^ crc_bit[2]  ^\n                  crc_bit[1];\n    new_bit[2]  = crc_bit[31] ^ crc_bit[30] ^ crc_bit[26] ^ crc_bit[24] ^ crc_bit[18] ^ crc_bit[17] ^ crc_bit[16] ^\n                  crc_bit[14] ^ crc_bit[13] ^ crc_bit[9]  ^ crc_bit[8]  ^ crc_bit[7]  ^ crc_bit[6]  ^ crc_bit[2]  ^\n                  crc_bit[1]  ^ crc_bit[0];\n    new_bit[1]  = crc_bit[28] ^ crc_bit[27] ^ crc_bit[24] ^ crc_bit[17] ^ crc_bit[16] ^ crc_bit[13] ^ crc_bit[12] ^\n                  crc_bit[11] ^ crc_bit[9]  ^ crc_bit[7]  ^ crc_bit[6]  ^ crc_bit[1]  ^ crc_bit[0];\n    new_bit[0]  = crc_bit[31] ^ crc_bit[30] ^ crc_bit[29] ^ crc_bit[28] ^ crc_bit[26] ^ crc_bit[25] ^ crc_bit[24] ^\n                  crc_bit[16] ^ crc_bit[12] ^ crc_bit[10] ^ crc_bit[9]  ^ crc_bit[6]  ^ crc_bit[0];\nend\n\n\nendmodule"}
{"task_id": 1253, "completion": "wire[63:0] fcSrcA;\n    wire[63:0] fcSrcB;\n    wire[63:0] fcSrcC;\n\n    reg[63:0] tIdValA;\n    reg[63:0] tIdValB;\n    reg[63:0] tIdValC;\n\n    wire fcCnvSrc;\n    wire[63:0] fcCnvOA;\n    wire[63:0] fcCnvOB;\n    wire[63:0] fcCnvOC;\n\n    FpuFp32To64 fpCvtRa(clock, fcCnvSrc, tIdValA[31:0], fcCnvOA);\n    FpuFp32To64 fpCvtRb(clock, fcCnvSrc, tIdValB[31:0], fcCnvOB);\n    FpuFp32To64 fpCvtRc(clock, fcCnvSrc, tIdValC[31:0], fcCnvOC);\n\n    wire fcCnvDst;\n    wire[63:0] fcCnvOD;\n    FpuFp64To32 fpCvtRd(clock, fcCnvDst, tDst, fcCnvOD[31:0]);\n    assign fcCnvOD[63:32] = 32'hXXXXXXXX;\n\n    reg fpaIsEn;\n\n    wire fpaIsSub;\n    wire[63:0] fpaSrcA;\n    wire[63:0] fpaSrcB;\n    wire[63:0] fpaDst;\n    FpuFpD_Add fpadd(clock, fpaIsEn, fpaIsSub, fpaSrcA, fpaSrcB, fpaDst);\n\n    assign fpaSrcA = fcSrcA;\n    assign fpaSrcB = fcSrcB;\n\n    wire[63:0] fpmSrcB;\n    wire[63:0] fpmDst;\n    FpuFpD_Mul fpmul(clock, fpaIsEn, fcSrcA, fpmSrcB, fpmDst);\n\n    assign fpaIsSub = ((opMode==UCMD_FPU_SUB) || (opMode==UCMD_FPU_MSC));\n    assign fpmSrcB = fcSrcB;\n\n    reg fpCnvifEn;\n    wire[63:0] fpCnvbDstI;\n    wire[63:0] fpCnvbDstF;\n    FpuFp64ToInt cnv2si1(clock, fpCnvifEn, 1, tIdValB, fpCnvbDstI);\n    FpuFp64FromInt cnv2is1(clock, fpCnvifEn, 1, tIdValB, fpCnvbDstF);\n\n    reg[63:0] tDst;\n    wire[63:0] tDst2;\n    reg[6:0] tIdRegD;\n    reg[1:0] tIdModeD;\n\n    reg[31:0] tSro;\n    reg[31:0] tFpul;\n    reg[31:0] tFpScr;\n\n    wire isOpF32;\n    assign isOpF32 = (idMode==0);\n\n    assign fcCnvSrc = (isOpF32 || (opMode==UCMD_FPU_CNVSD)) && (opMode!=UCMD_FPU_CNVIS);\n    assign fcCnvDst = (isOpF32 || (opMode==UCMD_FPU_CNVDS)) && (opMode!=UCMD_FPU_CNVSI);\n\n    assign fcSrcA = fcCnvSrc ? fcCnvOA : tIdValA;\n    assign fcSrcB = fcCnvSrc ? fcCnvOB : tIdValB;\n    assign fcSrcC = fcCnvSrc ? fcCnvOC : tIdValC;\n    assign tDst2  = fcCnvDst ? fcCnvOD : tDst;\n\n    assign idRegD = tIdRegD;\n    assign idModeD = tIdModeD;\n\n    reg[63:0] tDst_B0;\n    reg[63:0] tDst_B1;\n    reg[63:0] tDst_B2;\n    reg[63:0] tDst_B3;\n\n    reg[63:0] nxtDst_B0;\n    reg[63:0] nxtDst_B1;\n    reg[63:0] nxtDst_B2;\n    reg[63:0] nxtDst_B3;\n\n    reg[31:0] tFpul_B0;\n    reg[31:0] tFpul_B1;\n    reg[31:0] tFpul_B2;\n    reg[31:0] tFpul_B3;\n\n    reg[31:0] nxtFpul_B0;\n    reg[31:0] nxtFpul_B1;\n    reg[31:0] nxtFpul_B2;\n    reg[31:0] nxtFpul_B3;\n\n    reg[31:0] tSro_B0;\n    reg[31:0] tSro_B1;\n    reg[31:0] tSro_B2;\n    reg[31:0] tSro_B3;\n\n    reg[31:0] nxtSro_B0;\n    reg[31:0] nxtSro_B1;\n    reg[31:0] nxtSro_B2;\n    reg[31:0] nxtSro_B3;\n\n    assign idValD = tDst_B3;\n    assign ctlOutFpul = nxtFpul_B3;\n    assign ctlOutSr = nxtSro_B3;\n\n    always @*\n    begin\n        nxtDst_B0 = tDst2;    nxtDst_B1 = tDst_B0;\n        nxtDst_B2 = tDst_B1;    nxtDst_B3 = tDst_B2;\n\n        nxtFpul_B0 = tFpul;    nxtFpul_B1 = tFpul_B0;\n        nxtFpul_B2 = tFpul_B1;    nxtFpul_B3 = tFpul_B2;\n\n        nxtSro_B0 = tSro;    nxtSro_B1 = tSro_B0;\n        nxtSro_B2 = tSro_B1;    nxtSro_B3 = tSro_B2;\n    end\n\n    always @ (posedge clock)\n    begin\n        tIdValA <= idValA;\n        tIdValB <= idValB;\n        tIdValC <= idValC;\n\n        tDst_B0 <= nxtDst_B0;    tDst_B1 <= nxtDst_B1;\n        tDst_B2 <= nxtDst_B2;    tDst_B3 <= nxtDst_B3;\n\n        tFpul_B0 <= nxtFpul_B0;    tFpul_B1 <= nxtFpul_B1;\n        tFpul_B2 <= nxtFpul_B2;    tFpul_B3 <= nxtFpul_B3;\n\n        tSro_B0 <= nxtSro_B0;    tSro_B1 <= nxtSro_B1;\n        tSro_B2 <= nxtSro_B2;    tSro_B3 <= nxtSro_B3;\n    end\n\nendmodule"}
{"task_id": 1346, "completion": "localparam  IDLE      = 4'h0;\n    localparam  READ_WAIT = 4'h1;\n    localparam  FINISHED  = 4'h2;\n\n    reg           [3:0]   state;\n    assign  o_cmd_mode    = i_cmd_parameter;\n\n    always @ (posedge clk) begin\n      if (rst) begin\n        state                   <=  IDLE;\n        o_data_out_en           <=  0;\n        o_data_out              <=  0;\n        o_cmd_finished          <=  0;\n        o_cmd_data              <=  0;\n\n        o_write                 <=  0;\n        o_read                  <=  0;\n      end\n      else begin\n        o_cmd_finished          <=  0;\n        case (state)\n          IDLE: begin\n            o_write             <=  0;\n            o_read              <=  0;\n            o_data_out_en       <=  0;\n            if (i_cmd_write_stb) begin\n              o_data_out_en     <=  1;\n              o_data_out        <=  i_cmd_data;\n              o_write           <=  1;\n              state             <=  FINISHED;\n            end\n            else if (i_cmd_read_stb) begin\n              o_data_out_en     <=  0;\n              o_read            <=  1;\n              state             <=  READ_WAIT;\n            end\n          end\n          READ_WAIT: begin\n            state               <=  FINISHED;\n          end\n          FINISHED: begin\n            o_write             <=  0;\n            o_read              <=  0;\n            if (!o_data_out_en) begin\n              o_cmd_data        <=  i_data_in;\n            end\n            o_cmd_finished      <=  1;\n            state               <=  IDLE;\n          end\n        endcase\n      end\n    end\n\nendmodule"}
{"task_id": 460, "completion": "wire  [63:0] sdram_read_avalon_master_readdata;\n  wire         sdram_read_avalon_master_waitrequest;\n  wire  [31:0] sdram_read_avalon_master_address;\n  wire         sdram_read_avalon_master_read;\n  wire   [7:0] sdram_read_avalon_master_byteenable;\n  wire         sdram_read_avalon_master_readdatavalid;\n  wire         sdram_write_avalon_master_waitrequest;\n  wire  [31:0] sdram_write_avalon_master_address;\n  wire   [7:0] sdram_write_avalon_master_byteenable;\n  wire         sdram_write_avalon_master_write;\n  wire  [63:0] sdram_write_avalon_master_writedata;\n  wire         mm_interconnect_0_sdram_s1_chipselect;\n  wire  [15:0] mm_interconnect_0_sdram_s1_readdata;\n  wire         mm_interconnect_0_sdram_s1_waitrequest;\n  wire  [23:0] mm_interconnect_0_sdram_s1_address;\n  wire         mm_interconnect_0_sdram_s1_read;\n  wire   [1:0] mm_interconnect_0_sdram_s1_byteenable;\n  wire         mm_interconnect_0_sdram_s1_readdatavalid;\n  wire         mm_interconnect_0_sdram_s1_write;\n  wire  [15:0] mm_interconnect_0_sdram_s1_writedata;\n  wire         rst_controller_reset_out_reset;\n\n  qsys_sdram sdram (\n    .clk            (clk_clk),\n    .reset_n        (~rst_controller_reset_out_reset),\n    .az_addr        (mm_interconnect_0_sdram_s1_address),\n    .az_be_n        (~mm_interconnect_0_sdram_s1_byteenable),\n    .az_cs          (mm_interconnect_0_sdram_s1_chipselect),\n    .az_data        (mm_interconnect_0_sdram_s1_writedata),\n    .az_rd_n        (~mm_interconnect_0_sdram_s1_read),\n    .az_wr_n        (~mm_interconnect_0_sdram_s1_write),\n    .za_data        (mm_interconnect_0_sdram_s1_readdata),\n    .za_valid       (mm_interconnect_0_sdram_s1_readdatavalid),\n    .za_waitrequest (mm_interconnect_0_sdram_s1_waitrequest),\n    .zs_addr        (sdram_wire_addr),\n    .zs_ba          (sdram_wire_ba),\n    .zs_cas_n       (sdram_wire_cas_n),\n    .zs_cke         (sdram_wire_cke),\n    .zs_cs_n        (sdram_wire_cs_n),\n    .zs_dq          (sdram_wire_dq),\n    .zs_dqm         (sdram_wire_dqm),\n    .zs_ras_n       (sdram_wire_ras_n),\n    .zs_we_n        (sdram_wire_we_n)\n  );\n\n  qsys_sdram_clock sdram_clock (\n    .clk       (clk_clk),\n    .reset     (rst_controller_reset_out_reset),\n    .read      (),\n    .write     (),\n    .address   (),\n    .readdata  (),\n    .writedata (),\n    .c0        (sdram_clock_c0_clk),\n    .areset    (sdram_clock_areset_conduit_export),\n    .locked    (),\n    .phasedone ()\n  );\n\n  custom_master #(\n    .MASTER_DIRECTION    (0),\n    .DATA_WIDTH          (64),\n    .ADDRESS_WIDTH       (32),\n    .BURST_CAPABLE       (0),\n    .MAXIMUM_BURST_COUNT (2),\n    .BURST_COUNT_WIDTH   (2),\n    .FIFO_DEPTH          (8),\n    .FIFO_DEPTH_LOG2     (3),\n    .MEMORY_BASED_FIFO   (0)\n  ) sdram_read (\n    .clk                     (clk_clk),\n    .reset                   (rst_controller_reset_out_reset),\n    .master_address          (sdram_read_avalon_master_address),\n    .master_read             (sdram_read_avalon_master_read),\n    .master_byteenable       (sdram_read_avalon_master_byteenable),\n    .master_readdata         (sdram_read_avalon_master_readdata),\n    .master_readdatavalid    (sdram_read_avalon_master_readdatavalid),\n    .master_waitrequest      (sdram_read_avalon_master_waitrequest),\n    .control_fixed_location  (sdram_read_control_fixed_location),\n    .control_read_base       (sdram_read_control_read_base),\n    .control_read_length     (sdram_read_control_read_length),\n    .control_go              (sdram_read_control_go),\n    .control_done            (sdram_read_control_done),\n    .control_early_done      (sdram_read_control_early_done),\n    .user_read_buffer        (sdram_read_user_read_buffer),\n    .user_buffer_output_data (sdram_read_user_buffer_output_data),\n    .user_data_available     (sdram_read_user_data_available),\n    .master_write            (),\n    .master_writedata        (),\n    .master_burstcount       (),\n    .control_write_base      (32'b00000000000000000000000000000000),\n    .control_write_length    (32'b00000000000000000000000000000000),\n    .user_write_buffer       (1'b0),\n    .user_buffer_input_data  (64'b0000000000000000000000000000000000000000000000000000000000000000),\n    .user_buffer_full        ()\n  );\n\n  custom_master #(\n    .MASTER_DIRECTION    (1),\n    .DATA_WIDTH          (64),\n    .ADDRESS_WIDTH       (32),\n    .BURST_CAPABLE       (0),\n    .MAXIMUM_BURST_COUNT (2),\n    .BURST_COUNT_WIDTH   (2),\n    .FIFO_DEPTH          (8),\n    .FIFO_DEPTH_LOG2     (3),\n    .MEMORY_BASED_FIFO   (0)\n  ) sdram_write (\n    .clk                     (clk_clk),\n    .reset                   (rst_controller_reset_out_reset),\n    .master_address          (sdram_write_avalon_master_address),\n    .master_write            (sdram_write_avalon_master_write),\n    .master_byteenable       (sdram_write_avalon_master_byteenable),\n    .master_writedata        (sdram_write_avalon_master_writedata),\n    .master_waitrequest      (sdram_write_avalon_master_waitrequest),\n    .control_fixed_location  (sdram_write_control_fixed_location),\n    .control_write_base      (sdram_write_control_write_base),\n    .control_write_length    (sdram_write_control_write_length),\n    .control_go              (sdram_write_control_go),\n    .control_done            (sdram_write_control_done),\n    .user_write_buffer       (sdram_write_user_write_buffer),\n    .user_buffer_input_data  (sdram_write_user_buffer_input_data),\n    .user_buffer_full        (sdram_write_user_buffer_full),\n    .master_read             (),\n    .master_readdata         (64'b0000000000000000000000000000000000000000000000000000000000000000),\n    .master_readdatavalid    (1'b0),\n    .master_burstcount       (),\n    .control_read_base       (32'b00000000000000000000000000000000),\n    .control_read_length     (32'b00000000000000000000000000000000),\n    .control_early_done      (),\n    .user_read_buffer        (1'b0),\n    .user_buffer_output_data (),\n    .user_data_available     ()\n  );\n\n  qsys_mm_interconnect_0 mm_interconnect_0 (\n    .clk_clk_clk                                              (clk_clk),\n    .sdram_read_clock_reset_reset_bridge_in_reset_reset (rst_controller_reset_out_reset),\n    .sdram_read_avalon_master_address                         (sdram_read_avalon_master_address),\n    .sdram_read_avalon_master_waitrequest                     (sdram_read_avalon_master_waitrequest),\n    .sdram_read_avalon_master_byteenable                      (sdram_read_avalon_master_byteenable),\n    .sdram_read_avalon_master_read                            (sdram_read_avalon_master_read),\n    .sdram_read_avalon_master_readdata                        (sdram_read_avalon_master_readdata),\n    .sdram_read_avalon_master_readdatavalid                   (sdram_read_avalon_master_readdatavalid),\n    .sdram_write_avalon_master_address                        (sdram_write_avalon_master_address),\n    .sdram_write_avalon_master_waitrequest                    (sdram_write_avalon_master_waitrequest),\n    .sdram_write_avalon_master_byteenable                     (sdram_write_avalon_master_byteenable),\n    .sdram_write_avalon_master_write                          (sdram_write_avalon_master_write),\n    .sdram_write_avalon_master_writedata                      (sdram_write_avalon_master_writedata),\n    .sdram_s1_address                                         (mm_interconnect_0_sdram_s1_address),\n    .sdram_s1_write                                           (mm_interconnect_0_sdram_s1_write),\n    .sdram_s1_read                                            (mm_interconnect_0_sdram_s1_read),\n    .sdram_s1_readdata                                        (mm_interconnect_0_sdram_s1_readdata),\n    .sdram_s1_writedata                                       (mm_interconnect_0_sdram_s1_writedata),\n    .sdram_s1_byteenable                                      (mm_interconnect_0_sdram_s1_byteenable),\n    .sdram_s1_readdatavalid                                   (mm_interconnect_0_sdram_s1_readdatavalid),\n    .sdram_s1_waitrequest                                     (mm_interconnect_0_sdram_s1_waitrequest),\n    .sdram_s1_chipselect                                      (mm_interconnect_0_sdram_s1_chipselect)\n  );\n\n  altera_reset_controller #(\n    .NUM_RESET_INPUTS          (1),\n    .OUTPUT_RESET_SYNC_EDGES   (\"deassert\"),\n    .SYNC_DEPTH                (2),\n    .RESET_REQUEST_PRESENT     (0),\n    .RESET_REQ_WAIT_TIME       (1),\n    .MIN_RST_ASSERTION_TIME    (3),\n    .RESET_REQ_EARLY_DSRT_TIME (1),\n    .USE_RESET_REQUEST_IN0     (0),\n    .USE_RESET_REQUEST_IN1     (0),\n    .USE_RESET_REQUEST_IN2     (0),\n    .USE_RESET_REQUEST_IN3     (0),\n    .USE_RESET_REQUEST_IN4     (0),\n    .USE_RESET_REQUEST_IN5     (0),\n    .USE_RESET_REQUEST_IN6     (0),\n    .USE_RESET_REQUEST_IN7     (0),\n    .USE_RESET_REQUEST_IN8     (0),\n    .USE_RESET_REQUEST_IN9     (0),\n    .USE_RESET_REQUEST_IN10    (0),\n    .USE_RESET_REQUEST_IN11    (0),\n    .USE_RESET_REQUEST_IN12    (0),\n    .USE_RESET_REQUEST_IN13    (0),\n    .USE_RESET_REQUEST_IN14    (0),\n    .USE_RESET_REQUEST_IN15    (0),\n    .ADAPT_RESET_REQUEST       (0)\n  ) rst_controller (\n    .reset_in0      (~reset_reset_n),\n    .clk            (clk_clk),\n    .reset_out      (rst_controller_reset_out_reset),\n    .reset_req      (),\n    .reset_req_in0  (1'b0),\n    .reset_in1      (1'b0),\n    .reset_req_in1  (1'b0),\n    .reset_in2      (1'b0),\n    .reset_req_in2  (1'b0),\n    .reset_in3      (1'b0),\n    .reset_req_in3  (1'b0),\n    .reset_in4      (1'b0),\n    .reset_req_in4  (1'b0),\n    .reset_in5      (1'b0),\n    .reset_req_in5  (1'b0),\n    .reset_in6      (1'b0),\n    .reset_req_in6  (1'b0),\n    .reset_in7      (1'b0),\n    .reset_req_in7  (1'b0),\n    .reset_in8      (1'b0),\n    .reset_req_in8  (1'b0),\n    .reset_in9      (1'b0),\n    .reset_req_in9  (1'b0),\n    .reset_in10     (1'b0),\n    .reset_req_in10 (1'b0),\n    .reset_in11     (1'b0),\n    .reset_req_in11 (1'b0),\n    .reset_in12     (1'b0),\n    .reset_req_in12 (1'b0),\n    .reset_in13     (1'b0),\n    .reset_req_in13 (1'b0),\n    .reset_in14     (1'b0),\n    .reset_req_in14 (1'b0),\n    .reset_in15     (1'b0),\n    .reset_req_in15 (1'b0)\n  );\n\nendmodule"}
{"task_id": 192, "completion": "`ifdef E203_XLEN_IS_32\n  `else\n      !!! ERROR: There must be something wrong, our core must be 32bits wide !!!\n  `endif\n  wire [`E203_XLEN-1:0] mux_op1;\n  wire [`E203_XLEN-1:0] mux_op2;\n  wire [`E203_XLEN-1:0] misc_op1 = mux_op1[`E203_XLEN-1:0];\n  wire [`E203_XLEN-1:0] misc_op2 = mux_op2[`E203_XLEN-1:0];\n  wire [`E203_XLEN-1:0] shifter_op1 = alu_req_alu_op1[`E203_XLEN-1:0];\n  wire [`E203_XLEN-1:0] shifter_op2 = alu_req_alu_op2[`E203_XLEN-1:0];\n  wire op_max;\n  wire op_min ; \n  wire op_maxu;\n  wire op_minu;\n  wire op_add;\n  wire op_sub;\n  wire op_addsub = op_add | op_sub; \n  wire op_or;\n  wire op_xor;\n  wire op_and;\n  wire op_sll;\n  wire op_srl;\n  wire op_sra;\n  wire op_slt;\n  wire op_sltu;\n  wire op_mvop2;\n  wire op_cmp_eq ;\n  wire op_cmp_ne ;\n  wire op_cmp_lt ;\n  wire op_cmp_gt ;\n  wire op_cmp_ltu;\n  wire op_cmp_gtu;\n  wire cmp_res;\n  wire sbf_0_ena;\n  wire [33-1:0] sbf_0_nxt;\n  wire [33-1:0] sbf_0_r;\n  wire sbf_1_ena;\n  wire [33-1:0] sbf_1_nxt;\n  wire [33-1:0] sbf_1_r;\n  `ifdef E203_SUPPORT_SHARE_MULDIV //{\n  wire muldiv_req_alu;\n  wire [`E203_ALU_ADDER_WIDTH-1:0] muldiv_req_alu_op1;\n  wire [`E203_ALU_ADDER_WIDTH-1:0] muldiv_req_alu_op2;\n  wire muldiv_req_alu_add;\n  wire muldiv_req_alu_sub;\n  wire [`E203_ALU_ADDER_WIDTH-1:0] muldiv_req_alu_res;\n  wire muldiv_sbf_0_ena;\n  wire [33-1:0] muldiv_sbf_0_nxt;\n  wire [33-1:0] muldiv_sbf_0_r;\n  wire muldiv_sbf_1_ena;\n  wire [33-1:0] muldiv_sbf_1_nxt;\n  wire [33-1:0] muldiv_sbf_1_r;\n  `endif//E203_SUPPORT_SHARE_MULDIV\n  wire [`E203_XLEN-1:0] shifter_in1;\n  wire [5-1:0] shifter_in2;\n  wire [`E203_XLEN-1:0] shifter_res;\n  wire op_shift = op_sra | op_sll | op_srl; \n  assign shifter_in1 = {`E203_XLEN{op_shift}} & (\n               (op_sra | op_srl) ? \n                 {\n    shifter_op1[00],shifter_op1[01],shifter_op1[02],shifter_op1[03],\n    shifter_op1[04],shifter_op1[05],shifter_op1[06],shifter_op1[07],\n    shifter_op1[08],shifter_op1[09],shifter_op1[10],shifter_op1[11],\n    shifter_op1[12],shifter_op1[13],shifter_op1[14],shifter_op1[15],\n    shifter_op1[16],shifter_op1[17],shifter_op1[18],shifter_op1[19],\n    shifter_op1[20],shifter_op1[21],shifter_op1[22],shifter_op1[23],\n    shifter_op1[24],shifter_op1[25],shifter_op1[26],shifter_op1[27],\n    shifter_op1[28],shifter_op1[29],shifter_op1[30],shifter_op1[31]\n                 } : shifter_op1\n           );\n  assign shifter_in2 = {5{op_shift}} & shifter_op2[4:0];\n  assign shifter_res = (shifter_in1 << shifter_in2);\n  wire [`E203_XLEN-1:0] sll_res = shifter_res;\n  wire [`E203_XLEN-1:0] srl_res =  \n                 {\n    shifter_res[00],shifter_res[01],shifter_res[02],shifter_res[03],\n    shifter_res[04],shifter_res[05],shifter_res[06],shifter_res[07],\n    shifter_res[08],shifter_res[09],shifter_res[10],shifter_res[11],\n    shifter_res[12],shifter_res[13],shifter_res[14],shifter_res[15],\n    shifter_res[16],shifter_res[17],shifter_res[18],shifter_res[19],\n    shifter_res[20],shifter_res[21],shifter_res[22],shifter_res[23],\n    shifter_res[24],shifter_res[25],shifter_res[26],shifter_res[27],\n    shifter_res[28],shifter_res[29],shifter_res[30],shifter_res[31]\n                 };\n  wire [`E203_XLEN-1:0] eff_mask = (~(`E203_XLEN'b0)) >> shifter_in2;\n  wire [`E203_XLEN-1:0] sra_res =\n               (srl_res & eff_mask) | ({32{shifter_op1[31]}} & (~eff_mask));\n  wire [`E203_XLEN-1:0] misc_adder_op1 =\n      {{`E203_ALU_ADDER_WIDTH-`E203_XLEN{(~op_unsigned) & misc_op1[`E203_XLEN-1]}},misc_op1};\n  wire [`E203_ALU_ADDER_WIDTH-1:0] misc_adder_op2 =\n      {{`E203_ALU_ADDER_WIDTH-`E203_XLEN{(~op_unsigned) & misc_op2[`E203_XLEN-1]}},misc_op2};\n  wire [`E203_ALU_ADDER_WIDTH-1:0] adder_op1 = \n`ifdef E203_SUPPORT_SHARE_MULDIV //{\n      muldiv_req_alu ? muldiv_req_alu_op1 :\n`endif//E203_SUPPORT_SHARE_MULDIV\n      misc_adder_op1;\n  wire [`E203_ALU_ADDER_WIDTH-1:0] adder_op2 = \n`ifdef E203_SUPPORT_SHARE_MULDIV //{\n      muldiv_req_alu ? muldiv_req_alu_op2 :\n`endif//E203_SUPPORT_SHARE_MULDIV\n      misc_adder_op2;\n  wire adder_cin;\n  wire [`E203_ALU_ADDER_WIDTH-1:0] adder_in1;\n  wire [`E203_ALU_ADDER_WIDTH-1:0] adder_in2;\n  wire [`E203_ALU_ADDER_WIDTH-1:0] adder_res;\n  wire adder_add;\n  wire adder_sub;\n  assign adder_add =\n`ifdef E203_SUPPORT_SHARE_MULDIV //{\n      muldiv_req_alu ? muldiv_req_alu_add :\n`endif//E203_SUPPORT_SHARE_MULDIV\n      op_add; \n  assign adder_sub =\n`ifdef E203_SUPPORT_SHARE_MULDIV //{\n      muldiv_req_alu ? muldiv_req_alu_sub :\n`endif//E203_SUPPORT_SHARE_MULDIV\n               (op_sub | (op_cmp_lt | op_cmp_gt | \n                op_cmp_ltu | op_cmp_gtu | op_max | op_maxu |\n                op_min | op_minu | op_slt | op_sltu ));\n  wire adder_addsub = adder_add | adder_sub; \n  assign adder_in1 = {`E203_ALU_ADDER_WIDTH{adder_addsub}} & (adder_op1);\n  assign adder_in2 = {`E203_ALU_ADDER_WIDTH{adder_addsub}} & (adder_sub ? (~adder_op2) : adder_op2);\n  assign adder_cin = adder_addsub & adder_sub;\n  assign adder_res = adder_in1 + adder_in2 + adder_cin;\n  wire [`E203_XLEN-1:0] xorer_in1;\n  wire [`E203_XLEN-1:0] xorer_in2;\n  wire xorer_op = \n               op_xor | (op_cmp_eq | op_cmp_ne); \n  assign xorer_in1 = {`E203_XLEN{xorer_op}} & misc_op1;\n  assign xorer_in2 = {`E203_XLEN{xorer_op}} & misc_op2;\n  wire [`E203_XLEN-1:0] xorer_res = xorer_in1 ^ xorer_in2;\n  wire [`E203_XLEN-1:0] orer_res  = misc_op1 | misc_op2; \n  wire [`E203_XLEN-1:0] ander_res = misc_op1 & misc_op2; \n  wire neq  = (|xorer_res); \n  wire cmp_res_ne  = (op_cmp_ne  & neq);\n  wire cmp_res_eq  = op_cmp_eq  & (~neq);\n  wire cmp_res_lt  = op_cmp_lt  & adder_res[`E203_XLEN];\n  wire cmp_res_ltu = op_cmp_ltu & adder_res[`E203_XLEN];\n  wire op1_gt_op2  = (~adder_res[`E203_XLEN]);\n  wire cmp_res_gt  = op_cmp_gt  & op1_gt_op2;\n  wire cmp_res_gtu = op_cmp_gtu & op1_gt_op2;\n  assign cmp_res = cmp_res_eq | cmp_res_ne | cmp_res_lt | cmp_res_gt | cmp_res_ltu | cmp_res_gtu; \n  wire [`E203_XLEN-1:0] mvop2_res = misc_op2;\n  wire op_slttu = (op_slt | op_sltu);\n  wire slttu_cmp_lt = op_slttu & adder_res[`E203_XLEN];\n  wire [`E203_XLEN-1:0] slttu_res = slttu_cmp_lt ? `E203_XLEN'b1 : `E203_XLEN'b0;\n  wire maxmin_sel_op1 =  ((op_max | op_maxu) &   op1_gt_op2) |  ((op_min | op_minu) & (~op1_gt_op2));\n  wire [`E203_XLEN-1:0] maxmin_res  = maxmin_sel_op1 ? misc_op1 : misc_op2;  \n  wire [`E203_XLEN-1:0] alu_dpath_res = \n        ({`E203_XLEN{op_or       }} & orer_res )\n      | ({`E203_XLEN{op_and      }} & ander_res)\n      | ({`E203_XLEN{op_xor      }} & xorer_res)\n      | ({`E203_XLEN{op_addsub   }} & adder_res[`E203_XLEN-1:0])\n      | ({`E203_XLEN{op_srl      }} & srl_res)\n      | ({`E203_XLEN{op_sll      }} & sll_res)\n      | ({`E203_XLEN{op_sra      }} & sra_res)\n      | ({`E203_XLEN{op_mvop2    }} & mvop2_res)\n      | ({`E203_XLEN{op_slttu    }} & slttu_res)\n      | ({`E203_XLEN{op_max | op_maxu | op_min | op_minu}} & maxmin_res);\n  sirv_gnrl_dffl #(33) sbf_0_dffl (sbf_0_ena, sbf_0_nxt, sbf_0_r, clk);\n  sirv_gnrl_dffl #(33) sbf_1_dffl (sbf_1_ena, sbf_1_nxt, sbf_1_r, clk);\n  localparam DPATH_MUX_WIDTH = ((`E203_XLEN*2)+21);\n  assign  {\n     mux_op1\n    ,mux_op2\n    ,op_max  \n    ,op_min  \n    ,op_maxu \n    ,op_minu \n    ,op_add\n    ,op_sub\n    ,op_or\n    ,op_xor\n    ,op_and\n    ,op_sll\n    ,op_srl\n    ,op_sra\n    ,op_slt\n    ,op_sltu\n    ,op_mvop2\n    ,op_cmp_eq \n    ,op_cmp_ne \n    ,op_cmp_lt \n    ,op_cmp_gt \n    ,op_cmp_ltu\n    ,op_cmp_gtu\n    } = \n        ({DPATH_MUX_WIDTH{alu_req_alu}} & {\n             alu_req_alu_op1\n            ,alu_req_alu_op2\n            ,1'b0\n            ,1'b0\n            ,1'b0\n            ,1'b0\n            ,alu_req_alu_add\n            ,alu_req_alu_sub\n            ,alu_req_alu_or\n            ,alu_req_alu_xor\n            ,alu_req_alu_and\n            ,alu_req_alu_sll\n            ,alu_req_alu_srl\n            ,alu_req_alu_sra\n            ,alu_req_alu_slt\n            ,alu_req_alu_sltu\n            ,alu_req_alu_lui\n            ,1'b0\n            ,1'b0\n            ,1'b0\n            ,1'b0\n            ,1'b0\n            ,1'b0\n        })\n      | ({DPATH_MUX_WIDTH{bjp_req_alu}} & {\n             bjp_req_alu_op1\n            ,bjp_req_alu_op2\n            ,1'b0\n            ,1'b0\n            ,1'b0\n            ,1'b0\n            ,bjp_req_alu_add\n            ,1'b0\n            ,1'b0\n            ,1'b0\n            ,1'b0\n            ,1'b0\n            ,1'b0\n            ,1'b0\n            ,1'b0\n            ,1'b0\n            ,1'b0\n            ,bjp_req_alu_cmp_eq \n            ,bjp_req_alu_cmp_ne \n            ,bjp_req_alu_cmp_lt \n            ,bjp_req_alu_cmp_gt \n            ,bjp_req_alu_cmp_ltu\n            ,bjp_req_alu_cmp_gtu\n        })\n      | ({DPATH_MUX_WIDTH{agu_req_alu}} & {\n             agu_req_alu_op1\n            ,agu_req_alu_op2\n            ,agu_req_alu_max  \n            ,agu_req_alu_min  \n            ,agu_req_alu_maxu \n            ,agu_req_alu_minu \n            ,agu_req_alu_add\n            ,1'b0\n            ,agu_req_alu_or\n            ,agu_req_alu_xor\n            ,agu_req_alu_and\n            ,1'b0\n            ,1'b0\n            ,1'b0\n            ,1'b0\n            ,1'b0\n            ,agu_req_alu_swap\n            ,1'b0\n            ,1'b0\n            ,1'b0\n            ,1'b0\n            ,1'b0\n            ,1'b0\n        });\n  assign alu_req_alu_res     = alu_dpath_res[`E203_XLEN-1:0];\n  assign agu_req_alu_res     = alu_dpath_res[`E203_XLEN-1:0];\n  assign bjp_req_alu_add_res = alu_dpath_res[`E203_XLEN-1:0];\n  assign bjp_req_alu_cmp_res = cmp_res;\n`ifdef E203_SUPPORT_SHARE_MULDIV //{\n  assign muldiv_req_alu_res  = adder_res;\n`endif//E203_SUPPORT_SHARE_MULDIV\n  assign sbf_0_ena = \n`ifdef E203_SUPPORT_SHARE_MULDIV //{\n      muldiv_req_alu ? muldiv_sbf_0_ena : \n`endif//E203_SUPPORT_SHARE_MULDIV\n                 agu_sbf_0_ena;\n  assign sbf_1_ena = \n`ifdef E203_SUPPORT_SHARE_MULDIV //{\n      muldiv_req_alu ? muldiv_sbf_1_ena : \n`endif//E203_SUPPORT_SHARE_MULDIV\n                 agu_sbf_1_ena;\n  assign sbf_0_nxt = \n`ifdef E203_SUPPORT_SHARE_MULDIV //{\n      muldiv_req_alu ? muldiv_sbf_0_nxt : \n`endif//E203_SUPPORT_SHARE_MULDIV\n                 {1'b0,agu_sbf_0_nxt};\n  assign sbf_1_nxt = \n`ifdef E203_SUPPORT_SHARE_MULDIV //{\n      muldiv_req_alu ? muldiv_sbf_1_nxt : \n`endif//E203_SUPPORT_SHARE_MULDIV\n                 {1'b0,agu_sbf_1_nxt};\n  assign agu_sbf_0_r = sbf_0_r[`E203_XLEN-1:0];\n  assign agu_sbf_1_r = sbf_1_r[`E203_XLEN-1:0];\n`ifdef E203_SUPPORT_SHARE_MULDIV //{\n  assign muldiv_sbf_0_r = sbf_0_r;\n  assign muldiv_sbf_1_r = sbf_1_r;\n`endif//E203_SUPPORT_SHARE_MULDIV\nendmodule"}
{"task_id": 415, "completion": "input               clk;\n    input               rst;\n    output              ic_en;\n    output  [31:0]      icpu_adr_o;\n    output              icpu_cycstb_o;\n    output  [3:0]       icpu_sel_o;\n    output  [3:0]       icpu_tag_o;\n    input   [31:0]      icpu_dat_i;\n    input               icpu_ack_i;\n    input               icpu_rty_i;\n    input               icpu_err_i;\n    input   [31:0]      icpu_adr_i;\n    input   [3:0]       icpu_tag_i;\n    output              immu_en;\n    output  [31:0]      ex_insn;\n    output              ex_freeze;\n    output  [31:0]      id_pc;\n    output  [`OR1200_BRANCHOP_WIDTH-1:0]    branch_op;\n    input   [dw-1:0]    du_addr;\n    input   [dw-1:0]    du_dat_du;\n    input               du_read;\n    input               du_write;\n    input   [`OR1200_DU_DSR_WIDTH-1:0]    du_dsr;\n    input               du_hwbkpt;\n    output  [12:0]      du_except;\n    output  [dw-1:0]    du_dat_cpu;\n    output  [dw-1:0]    rf_dataw;\n    output  [31:0]      dcpu_adr_o;\n    output              dcpu_cycstb_o;\n    output              dcpu_we_o;\n    output  [3:0]       dcpu_sel_o;\n    output  [3:0]       dcpu_tag_o;\n    output  [31:0]      dcpu_dat_o;\n    input   [31:0]      dcpu_dat_i;\n    input               dcpu_ack_i;\n    input               dcpu_rty_i;\n    input               dcpu_err_i;\n    input   [3:0]       dcpu_tag_i;\n    output              dc_en;\n    output              dmmu_en;\n    output              supv;\n    input   [dw-1:0]    spr_dat_pic;\n    input   [dw-1:0]    spr_dat_tt;\n    input   [dw-1:0]    spr_dat_pm;\n    input   [dw-1:0]    spr_dat_dmmu;\n    input   [dw-1:0]    spr_dat_immu;\n    input   [dw-1:0]    spr_dat_du;\n    output  [dw-1:0]    spr_addr;\n    output  [dw-1:0]    spr_dat_cpu;\n    output  [dw-1:0]    spr_dat_npc;\n    output  [31:0]      spr_cs;\n    output              spr_we;\n    input               sig_int;\n    input               sig_tick;\n\n    wire    [31:0]      if_insn;\n    wire    [31:0]      if_pc;\n    wire    [31:2]      lr_sav;\n    wire    [aw-1:0]    rf_addrw;\n    wire    [aw-1:0]    rf_addra;\n    wire    [aw-1:0]    rf_addrb;\n    wire                rf_rda;\n    wire                rf_rdb;\n    wire    [dw-1:0]    simm;\n    wire    [dw-1:2]    branch_addrofs;\n    wire    [`OR1200_ALUOP_WIDTH-1:0]     alu_op;\n    wire    [`OR1200_SHROTOP_WIDTH-1:0]   shrot_op;\n    wire    [`OR1200_COMPOP_WIDTH-1:0]    comp_op;\n    wire    [`OR1200_BRANCHOP_WIDTH-1:0]  branch_op;\n    wire    [`OR1200_LSUOP_WIDTH-1:0]     lsu_op;\n    wire                genpc_freeze;\n    wire                if_freeze;\n    wire                id_freeze;\n    wire                ex_freeze;\n    wire                wb_freeze;\n    wire    [`OR1200_SEL_WIDTH-1:0]    sel_a;\n    wire    [`OR1200_SEL_WIDTH-1:0]    sel_b;\n    wire    [`OR1200_RFWBOP_WIDTH-1:0]  rfwb_op;\n    wire    [dw-1:0]    rf_dataw;\n    wire    [dw-1:0]    rf_dataa;\n    wire    [dw-1:0]    rf_datab;\n    wire    [dw-1:0]    muxed_b;\n    wire    [dw-1:0]    wb_forw;\n    wire                wbforw_valid;\n    wire    [dw-1:0]    operand_a;\n    wire    [dw-1:0]    operand_b;\n    wire    [dw-1:0]    alu_dataout;\n    wire    [dw-1:0]    lsu_dataout;\n    wire    [dw-1:0]    sprs_dataout;\n    wire    [31:0]      lsu_addrofs;\n    wire    [`OR1200_MULTICYCLE_WIDTH-1:0] multicycle;\n    wire    [`OR1200_EXCEPT_WIDTH-1:0]    except_type;\n    wire    [4:0]       cust5_op;\n    wire    [5:0]       cust5_limm;\n    wire                flushpipe;\n    wire                extend_flush;\n    wire                branch_taken;\n    wire                flag;\n    wire                flagforw;\n    wire                flag_we;\n    wire                carry;\n    wire                cyforw;\n    wire                cy_we;\n    wire                lsu_stall;\n    wire                epcr_we;\n    wire                eear_we;\n    wire                esr_we;\n    wire                pc_we;\n    wire    [31:0]      epcr;\n    wire    [31:0]      eear;\n    wire    [`OR1200_SR_WIDTH-1:0]    esr;\n    wire                sr_we;\n    wire    [`OR1200_SR_WIDTH-1:0]    to_sr;\n    wire    [`OR1200_SR_WIDTH-1:0]    sr;\n    wire                except_start;\n    wire                except_started;\n    wire    [31:0]      wb_insn;\n    wire    [15:0]      spr_addrimm;\n    wire                sig_syscall;\n    wire                sig_trap;\n    wire    [31:0]      spr_dat_cfgr;\n    wire    [31:0]      spr_dat_rf;\n    wire    [31:0]      spr_dat_npc;\n    wire    [31:0]      spr_dat_ppc;\n    wire    [31:0]      spr_dat_mac;\n    wire                force_dslot_fetch;\n    wire                no_more_dslot;\n    wire                ex_void;\n    wire                if_stall;\n    wire                id_macrc_op;\n    wire                ex_macrc_op;\n    wire    [`OR1200_MACOP_WIDTH-1:0] mac_op;\n    wire    [31:0]      mult_mac_result;\n    wire                mac_stall;\n    wire    [12:0]      except_stop;\n    wire                genpc_refetch;\n    wire                rfe;\n    wire                lsu_unstall;\n    wire                except_align;\n    wire                except_dtlbmiss;\n    wire                except_dmmufault;\n    wire                except_illegal;\n    wire                except_itlbmiss;\n    wire                except_immufault;\n    wire                except_ibuserr;\n    wire                except_dbuserr;\n    wire                abort_ex;\n    assign du_except = except_stop;\n    assign dc_en = sr[`OR1200_SR_DCE];\n    assign ic_en = sr[`OR1200_SR_ICE];\n    assign dmmu_en = sr[`OR1200_SR_DME];\n    assign immu_en = sr[`OR1200_SR_IME];\n    assign supv = sr[`OR1200_SR_SM];\n    or1200_genpc or1200_genpc(\n        .clk(clk),\n        .rst(rst),\n        .icpu_adr_o(icpu_adr_o),\n        .icpu_cycstb_o(icpu_cycstb_o),\n        .icpu_sel_o(icpu_sel_o),\n        .icpu_tag_o(icpu_tag_o),\n        .icpu_rty_i(icpu_rty_i),\n        .icpu_adr_i(icpu_adr_i),\n        .branch_op(branch_op),\n        .except_type(except_type),\n        .except_start(except_start),\n        .except_prefix(sr[`OR1200_SR_EPH]),\n        .branch_addrofs(branch_addrofs),\n        .lr_restor(operand_b),\n        .flag(flag),\n        .taken(branch_taken),\n        .binsn_addr(lr_sav),\n        .epcr(epcr),\n        .spr_dat_i(spr_dat_cpu),\n        .spr_pc_we(pc_we),\n        .genpc_refetch(genpc_refetch),\n        .genpc_freeze(genpc_freeze),\n        .no_more_dslot(no_more_dslot)\n    );\n    or1200_if or1200_if(\n        .clk(clk),\n        .rst(rst),\n        .icpu_dat_i(icpu_dat_i),\n        .icpu_ack_i(icpu_ack_i),\n        .icpu_err_i(icpu_err_i),\n        .icpu_adr_i(icpu_adr_i),\n        .icpu_tag_i(icpu_tag_i),\n        .if_freeze(if_freeze),\n        .if_insn(if_insn),\n        .if_pc(if_pc),\n        .flushpipe(flushpipe),\n        .if_stall(if_stall),\n        .no_more_dslot(no_more_dslot),\n        .genpc_refetch(genpc_refetch),\n        .rfe(rfe),\n        .except_itlbmiss(except_itlbmiss),\n        .except_immufault(except_immufault),\n        .except_ibuserr(except_ibuserr)\n    );\n    or1200_ctrl or1200_ctrl(\n        .clk(clk),\n        .rst(rst),\n        .id_freeze(id_freeze),\n        .ex_freeze(ex_freeze),\n        .wb_freeze(wb_freeze),\n        .flushpipe(flushpipe),\n        .if_insn(if_insn),\n        .ex_insn(ex_insn),\n        .branch_op(branch_op),\n        .branch_taken(branch_taken),\n        .rf_addra(rf_addra),\n        .rf_addrb(rf_addrb),\n        .rf_rda(rf_rda),\n        .rf_rdb(rf_rdb),\n        .alu_op(alu_op),\n        .mac_op(mac_op),\n        .shrot_op(shrot_op),\n        .comp_op(comp_op),\n        .rf_addrw(rf_addrw),\n        .rfwb_op(rfwb_op),\n        .wb_insn(wb_insn),\n        .simm(simm),\n        .branch_addrofs(branch_addrofs),\n        .lsu_addrofs(lsu_addrofs),\n        .sel_a(sel_a),\n        .sel_b(sel_b),\n        .lsu_op(lsu_op),\n        .cust5_op(cust5_op),\n        .cust5_limm(cust5_limm),\n        .multicycle(multicycle),\n        .spr_addrimm(spr_addrimm),\n        .wbforw_valid(wbforw_valid),\n        .sig_syscall(sig_syscall),\n        .sig_trap(sig_trap),\n        .force_dslot_fetch(force_dslot_fetch),\n        .no_more_dslot(no_more_dslot),\n        .ex_void(ex_void),\n        .id_macrc_op(id_macrc_op),\n        .ex_macrc_op(ex_macrc_op),\n        .rfe(rfe),\n        .du_hwbkpt(du_hwbkpt),\n        .except_illegal(except_illegal)\n    );\n    or1200_rf or1200_rf(\n        .clk(clk),\n        .rst(rst),\n        .supv(sr[`OR1200_SR_SM]),\n        .wb_freeze(wb_freeze),\n        .addrw(rf_addrw),\n        .dataw(rf_dataw),\n        .id_freeze(id_freeze),\n        .we(rfwb_op[0]),\n        .flushpipe(flushpipe),\n        .addra(rf_addra),\n        .rda(rf_rda),\n        .dataa(rf_dataa),\n        .addrb(rf_addrb),\n        .rdb(rf_rdb),\n        .datab(rf_datab),\n        .spr_cs(spr_cs[`OR1200_SPR_GROUP_SYS]),\n        .spr_write(spr_we),\n        .spr_addr(spr_addr),\n        .spr_dat_i(spr_dat_cpu),\n        .spr_dat_o(spr_dat_rf)\n    );\n    or1200_operandmuxes or1200_operandmuxes(\n        .clk(clk),\n        .rst(rst),\n        .id_freeze(id_freeze),\n        .ex_freeze(ex_freeze),\n        .rf_dataa(rf_dataa),\n        .rf_datab(rf_datab),\n        .ex_forw(rf_dataw),\n        .wb_forw(wb_forw),\n        .simm(simm),\n        .sel_a(sel_a),\n        .sel_b(sel_b),\n        .operand_a(operand_a),\n        .operand_b(operand_b),\n        .muxed_b(muxed_b)\n    );\n    or1200_alu or1200_alu(\n        .a(operand_a),\n        .b(operand_b),\n        .mult_mac_result(mult_mac_result),\n        .macrc_op(ex_macrc_op),\n        .alu_op(alu_op),\n        .shrot_op(shrot_op),\n        .comp_op(comp_op),\n        .cust5_op(cust5_op),\n        .cust5_limm(cust5_limm),\n        .result(alu_dataout),\n        .flagforw(flagforw),\n        .flag_we(flag_we),\n        .cyforw(cyforw),\n        .cy_we(cy_we),\n        .flag(flag),\n        .carry(carry)\n    );\n    or1200_mult_mac or1200_mult_mac(\n        .clk(clk),\n        .rst(rst),\n        .ex_freeze(ex_freeze),\n        .id_macrc_op(id_macrc_op),\n        .macrc_op(ex_macrc_op),\n        .a(operand_a),\n        .b(operand_b),\n        .mac_op(mac_op),\n        .alu_op(alu_op),\n        .result(mult_mac_result),\n        .mac_stall_r(mac_stall),\n        .spr_cs(spr_cs[`OR1200_SPR_GROUP_MAC]),\n        .spr_write(spr_we),\n        .spr_addr(spr_addr),\n        .spr_dat_i(spr_dat_cpu),\n        .spr_dat_o(spr_dat_mac)\n    );\n    or1200_sprs or1200_sprs(\n        .clk(clk),\n        .rst(rst),\n        .addrbase(operand_a),\n        .addrofs(spr_addrimm),\n        .dat_i(operand_b),\n        .alu_op(alu_op),\n        .flagforw(flagforw),\n        .flag_we(flag_we),\n        .flag(flag),\n        .cyforw(cyforw),\n        .cy_we(cy_we),\n        .carry(carry),\n        .to_wbmux(sprs_dataout),\n        .du_addr(du_addr),\n        .du_dat_du(du_dat_du),\n        .du_read(du_read),\n        .du_write(du_write),\n        .du_dat_cpu(du_dat_cpu),\n        .spr_addr(spr_addr),\n        .spr_dat_pic(spr_dat_pic),\n        .spr_dat_tt(spr_dat_tt),\n        .spr_dat_pm(spr_dat_pm),\n        .spr_dat_cfgr(spr_dat_cfgr),\n        .spr_dat_rf(spr_dat_rf),\n        .spr_dat_npc(spr_dat_npc),\n        .spr_dat_ppc(spr_dat_ppc),\n        .spr_dat_mac(spr_dat_mac),\n        .spr_dat_dmmu(spr_dat_dmmu),\n        .spr_dat_immu(spr_dat_immu),\n        .spr_dat_du(spr_dat_du),\n        .spr_dat_o(spr_dat_cpu),\n        .spr_cs(spr_cs),\n        .spr_we(spr_we),\n        .epcr_we(epcr_we),\n        .eear_we(eear_we),\n        .esr_we(esr_we),\n        .pc_we(pc_we),\n        .epcr(epcr),\n        .eear(eear),\n        .esr(esr),\n        .except_started(except_started),\n        .sr_we(sr_we),\n        .to_sr(to_sr),\n        .sr(sr),\n        .branch_op(branch_op)\n    );\n    or1200_lsu or1200_lsu(\n        .addrbase(operand_a),\n        .addrofs(lsu_addrofs),\n        .lsu_op(lsu_op),\n        .lsu_datain(operand_b),\n        .lsu_dataout(lsu_dataout),\n        .lsu_stall(lsu_stall),\n        .lsu_unstall(lsu_unstall),\n        .du_stall(du_stall),\n        .except_align(except_align),\n        .except_dtlbmiss(except_dtlbmiss),\n        .except_dmmufault(except_dmmufault),\n        .except_dbuserr(except_dbuserr),\n        .dcpu_adr_o(dcpu_adr_o),\n        .dcpu_cycstb_o(dcpu_cycstb_o),\n        .dcpu_we_o(dcpu_we_o),\n        .dcpu_sel_o(dcpu_sel_o),\n        .dcpu_tag_o(dcpu_tag_o),\n        .dcpu_dat_o(dcpu_dat_o),\n        .dcpu_dat_i(dcpu_dat_i),\n        .dcpu_ack_i(dcpu_ack_i),\n        .dcpu_rty_i(dcpu_rty_i),\n        .dcpu_err_i(dcpu_err_i),\n        .dcpu_tag_i(dcpu_tag_i)\n    );\n    or1200_wbmux or1200_wbmux(\n        .clk(clk),\n        .rst(rst),\n        .wb_freeze(wb_freeze),\n        .rfwb_op(rfwb_op),\n        .muxin_a(alu_dataout),\n        .muxin_b(lsu_dataout),\n        .muxin_c(sprs_dataout),\n        .muxin_d({lr_sav, 2'b0}),\n        .muxout(rf_dataw),\n        .muxreg(wb_forw),\n        .muxreg_valid(wbforw_valid)\n    );\n    or1200_freeze or1200_freeze(\n        .clk(clk),\n        .rst(rst),\n        .multicycle(multicycle),\n        .flushpipe(flushpipe),\n        .extend_flush(extend_flush),\n        .lsu_stall(lsu_stall),\n        .if_stall(if_stall),\n        .lsu_unstall(lsu_unstall),\n        .force_dslot_fetch(force_dslot_fetch),\n        .abort_ex(abort_ex),\n        .du_stall(du_stall),\n        .mac_stall(mac_stall),\n        .genpc_freeze(genpc_freeze),\n        .if_freeze(if_freeze),\n        .id_freeze(id_freeze),\n        .ex_freeze(ex_freeze),\n        .wb_freeze(wb_freeze),\n        .icpu_ack_i(icpu_ack_i),\n        .icpu_err_i(icpu_err_i)\n    );\n    or1200_except or1200_except(\n        .clk(clk),\n        .rst(rst),\n        .sig_ibuserr(except_ibuserr),\n        .sig_dbuserr(except_dbuserr),\n        .sig_illegal(except_illegal),\n        .sig_align(except_align),\n        .sig_range(1'b0),\n        .sig_dtlbmiss(except_dtlbmiss),\n        .sig_dmmufault(except_dmmufault),\n        .sig_int(sig_int),\n        .sig_syscall(sig_syscall),\n        .sig_trap(sig_trap),\n        .sig_itlbmiss(except_itlbmiss),\n        .sig_immufault(except_immufault),\n        .sig_tick(sig_tick),\n        .branch_taken(branch_taken),\n        .icpu_ack_i(icpu_ack_i),\n        .icpu_err_i(icpu_err_i),\n        .dcpu_ack_i(dcpu_ack_i),\n        .dcpu_err_i(dcpu_err_i),\n        .genpc_freeze(genpc_freeze),\n        .id_freeze(id_freeze),\n        .ex_freeze(ex_freeze),\n        .wb_freeze(wb_freeze),\n        .if_stall(if_stall),\n        .if_pc(if_pc),\n        .id_pc(id_pc),\n        .lr_sav(lr_sav),\n        .flushpipe(flushpipe),\n        .extend_flush(extend_flush),\n        .except_type(except_type),\n        .except_start(except_start),\n        .except_started(except_started),\n        .except_stop(except_stop),\n        .ex_void(ex_void),\n        .spr_dat_ppc(spr_dat_ppc),\n        .spr_dat_npc(spr_dat_npc),\n        .datain(operand_b),\n        .du_dsr(du_dsr),\n        .epcr_we(epcr_we),\n        .eear_we(eear_we),\n        .esr_we(esr_we),\n        .pc_we(pc_we),\n        .epcr(epcr),\n        .eear(eear),\n        .esr(esr),\n        .lsu_addr(dcpu_adr_o),\n        .sr_we(sr_we),\n        .to_sr(to_sr),\n        .sr(sr),\n        .abort_ex(abort_ex)\n    );\n    or1200_cfgr or1200_cfgr(\n        .spr_addr(spr_addr),\n        .spr_dat_o(spr_dat_cfgr)\n    );\nendmodule"}
{"task_id": 1420, "completion": "assign out[DW-1:0] = ({(DW){sel0}}  & in0[DW-1:0] | {(DW){sel1}}  & in1[DW-1:0] | {(DW){sel2}}  & in2[DW-1:0] | {(DW){sel3}}  & in3[DW-1:0] | {(DW){sel4}}  & in4[DW-1:0] | {(DW){sel5}}  & in5[DW-1:0] | {(DW){sel6}}  & in6[DW-1:0] | {(DW){sel7}}  & in7[DW-1:0] | {(DW){sel8}}  & in8[DW-1:0] | {(DW){sel9}}  & in9[DW-1:0] | {(DW){sel10}} & in10[DW-1:0] | {(DW){sel11}} & in11[DW-1:0]); endmodule"}
{"task_id": 1374, "completion": "parameter DEFAULT_VALUE = 0;\n    typedef bit [KEY_WIDTH-1:0] key_t;\n    typedef bit [VAL_WIDTH-1:0] val_t;\n\n    typedef enum {Red, Black} color_t;\n\n    typedef struct {\n        color_t color;\n        key_t key;\n        val_t value;\n        tree_ptr left;\n        tree_ptr right;\n    } node_t;\n\n    typedef node_t tree_t;\n\n    tree_t empty_tree;\n\n    function val_t lookup(key_t x, tree_t t);\n        if (t == empty_tree) return DEFAULT_VALUE;\n        else if (x < t.key) return lookup(x, t.left);\n        else if (x > t.key) return lookup(x, t.right);\n        else return t.value;\n    endfunction\n\n    function tree_t balance(color_t color, tree_t left, key_t k, val_t v, tree_t right);\n        // Balance logic omitted for brevity\n        return t;\n    endfunction\n\n    function tree_t insert(key_t x, val_t vx, tree_t s);\n        if (s == empty_tree) return T(Red, empty_tree, x, vx, empty_tree);\n        // Insertion logic omitted for brevity\n        return makeBlack(ins(x, vx, s));\n    endfunction\n    ...\n    endmodule"}
{"task_id": 884, "completion": "wire          clock_cross_kernel_mem1_m0_translator_avalon_universal_master_0_waitrequest;\n\twire    [9:0] clock_cross_kernel_mem1_m0_translator_avalon_universal_master_0_burstcount;\n\twire  [255:0] clock_cross_kernel_mem1_m0_translator_avalon_universal_master_0_writedata;\n\twire   [29:0] clock_cross_kernel_mem1_m0_translator_avalon_universal_master_0_address;\n\twire          clock_cross_kernel_mem1_m0_translator_avalon_universal_master_0_lock;\n\twire          clock_cross_kernel_mem1_m0_translator_avalon_universal_master_0_write;\n\twire          clock_cross_kernel_mem1_m0_translator_avalon_universal_master_0_read;\n\twire  [255:0] clock_cross_kernel_mem1_m0_translator_avalon_universal_master_0_readdata;\n\twire          clock_cross_kernel_mem1_m0_translator_avalon_universal_master_0_debugaccess;\n\twire   [31:0] clock_cross_kernel_mem1_m0_translator_avalon_universal_master_0_byteenable;\n\twire          clock_cross_kernel_mem1_m0_translator_avalon_universal_master_0_readdatavalid;\n\n\taltera_merlin_master_translator #(\n\t\t.AV_ADDRESS_W                (30),\n\t\t.AV_DATA_W                   (256),\n\t\t.AV_BURSTCOUNT_W             (5),\n\t\t.AV_BYTEENABLE_W             (32),\n\t\t.UAV_ADDRESS_W               (30),\n\t\t.UAV_BURSTCOUNT_W            (10),\n\t\t.USE_READ                    (1),\n\t\t.USE_WRITE                   (1),\n\t\t.USE_BEGINBURSTTRANSFER      (0),\n\t\t.USE_BEGINTRANSFER           (0),\n\t\t.USE_CHIPSELECT              (0),\n\t\t.USE_BURSTCOUNT              (1),\n\t\t.USE_READDATAVALID           (1),\n\t\t.USE_WAITREQUEST             (1),\n\t\t.USE_READRESPONSE            (0),\n\t\t.USE_WRITERESPONSE           (0),\n\t\t.AV_SYMBOLS_PER_WORD         (32),\n\t\t.AV_ADDRESS_SYMBOLS          (1),\n\t\t.AV_BURSTCOUNT_SYMBOLS       (0),\n\t\t.AV_CONSTANT_BURST_BEHAVIOR  (1),\n\t\t.UAV_CONSTANT_BURST_BEHAVIOR (1),\n\t\t.AV_LINEWRAPBURSTS           (0),\n\t\t.AV_REGISTERINCOMINGSIGNALS  (0)\n\t) clock_cross_kernel_mem1_m0_translator (\n\t\t.clk                      (pll_outclk0_clk),\n\t\t.reset                    (clock_cross_kernel_mem1_m0_reset_reset_bridge_in_reset_reset),\n\t\t.uav_address              (clock_cross_kernel_mem1_m0_translator_avalon_universal_master_0_address),\n\t\t.uav_burstcount           (clock_cross_kernel_mem1_m0_translator_avalon_universal_master_0_burstcount),\n\t\t.uav_read                 (clock_cross_kernel_mem1_m0_translator_avalon_universal_master_0_read),\n\t\t.uav_write                (clock_cross_kernel_mem1_m0_translator_avalon_universal_master_0_write),\n\t\t.uav_waitrequest          (clock_cross_kernel_mem1_m0_translator_avalon_universal_master_0_waitrequest),\n\t\t.uav_readdatavalid        (clock_cross_kernel_mem1_m0_translator_avalon_universal_master_0_readdatavalid),\n\t\t.uav_byteenable           (clock_cross_kernel_mem1_m0_translator_avalon_universal_master_0_byteenable),\n\t\t.uav_readdata             (clock_cross_kernel_mem1_m0_translator_avalon_universal_master_0_readdata),\n\t\t.uav_writedata            (clock_cross_kernel_mem1_m0_translator_avalon_universal_master_0_writedata),\n\t\t.uav_lock                 (clock_cross_kernel_mem1_m0_translator_avalon_universal_master_0_lock),\n\t\t.uav_debugaccess          (clock_cross_kernel_mem1_m0_translator_avalon_universal_master_0_debugaccess),\n\t\t.av_address               (clock_cross_kernel_mem1_m0_address),\n\t\t.av_waitrequest           (clock_cross_kernel_mem1_m0_waitrequest),\n\t\t.av_burstcount            (clock_cross_kernel_mem1_m0_burstcount),\n\t\t.av_byteenable            (clock_cross_kernel_mem1_m0_byteenable),\n\t\t.av_read                  (clock_cross_kernel_mem1_m0_read),\n\t\t.av_readdata              (clock_cross_kernel_mem1_m0_readdata),\n\t\t.av_readdatavalid         (clock_cross_kernel_mem1_m0_readdatavalid),\n\t\t.av_write                 (clock_cross_kernel_mem1_m0_write),\n\t\t.av_writedata             (clock_cross_kernel_mem1_m0_writedata),\n\t\t.av_debugaccess           (clock_cross_kernel_mem1_m0_debugaccess),\n\t\t.av_beginbursttransfer    (1'b0),\n\t\t.av_begintransfer         (1'b0),\n\t\t.av_chipselect            (1'b0),\n\t\t.av_lock                  (1'b0),\n\t\t.uav_clken                (),\n\t\t.av_clken                 (1'b1),\n\t\t.uav_response             (2'b00),\n\t\t.av_response              (),\n\t\t.uav_writeresponserequest (),\n\t\t.uav_writeresponsevalid   (1'b0),\n\t\t.av_writeresponserequest  (1'b0),\n\t\t.av_writeresponsevalid    ()\n\t);\n\n\taltera_merlin_slave_translator #(\n\t\t.AV_ADDRESS_W                   (25),\n\t\t.AV_DATA_W                      (256),\n\t\t.UAV_DATA_W                     (256),\n\t\t.AV_BURSTCOUNT_W                (5),\n\t\t.AV_BYTEENABLE_W                (32),\n\t\t.UAV_BYTEENABLE_W               (32),\n\t\t.UAV_ADDRESS_W                  (30),\n\t\t.UAV_BURSTCOUNT_W               (10),\n\t\t.AV_READLATENCY                 (0),\n\t\t.USE_READDATAVALID              (1),\n\t\t.USE_WAITREQUEST                (1),\n\t\t.USE_UAV_CLKEN                  (0),\n\t\t.USE_READRESPONSE               (0),\n\t\t.USE_WRITERESPONSE              (0),\n\t\t.AV_SYMBOLS_PER_WORD            (32),\n\t\t.AV_ADDRESS_SYMBOLS             (0),\n\t\t.AV_BURSTCOUNT_SYMBOLS          (0),\n\t\t.AV_CONSTANT_BURST_BEHAVIOR     (0),\n\t\t.UAV_CONSTANT_BURST_BEHAVIOR    (0),\n\t\t.AV_REQUIRE_UNALIGNED_ADDRESSES (0),\n\t\t.CHIPSELECT_THROUGH_READLATENCY (0),\n\t\t.AV_READ_WAIT_CYCLES            (1),\n\t\t.AV_WRITE_WAIT_CYCLES           (0),\n\t\t.AV_SETUP_WAIT_CYCLES           (0),\n\t\t.AV_DATA_HOLD_CYCLES            (0)\n\t) address_span_extender_kernel_windowed_slave_translator (\n\t\t.clk                      (pll_outclk0_clk),\n\t\t.reset                    (clock_cross_kernel_mem1_m0_reset_reset_bridge_in_reset_reset),\n\t\t.uav_address              (clock_cross_kernel_mem1_m0_translator_avalon_universal_master_0_address),\n\t\t.uav_burstcount           (clock_cross_kernel_mem1_m0_translator_avalon_universal_master_0_burstcount),\n\t\t.uav_read                 (clock_cross_kernel_mem1_m0_translator_avalon_universal_master_0_read),\n\t\t.uav_write                (clock_cross_kernel_mem1_m0_translator_avalon_universal_master_0_write),\n\t\t.uav_waitrequest          (clock_cross_kernel_mem1_m0_translator_avalon_universal_master_0_waitrequest),\n\t\t.uav_readdatavalid        (clock_cross_kernel_mem1_m0_translator_avalon_universal_master_0_readdatavalid),\n\t\t.uav_byteenable           (clock_cross_kernel_mem1_m0_translator_avalon_universal_master_0_byteenable),\n\t\t.uav_readdata             (clock_cross_kernel_mem1_m0_translator_avalon_universal_master_0_readdata),\n\t\t.uav_writedata            (clock_cross_kernel_mem1_m0_translator_avalon_universal_master_0_writedata),\n\t\t.uav_lock                 (clock_cross_kernel_mem1_m0_translator_avalon_universal_master_0_lock),\n\t\t.uav_debugaccess          (clock_cross_kernel_mem1_m0_translator_avalon_universal_master_0_debugaccess),\n\t\t.av_address               (address_span_extender_kernel_windowed_slave_address),\n\t\t.av_write                 (address_span_extender_kernel_windowed_slave_write),\n\t\t.av_read                  (address_span_extender_kernel_windowed_slave_read),\n\t\t.av_readdata              (address_span_extender_kernel_windowed_slave_readdata),\n\t\t.av_writedata             (address_span_extender_kernel_windowed_slave_writedata),\n\t\t.av_burstcount            (address_span_extender_kernel_windowed_slave_burstcount),\n\t\t.av_byteenable            (address_span_extender_kernel_windowed_slave_byteenable),\n\t\t.av_readdatavalid         (address_span_extender_kernel_windowed_slave_readdatavalid),\n\t\t.av_waitrequest           (address_span_extender_kernel_windowed_slave_waitrequest),\n\t\t.av_begintransfer         (),\n\t\t.av_beginbursttransfer    (),\n\t\t.av_writebyteenable       (),\n\t\t.av_lock                  (),\n\t\t.av_chipselect            (),\n\t\t.av_clken                 (),\n\t\t.uav_clken                (1'b0),\n\t\t.av_debugaccess           (),\n\t\t.av_outputenable          (),\n\t\t.uav_response             (),\n\t\t.av_response              (2'b00),\n\t\t.uav_writeresponserequest (1'b0),\n\t\t.uav_writeresponsevalid   (),\n\t\t.av_writeresponserequest  (),\n\t\t.av_writeresponsevalid    (1'b0)\n\t);\n\nendmodule"}
{"task_id": 174, "completion": "`ifndef ALTERA_RESERVED_QIS\n// synopsys translate_off\n`endif\n\ttri1\t  clock;\n`ifndef ALTERA_RESERVED_QIS\n// synopsys translate_on\n`endif\nendmodule"}
{"task_id": 276, "completion": "endmodule"}
{"task_id": 210, "completion": "parameter WIDTH = 8;\n   wire false1, false2;\n   select U_SELECT1_OUT(\n                    .in(r),\n                    .sel(cond1),\n                    .false(false1),\n                    .true(r1),\n                    .rstn(rstn)\n                    );\n   mux2 U_MUX1_IN(\n                        .a0(false1),\n                        .a1(a1),\n                        .s(cond1),\n                        .z(a1mux)\n                        );\n   select U_SELECT2_OUT(\n                        .in(r),\n                        .sel(cond2),\n                        .false(false2),\n                        .true(r2),\n                        .rstn(rstn)\n                        );\n   mux2 U_MUX2_IN(\n                  .a0(false2),\n                  .a1(a2),\n                  .s(cond2),\n                  .z(a2mux)\n                  );\n   muller3 U_MULLER3(\n                     .a(r),\n                     .b(a1mux),\n                     .c(a2mux),\n                     .z(a),\n                     .rstn(rstn)\n                     );\n\nendmodule"}
{"task_id": 559, "completion": "input  A   ,\n    input  B   ,\n    input  C   ,\n    output Y   ,\n\n    input  VPB ,\n    input  VPWR,\n    input  VGND,\n    input  VNB\n);\nendmodule"}
{"task_id": 552, "completion": "reg [31:0] mem[31:0];\n  always @(posedge clock_a) begin\n    if (wren_a) begin\n      mem[address_a][7:0]   <= data_a[7:0];\n      mem[address_a][15:8]  <= data_a[15:8];\n      mem[address_a][23:16] <= data_a[23:16];\n      mem[address_a][31:24] <= data_a[31:24];\n    end\n\n    q_a <= mem[address_a];\n  end\n\n  always @(posedge clock_b) begin\n    if (wren_b) mem[address_b] <= data_b;\n\n    q_b <= mem[address_b];\n  end\n\nendmodule"}
{"task_id": 783, "completion": "endmodule"}
{"task_id": 746, "completion": "endmodule"}
{"task_id": 551, "completion": "wire or0_out;    \n    wire and0_out_X; \n    wire pwrgood_pp0_out_X; \n\n    or or0 (or0_out, A2, A1, A3); \n    and and0 (and0_out_X, or0_out, B1); \n    sky130_fd_sc_ls__udp_pwrgood_pp$PG pwrgood_pp0 (pwrgood_pp0_out_X, and0_out_X, VPWR, VGND); \n    buf buf0 (X, pwrgood_pp0_out_X); \n\nendmodule"}
{"task_id": 259, "completion": "// synthesis translate_off\n\n          BLKMEMSP_V6_2 #(\n            .c_addr_width(11),\n            .c_default_data(\"0\"),\n            .c_depth(2048),\n            .c_enable_rlocs(0),\n            .c_has_default_data(1),\n            .c_has_din(1),\n            .c_has_en(1),\n            .c_has_limit_data_pitch(0),\n            .c_has_nd(0),\n            .c_has_rdy(0),\n            .c_has_rfd(0),\n            .c_has_sinit(0),\n            .c_has_we(1),\n            .c_limit_data_pitch(18),\n            .c_mem_init_file(\"mif_file_16_1\"),\n            .c_pipe_stages(0),\n            .c_reg_inputs(0),\n            .c_sinit_value(\"0\"),\n            .c_width(8),\n            .c_write_mode(0),\n            .c_ybottom_addr(\"0\"),\n            .c_yclk_is_rising(1),\n            .c_yen_is_high(0),\n            .c_yhierarchy(\"hierarchy1\"),\n            .c_ymake_bmm(0),\n            .c_yprimitive_type(\"16kx1\"),\n            .c_ysinit_is_high(1),\n            .c_ytop_addr(\"1024\"),\n            .c_yuse_single_primitive(0),\n            .c_ywe_is_high(0),\n            .c_yydisable_warnings(1))\n    inst (\n            .ADDR(addr),\n            .CLK(clk),\n            .DIN(din),\n            .DOUT(dout),\n            .EN(en),\n            .WE(we),\n            .ND(),\n            .RFD(),\n            .RDY(),\n            .SINIT());\n\n\n    // synthesis translate_on\n\n    // XST black box declaration\n    // box_type \"black_box\"\n    // synthesis attribute box_type of rom_8x2k_lo is \"black_box\"\n\nendmodule"}
{"task_id": 602, "completion": "input pclk;\n  input [7:0]data;\n  output [15:0]rgb;\nendmodule"}
{"task_id": 15, "completion": "output Q      ;\n    output Q_N    ;\n    input  D      ;\n    input  SCD    ;\n    input  SCE    ;\n    input  CLK_N  ;\n    input  SET_B  ;\n    input  RESET_B;\n    input  VPWR   ;\n    input  VGND   ;\n\n    wire RESET          ;\n    wire SET            ;\n    wire CLK            ;\n    wire buf_Q          ;\n    reg  notifier       ;\n    wire D_delayed      ;\n    wire SCD_delayed    ;\n    wire SCE_delayed    ;\n    wire CLK_N_delayed  ;\n    wire SET_B_delayed  ;\n    wire RESET_B_delayed;\n    wire mux_out        ;\n    wire awake          ;\n    wire cond0          ;\n    wire cond1          ;\n    wire condb          ;\n    wire cond_D         ;\n    wire cond_SCD       ;\n    wire cond_SCE       ;\n\n    not                                     not0                    (RESET  , RESET_B_delayed                               );\n    not                                     not1                    (SET    , SET_B_delayed                                 );\n    not                                     not2                    (CLK    , CLK_N_delayed                                 );\n    sky130_fd_sc_hs__u_mux_2_1              u_mux_20                (mux_out, D_delayed, SCD_delayed, SCE_delayed           );\n    sky130_fd_sc_hs__u_dfb_setdom_notify_pg u_dfb_setdom_notify_pg0 (buf_Q  , SET, RESET, CLK, mux_out, notifier, VPWR, VGND);\n    assign awake = ( VPWR === 1'b1 );\n    assign cond0 = ( awake && ( RESET_B_delayed === 1'b1 ) );\n    assign cond1 = ( awake && ( SET_B_delayed === 1'b1 ) );\n    assign condb = ( cond0 & cond1 );\n    assign cond_D = ( ( SCE_delayed === 1'b0 ) && condb );\n    assign cond_SCD = ( ( SCE_delayed === 1'b1 ) && condb );\n    assign cond_SCE = ( ( D_delayed !== SCD_delayed ) && condb );\n    buf                                     buf0                    (Q      , buf_Q                                         );\n    not                                     not3                    (Q_N    , buf_Q                                         );\n\nendmodule"}
{"task_id": 476, "completion": "wire active = i_rstb && i_spi_active;\n   reg [7:0] r_data_to_send;\n   reg [7:0] rv_opcode;\n   reg r_read_map;\n   reg r_write_map;\n   reg [7:0] rv_addr;\n   always @( posedge i_rx_valid or negedge active ) begin : opcode_fsm\n     if ( !active ) begin\n       rv_opcode <= 0;\n       r_read_map <= 0;\n       r_write_map <= 0;\n       rv_addr <= 0;\n     end else begin\n       if ( 0 == vi_byte_num )\n\t\t   rv_opcode <= vi_data_rx;\n       if ( 1 == vi_byte_num )\n\t\t   rv_addr <= vi_data_rx;\n       if ( 1 == vi_byte_num ) begin\n\t\t\tif ( 32 == rv_opcode )\n\t\t\t   r_write_map <= 1;\n\t\t\telse\n\t\t\t   r_write_map <= 0;\n\t\t\tif ( 48 == rv_opcode )\n\t\t\t   r_read_map <= 1;\n\t\t\telse\n\t\t\t   r_read_map <= 0;\n       end\n     end\n   end\n   always @( posedge i_rx_valid or negedge i_rstb ) begin\n     if ( !i_rstb ) begin\n       // INSERT_RESET_REGS\n     end else begin\n       // INSERT_WRITE_REGS\n     end\n   end\n   always @( posedge i_rx_valid or negedge active ) begin\n     if ( !active ) begin\n       // INSERT_PULSE_RESET\n     end else begin\n       if (( 2 == vi_byte_num ) && (r_write_map )) begin\n\t\t   // INSERT_PULSE_REG\n       end\n     end\n   end\n   always @( posedge i_rx_valid or negedge active ) begin\n     if ( !active ) begin\n       r_data_to_send <= 0;\n     end else begin\n       // INSERT_READ_REGS\n     end\n   end\n   assign vio_data_spi = r_read_map ? r_data_to_send : 8'bz;\nendmodule"}
{"task_id": 643, "completion": "output X;\n    input  A;\n\n    // Voltage supply signals\n    supply1 VPWR;\n    supply0 VGND;\n\n    sky130_fd_sc_hs__dlygate4sd1 base (\n        .X(X),\n        .A(A)\n    );\n\nendmodule"}
{"task_id": 394, "completion": "parameter integer S = 8;\nparameter integer D = 8;\nparameter integer DS = (D*S)-1;\nwire rst;\nreg [DS:0] txd;\nparameter [S-1:0] TX_CLK_GEN = 8'hAA;\nassign rst = reset;\n\nclock_generator_ddr_s8_diff #(\n.S (S))\ninst_clkgen(\n.clkin_p (refclkin_p), \n.clkin_n (refclkin_n),\n.ioclkap (txioclkp),\n.ioclkan (txioclkn),\n.serdesstrobea (tx_serdesstrobe),\n.ioclkbp (),\n.ioclkbn (),\n.serdesstrobeb (),\n.gclk (tx_bufg_x1));\n\nalways @ (posedge tx_bufg_x1 or posedge rst) begin\nif (rst == 1'b1) begin\ntxd <= 64'h3000000000000001;\nend\nelse begin\ntxd <= {txd[63:60], txd[58:0], txd[59]};\nend\nend\n\nserdes_n_to_1_ddr_s8_se #(\n.S (S),\n.D (1))\ninst_clkout (\n.dataout (clkout),\n.txioclkp (txioclkp),\n.txioclkn (txioclkn),\n.txserdesstrobe (tx_serdesstrobe),\n.gclk (tx_bufg_x1),\n.reset (rst),\n.datain (TX_CLK_GEN));\n\nserdes_n_to_1_ddr_s8_se #(\n.S (S),\n.D (D))\ninst_dataout (\n.dataout (dataout),\n.txioclkp (txioclkp),\n.txioclkn (txioclkn),\n.txserdesstrobe (tx_serdesstrobe),\n.gclk (tx_bufg_x1),\n.reset (rst),\n.datain (txd));\n\nendmodule"}
{"task_id": 883, "completion": "/* synthesis syn_black_box black_box_pad_pin=\"clk,clk_x2,clk_100,active,hsync,vsync,rgb888[23:0],hdmi_clk,hdmi_hsync,hdmi_vsync,hdmi_d[15:0],hdmi_de,hdmi_scl,hdmi_sda\" */\n  input clk;\n  input clk_x2;\n  input clk_100;\n  input active;\n  input hsync;\n  input vsync;\n  input [23:0]rgb888;\n  output hdmi_clk;\n  output hdmi_hsync;\n  output hdmi_vsync;\n  output [15:0]hdmi_d;\n  output hdmi_de;\n  output hdmi_scl;\n  inout hdmi_sda;\nendmodule"}
{"task_id": 771, "completion": "reg [31:0] crc_f;  genvar i;  always@(posedge clk, negedge rst_n)  begin    if(~rst_n)    begin      crc_f <= CRC_INIT_VAL;    end    else    begin      if(fcs_calc_rst)      begin        crc_f <= CRC_INIT_VAL;      end      else if(fcs_calc_valid)      begin        crc_f <= nextCRC32_D8(fcs_calc_data, crc_f);      end    end  end  generate    for(i=0; i<32; i++)    begin      assign fcs[i] = ~crc_f[31-i];    end  endgenerate  endmodule"}
{"task_id": 920, "completion": "assign p_n = (n == 0) ? 1 : (n > 0) ? 1 : 0;\n    assign p_n_plus_1 = (p_n && (n  > 0)) ? 1 : 0;\nendmodule"}
{"task_id": 545, "completion": "localparam ADDR_WIDTH = $clog2(FIFO_DEPTH);\n    reg [DATA_WIDTH-1:0] mem [0:FIFO_DEPTH-1];\n    reg [ADDR_WIDTH:0] wr_ptr;\n    reg [ADDR_WIDTH:0] rd_ptr;\n    reg [ADDR_WIDTH:0] ptr_diff;\n\n    assign empty = (wr_ptr == rd_ptr);\n    assign full = (wr_ptr[ADDR_WIDTH-1:0] == rd_ptr[ADDR_WIDTH-1:0]) && (wr_ptr[ADDR_WIDTH] != rd_ptr[ADDR_WIDTH]);\n    assign data_out = mem[rd_ptr[ADDR_WIDTH-1:0]];\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            wr_ptr <= 0;\n        end else if (wr_en && !full) begin\n            mem[wr_ptr[ADDR_WIDTH-1:0]] <= data_in;\n            wr_ptr <= wr_ptr + 1;\n        end\n    end\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            rd_ptr <= 0;\n        end else if (rd_en && !empty) begin\n            rd_ptr <= rd_ptr + 1;\n        end\n    end\nendmodule"}
{"task_id": 1055, "completion": "output Y   ;\n    input  A   ;\n    input  B_N ;\n    input  VPWR;\n    input  VGND;\n    input  VPB ;\n    input  VNB ;\nendmodule"}
{"task_id": 1076, "completion": "endmodule"}
{"task_id": 977, "completion": "always@(posedge CLK) \n    begin\n\n        if (s1==1'b1) \n        begin \n            od <= d1; \n            os <= 1'b1; \n        end else if (s2==1'b1) \n        begin \n            od <= d2; \n            os <= 1'b1; \n        end else\n        begin \n            od <= 16'b0; \n            os <= 1'b0; \n        end\n\n        if (c1==1'b1 || c2==1'b1) oc <= 1'b1; \n        else oc <= 1'b0; \n\n    end\nendmodule"}
{"task_id": 922, "completion": "wire signed [17:0] Data_Type_Conversion_out1;\n\n  assign Data_Type_Conversion_out1 = In1[35:18];\n\n  assign Out1 = Data_Type_Conversion_out1;\n\nendmodule"}
{"task_id": 704, "completion": "wire [10:0]addra;\n  wire clka;\n  wire [19:0]dina;\n  wire [19:0]douta;\n  wire ena;\n  wire [0:0]wea;\n\n  decalper_eb_ot_sdeen_pot_pi_dehcac_xnilix_blk_mem_gen_v8_3_5 U0\n       (.addra(addra),\n        .clka(clka),\n        .dina(dina),\n        .douta(douta),\n        .ena(ena),\n        .wea(wea));\nendmodule"}
{"task_id": 211, "completion": "parameter dw = 32;\n   parameter aw = 32;\n   parameter DEBUG = 0;\n\n   wire [aw-1:0] sum_adr_o;\n   wire [dw-1:0] sum_dat_o;\n   wire [3:0] sum_sel_o;\n   wire sum_we_o;\n   wire sum_cyc_o;\n   wire sum_stb_o;\n   wire [2:0] sum_cti_o;\n   wire [1:0] sum_bte_o;\n\n   equation_sum #(.aw(aw), .dw(dw),.DEBUG(DEBUG))\n   sum(\n       // Outputs\n       .wb_adr_o(sum_adr_o), \n       .wb_dat_o(sum_dat_o), \n       .wb_sel_o(sum_sel_o), \n       .wb_we_o(sum_we_o), \n       .wb_cyc_o(sum_cyc_o), \n       .wb_stb_o(sum_stb_o),\n       .wb_cti_o(), \n       .wb_bte_o(), \n       .equation_done(sum_equation_done),\n       \n       // Inputs\n       .wb_clk(wb_clk), \n       .wb_rst(wb_rst), \n       .wb_dat_i(wb_dat_i), \n       .wb_ack_i(wb_ack_i), \n       .wb_err_i(wb_err_i), \n       .wb_rty_i(wb_rty_i),\n       .base_address(base_address), \n       .equation_enable(equation_enable)\n       );\n   assign eq_adr_o = sum_adr_o;\n   assign eq_dat_o = sum_dat_o; \n   assign eq_sel_o = sum_sel_o;\n   assign eq_we_o  = sum_we_o;\n   assign eq_cyc_o = sum_cyc_o;\n   assign eq_stb_o = sum_stb_o;\n   assign eq_cti_o = sum_cti_o;\n   assign eq_bte_o = sum_bte_o;\n   assign eq_cti_o = 0;\n   assign eq_bte_o = 0;\n   assign equation_done = sum_equation_done;\nendmodule"}
{"task_id": 320, "completion": "wire [C_DATA_WIDTH-1:0]  trn_td;\n  wire [REM_WIDTH-1:0]     trn_trem;\n  wire                     trn_tsof;\n  wire                     trn_teof;\n  wire                     trn_tsrc_rdy;\n  wire                     trn_tsrc_dsc;\n  wire                     trn_terrfwd;\n  wire                     trn_tecrc_gen;\n  wire                     trn_tstr;\n  wire [C_DATA_WIDTH-1:0]  trn_rd;\n  wire [REM_WIDTH-1:0]     trn_rrem;\n  wire                     trn_rdst_rdy;\n  wire                     trn_rsof;\n  wire                     trn_reof;\n  wire                     trn_rsrc_rdy;\n  wire                     trn_rsrc_dsc;\n  wire [7:0]               trn_rbar_hit;\n  ...\n  assign        cfg_status   = {16'b0};\n  assign        cfg_command  = {5'b0,\n                                cfg_command_interrupt_disable,\n                                1'b0,\n                                cfg_command_serr_en,\n                                5'b0,\n                                cfg_command_bus_master_enable,\n                                cfg_command_mem_enable,\n                                cfg_command_io_enable};\n  always @(posedge user_clk_out) begin\n    if (~user_lnk_up)\n    begin\n      cfg_bus_number_d <= 8'b0;\n    end\n    else if (~cfg_msg_received)\n    begin\n      cfg_bus_number_d <= cfg_msg_data[15:8];\n    end\n  end\n  pcieCore_axi_basic_top #(\n    ...\n  ) axi_basic_top (\n    ...\n  );\n  pcieCore_pcie_7x # (\n    ...\n  ) pcie_7x_i (\n    ...\n  );\n  pcieCore_pcie_pipe_pipeline # (\n    ...\n  ) pcie_pipe_pipeline_i (\n    ...\n  );\nendmodule"}
{"task_id": 1130, "completion": "a = 1'b0;\n    b = 1'b1;\n    #1;\n    if (y !== 1'b0) begin\n      $display(\"FAILED: a=1'b0, b=1'b1, hidden=1'b0, expected 1'b0, got %b\", y);\n      pass = 1'b0;\n    end\n\n    a = 1'b1;\n    b = 1'b0;\n    #1;\n    if (y !== 1'b0) begin\n      $display(\"FAILED: a=1'b1, b=1'b0, hidden=1'b0, expected 1'b0, got %b\", y);\n      pass = 1'b0;\n    end\n\n    a = 1'b1;\n    b = 1'b1;\n    #1;\n    if (y !== 1'b1) begin\n      $display(\"FAILED: a=1'b1, b=1'b1, hidden=1'b0, expected 1'b1, got %b\", y);\n      pass = 1'b0;\n    end\n\n    hidden = 1'b0;\n    a = 1'b0;\n    b = 1'b0;\n    #1;\n    if (y !== 1'b0) begin\n      $display(\"FAILED: a=1'b0, b=1'b0, hidden=1'b0, expected 1'b0, got %b\", y);\n      pass = 1'b0;\n    end\n\n    hidden = 1'b1;\n    a = 1'b0;\n    b = 1'b0;\n    #1;\n    if (y !== 1'b1) begin\n      $display(\"FAILED: a=1'b0, b=1'b0, hidden=1'b1, expected 1'b1, got %b\", y);\n      pass = 1'b0;\n    end\n\n    if (pass) $display(\"PASSED\");\n  end\nendmodule"}
{"task_id": 630, "completion": "Require Import Classical.\nRequire Import List.\nRequire Import Omega.\nRequire Import Arith.\nRequire Import Wf.\n\nRequire Import Ranked_properties.\nRequire SF_spec.\n\nSection SF_spec_properties.\n  Variable candidate:Set.\n\n  Let rankSelection := list candidate.\n  Let ballot := list rankSelection.\n  Let election := list ballot.\n\n  Lemma next_ranking_elim_unchanged :\n    forall (elim elim':candidate -> Prop) b c r,\n      (forall x, elim x -> elim' x) ->\n      ~elim' c ->\n      SF_spec.next_ranking candidate elim b r ->\n      In c r ->\n      SF_spec.next_ranking candidate elim' b r.\n  Proof.\n    intros.\n    induction H1.\n    * apply SF_spec.next_ranking_eliminated; auto.\n      rewrite Forall_forall in *; firstorder.\n    * apply SF_spec.next_ranking_valid with c; auto.\n  Qed.\n\n  Lemma selected_candidate_elim_unchanged :\n    forall (elim elim':candidate -> Prop) b c,\n      SF_spec.selected_candidate candidate elim b c ->\n      (forall x, elim x -> elim' x) ->\n      ~elim' c ->\n      SF_spec.selected_candidate candidate elim' b c.\n  Proof.\n    intros.\n    destruct H.\n    destruct H2 as [r [Hr Hc]].\n    split.\n    * intro. apply H.\n      destruct H2.\n      elim H2.\n      exists r. eapply next_ranking_elim_unchanged; eauto.\n      destruct H2 as [r' [??]].\n      assert (r = r').\n      { cut (SF_spec.next_ranking candidate elim' b r'); [ apply SF_spec.next_ranking_unique; auto | auto ].\n        eapply next_ranking_elim_unchanged; eauto.\n      }\n      subst r'.\n      right; exists r; split; auto.\n    * exists r; split; auto.\n      eapply next_ranking_elim_unchanged; eauto.\n  Qed.\n\n  ... (\u7701\u7565\u5176\u4ed6\u4ee3\u7801) ...\n\n  Theorem SF_spec_total e (eliminated:candidate -> Prop) :\n    (forall c0, eliminated c0 -> SF_spec.participates _ c0 e) ->\n    (exists c n, n > 0 /\\n    SF_spec.first_choices _ eliminated c e n) ->\n    exists c, SF_spec.winner _ e eliminated c.\n  Proof.\n    intros.\n    apply SF_spec_existential_induction with e (fun _ => True); intuition.\n    * apply SF_spec.winner_now; auto.\n    * destruct (sf_loser_exists e eliminated0) as [loser ?]; auto.\n      + destruct H2 as [c [n [??]]].\n        destruct (nonzero_first_choices_selected eliminated0 c e n) as [b [??]]; auto.\n        exists c.\n        generalize (SF_spec.selected_candidate_not_eliminated _ _ b c H6); intro.\n        split; auto.\n        destruct H6.\n        red; exists b. split; auto.\n        destruct H8 as [r [??]].\n        exists r; split; auto.\n        eapply SF_spec.next_ranking_in_ballot; eauto.\n      + exists loser; intuition.\n        apply SF_spec.winner_elimination with loser; auto.\n  Qed.\n\n  Definition mutual_majority_invariant (e:election) (group:list candidate) (eliminated:candidate -> Prop) :=\n    exists c, In c group /\n    ~eliminated c.\n\n  Lemma majority_satisfies_monotone (P Q:ballot -> Prop) : \n    forall e,\n      (forall b, P b -> Q b) ->\n      majority_satisfies _ P e ->\n      majority_satisfies _ Q e.\n  Proof.\n    intros e HPQ [nmaj [ntotal [?[??]]]].\n    destruct (count_monotone _ P Q e HPQ nmaj H) as [nmaj' [??]].\n    exists nmaj'. exists ntotal. intuition.\n  Qed.\n\n  Lemma selected_candidate_tail (eliminated : candidate -> Prop) :\n    forall a h c,\n      SF_spec.does_not_select _ eliminated a ->\n      SF_spec.selected_candidate _ eliminated h c ->\n      SF_spec.selected_candidate _ eliminated (a :: h) c.\n  Proof.\n    intros. destruct H0. split.\n    intro. apply H0.\n    destruct H2.\n    left.\n    intros [q ?].\n    apply H2. exists q.\n    apply SF_spec.next_ranking_eliminated; auto.\n    rewrite Forall_forall.\n    intros.\n    destruct H. subst a. elim H4.\n    ...\n    endmodule"}
{"task_id": 146, "completion": "wire srst;\n   reg reset_gen1 = 1'b0;\n   reg reset_gen_d1 = 1'b0;\n   reg reset_gen_d2 = 1'b0;\n \n   always @(posedge s_aclk)\n   begin\n    reset_gen1 <= 1'b1;\n  reset_gen_d1 <= reset_gen1;\n  reset_gen_d2 <= reset_gen_d1;\n   end\n \n   generate\n   if(has_aresetn == 0)\n   begin:if_block\n         assign srst = reset_gen_d2;\n   end\n   else\n   begin:else_block\n     assign srst = ~((~aresetn) & ce);\n   end\n   endgenerate\n \n   generate\n \n\nif (core_name0 == \"channelizer_fifo_generator_v12_0_0\") \n     begin:comp0\nchannelizer_fifo_generator_v12_0_0 core_instance0 ( \n        .s_aclk(s_aclk),\n        .s_aresetn(srst),\n        .s_axis_tdata(s_axis_tdata),\n        .s_axis_tlast(s_axis_tlast),\n        .s_axis_tid  (s_axis_tid),\n        .s_axis_tdest(s_axis_tdest),\n        .s_axis_tuser(s_axis_tuser),\n        .s_axis_tvalid(s_axis_tvalid),\n        .s_axis_tready(s_axis_tready),\n        .m_axis_tdata(m_axis_tdata),\n        .m_axis_tlast(m_axis_tlast),\n        .m_axis_tid  (m_axis_tid),\n        .m_axis_tdest(m_axis_tdest),\n        .m_axis_tuser(m_axis_tuser),\n        .m_axis_tvalid(m_axis_tvalid),\n        .m_axis_tready(m_axis_tready)\n       ); \n     end \n\nendgenerate\n endmodule"}
{"task_id": 1199, "completion": "endmodule"}
{"task_id": 1314, "completion": "wire \\blk00000001/sig00000068 ;\n  wire \\blk00000001/sig00000067 ;\n  wire \\blk00000001/sig00000066 ;\n  // ... \u7701\u7565\u4e2d\u95f4\u903b\u8f91  ... \n  GND   \\blk00000001/blk00000002  (\n    .G(\\blk00000001/sig00000027 )\n  );\n\nendmodule"}
{"task_id": 1247, "completion": "wire [4095:0] convexPoints;    wire [7:0] convexSetSize;        reg [4:0] SSD;    reg [7:0] SSD_CATHODES;    reg [3:0] count;    wire [31:0] outputResult;    reg scan_ca;        assign AN[0] = scan_ca;        assign {CA, CB, CC, CD, CE, CF, CG, DP} = { SSD_CATHODES, 1'b1};        reg [26:0] DIV_CLK;    always @(posedge CLK100MHZ, negedge CPU_RESETN) begin                             if (!CPU_RESETN) begin            DIV_CLK <= 0;        end                else begin            DIV_CLK <= DIV_CLK + 1'b1;        end    end        m_port_ultra portableUltrasoundFSM (        .clk (CLK100MHZ),        .slowClk (DIV_CLK[25:24]),        .reset_n (CPU_RESETN),        .ack (BTNC),        .shiftRight (BTNR),        .shiftLeft (BTNL),        .convexPoints (convexPoints),        .convexSetSize (convexSetSize)    );        wire [3:0] BCD0, BCD1, BCD2, BCD3, BCD4;        assign BCD4 = (convexSetSize / 10000);    assign BCD3 = (((convexSetSize % 10000) - (convexSetSize % 1000)) / 1000);    assign BCD2 = (((convexSetSize % 1000) - (convexSetSize % 100)) / 100);    assign BCD1 = (((convexSetSize % 100) - (convexSetSize % 10)) / 10);    assign BCD0 = (((convexSetSize % 10) - (convexSetSize % 1)) / 1);        assign outputResult [31:28] = 4'b0000;    assign outputResult [27:24] = 4'b0000;    assign outputResult [23:20] = 4'b0000;    assign outputResult [19:16] = BCD4;    assign outputResult [15:12] = BCD3;    assign outputResult [11:8] = BCD2;    assign outputResult [7:4] = BCD1;    assign outputResult [3:0] = BCD0;        wire[2:0] ssdscan_clk;    assign ssdscan_clk = DIV_CLK[19:17];    assign AN[0] = !( (~(ssdscan_clk[2])) && ~(ssdscan_clk[1]) && ~(ssdscan_clk[0]) );    assign AN[1] = !( (~(ssdscan_clk[2])) && ~(ssdscan_clk[1]) &&  (ssdscan_clk[0]) );    assign AN[2] = !( (~(ssdscan_clk[2])) &&  (ssdscan_clk[1]) && ~(ssdscan_clk[0]) );    assign AN[3] = !( (~(ssdscan_clk[2])) &&  (ssdscan_clk[1]) &&  (ssdscan_clk[0]) );    assign AN[4] = !( ( (ssdscan_clk[2])) && ~(ssdscan_clk[1]) && ~(ssdscan_clk[0]) );    assign AN[5] = !( ( (ssdscan_clk[2])) && ~(ssdscan_clk[1]) &&  (ssdscan_clk[0]) );    assign AN[6] = !( ( (ssdscan_clk[2])) &&  (ssdscan_clk[1]) && ~(ssdscan_clk[0]) );    assign AN[7] = !( ( (ssdscan_clk[2])) &&  (ssdscan_clk[1]) &&  (ssdscan_clk[0]) );        wire[3:0] SSD7, SSD6, SSD5, SSD4, SSD3, SSD2, SSD1, SSD0;        assign SSD7 = outputResult[31:28];    assign SSD6 = outputResult[27:24];    assign SSD5 = outputResult[23:20];    assign SSD4 = outputResult[19:16];    assign SSD3 = outputResult[15:12];    assign SSD2 = outputResult[11:8];    assign SSD1 = outputResult[7:4];    assign SSD0 = outputResult[3:0];        always @ (ssdscan_clk, SSD0, SSD1, SSD2, SSD3, SSD4, SSD5, SSD6, SSD7)    begin : SSD_SCAN_OUT        case (ssdscan_clk)         3'b000: SSD = SSD0;        3'b001: SSD = SSD1;        3'b010: SSD = SSD2;        3'b011: SSD = SSD3;        3'b100: SSD = SSD4;        3'b101: SSD = SSD5;        3'b110: SSD = SSD6;        3'b111: SSD = SSD7;        endcase     end    always @ (SSD) begin        case (SSD)            4'b1010: SSD_CATHODES = 7'b0001000 ; // A            4'b1011: SSD_CATHODES = 7'b1100000 ; // B            4'b1100: SSD_CATHODES = 7'b0110001 ; // C            4'b1101: SSD_CATHODES = 7'b1000010 ; // D            4'b1110: SSD_CATHODES = 7'b0110000 ; // E            4'b1111: SSD_CATHODES = 7'b0111000 ; // F               4'b0000: SSD_CATHODES = 7'b0000001 ; // 0              4'b0001: SSD_CATHODES = 7'b1001111 ; // 1            4'b0010: SSD_CATHODES = 7'b0010010 ; // 2               4'b0011: SSD_CATHODES = 7'b0000110 ; // 3               4'b0100: SSD_CATHODES = 7'b1001100 ; // 4               4'b0101: SSD_CATHODES = 7'b0100100 ; // 5              4'b0110: SSD_CATHODES = 7'b0100000 ; // 6              4'b0111: SSD_CATHODES = 7'b0001111 ; // 7               4'b1000: SSD_CATHODES = 7'b0000000 ; // 8              4'b1001: SSD_CATHODES = 7'b0001100 ; // 9        endcase    end    endmodule"}
{"task_id": 19, "completion": "// \u90e8\u5206\u7b80\u5316\u57fa\u672c\u5b9e\u73b0\u4ee3\u7801\n  generate if(C_COMMON_CLK && (C_WRITE_MODE_A == \"WRITE_FIRST\") && (C_WRITE_MODE_B == \"WRITE_FIRST\")) begin : com_clk_sched_wf_wf\n    always @(posedge CLKA) begin\n      if (WEA) write_a(ADDRA, WEA, DINA, INJECTSBITERR, INJECTDBITERR);\n      if (reb) read_b(ADDRB, rstb);\n      if (rea) read_a(ADDRA, reseta);\n    end\n  end\n  endgenerate\n  // \u5176\u4ed6\u529f\u80fd\u5b9e\u73b0\u7684\u4ee3\u7801\nendmodule"}
{"task_id": 153, "completion": "localparam      IDLE              = 0;\nlocalparam      INGRESS_DMA_EN    = 1;\nlocalparam      INGRESS_DMA_ACT   = 2;\nlocalparam      INGRESS_DMA_FLUSH = 3;\nlocalparam      EGRESS_DMA_EN     = 4;\nlocalparam      EGRESS_DMA_ACT    = 5;\nlocalparam      EGRESS_DMA_FLUSH  = 6;\n\nreg   [23:0]          r_count;\nreg   [3:0]           state;\nreg                   r_ingress_rd_stb;\nwire                  w_ingress_rd_rdy;\nreg                   r_ingress_rd_act;\nwire  [23:0]          w_ingress_rd_size;\nwire  [31:0]          w_ingress_rd_data;\nwire  [1:0]           w_egress_wr_rdy;\nreg   [1:0]           r_egress_wr_act;\nwire  [23:0]          w_egress_wr_size;\nreg                   r_egress_wr_stb;\nwire  [31:0]          w_egress_wr_data;\nwire                  usr_clk;\nreg   [23:0]          r_transfer_size;\nreg                         r_wea_a;\nreg   [BUFFER_WIDTH - 1:0]  r_addr_a;\nwire  [31:0]                w_din_a;\nwire  [31:0]                w_dout_a;\n\nppfifo #(\n  .DATA_WIDTH     (32                 ),\n  .ADDRESS_WIDTH  (FIFO_WIDTH         )\n)ingress(\n  .reset          (rst                ),\n  .write_clock    (clk                ),\n  .write_ready    (o_write_ready      ),\n  .write_activate (i_write_activate   ),\n  .write_fifo_size(o_write_size       ),\n  .write_strobe   (i_write_strobe     ),\n  .write_data     (i_write_data       ),\n  .starved        (                   ),\n  .read_clock     (usr_clk            ),\n  .read_strobe    (r_ingress_rd_stb   ),\n  .read_ready     (w_ingress_rd_rdy   ),\n  .read_activate  (r_ingress_rd_act   ),\n  .read_count     (w_ingress_rd_size  ),\n  .read_data      (w_ingress_rd_data  ),\n  .inactive       (                   )\n);\n\nppfifo #(\n  .DATA_WIDTH     (32                 ),\n  .ADDRESS_WIDTH  (FIFO_WIDTH         )\n) egress (\n  .reset          (rst                ),\n  .write_clock    (usr_clk            ),\n  .write_ready    (w_egress_wr_rdy    ),\n  .write_activate (r_egress_wr_act    ),\n  .write_fifo_size(w_egress_wr_size   ),\n  .write_strobe   (r_egress_wr_stb    ),\n  .write_data     (w_egress_wr_data   ),\n  .starved        (                   ),\n  .read_clock     (clk                ),\n  .read_strobe    (i_read_strobe      ),\n  .read_ready     (o_read_ready       ),\n  .read_activate  (i_read_activate    ),\n  .read_count     (o_read_size        ),\n  .read_data      (o_read_data        ),\n  .inactive       (                   )\n);\n\ndpb #(\n  .DATA_WIDTH     (32                 ),\n  .ADDR_WIDTH     (BUFFER_WIDTH       )\n) local_buffer (\n  .clka           (usr_clk            ),\n  .wea            (r_wea_a            ),\n  .addra          (r_addr_a           ),\n  .dina           (w_din_a            ),\n  .douta          (w_dout_a           ),\n  .clkb           (clk                ),\n  .web            (i_bram_wea         ),\n  .addrb          (i_bram_addr        ),\n  .dinb           (i_bram_din         ),\n  .doutb          (o_bram_dout        )\n);\n\nassign  usr_clk       = clk;          \nassign  o_read_error  = 1'b0;\nassign  w_din_a       = w_ingress_rd_data;\nassign  w_egress_wr_data  = w_dout_a;\n\nalways @ (posedge clk) begin\n  if (rst) begin\n    state                 <=  IDLE;\n    r_ingress_rd_act      <=  0;\n    r_egress_wr_act       <=  0;\n    r_transfer_size       <=  0;\n    r_wea_a               <=  0;\n    r_addr_a              <=  0;\n  end\n  else begin\n    r_ingress_rd_stb      <=  0;\n    r_egress_wr_stb       <=  0;\n    case (state)\n      IDLE: begin\n        r_ingress_rd_act  <=  0;\n        r_egress_wr_act   <=  0;\n        r_count           <=  0;\n        if (w_ingress_rd_rdy) begin\n          state             <=  INGRESS_DMA_EN;\n          r_addr_a          <=  i_write_addr;\n          r_transfer_size   <=  i_write_count;\n        end\n        else if (i_read_enable) begin\n          state             <=  EGRESS_DMA_EN;\n          r_addr_a          <=  i_read_addr;\n          r_transfer_size   <=  i_read_count;\n        end\n      end\n      INGRESS_DMA_EN: begin\n        if (w_ingress_rd_rdy && !r_ingress_rd_act) begin\n          r_ingress_rd_act  <=  1;\n          r_count           <=  0;\n          state             <=  INGRESS_DMA_ACT;\n        end\n        if (i_write_flush) begin\n          state             <=  INGRESS_DMA_FLUSH;\n        end\n        if (!w_ingress_rd_rdy) begin\n          state             <=  IDLE;\n        end\n      end\n      INGRESS_DMA_ACT: begin\n        if (r_ingress_rd_stb) begin\n          if (i_write_addr_inc) begin\n            r_addr_a        <=  r_addr_a + 1;\n          end\n          else if (i_write_addr_dec) begin\n            r_addr_a        <=  r_addr_a - 1;\n          end\n        end\n        if (r_count < w_ingress_rd_size) begin\n          r_ingress_rd_stb  <=  1;\n          r_wea_a           <=  1;\n          r_count           <=  r_count + 1;\n        end\n        else begin\n          r_wea_a           <=  0;\n          r_ingress_rd_act  <=  0;\n          state             <=  INGRESS_DMA_EN;\n        end\n      end\n      INGRESS_DMA_FLUSH: begin\n        if (w_ingress_rd_rdy && !r_ingress_rd_act) begin\n          r_ingress_rd_act  <=  1;\n          r_count           <=  0;\n        end\n        else if(r_ingress_rd_act) begin\n          if (r_count < w_ingress_rd_size) begin\n            r_ingress_rd_stb<=  1;\n            r_count         <=  r_count + 1;\n          end\n          else begin\n            r_ingress_rd_act  <=  0;\n          end\n        end\n        else begin\n          state             <=  INGRESS_DMA_EN;\n        end\n      end\n      EGRESS_DMA_EN: begin\n        if (i_read_enable) begin\n          if ((w_egress_wr_rdy > 0) && (r_egress_wr_act == 0)) begin\n            r_count                 <=  0;\n            if (w_egress_wr_rdy[0]) begin\n              r_egress_wr_act[0]    <=  1;\n            end\n            else begin\n              r_egress_wr_act[1]    <=  1;\n            end\n            state                   <=  EGRESS_DMA_ACT;\n          end\n        end\n        else begin\n          state                     <=  IDLE;\n        end\n      end\n      EGRESS_DMA_ACT: begin\n        if (r_egress_wr_act > 0) begin\n          if (r_count < w_egress_wr_size) begin\n            r_count                 <=  r_count + 1;\n            r_egress_wr_stb         <=  1;\n            if (i_read_addr_inc) begin\n              r_addr_a              <=  r_addr_a + 1;\n            end\n            else if (i_read_addr_dec) begin\n              r_addr_a              <=  r_addr_a - 1;\n            end\n          end\n          else begin\n            r_egress_wr_act         <=  0;\n          end\n        end\n        else begin\n          state                     <=  EGRESS_DMA_EN;\n        end\n        if (i_read_flush) begin\n          state                     <=  EGRESS_DMA_FLUSH;\n        end\n      end\n      EGRESS_DMA_FLUSH: begin\n        if (r_egress_wr_act > 0) begin\n          if (r_count < w_egress_wr_size) begin\n            r_count                 <=  r_count + 1;\n          end\n          else begin\n            r_egress_wr_act         <=  0;\n          end\n        end\n        else begin\n          state             <=  EGRESS_DMA_EN;\n        end\n      end\n      default: begin\n      end\n    endcase\n  end\nend\n\nendmodule"}
{"task_id": 89, "completion": "wire S_AXI_AWREADY;\n  wire S_AXI_WREADY;\n  wire S_AXI_BVALID;\n  wire S_AXI_ARREADY;\n  wire S_AXI_RLAST;\n  wire S_AXI_RVALID;\n  wire S_AXI_SBITERR;\n  wire S_AXI_DBITERR;\n\n  assign S_AXI_BVALID = (1'b0);\n  assign S_AXI_AWREADY = (1'b0);\n  assign S_AXI_WREADY = (1'b0);\n  assign S_AXI_RVALID = (1'b0);\n  assign S_AXI_RLAST = (1'b0);\n  assign RDADDRECC = (0);\n  assign S_AXI_AWREADY = (1'b0);\n  assign S_AXI_BVALID = (1'b0);\n  assign S_AXI_ARREADY = (1'b0);\n  assign S_AXI_DBITERR = (1'b0);\n  assign S_AXI_SBITERR = (1'b0);\n\nendmodule"}
{"task_id": 209, "completion": "parameter [0 : 0] hasDebugLogic = 1'b0;\n  wire [31 : 0] wciS0_SData, wsiM0_MData;\n  wire [11 : 0] wsiM0_MBurstLength;\n  wire [7 : 0] wsiM0_MReqInfo;\n  wire [3 : 0] wsiM0_MByteEn;\n  wire [2 : 0] wsiM0_MCmd;\n  wire [1 : 0] wciS0_SFlag, wciS0_SResp;\n  wire CLK_GATE_adcSdrClk,\n       CLK_GATE_adc_sclk,\n       CLK_GATE_adc_sclkn,\n       CLK_adcSdrClk,\n       CLK_adc_sclk,\n       CLK_adc_sclkn,\n       RST_N_adcSdrRst,\n       RST_N_adc_rst,\n       adc_oe,\n       adc_resetp,\n       adc_sclkgate,\n       adc_sen,\n       adc_smosi,\n       wciS0_SThreadBusy,\n       wsiM0_MBurstPrecise,\n       wsiM0_MReqLast,\n       wsiM0_MReset_n,\n       wtiS0_SReset_n,\n       wtiS0_SThreadBusy;\n  // Internals and signal assignments...\n  // Implementation details go here...\nendmodule"}
{"task_id": 1207, "completion": "input clock;\n    input reset;\n\n    input [31:0] in1;\n    input [31:0] in2;\n    input [31:0] in3;\n    input [31:0] in4;\n    input [31:0] in5;\n\n    output [31:0] out_1;\n    output [31:0] out_2;\n    output [31:0] out_3;\n    output [31:0] out_4;\n\n    wire [31:0] x1;\n    wire [31:0] x2;\n    wire [31:0] x3;\n    wire [31:0] x4;\n\n    wire [31:0] add1;\n    wire [31:0] add2;\n    wire [31:0] add3;\n    wire [31:0] add4;\n    wire [31:0] add5;\n\n    reg [31:0] reg1;\n    reg [31:0] reg2;\n    reg [31:0] reg3;\n    reg [31:0] reg4;\n    reg [31:0] reg5;\n    reg [31:0] reg6;\n\n    wire [31:0] out_1;\n    wire [31:0] out_2;\n    wire [31:0] out_3;\n    wire [31:0] out_4;\n\n    wire [7:0] add1_control;\n    fpu_add add1_add\n    ( \n        .clk(clock), \n        .opa(reg6), \n        .opb(in4), \n        .out(add1), \n        .control(add1_control) \n    );\n\n    wire [7:0] x1_control;\n    fpu_mul x1_mul\n    ( \n        .clk(clock), \n        .opa(x3), \n        .opb(in1), \n        .out(x1), \n        .control(x1_control) \n    );\n\n    wire [7:0] add2_control;\n    fpu_add add2_add\n    ( \n        .clk(clock), \n        .opa(add5), \n        .opb(add1), \n        .out(add2), \n        .control(add2_control) \n    );\n\n    wire [7:0] x2_control;\n    fpu_mul x2_mul\n    ( \n        .clk(clock), \n        .opa(x1), \n        .opb(add2), \n        .out(x2), \n        .control(x2_control) \n    );\n\n    wire [7:0] add3_control;\n    fpu_add add3_add\n    ( \n        .clk(clock), \n        .opa(in1), \n        .opb(reg6), \n        .out(add3), \n        .control(add3_control) \n    );\n\n    wire [7:0] x3_control;\n    fpu_mul x3_mul\n    ( \n        .clk(clock), \n        .opa(in3), \n        .opb(in1), \n        .out(x3), \n        .control(x3_control) \n    );\n\n    wire [7:0] add4_control;\n    fpu_add add4_add\n    ( \n        .clk(clock), \n        .opa(in5), \n        .opb(in3), \n        .out(add4), \n        .control(add4_control) \n    );\n\n    wire [7:0] x4_control;\n    fpu_mul x4_mul\n    ( \n        .clk(clock), \n        .opa(in5), \n        .opb(in4), \n        .out(x4), \n        .control(x4_control) \n    );\n\n    wire [7:0] add5_control;\n    fpu_add add5_add\n    ( \n        .clk(clock), \n        .opa(in5), \n        .opb(in4), \n        .out(add5), \n        .control(add5_control) \n    );\n\n    assign out_1 = x2;\n    assign out_2 = add3;\n    assign out_3 = add4;\n    assign out_4 = x4;\n\n    always @(posedge clock)\n    begin\n        reg1 <= in2;\n        reg2 <= reg1;\n        reg3 <= reg2;\n        reg4 <= reg3;\n        reg5 <= reg4;\n        reg6 <= reg5;\n    end\n\nendmodule"}
{"task_id": 1377, "completion": "// \u6570\u636e\u5b58\u50a8\u7528\u7684\u5185\u5b58 \n    localparam ADDR_WIDTH = $clog2(FIFO_DEPTH); \n    reg [RELATION_WIDTH-1:0] mem [0:FIFO_DEPTH-1]; \n    reg [ADDR_WIDTH:0] wr_ptr; \n    reg [ADDR_WIDTH:0] rd_ptr; \n    reg [ADDR_WIDTH:0] ptr_diff;\n\n    // FIFO \u7a7a/\u6ee1\u6807\u5fd7 \n    assign empty = (wr_ptr == rd_ptr); \n    assign full = (wr_ptr[ADDR_WIDTH-1:0] == rd_ptr[ADDR_WIDTH-1:0]) && (wr_ptr[ADDR_WIDTH] != rd_ptr[ADDR_WIDTH]);\n\n    // \u6570\u636e\u8f93\u51fa \n    assign data_out = mem[rd_ptr[ADDR_WIDTH-1:0]]; \n\n    // \u5199\u64cd\u4f5c \n    always @(posedge clk or negedge rst_n) begin \n        if (!rst_n) begin \n            wr_ptr <= 0; \n        end else if (wr_en && !full) begin \n            mem[wr_ptr[ADDR_WIDTH-1:0]] <= data_in; \n            wr_ptr <= wr_ptr + 1; \n        end \n    end \n\n    // \u8bfb\u64cd\u4f5c \n    always @(posedge clk or negedge rst_n) begin \n        if (!rst_n) begin \n            rd_ptr <= 0; \n        end else if (rd_en && !empty) begin \n            rd_ptr <= rd_ptr + 1; \n        end \n    end \n\nendmodule"}
{"task_id": 1255, "completion": "wire [0:0] sub_wire0;\n    wire [0:0] sub_wire1;\n    wire [0:0] sub_wire2;\n    wire [0:0] sub_wire3;\n    wire [0:0] sub_wire4;\n    wire [0:0] sub_wire5;\n    wire [0:0] sub_wire6;\n    wire [0:0] sub_wire7;\n    wire [2:0] sub_wire8;\n    wire [0:0] sub_wire9;\n    wire [0:0] sub_wire10;\n    wire [0:0] sub_wire11;\n    wire [7:0] sub_wire12;\n    wire [0:0] rx_patterndetect = sub_wire0[0:0];\n    wire [0:0] rx_ctrldetect = sub_wire1[0:0];\n    wire [0:0] pipedatavalid = sub_wire2[0:0];\n    wire [0:0] pipephydonestatus = sub_wire3[0:0];\n    wire [0:0] rx_pll_locked = sub_wire4[0:0];\n    wire [0:0] rx_freqlocked = sub_wire5[0:0];\n    wire [0:0] tx_dataout = sub_wire6[0:0];\n    wire [0:0] pipeelecidle = sub_wire7[0:0];\n    wire [2:0] pipestatus = sub_wire8[2:0];\n    wire [0:0] rx_syncstatus = sub_wire9[0:0];\n    wire [0:0] tx_clkout = sub_wire10[0:0];\n    wire [0:0] pll_locked = sub_wire11[0:0];\n    wire [7:0] rx_dataout = sub_wire12[7:0];\n\n    altpcie_serdes_2agx_x1d_gen1_08p_alt4gxb_sp59 altpcie_serdes_2agx_x1d_gen1_08p_alt4gxb_sp59_component (\n                .tx_forceelecidle (tx_forceelecidle),\n                .pll_inclk (pll_inclk),\n                .gxb_powerdown (gxb_powerdown),\n                .tx_datain (tx_datain),\n                .rx_cruclk (rx_cruclk),\n                .cal_blk_clk (cal_blk_clk),\n                .powerdn (powerdn),\n                .rx_datain (rx_datain),\n                .tx_ctrlenable (tx_ctrlenable),\n                .rx_analogreset (rx_analogreset),\n                .pipe8b10binvpolarity (pipe8b10binvpolarity),\n                .rx_digitalreset (rx_digitalreset),\n                .tx_digitalreset (tx_digitalreset),\n                .tx_forcedispcompliance (tx_forcedispcompliance),\n                .tx_detectrxloop (tx_detectrxloop),\n                .rx_patterndetect (sub_wire0),\n                .rx_ctrldetect (sub_wire1),\n                .pipedatavalid (sub_wire2),\n                .pipephydonestatus (sub_wire3),\n                .rx_pll_locked (sub_wire4),\n                .rx_freqlocked (sub_wire5),\n                .tx_dataout (sub_wire6),\n                .pipeelecidle (sub_wire7),\n                .pipestatus (sub_wire8),\n                .rx_syncstatus (sub_wire9),\n                .tx_clkout (sub_wire10),\n                .pll_locked (sub_wire11),\n                .rx_dataout (sub_wire12));\n\nendmodule"}
{"task_id": 1430, "completion": "wire [2*SW-1:0] Result;\n\n    generate\n     if (Opt_FPGA_ASIC) begin : KOA_FPGA\n        KOA_FPGA #(.SW(SW)) main_KOA(\n                .Data_A_i(Data_A_i[SW-1:0]),\n                .Data_B_i(Data_B_i[SW-1:0]),\n                .sgf_result_o(Result[2*SW-1:0])\n            );\n     end else begin  : KOA_ASIC\n            KOA_c #(.SW(SW), .precision(0), .depth(1)) main_KOA(\n                .Data_A_i(Data_A_i[SW-1:0]),\n                .Data_B_i(Data_B_i[SW-1:0]),\n                .sgf_result_o(Result[2*SW-1:0])\n            );\n         end\n    endgenerate\n\n    RegisterAdd #(.W(2*SW)) finalreg (\n                .clk(clk), \n                .rst(rst), \n                .load(load_b_i), \n                .D(Result[2*SW-1:0]), \n                .Q({sgf_result_o[2*SW-1:0]})\n            );\nendmodule"}
{"task_id": 1465, "completion": "reg [DATA_WIDTH-1:0] ram [(2**ADDR_WIDTH)-1:0];\n    reg ack;\n    assign ack_o = ack;\n    assign dat_o = ram[adr_i];\n\n    always @(posedge clk) begin\n        if (stb_i && cyc_i) begin\n            ack <= 1;\n            if (we_i) begin\n                ram[adr_i] <= dat_i;\n            end\n        end else begin\n            ack <= 0;\n        end\n    end\nendmodule"}
{"task_id": 1461, "completion": "integer n = 0;\n    assign even = (n % 2 == 0);\nendmodule"}
{"task_id": 52, "completion": "/////////////////////////////////////////////////////////////////////////////\n  // Functions\n  /////////////////////////////////////////////////////////////////////////////\n  \n  /////////////////////////////////////////////////////////////////////////////\n  // Local params\n  /////////////////////////////////////////////////////////////////////////////\n  \n  /////////////////////////////////////////////////////////////////////////////\n  // Variables for generating parameter controlled instances.\n  /////////////////////////////////////////////////////////////////////////////\n  \n  /////////////////////////////////////////////////////////////////////////////\n  // Internal signals\n  /////////////////////////////////////////////////////////////////////////////\n  \n  /////////////////////////////////////////////////////////////////////////////\n  // Handle Write Channels (AW/W/B)\n  /////////////////////////////////////////////////////////////////////////////\n  generate\n    if (C_AXI_SUPPORTS_WRITE == 1) begin : USE_WRITE\n      wire                              wr_cmd_valid;\n      wire [C_AXI_ID_WIDTH-1:0]         wr_cmd_id;\n      wire [4-1:0]                      wr_cmd_length;\n      wire                              wr_cmd_ready;\n      wire                              wr_cmd_b_valid;\n      wire                              wr_cmd_b_split;\n      wire [4-1:0]                      wr_cmd_b_repeat;\n      wire                              wr_cmd_b_ready;\n      axi_protocol_converter_v2_1_a_axi3_conv #\n      (\n       .C_FAMILY                    (C_FAMILY),\n       .C_AXI_ID_WIDTH              (C_AXI_ID_WIDTH),\n       .C_AXI_ADDR_WIDTH            (C_AXI_ADDR_WIDTH),\n       .C_AXI_DATA_WIDTH            (C_AXI_DATA_WIDTH),\n       .C_AXI_SUPPORTS_USER_SIGNALS (C_AXI_SUPPORTS_USER_SIGNALS),\n       .C_AXI_AUSER_WIDTH           (C_AXI_AWUSER_WIDTH),\n       .C_AXI_CHANNEL               (0),\n       .C_SUPPORT_SPLITTING         (C_SUPPORT_SPLITTING),\n       .C_SUPPORT_BURSTS            (C_SUPPORT_BURSTS),\n       .C_SINGLE_THREAD             (C_SINGLE_THREAD)\n        ) write_addr_inst\n       (\n        .ARESET                     (~ARESETN),\n        .ACLK                       (ACLK),\n        .cmd_valid                  (wr_cmd_valid),\n        .cmd_split                  (),\n        .cmd_id                     (wr_cmd_id),\n        .cmd_length                 (wr_cmd_length),\n        .cmd_ready                  (wr_cmd_ready),\n        .cmd_b_valid                (wr_cmd_b_valid),\n        .cmd_b_split                (wr_cmd_b_split),\n        .cmd_b_ready                (wr_cmd_b_ready),\n        .S_AXI_AID                  (S_AXI_AWID),\n        .S_AXI_AADDR                (S_AXI_AWADDR),\n        .S_AXI_ALEN                 (S_AXI_AWLEN),\n        .S_AXI_ASIZE                (S_AXI_AWSIZE),\n        .S_AXI_ABURST               (S_AXI_AWBURST),\n        .S_AXI_ALOCK                (S_AXI_AWLOCK),\n        .S_AXI_ACACHE               (S_AXI_AWCACHE),\n        .S_AXI_APROT                (S_AXI_AWPROT),\n        .S_AXI_AQOS                 (S_AXI_AWQOS),\n        .S_AXI_AUSER                (S_AXI_AWUSER),\n        .S_AXI_AVALID               (S_AXI_AWVALID),\n        .S_AXI_AREADY               (S_AXI_AWREADY),\n        .M_AXI_AID                  (M_AXI_AWID),\n        .M_AXI_AADDR                (M_AXI_AWADDR),\n        .M_AXI_ALEN                 (M_AXI_AWLEN),\n        .M_AXI_ASIZE                (M_AXI_AWSIZE),\n        .M_AXI_ABURST               (M_AXI_AWBURST),\n        .M_AXI_ALOCK                (M_AXI_AWLOCK),\n        .M_AXI_ACACHE               (M_AXI_AWCACHE),\n        .M_AXI_APROT                (M_AXI_AWPROT),\n        .M_AXI_AQOS                 (M_AXI_AWQOS),\n        .M_AXI_AUSER                (M_AXI_AWUSER),\n        .M_AXI_AVALID               (M_AXI_AWVALID),\n        .M_AXI_AREADY               (M_AXI_AWREADY)\n       );\n      axi_protocol_converter_v2_1_w_axi3_conv #\n      (\n       .C_FAMILY                    (C_FAMILY),\n       .C_AXI_ID_WIDTH              (C_AXI_ID_WIDTH),\n       .C_AXI_DATA_WIDTH            (C_AXI_DATA_WIDTH),\n       .C_AXI_SUPPORTS_USER_SIGNALS (C_AXI_SUPPORTS_USER_SIGNALS),\n       .C_AXI_WUSER_WIDTH           (C_AXI_WUSER_WIDTH),\n       .C_SUPPORT_SPLITTING         (C_SUPPORT_SPLITTING),\n       .C_SUPPORT_BURSTS            (C_SUPPORT_BURSTS)\n        ) write_data_inst\n       (\n        .ARESET                     (~ARESETN),\n        .ACLK                       (ACLK),\n        .cmd_valid                  (wr_cmd_valid),\n        .cmd_id                     (wr_cmd_id),\n        .cmd_length                 (wr_cmd_length),\n        .cmd_ready                  (wr_cmd_ready),\n        .S_AXI_WDATA                (S_AXI_WDATA),\n        .S_AXI_WSTRB                (S_AXI_WSTRB),\n        .S_AXI_WLAST                (S_AXI_WLAST),\n        .S_AXI_WUSER                (S_AXI_WUSER),\n        .S_AXI_WVALID               (S_AXI_WVALID),\n        .S_AXI_WREADY               (S_AXI_WREADY),\n        .M_AXI_WID                  (M_AXI_WID),\n        .M_AXI_WDATA                (M_AXI_WDATA),\n        .M_AXI_WSTRB                (M_AXI_WSTRB),\n        .M_AXI_WLAST                (M_AXI_WLAST),\n        .M_AXI_WUSER                (M_AXI_WUSER),\n        .M_AXI_WVALID               (M_AXI_WVALID),\n        .M_AXI_WREADY               (M_AXI_WREADY)\n       );\n      if ( C_SUPPORT_SPLITTING == 1 && C_SUPPORT_BURSTS == 1 ) begin : USE_SPLIT_W\n        axi_protocol_converter_v2_1_b_downsizer #\n        (\n         .C_FAMILY                    (C_FAMILY),\n         .C_AXI_ID_WIDTH              (C_AXI_ID_WIDTH),\n         .C_AXI_SUPPORTS_USER_SIGNALS (C_AXI_SUPPORTS_USER_SIGNALS),\n         .C_AXI_BUSER_WIDTH           (C_AXI_BUSER_WIDTH)\n          ) write_resp_inst\n         (\n          .ARESET                     (~ARESETN),\n          .ACLK                       (ACLK),\n          .cmd_valid                  (wr_cmd_b_valid),\n          .cmd_split                  (wr_cmd_b_split),\n          .cmd_repeat                 (wr_cmd_b_repeat),\n          .cmd_ready                  (wr_cmd_b_ready),\n          .S_AXI_BID                  (S_AXI_BID),\n          .S_AXI_BRESP                (S_AXI_BRESP),\n          .S_AXI_BUSER                (S_AXI_BUSER),\n          .S_AXI_BVALID               (S_AXI_BVALID),\n          .S_AXI_BREADY               (S_AXI_BREADY),\n          .M_AXI_BID                  (M_AXI_BID),\n          .M_AXI_BRESP                (M_AXI_BRESP),\n          .M_AXI_BUSER                (M_AXI_BUSER),\n          .M_AXI_BVALID               (M_AXI_BVALID),\n          .M_AXI_BREADY               (M_AXI_BREADY)\n         );\n      end else begin : NO_SPLIT_W\n        assign S_AXI_BID      = M_AXI_BID;\n        assign S_AXI_BRESP    = M_AXI_BRESP;\n        assign S_AXI_BUSER    = M_AXI_BUSER;\n        assign S_AXI_BVALID   = M_AXI_BVALID;\n        assign M_AXI_BREADY   = S_AXI_BREADY;\n      end\n    end else begin : NO_WRITE\n      assign S_AXI_AWREADY = 1'b0;\n      assign S_AXI_WREADY  = 1'b0;\n      assign S_AXI_BID     = {C_AXI_ID_WIDTH{1'b0}};\n      assign S_AXI_BRESP   = 2'b0;\n      assign S_AXI_BUSER   = {C_AXI_BUSER_WIDTH{1'b0}};\n      assign S_AXI_BVALID  = 1'b0;\n      assign M_AXI_AWID    = {C_AXI_ID_WIDTH{1'b0}};\n      assign M_AXI_AWADDR  = {C_AXI_ADDR_WIDTH{1'b0}};\n      assign M_AXI_AWLEN   = 4'b0;\n      assign M_AXI_AWSIZE  = 3'b0;\n      assign M_AXI_AWBURST = 2'b0;\n      assign M_AXI_AWLOCK  = 2'b0;\n      assign M_AXI_AWCACHE = 4'b0;\n      assign M_AXI_AWPROT  = 3'b0;\n      assign M_AXI_AWQOS   = 4'b0;\n      assign M_AXI_AWUSER  = {C_AXI_AWUSER_WIDTH{1'b0}};\n      assign M_AXI_AWVALID = 1'b0;\n      assign M_AXI_WDATA   = {C_AXI_DATA_WIDTH{1'b0}};\n      assign M_AXI_WSTRB   = {C_AXI_DATA_WIDTH/8{1'b0}};\n      assign M_AXI_WLAST   = 1'b0;\n      assign M_AXI_WUSER   = {C_AXI_WUSER_WIDTH{1'b0}};\n      assign M_AXI_WVALID  = 1'b0;\n      assign M_AXI_BREADY  = 1'b0;\n    end\n  endgenerate\n  /////////////////////////////////////////////////////////////////////////////\n  // Handle Read Channels (AR/R)\n  /////////////////////////////////////////////////////////////////////////////\n  generate\n    if (C_AXI_SUPPORTS_READ == 1) begin : USE_READ\n      if ( C_SUPPORT_SPLITTING == 1 && C_SUPPORT_BURSTS == 1 ) begin : USE_SPLIT_R\n        wire                              rd_cmd_valid;\n        wire                              rd_cmd_split;\n        wire                              rd_cmd_ready;\n        axi_protocol_converter_v2_1_a_axi3_conv #\n        (\n         .C_FAMILY                    (C_FAMILY),\n         .C_AXI_ID_WIDTH              (C_AXI_ID_WIDTH),\n         .C_AXI_ADDR_WIDTH            (C_AXI_ADDR_WIDTH),\n         .C_AXI_DATA_WIDTH            (C_AXI_DATA_WIDTH),\n         .C_AXI_SUPPORTS_USER_SIGNALS (C_AXI_SUPPORTS_USER_SIGNALS),\n         .C_AXI_AUSER_WIDTH           (C_AXI_ARUSER_WIDTH),\n         .C_AXI_CHANNEL               (1),\n         .C_SUPPORT_SPLITTING         (C_SUPPORT_SPLITTING),\n         .C_SUPPORT_BURSTS            (C_SUPPORT_BURSTS),\n         .C_SINGLE_THREAD             (C_SINGLE_THREAD)\n          ) read_addr_inst\n         (\n          .ARESET                     (~ARESETN),\n          .ACLK                       (ACLK),\n          .cmd_valid                  (rd_cmd_valid),\n          .cmd_split                  (rd_cmd_split),\n          .cmd_ready                  (rd_cmd_ready),\n          .S_AXI_AID                  (S_AXI_ARID),\n          .S_AXI_AADDR                (S_AXI_ARADDR),\n          .S_AXI_ALEN                 (S_AXI_ARLEN),\n          .S_AXI_ASIZE                (S_AXI_ARSIZE),\n          .S_AXI_ABURST               (S_AXI_ARBURST),\n          .S_AXI_ALOCK                (S_AXI_ARLOCK),\n          .S_AXI_ACACHE               (S_AXI_ARCACHE),\n          .S_AXI_APROT                (S_AXI_ARPROT),\n          .S_AXI_AQOS                 (S_AXI_ARQOS),\n          .S_AXI_AUSER                (S_AXI_ARUSER),\n          .S_AXI_AVALID               (S_AXI_ARVALID),\n          .S_AXI_AREADY               (S_AXI_ARREADY),\n          .M_AXI_AID                  (M_AXI_ARID),\n          .M_AXI_AADDR                (M_AXI_ARADDR),\n          .M_AXI_ALEN                 (M_AXI_ARLEN),\n          .M_AXI_ASIZE                (M_AXI_ARSIZE),\n          .M_AXI_ABURST               (M_AXI_ARBURST),\n          .M_AXI_ALOCK                (M_AXI_ARLOCK),\n          .M_AXI_ACACHE               (M_AXI_ARCACHE),\n          .M_AXI_APROT                (M_AXI_ARPROT),\n          .M_AXI_AQOS                 (M_AXI_ARQOS),\n          .M_AXI_AUSER                (M_AXI_ARUSER),\n          .M_AXI_AVALID               (M_AXI_ARVALID),\n          .M_AXI_AREADY               (M_AXI_ARREADY)\n         );\n         axi_protocol_converter_v2_1_r_axi3_conv #\n        (\n         .C_FAMILY                    (C_FAMILY),\n         .C_AXI_ID_WIDTH              (C_AXI_ID_WIDTH),\n         .C_AXI_DATA_WIDTH            (C_AXI_DATA_WIDTH),\n         .C_AXI_SUPPORTS_USER_SIGNALS (C_AXI_SUPPORTS_USER_SIGNALS),\n         .C_AXI_RUSER_WIDTH           (C_AXI_RUSER_WIDTH),\n         .C_SUPPORT_SPLITTING         (C_SUPPORT_SPLITTING),\n         .C_SUPPORT_BURSTS            (C_SUPPORT_BURSTS)\n          ) read_data_inst\n         (\n          .ARESET                     (~ARESETN),\n          .ACLK                       (ACLK),\n          .cmd_valid                  (rd_cmd_valid),\n          .cmd_split                  (rd_cmd_split),\n          .cmd_ready                  (rd_cmd_ready),\n          .S_AXI_RID                  (S_AXI_RID),\n          .S_AXI_RDATA                (S_AXI_RDATA),\n          .S_AXI_RRESP                (S_AXI_RRESP),\n          .S_AXI_RLAST                (S_AXI_RLAST),\n          .S_AXI_RUSER                (S_AXI_RUSER),\n          .S_AXI_RVALID               (S_AXI_RVALID),\n          .S_AXI_RREADY               (S_AXI_RREADY),\n          .M_AXI_RID                  (M_AXI_RID),\n          .M_AXI_RDATA                (M_AXI_RDATA),\n          .M_AXI_RRESP                (M_AXI_RRESP),\n          .M_AXI_RLAST                (M_AXI_RLAST),\n          .M_AXI_RUSER                (M_AXI_RUSER),\n          .M_AXI_RVALID               (M_AXI_RVALID),\n          .M_AXI_RREADY               (M_AXI_RREADY)\n         );\n      end else begin : NO_SPLIT_R\n        assign M_AXI_ARID     = S_AXI_ARID;\n        assign M_AXI_ARADDR   = S_AXI_ARADDR;\n        assign M_AXI_ARLEN    = S_AXI_ARLEN;\n        assign M_AXI_ARSIZE   = S_AXI_ARSIZE;\n        assign M_AXI_ARBURST  = S_AXI_ARBURST;\n        assign M_AXI_ARLOCK   = S_AXI_ARLOCK;\n        assign M_AXI_ARCACHE  = S_AXI_ARCACHE;\n        assign M_AXI_ARPROT   = S_AXI_ARPROT;\n        assign M_AXI_ARQOS    = S_AXI_ARQOS;\n        assign M_AXI_ARUSER   = S_AXI_ARUSER;\n        assign M_AXI_ARVALID  = S_AXI_ARVALID;\n        assign S_AXI_ARREADY  = M_AXI_ARREADY;\n        assign S_AXI_RID      = M_AXI_RID;\n        assign S_AXI_RDATA    = M_AXI_RDATA;\n        assign S_AXI_RRESP    = M_AXI_RRESP;\n        assign S_AXI_RLAST    = M_AXI_RLAST;\n        assign S_AXI_RUSER    = M_AXI_RUSER;\n        assign S_AXI_RVALID   = M_AXI_RVALID;\n        assign M_AXI_RREADY   = S_AXI_RREADY;\n      end\n    end else begin : NO_READ\n      assign S_AXI_ARREADY = 1'b0;\n      assign S_AXI_RID     = {C_AXI_ID_WIDTH{1'b0}};\n      assign S_AXI_RDATA   = {C_AXI_DATA_WIDTH{1'b0}};\n      assign S_AXI_RRESP   = 2'b0;\n      assign S_AXI_RLAST   = 1'b0;\n      assign S_AXI_RUSER   = {C_AXI_RUSER_WIDTH{1'b0}};\n      assign S_AXI_RVALID  = 1'b0;\n      assign M_AXI_ARID    = {C_AXI_ID_WIDTH{1'b0}};\n      assign M_AXI_ARADDR  = {C_AXI_ADDR_WIDTH{1'b0}};\n      assign M_AXI_ARLEN   = 4'b0;\n      assign M_AXI_ARSIZE  = 3'b0;\n      assign M_AXI_ARBURST = 2'b0;\n      assign M_AXI_ARLOCK  = 2'b0;\n      assign M_AXI_ARCACHE = 4'b0;\n      assign M_AXI_ARPROT  = 3'b0;\n      assign M_AXI_ARQOS   = 4'b0;\n      assign M_AXI_ARUSER  = {C_AXI_ARUSER_WIDTH{1'b0}};\n      assign M_AXI_ARVALID = 1'b0;\n      assign M_AXI_RREADY  = 1'b0;\n    end\n  endgenerate\nendmodule"}
{"task_id": 299, "completion": "bd_350b inst (\n    .clk(clk),\n    .SLOT_0_AXI_awaddr(SLOT_0_AXI_awaddr),\n    .SLOT_0_AXI_awvalid(SLOT_0_AXI_awvalid),\n    .SLOT_0_AXI_awready(SLOT_0_AXI_awready),\n    .SLOT_0_AXI_wdata(SLOT_0_AXI_wdata),\n    .SLOT_0_AXI_wstrb(SLOT_0_AXI_wstrb),\n    .SLOT_0_AXI_wvalid(SLOT_0_AXI_wvalid),\n    .SLOT_0_AXI_wready(SLOT_0_AXI_wready),\n    .SLOT_0_AXI_bresp(SLOT_0_AXI_bresp),\n    .SLOT_0_AXI_bvalid(SLOT_0_AXI_bvalid),\n    .SLOT_0_AXI_bready(SLOT_0_AXI_bready),\n    .SLOT_0_AXI_araddr(SLOT_0_AXI_araddr),\n    .SLOT_0_AXI_arvalid(SLOT_0_AXI_arvalid),\n    .SLOT_0_AXI_arready(SLOT_0_AXI_arready),\n    .SLOT_0_AXI_rdata(SLOT_0_AXI_rdata),\n    .SLOT_0_AXI_rresp(SLOT_0_AXI_rresp),\n    .SLOT_0_AXI_rvalid(SLOT_0_AXI_rvalid),\n    .SLOT_0_AXI_rready(SLOT_0_AXI_rready),\n    .SLOT_1_GPIO_tri_o(SLOT_1_GPIO_tri_o),\n    .SLOT_2_AXI_awid(SLOT_2_AXI_awid),\n    .SLOT_2_AXI_awaddr(SLOT_2_AXI_awaddr),\n    .SLOT_2_AXI_awlen(SLOT_2_AXI_awlen),\n    .SLOT_2_AXI_awsize(SLOT_2_AXI_awsize),\n    .SLOT_2_AXI_awburst(SLOT_2_AXI_awburst),\n    .SLOT_2_AXI_awlock(SLOT_2_AXI_awlock),\n    .SLOT_2_AXI_awcache(SLOT_2_AXI_awcache),\n    .SLOT_2_AXI_awprot(SLOT_2_AXI_awprot),\n    .SLOT_2_AXI_awqos(SLOT_2_AXI_awqos),\n    .SLOT_2_AXI_awvalid(SLOT_2_AXI_awvalid),\n    .SLOT_2_AXI_awready(SLOT_2_AXI_awready),\n    .SLOT_2_AXI_wdata(SLOT_2_AXI_wdata),\n    .SLOT_2_AXI_wstrb(SLOT_2_AXI_wstrb),\n    .SLOT_2_AXI_wlast(SLOT_2_AXI_wlast),\n    .SLOT_2_AXI_wvalid(SLOT_2_AXI_wvalid),\n    .SLOT_2_AXI_wready(SLOT_2_AXI_wready),\n    .SLOT_2_AXI_bid(SLOT_2_AXI_bid),\n    .SLOT_2_AXI_bresp(SLOT_2_AXI_bresp),\n    .SLOT_2_AXI_bvalid(SLOT_2_AXI_bvalid),\n    .SLOT_2_AXI_bready(SLOT_2_AXI_bready),\n    .SLOT_2_AXI_arid(SLOT_2_AXI_arid),\n    .SLOT_2_AXI_araddr(SLOT_2_AXI_araddr),\n    .SLOT_2_AXI_arlen(SLOT_2_AXI_arlen),\n    .SLOT_2_AXI_arsize(SLOT_2_AXI_arsize),\n    .SLOT_2_AXI_arburst(SLOT_2_AXI_arburst),\n    .SLOT_2_AXI_arlock(SLOT_2_AXI_arlock),\n    .SLOT_2_AXI_arcache(SLOT_2_AXI_arcache),\n    .SLOT_2_AXI_arprot(SLOT_2_AXI_arprot),\n    .SLOT_2_AXI_arqos(SLOT_2_AXI_arqos),\n    .SLOT_2_AXI_arvalid(SLOT_2_AXI_arvalid),\n    .SLOT_2_AXI_arready(SLOT_2_AXI_arready),\n    .SLOT_2_AXI_rid(SLOT_2_AXI_rid),\n    .SLOT_2_AXI_rdata(SLOT_2_AXI_rdata),\n    .SLOT_2_AXI_rresp(SLOT_2_AXI_rresp),\n    .SLOT_2_AXI_rlast(SLOT_2_AXI_rlast),\n    .SLOT_2_AXI_rvalid(SLOT_2_AXI_rvalid),\n    .SLOT_2_AXI_rready(SLOT_2_AXI_rready),\n    .resetn(resetn),\n    .TRIG_IN_trig(TRIG_IN_trig),\n    .TRIG_IN_ack(TRIG_IN_ack),\n    .TRIG_OUT_trig(TRIG_OUT_trig),\n    .TRIG_OUT_ack(TRIG_OUT_ack)\n  );\nendmodule"}
{"task_id": 1408, "completion": "input [ADDR_WIDTH-1:0] app_addr;\n  localparam ADDR_WIDTH = RANK_WIDTH + BANK_WIDTH + ROW_WIDTH + COL_WIDTH;\n  localparam CWL_M = (REG_CTRL == \"ON\") ? CWL + 1 : CWL;\n  input app_correct_en;\n  output wire correct_en;\n  assign correct_en = app_correct_en;\n  input app_sr_req;\n  output wire sr_req;\n  assign sr_req = app_sr_req;\n  input sr_active;\n  output wire app_sr_active;\n  assign app_sr_active = sr_active;\n  input app_ref_req;\n  output wire ref_req;\n  assign ref_req = app_ref_req;\n  input ref_ack;\n  output wire app_ref_ack;\n  assign app_ref_ack = ref_ack;\n  input app_zq_req;\n  output wire zq_req;\n  assign zq_req = app_zq_req;\n  input zq_ack;\n  output wire app_zq_ack;\n  assign app_zq_ack = zq_ack;\n  generate\n    if(DATA_BUF_ADDR_WIDTH > 4) begin\n      assign wr_data_buf_addr[DATA_BUF_ADDR_WIDTH-1:4] = 0;\n    end\n  endgenerate\n  mig_7series_v1_8_ui_cmd #(/*AUTOINSTPARAM*/)\n    ui_cmd0(/*AUTOINST*/);\n  mig_7series_v1_8_ui_wr_data #(/*AUTOINSTPARAM*/)\n    ui_wr_data0(/*AUTOINST*/);\n  mig_7series_v1_8_ui_rd_data #(/*AUTOINSTPARAM*/)\n    ui_rd_data0(/*AUTOINST*/);\nendmodule"}
{"task_id": 1180, "completion": "reg [5:0] rd_buf_indx_r;  reg ram_init_done_r_lcl;  assign ram_init_done_r = ram_init_done_r_lcl;  wire app_rd_data_valid_ns;  wire single_data;  reg [5:0] rd_buf_indx_ns;  generate begin : rd_buf_indx    wire upd_rd_buf_indx = ~ram_init_done_r_lcl || app_rd_data_valid_ns;    wire ram_init_done_ns = ~rst && (ram_init_done_r_lcl || (rd_buf_indx_r[4:0] == 5'h1f));    always @(posedge clk) ram_init_done_r_lcl <= #TCQ ram_init_done_ns;    always @(/*AS*/rd_buf_indx_r or rst or single_data or upd_rd_buf_indx) begin      rd_buf_indx_ns = rd_buf_indx_r;      if (rst) rd_buf_indx_ns = 6'b0;      else if (upd_rd_buf_indx) rd_buf_indx_ns = rd_buf_indx_r + 6'h1 + single_data;    end    always @(posedge clk) rd_buf_indx_r <= #TCQ rd_buf_indx_ns;  end  endgenerate  assign ram_init_addr = rd_buf_indx_r[3:0];  localparam RD_BUF_WIDTH = APP_DATA_WIDTH + (ECC == \"OFF\" ? 0 : 4);  localparam FULL_RAM_CNT = (RD_BUF_WIDTH/6);  localparam REMAINDER = RD_BUF_WIDTH % 6;  localparam RAM_CNT = FULL_RAM_CNT + ((REMAINDER == 0 ) ? 0 : 1);  localparam RAM_WIDTH = (RAM_CNT*6);  generate    if (ORDERING == \"STRICT\") begin : strict_mode      assign app_rd_data_valid_ns = 1'b0;      assign single_data = 1'b0;      assign rd_buf_full = 1'b0;      reg [3:0] rd_data_buf_addr_r_lcl;      wire [3:0] rd_data_buf_addr_ns = rst ? 4'b0 : rd_data_buf_addr_r_lcl + {3'b0, rd_accepted};      always @(posedge clk) rd_data_buf_addr_r_lcl <= #TCQ rd_data_buf_addr_ns;      assign rd_data_buf_addr_r = rd_data_buf_addr_ns;      if (ECC == \"OFF\") begin : ecc_off        always @(/*AS*/rd_data) app_rd_data = rd_data;        always @(/*AS*/rd_data_en) app_rd_data_valid = rd_data_en;        always @(/*AS*/rd_data_end) app_rd_data_end = rd_data_end;      end else begin : ecc_on        always @(posedge clk) app_rd_data <= #TCQ rd_data;        always @(posedge clk) app_rd_data_valid <= #TCQ rd_data_en;        always @(posedge clk) app_rd_data_end <= #TCQ rd_data_end;        always @(posedge clk) app_ecc_multiple_err_r <= #TCQ ecc_multiple;      end    end else begin : not_strict_mode      wire rd_buf_we = ~ram_init_done_r_lcl || rd_data_en;      wire [4:0] rd_buf_wr_addr = {rd_data_addr, rd_data_offset};      wire [1:0] rd_status;      begin : status_ram        wire [4:0] status_ram_wr_addr_ns = ram_init_done_r_lcl ? rd_buf_wr_addr : rd_buf_indx_r[4:0];        reg [4:0] status_ram_wr_addr_r;        always @(posedge clk) status_ram_wr_addr_r <= #TCQ status_ram_wr_addr_ns;        wire [1:0] wr_status;        reg wr_status_r1;        always @(posedge clk) wr_status_r1 <= #TCQ wr_status[0];        wire [1:0] status_ram_wr_data_ns =                ram_init_done_r_lcl                  ? {rd_data_end, ~(rd_data_offset ? wr_status_r1 : wr_status[0])}                  : 2'b0;        reg [1:0] status_ram_wr_data_r;        always @(posedge clk) status_ram_wr_data_r <= #TCQ status_ram_wr_data_ns;        reg rd_buf_we_r1;        always @(posedge clk) rd_buf_we_r1 <= #TCQ rd_buf_we;        RAM32M #(.INIT_A(64'h0000000000000000), .INIT_B(64'h0000000000000000), .INIT_C(64'h0000000000000000), .INIT_D(64'h0000000000000000)) RAM32M0 (          .DOA(rd_status),          .DIA(status_ram_wr_data_r),          .ADDRA(rd_buf_indx_r[4:0]),          .WE(rd_buf_we_r1),          .WCLK(clk)        );      end      wire [RAM_WIDTH-1:0] rd_buf_out_data;      begin : rd_buf        wire [RAM_WIDTH-1:0] rd_buf_in_data;        if (REMAINDER == 0)          if (ECC == \"OFF\")            assign rd_buf_in_data = rd_data;          else            assign rd_buf_in_data = {ecc_multiple, rd_data};        else          if (ECC == \"OFF\")            assign rd_buf_in_data = {{6-REMAINDER{1'b0}}, rd_data};          else            assign rd_buf_in_data = {{6-REMAINDER{1'b0}}, ecc_multiple, rd_data};        (* equivalent_register_removal = \"no\" *)        reg [4:0] rd_buf_indx_copy_r;        always @(posedge clk) rd_buf_indx_copy_r <= #TCQ rd_buf_indx_ns[4:0];        genvar i;        for (i=0; i<RAM_CNT; i=i+1) begin : rd_buffer_ram          RAM32M #(.INIT_A(64'h0000000000000000), .INIT_B(64'h0000000000000000), .INIT_C(64'h0000000000000000), .INIT_D(64'h0000000000000000)) RAM32M0 (            .DOA(rd_buf_out_data[((i*6)+4)+:2]),            .DIA(rd_buf_in_data[((i*6)+4)+:2]),            .ADDRA(rd_buf_indx_copy_r[4:0]),            .WE(rd_buf_we),            .WCLK(clk)          );        end      end      wire rd_data_rdy = (rd_status[0] == rd_buf_indx_r[5]);      wire bypass = rd_data_en && (rd_buf_wr_addr[4:0] == rd_buf_indx_r[4:0]);      assign app_rd_data_valid_ns = ram_init_done_r_lcl && (bypass || rd_data_rdy);      wire app_rd_data_end_ns = bypass ? rd_data_end : rd_status[1];      always @(posedge clk) app_rd_data_valid <= #TCQ app_rd_data_valid_ns;      always @(posedge clk) app_rd_data_end <= #TCQ app_rd_data_end_ns;      assign single_data = app_rd_data_valid_ns && app_rd_data_end_ns && ~rd_buf_indx_r[0];      wire [APP_DATA_WIDTH-1:0] app_rd_data_ns = bypass ? rd_data : rd_buf_out_data[APP_DATA_WIDTH-1:0];      always @(posedge clk) app_rd_data <= #TCQ app_rd_data_ns;      if (ECC != \"OFF\") begin : assign_app_ecc_multiple        wire [3:0] app_ecc_multiple_err_ns = bypass ? ecc_multiple : rd_buf_out_data[APP_DATA_WIDTH+:4];        always @(posedge clk) app_ecc_multiple_err_r <= #TCQ app_ecc_multiple_err_ns;      end      (* equivalent_register_removal = \"no\" *)      reg app_rd_data_valid_copy;      always @(posedge clk) app_rd_data_valid_copy <= #TCQ app_rd_data_valid_ns;      wire free_rd_buf = app_rd_data_valid_copy && app_rd_data_end;      reg [4:0] occ_cnt_r;      wire [4:0] occ_minus_one = occ_cnt_r - 5'b1;      wire [4:0] occ_plus_one = occ_cnt_r + 5'b1;      begin : occupied_counter        reg [4:0] occ_cnt_ns;        always @(/*AS*/free_rd_buf or occ_cnt_r or rd_accepted or rst or occ_minus_one or occ_plus_one) begin          occ_cnt_ns = occ_cnt_r;          if (rst) occ_cnt_ns = 5'b0;          else case ({rd_accepted, free_rd_buf})                 2'b01 : occ_cnt_ns = occ_minus_one;                 2'b10 : occ_cnt_ns = occ_plus_one;          endcase        end        always @(posedge clk) occ_cnt_r <= #TCQ occ_cnt_ns;        assign rd_buf_full = occ_cnt_ns[4];`ifdef MC_SVA        rd_data_buffer_full: cover property (@(posedge clk) (~rst && rd_buf_full));        rd_data_buffer_inc_dec_15: cover property (@(posedge clk) (~rst && rd_accepted && free_rd_buf && (occ_cnt_r == 5'hf)));        rd_data_underflow: assert property (@(posedge clk) (rst || !((occ_cnt_r == 5'b0) && (occ_cnt_ns == 5'h1f))));        rd_data_overflow: assert property (@(posedge clk) (rst || !((occ_cnt_r == 5'h10) && (occ_cnt_ns == 5'h11))));`endif      end      reg [3:0] rd_data_buf_addr_r_lcl;      assign rd_data_buf_addr_r = rd_data_buf_addr_r_lcl;      begin : data_buf_addr        reg [3:0] rd_data_buf_addr_ns;        always @(/*AS*/rd_accepted or rd_data_buf_addr_r_lcl or rst) begin          rd_data_buf_addr_ns = rd_data_buf_addr_r_lcl;          if (rst) rd_data_buf_addr_ns = 4'b0;          else if (rd_accepted) rd_data_buf_addr_ns = rd_data_buf_addr_r_lcl + 4'h1;        end        always @(posedge clk) rd_data_buf_addr_r_lcl <= #TCQ rd_data_buf_addr_ns;      end    end  endgenerateendmodule"}
{"task_id": 1493, "completion": "localparam constantNumber = 8_000;\n   reg [63:0] count;\n   always @ (posedge(clk) or posedge(rst))\n   begin\n       if (rst == 1'b1)\n           count <= 32'd0;\n       else if (count == (constantNumber - 32'd1))\n           count <= 32'd0;\n       else\n           count <= count + 32'b1;\n   end\n   always @ (posedge(clk) or posedge(rst))\n   begin\n       if (rst == 1'b1)\n           clk_div <= 1'b0;\n       else if (count == (constantNumber - 1))\n           clk_div <= ~clk_div;\n       else\n           clk_div <= clk_div;\n   end \nendmodule"}
{"task_id": 1193, "completion": "wire dc_i;\n    wire dc_o;\n    wire dc_t;\n    wire res_i;\n    wire res_o;\n    wire res_t;\n    wire vccen_i;\n    wire vccen_o;\n    wire vccen_t;\n    wire pmoden_i;\n    wire pmoden_o;\n    wire pmoden_t;\n    wire ss_i;\n    wire ss_o;\n    wire ss_t;\n    wire sck_i;\n    wire sck_o;\n    wire sck_t;\n    wire mosi_i;\n    wire mosi_o;\n    wire mosi_t;\n    wire miso_i;\n    wire miso_o;\n    wire miso_t;\n\n// Instantiation of Axi Bus Interface AXI_LITE_SPI\n    /*PmodOLEDrgb_v1_0_AXI_LITE_SPI # ( \n        .C_S_AXI_DATA_WIDTH(C_AXI_LITE_SPI_DATA_WIDTH),\n        .C_S_AXI_ADDR_WIDTH(C_AXI_LITE_SPI_ADDR_WIDTH)\n    ) PmodOLEDrgb_v1_0_AXI_LITE_SPI_inst (\n        .S_AXI_ACLK(s_axi_aclk),\n        .S_AXI_ARESETN(s_axi_aresetn),\n        .S_AXI_AWADDR(axi_lite_spi_awaddr),\n        .S_AXI_AWPROT(axi_lite_spi_awprot),\n        .S_AXI_AWVALID(axi_lite_spi_awvalid),\n        .S_AXI_AWREADY(axi_lite_spi_awready),\n        .S_AXI_WDATA(axi_lite_spi_wdata),\n        .S_AXI_WSTRB(axi_lite_spi_wstrb),\n        .S_AXI_WVALID(axi_lite_spi_wvalid),\n        .S_AXI_WREADY(axi_lite_spi_wready),\n        .S_AXI_BRESP(axi_lite_spi_bresp),\n        .S_AXI_BVALID(axi_lite_spi_bvalid),\n        .S_AXI_BREADY(axi_lite_spi_bready),\n        .S_AXI_ARADDR(axi_lite_spi_araddr),\n        .S_AXI_ARPROT(axi_lite_spi_arprot),\n        .S_AXI_ARVALID(axi_lite_spi_arvalid),\n        .S_AXI_ARREADY(axi_lite_spi_arready),\n        .S_AXI_RDATA(axi_lite_spi_rdata),\n        .S_AXI_RRESP(axi_lite_spi_rresp),\n        .S_AXI_RVALID(axi_lite_spi_rvalid),\n        .S_AXI_RREADY(axi_lite_spi_rready)\n    );*/\n\n// Instantiation of Axi Bus Interface AXI_LITE_GPIO\n    /*PmodOLEDrgb_AXI_LITE_GPIO # ( \n        .C_S_AXI_DATA_WIDTH(C_AXI_LITE_GPIO_DATA_WIDTH),\n        .C_S_AXI_ADDR_WIDTH(C_AXI_LITE_GPIO_ADDR_WIDTH)\n    ) PmodOLEDrgb_AXI_LITE_GPIO_inst (\n        .pin7_o(pin7_o),\n        .pin8_o(pin8_o),\n        .pin9_o(pin9_o),\n        .pin10_o(pin10_o),\n        .S_AXI_ACLK(s_axi_aclk),\n        .S_AXI_ARESETN(s_axi_aresetn),\n        .S_AXI_AWADDR(axi_lite_gpio_awaddr),\n        .S_AXI_AWPROT(axi_lite_gpio_awprot),\n        .S_AXI_AWVALID(axi_lite_gpio_awvalid),\n        .S_AXI_AWREADY(axi_lite_gpio_awready),\n        .S_AXI_WDATA(axi_lite_gpio_wdata),\n        .S_AXI_WSTRB(axi_lite_gpio_wstrb),\n        .S_AXI_WVALID(axi_lite_gpio_wvalid),\n        .S_AXI_WREADY(axi_lite_gpio_wready),\n        .S_AXI_BRESP(axi_lite_gpio_bresp),\n        .S_AXI_BVALID(axi_lite_gpio_bvalid),\n        .S_AXI_BREADY(axi_lite_gpio_bready),\n        .S_AXI_ARADDR(axi_lite_gpio_araddr),\n        .S_AXI_ARPROT(axi_lite_gpio_arprot),\n        .S_AXI_ARVALID(axi_lite_gpio_arvalid),\n        .S_AXI_ARREADY(axi_lite_gpio_arready),\n        .S_AXI_RDATA(axi_lite_gpio_rdata),\n        .S_AXI_RRESP(axi_lite_gpio_rresp),\n        .S_AXI_RVALID(axi_lite_gpio_rvalid),\n        .S_AXI_RREADY(axi_lite_gpio_rready)\n    );*/\n    // Add user logic here\n\n\nPmodOLEDrgb_pmod_bridge_0_0 pmod_bridge_0\n           (.in0_I(ss_i),\n            .in0_O(ss_o),\n            .in0_T(ss_t),\n            .in1_I(mosi_i),\n            .in1_O(mosi_o),\n            .in1_T(mosi_t),\n            .in2_I(miso_i),\n            .in2_O(miso_o),\n            .in2_T(miso_t),\n            .in3_I(sck_i),\n            .in3_O(sck_o),\n            .in3_T(sck_t),\n            .in4_I(dc_i),\n            .in4_O(dc_o),\n            .in4_T(dc_t),\n            .in5_I(res_i),\n            .in5_O(res_o),\n            .in5_T(res_t),\n            .in6_I(vccen_i),\n            .in6_O(vccen_o),\n            .in6_T(vccen_t),\n            .in7_I(pmoden_i),\n            .in7_O(pmoden_o),\n            .in7_T(pmoden_t),\n            .out0_I(pmod_out_pin1_i),\n            .out0_O(pmod_out_pin1_o),\n            .out0_T(pmod_out_pin1_t),\n            .out1_I(pmod_out_pin2_i),\n            .out1_O(pmod_out_pin2_o),\n            .out1_T(pmod_out_pin2_t),\n            .out2_I(pmod_out_pin3_i),\n            .out2_O(pmod_out_pin3_o),\n            .out2_T(pmod_out_pin3_t),\n            .out3_I(pmod_out_pin4_i),\n            .out3_O(pmod_out_pin4_o),\n            .out3_T(pmod_out_pin4_t),\n            .out4_I(pmod_out_pin7_i),\n            .out4_O(pmod_out_pin7_o),\n            .out4_T(pmod_out_pin7_t),\n            .out5_I(pmod_out_pin8_i),\n            .out5_O(pmod_out_pin8_o),\n            .out5_T(pmod_out_pin8_t),\n            .out6_I(pmod_out_pin9_i),\n            .out6_O(pmod_out_pin9_o),\n            .out6_T(pmod_out_pin9_t),\n            .out7_I(pmod_out_pin10_i),\n            .out7_O(pmod_out_pin10_o),\n            .out7_T(pmod_out_pin10_t));\n\n  PmodOLEDrgb_axi_gpio_0_1 axi_gpio_0\n       (.gpio_io_i({pmoden_i,vccen_i,res_i,dc_i}),\n        .gpio_io_o({pmoden_o,vccen_o,res_o,dc_o}),\n        .gpio_io_t({pmoden_t,vccen_t,res_t,dc_t}),\n        .s_axi_aclk(s_axi_aclk),\n        .s_axi_araddr(axi_lite_gpio_araddr),\n        .s_axi_aresetn(s_axi_aresetn),\n        .s_axi_arready(axi_lite_gpio_arready),\n        .s_axi_arvalid(axi_lite_gpio_arvalid),\n        .s_axi_awaddr(axi_lite_gpio_awaddr),\n        .s_axi_awready(axi_lite_gpio_awready),\n        .s_axi_awvalid(axi_lite_gpio_awvalid),\n        .s_axi_bready(axi_lite_gpio_bready),\n        .s_axi_bresp(axi_lite_gpio_bresp),\n        .s_axi_bvalid(axi_lite_gpio_bvalid),\n        .s_axi_rdata(axi_lite_gpio_rdata),\n        .s_axi_rready(axi_lite_gpio_rready),\n        .s_axi_rresp(axi_lite_gpio_rresp),\n        .s_axi_rvalid(axi_lite_gpio_rvalid),\n        .s_axi_wdata(axi_lite_gpio_wdata),\n        .s_axi_wready(axi_lite_gpio_wready),\n        .s_axi_wstrb(axi_lite_gpio_wstrb),\n        .s_axi_wvalid(axi_lite_gpio_wvalid));\n\n  PmodOLEDrgb_axi_quad_spi_0_0 axi_quad_spi_0\n        (.ext_spi_clk(ext_spi_clk),\n          .io0_i(mosi_i),\n          .io0_o(mosi_o),\n          .io0_t(mosi_t),\n          .io1_i(miso_i),\n          .io1_o(miso_o),\n          .io1_t(miso_t),\n          .s_axi_aclk(s_axi_aclk2),\n          .s_axi_araddr(axi_lite_spi_araddr),\n          .s_axi_aresetn(s_axi_aresetn),\n          .s_axi_arready(axi_lite_spi_arready),\n          .s_axi_arvalid(axi_lite_spi_arvalid),\n          .s_axi_awaddr(axi_lite_spi_awaddr),\n          .s_axi_awready(axi_lite_spi_awready),\n          .s_axi_awvalid(axi_lite_spi_awvalid),\n          .s_axi_bready(axi_lite_spi_bready),\n          .s_axi_bresp(axi_lite_spi_bresp),\n          .s_axi_bvalid(axi_lite_spi_bvalid),\n          .s_axi_rdata(axi_lite_spi_rdata),\n          .s_axi_rready(axi_lite_spi_rready),\n          .s_axi_rresp(axi_lite_spi_rresp),\n          .s_axi_rvalid(axi_lite_spi_rvalid),\n          .sck_i(sck_i),\n          .sck_o(sck_o),\n          .sck_t(sck_t),\n          .ss_i(ss_i),\n          .ss_o(ss_o),\n          .ss_t(ss_t));\n    // User logic ends\n\nendmodule"}
{"task_id": 357, "completion": "`define B31 [255:248]\n    `define B30 [247:240]\n    `define B29 [239:232]\n    `define B28 [231:224]\n    `define B27 [223:216]\n    `define B26 [215:208]\n    `define B25 [207:200]\n    `define B24 [199:192]\n    `define B23 [191:184]\n    `define B22 [183:176]\n    `define B21 [175:168]\n    `define B20 [167:160]\n    `define B19 [159:152]\n    `define B18 [151:144]\n    `define B17 [143:136]\n    `define B16 [135:128]\n    `define B15 [127:120]\n    `define B14 [119:112]\n    `define B13 [111:104]\n    `define B12 [103:96]\n    `define B11 [95:88]\n    `define B10 [87:80]\n    `define B9  [79:72]\n    `define B8  [71:64]\n    `define B7  [63:56]\n    `define B6  [55:48]\n    `define B5  [47:40]\n    `define B4  [39:32]\n    `define B3  [31:24]\n    `define B2  [23:16]\n    `define B1  [15:8]\n    `define B0  [7:0]\n\n    parameter READ_IDLE    = 2'b00,\n              READ_FIRST   = 2'b01,\n              READ_SECOND  = 2'b10;\n\n    reg [1:0] read_state;\n    reg local_word;\n    reg [5:0] local_size_128;\n    reg [5:0] read_size;\n    reg read_start;\n    reg bb_hold;\n\n    reg ddr3_burstbegin_wr;\n    reg [23:1] ddr3_address_wr;\n    reg [4:0] ddr3_size_wr;\n\n    wire [255:0] local_rdata;\n    wire one_word;\n    wire read_cmd_empty;\n    reg pop_read_128;\n\n    wire z_hit;\n    wire z_miss;\n    reg z_addr_0;\n    reg z_rdata_valid;\n    reg [255:0] z_cache;\n    wire z_load;\n    wire last_word;\n\n    assign last_word = ~|local_size_128[5:1] & local_size_128[0];\n    assign one_word = ~|mc_local_size[5:1] & mc_local_size[0];\n\n    always @(posedge mclock, negedge mc_rstn) begin\n        if(!mc_rstn) begin\n            local_size_128 <= 6'h0;\n            local_word     <= 1'b0;\n        end\n        else begin\n        ddr3_address_wr <= mc_local_address[23:1];\n        ddr3_size_wr  <= (mc_local_size >> 1) + (mc_local_size[0] | mc_local_address[0]);\n\n        if(mc_local_burstbegin) begin\n            local_size_128 <= mc_local_size - 6'h1;\n            local_word     <= ~mc_local_address[0];\n        end\n        else if(mc_local_write_req) begin\n            local_size_128 <= local_size_128 - 6'h1; \n            local_word     <= ~local_word; \n        end\n\n        bb_hold <= 1'b0;\n        casex({mc_local_write_req, mc_local_burstbegin, one_word, last_word, mc_local_address[0], local_word})\n            6'b111x0x: begin\n                ddr3_be[15:0]      <= mc_local_be;\n                ddr3_be[31:16]     <= 16'h0;\n                ddr3_wdata[127:0]  <= mc_local_wdata;\n                ddr3_write_req     <= |(mc_local_be);\n                ddr3_burstbegin_wr <= |(mc_local_be);\n            end\n            6'b111x1x: begin\n                ddr3_be[15:0]       <= 16'h0;\n                ddr3_be[31:16]      <= mc_local_be;\n                ddr3_wdata[255:128] <= mc_local_wdata;\n                ddr3_write_req      <= |(mc_local_be);\n                ddr3_burstbegin_wr  <= |(mc_local_be);\n            end\n            6'b110x0x: begin\n                ddr3_be[15:0]      <= mc_local_be;\n                ddr3_wdata[127:0]  <= mc_local_wdata;\n                ddr3_write_req     <= 1'b0;\n                ddr3_burstbegin_wr <= 1'b0;\n                bb_hold           <= 1'b1;\n            end\n            6'b110x1x: begin\n                ddr3_be[31:16]      <= mc_local_be;\n                ddr3_be[15:0]       <= 16'h0;\n                ddr3_wdata[255:128] <= mc_local_wdata;\n                ddr3_write_req      <= 1'b1;\n                ddr3_burstbegin_wr  <= 1'b1;\n            end\n            6'b10x0x0: begin\n                ddr3_be[15:0]      <= mc_local_be;\n                ddr3_wdata[127:0]  <= mc_local_wdata;\n                ddr3_write_req     <= 1'b0;\n                ddr3_burstbegin_wr <= 1'b0;\n            end\n            6'b10xxx1: begin\n                ddr3_be[31:16]      <= mc_local_be;\n                ddr3_wdata[255:128] <= mc_local_wdata;\n                ddr3_write_req      <= 1'b1;\n                ddr3_burstbegin_wr  <= bb_hold;\n            end\n            6'b10x1x0: begin\n                ddr3_be[15:0]      <= mc_local_be;\n                ddr3_be[31:16]     <= 16'h0;\n                ddr3_wdata[127:0]  <= mc_local_wdata;\n                ddr3_write_req     <= 1'b1;\n                ddr3_burstbegin_wr <= 1'b0;\n            end\n            default: begin\n                ddr3_be            <= 32'hffffffff;\n                ddr3_write_req     <= 1'b0;\n                ddr3_burstbegin_wr <= 1'b0;\n            end\n            endcase\n    end\n    end\n\n    assign z_hit =  1'b0;\n    assign z_miss = 1'b1;\n\n    always @* begin\n        if(mc_local_read_req & ddr3_ready & ~z_hit) begin\n            ddr3_read_req   = 1'b1;\n            ddr3_burstbegin = 1'b1;\n            ddr3_address    =  mc_local_address[23:1];\n            ddr3_size      = (mc_local_size >> 1) + (mc_local_size[0] | mc_local_address[0]);\n        end\n        else begin\n            ddr3_read_req   = 1'b0;\n            ddr3_burstbegin = ddr3_burstbegin_wr;\n            ddr3_address    = ddr3_address_wr;\n            ddr3_size      = ddr3_size_wr;\n        end\n    end\n\n    assign mc_local_ready = ddr3_ready;\n\n    mc_cache_fifo_256   u0_read_fifo_la\n        (\n        .clock      (mclock),\n        .aclr       (~mc_rstn),\n        .wrreq      (ddr3_rdata_valid),\n        .data       (ddr3_rdata),\n        .rdreq      (ff_rdata_pop),\n        .almost_full (),\n        .empty      (local_read_empty),\n        .full       (),\n        .usedw      (data_fifo_used),\n        .q          (local_rdata)\n        );\n\n    sfifo_8x16_la u_read_128\n        (\n        .aclr         (~mc_rstn),\n        .clock        (mclock),\n        .wrreq        (mc_local_read_req & ddr3_ready),\n        .data         ({z_miss, mc_local_address[0], {6{~z_hit}} & mc_local_size}),\n        .rdreq        (pop_read_128),\n\n        .q            ({z_load, read_adr_0, read_count_128}),\n        .full         (),\n        .empty        (read_cmd_empty),\n        .usedw        (read_cmd_used),\n        .almost_full  ()\n        );\n\n    always @(posedge mclock, negedge mc_rstn) begin\n        if(!mc_rstn)               z_cache   <= 256'h0;\n        else if(ddr3_write_req & (mc_dev_sel == 4'h8)) begin \n            if(ddr3_be[31]) z_cache`B31 <= ddr3_wdata`B31;\n            if(ddr3_be[30]) z_cache`B30 <= ddr3_wdata`B30;\n            if(ddr3_be[29]) z_cache`B29 <= ddr3_wdata`B29;\n            if(ddr3_be[28]) z_cache`B28 <= ddr3_wdata`B28;\n            if(ddr3_be[27]) z_cache`B27 <= ddr3_wdata`B27;\n            if(ddr3_be[26]) z_cache`B26 <= ddr3_wdata`B26;\n            if(ddr3_be[25]) z_cache`B25 <= ddr3_wdata`B25;\n            if(ddr3_be[24]) z_cache`B24 <= ddr3_wdata`B24;\n            if(ddr3_be[23]) z_cache`B23 <= ddr3_wdata`B23;\n            if(ddr3_be[22]) z_cache`B22 <= ddr3_wdata`B22;\n            if(ddr3_be[21]) z_cache`B21 <= ddr3_wdata`B21;\n            if(ddr3_be[20]) z_cache`B20 <= ddr3_wdata`B20;\n            if(ddr3_be[19]) z_cache`B19 <= ddr3_wdata`B19;\n            if(ddr3_be[18]) z_cache`B18 <= ddr3_wdata`B18;\n            if(ddr3_be[17]) z_cache`B17 <= ddr3_wdata`B17;\n            if(ddr3_be[16]) z_cache`B16 <= ddr3_wdata`B16;\n            if(ddr3_be[15]) z_cache`B15 <= ddr3_wdata`B15;\n            if(ddr3_be[14]) z_cache`B14 <= ddr3_wdata`B14;\n            if(ddr3_be[13]) z_cache`B13 <= ddr3_wdata`B13;\n            if(ddr3_be[12]) z_cache`B12 <= ddr3_wdata`B12;\n            if(ddr3_be[11]) z_cache`B11 <= ddr3_wdata`B11;\n            if(ddr3_be[10]) z_cache`B10 <= ddr3_wdata`B10;\n            if(ddr3_be[9])  z_cache`B9 <= ddr3_wdata`B9;\n            if(ddr3_be[8])  z_cache`B8 <= ddr3_wdata`B8;\n            if(ddr3_be[7])  z_cache`B7 <= ddr3_wdata`B7;\n            if(ddr3_be[6])  z_cache`B6 <= ddr3_wdata`B6;\n            if(ddr3_be[5])  z_cache`B5 <= ddr3_wdata`B5;\n            if(ddr3_be[4])  z_cache`B4 <= ddr3_wdata`B4;\n            if(ddr3_be[3])  z_cache`B3 <= ddr3_wdata`B3;\n            if(ddr3_be[2])  z_cache`B2 <= ddr3_wdata`B2;\n            if(ddr3_be[1])  z_cache`B1 <= ddr3_wdata`B1;\n            if(ddr3_be[0])  z_cache`B0 <= ddr3_wdata`B0;\n        end\n        else if(z_load & ddr3_rdata_valid) z_cache   <= ddr3_rdata;\n    end\n\n    always @(posedge mclock, negedge mc_rstn) begin\n        if(!mc_rstn) begin\n            read_state         <= READ_FIRST;\n            read_size          <= 6'h0;\n            read_start         <= 1'b0;\n            z_rdata_valid      <= 1'b0;\n            z_addr_0          <= 1'b0;\n        end\n        else begin\n            z_rdata_valid <= 1'b0;\n            case(read_state)\n            READ_IDLE: begin\n                    read_start <= read_adr_0;\n                    if(!read_cmd_empty & (read_count_128 == 6'h0)) begin\n                        read_state <= READ_IDLE;\n                        z_rdata_valid <= 1'b1;\n                        z_addr_0      <= read_adr_0;\n                    end\n                    else if(~local_read_empty) begin\n                        if(read_adr_0) read_state <= READ_SECOND;\n                        else           read_state <= READ_FIRST;\n                        read_size          <= read_count_128;\n                    end\n                    else read_state <= READ_IDLE;\n                end\n            READ_FIRST: begin\n                    if((read_size == 6'h1) & ~local_read_empty) begin\n                        read_size         <= read_size - 6'h1;\n                        read_state        <= READ_IDLE;\n                    end\n                    else if((read_size != 6'h0) & ~local_read_empty) begin\n                        read_size         <= read_size - 6'h1;\n                        read_state        <= READ_SECOND;\n                        read_start        <= ~read_start;\n                    end\n                    else if((read_size != 6'h0) & local_read_empty) begin\n                        read_state        <= READ_FIRST;\n                    end\n                    else read_state    <= READ_IDLE;\n                end\n            READ_SECOND: begin\n                    if((read_size == 6'h1) & ~local_read_empty) begin\n                        read_size         <= read_size - 6'h1;\n                        read_state        <= READ_IDLE;\n                    end\n                    else if((read_size != 6'h0) & ~local_read_empty) begin\n                        read_size         <= read_size - 6'h1;\n                        read_state        <= READ_FIRST;\n                        read_start        <= ~read_start;\n                    end\n                    else if((read_size != 6'h0) & local_read_empty) begin\n                        read_state        <= READ_SECOND;\n                    end\n                    else read_state   <= READ_IDLE;\n                end\n            endcase\n        end\n    end\n\n    always @* pop_read_128 = ((((read_state == READ_FIRST) | (read_state == READ_SECOND)) & (read_size == 6'h1)) & ~local_read_empty) |\n                   ((read_state == READ_IDLE) & (!read_cmd_empty & (read_count_128 == 6'h0)));\n\n    always @* ff_rdata_pop = (((read_state == READ_FIRST) & (read_size == 6'h1)) | (read_state == READ_SECOND)) & ~local_read_empty;\n\n    always @* mc_local_rdata = (z_rdata_valid & z_addr_0) ? z_cache[255:128] :\n                   (z_rdata_valid & ~z_addr_0) ? z_cache[127:0] :\n                   (read_start) ?  local_rdata[255:128] : local_rdata[127:0];\n\n    always @* mc_local_rdata_valid = (((read_state == READ_FIRST) | (read_state == READ_SECOND)) & ((read_size != 6'h0) & ~local_read_empty)) | z_rdata_valid;\n\nendmodule"}
{"task_id": 1502, "completion": "generate if (DEVICE_FAMILY == \"MAX 10\") begin fiftyfivenm_oscillator # ( .device_id(DEVICE_ID), .clock_frequency(CLOCK_FREQUENCY) ) oscillator_dut ( .clkout(wire_clkout), .clkout1(), .oscena(oscena)); end endgenerate endmodule"}
{"task_id": 1491, "completion": "localparam low_addr_bits16 = 16 - sdram_addrdepth;\n  localparam low_addr_bits12 = sdram_addrdepth - 12;\n\nwire csr_selected = csr_a[2] == csr_addr;\n\nassign sdram_ba = 2'b00;\n\nalways @(posedge sys_clk) begin\n\tif(sys_rst) begin\n\t\tcsr_do <= 16'd0;\n\t\t\n\t\tbypass <= 1'b1;\n\t\tsdram_rst <= 1'b1;\n\t\t\n\t\tsdram_cke <= 1'b0;\n\t\tsdram_adr <= {sdram_addrdepth{1'd0}};\n\t\t\n\t\ttim_rp <= 3'd2;\n\t\ttim_rcd <= 3'd2;\n\t\ttim_cas <= 1'b0;\n\t\ttim_refi <= 11'd740;\n\t\ttim_rfc <= 4'd8;\n\t\ttim_wr <= 2'd2;\n\tend else begin\n\t\tsdram_cs_n <= 1'b1;\n\t\tsdram_we_n <= 1'b1;\n\t\tsdram_cas_n <= 1'b1;\n\t\tsdram_ras_n <= 1'b1;\n\t\t\n\t\tcsr_do <= 16'd0;\n\t\tif(csr_selected) begin\n\t\t\tif(csr_we) begin\n\t\t\t\tcase(csr_a[1:0])\n\t\t\t\t\t2'b00: begin\n\t\t\t\t\t\tbypass <= csr_di[0];\n\t\t\t\t\t\tsdram_rst <= csr_di[1];\n\t\t\t\t\t\tsdram_cke <= csr_di[2];\n\t\t\t\t\tend\n\t\t\t\t\t2'b01: begin\n\t\t\t\t\t\tsdram_cs_n <= ~csr_di[0];\n\t\t\t\t\t\tsdram_we_n <= ~csr_di[1];\n\t\t\t\t\t\tsdram_cas_n <= ~csr_di[2];\n\t\t\t\t\t\tsdram_ras_n <= ~csr_di[3];\n\t\t\t\t\t\tsdram_adr <= { {low_addr_bits12{1'b0}}, csr_di[15:4]};\n\t\t\t\t\tend\n\t\t\t\t\t2'b10: begin\n\t\t\t\t\t\ttim_rp <= csr_di[2:0];\n\t\t\t\t\t\ttim_rcd <= csr_di[5:3];\n\t\t\t\t\t\ttim_cas <= csr_di[6];\n\t\t\t\t\t\ttim_rfc <= csr_di[10:7];\n\t\t\t\t\t\ttim_wr <= csr_di[12:11];\n\t\t\t\t\tend\n\t\t\t\t\t2'b11: begin\n\t\t\t\t\t\ttim_refi <= csr_di[10:0];\n\t\t\t\t\tend\n\t\t\t\tendcase\n\t\t\tend\n\t\t\tcase(csr_a[1:0])\n\t\t\t\t2'b00: csr_do <= {sdram_cke, sdram_rst, bypass};\n\t\t\t\t2'b01: csr_do <= {sdram_adr, {low_addr_bits16{1'b0}} };\n\t\t\t\t2'b10: csr_do <= {tim_wr, tim_rfc, tim_cas, tim_rcd, tim_rp};\n\t\t\t\t2'b11: csr_do <= {5'd0, tim_refi};\n\t\t\tendcase\n\t\tend\n\tend\nend\n\nendmodule"}
{"task_id": 1050, "completion": "localparam PARAM1 = 32'h00000000; wire w_mem_fin; wire w_dma_write_fin; reg r_dma_read_fin; wire [27:0] o_ddr3_cmd_word_addr; wire w_mem_ingress_rdy; wire [23:0] w_mem_ingress_size; wire w_mem_ingress_act; wire w_mem_ingress_stb; wire [31:0] w_mem_ingress_data; wire [1:0] w_mem_egress_rdy; wire [1:0] w_mem_egress_act; wire [23:0] w_mem_egress_size; wire w_mem_egress_stb; wire [31:0] w_mem_egress_data; wire w_per_ingress_rdy; wire w_per_ingress_act; wire [23:0] w_per_ingress_size; wire w_per_ingress_stb; wire [31:0] w_per_ingress_data; wire [1:0] w_per_egress_rdy; wire [1:0] w_per_egress_act; wire [23:0] w_per_egress_size; wire w_per_egress_stb; wire [31:0] w_per_egress_data; wire w_mem_write_en; wire w_mem_read_en; wire [27:0] w_mem_adr; wire [1:0] w_ddr3_ingress_rdy; wire [23:0] w_ddr3_ingress_size; wire [1:0] w_ddr3_ingress_act; wire w_ddr3_ingress_stb; wire [31:0] w_ddr3_ingress_data; wire w_ddr3_egress_rdy; wire [23:0] w_ddr3_egress_size; wire w_ddr3_egress_act; wire w_ddr3_egress_stb; wire [31:0] w_ddr3_egress_data; wire w_ddr3_egress_inactive; wire [3:0] w_ih_state; wire [3:0] w_oh_state; ddr3_pcie_controller dc (.clk(clk), .rst(rst), .data_size(i_pcie_data_address), .write_address(w_mem_adr), .write_en(w_mem_write_en), .read_address(w_mem_adr), .read_en(w_mem_read_en), .finished(w_mem_fin), .if_write_strobe(w_ddr3_ingress_stb), .if_write_data(w_ddr3_ingress_data), .if_write_ready(w_ddr3_ingress_rdy), .if_write_activate(w_ddr3_ingress_act), .if_write_fifo_size(w_ddr3_ingress_size), .of_read_strobe(w_ddr3_egress_stb), .of_read_ready(w_ddr3_egress_rdy), .of_read_activate(w_ddr3_egress_act), .of_read_size(w_ddr3_egress_size), .of_read_data(w_ddr3_egress_data), .of_read_inactive(w_ddr3_egress_inactive), .cmd_en(o_ddr3_cmd_en), .cmd_instr(o_ddr3_cmd_instr), .cmd_bl(o_ddr3_cmd_bl), .cmd_word_addr(o_ddr3_cmd_word_addr), .cmd_empty(i_ddr3_cmd_empty), .cmd_full(i_ddr3_cmd_full), .wr_en(o_ddr3_wr_en), .wr_mask(o_ddr3_wr_mask), .wr_data(o_ddr3_wr_data), .wr_full(i_ddr3_wr_full), .wr_empty(i_ddr3_wr_empty), .wr_count(i_ddr3_wr_count), .wr_underrun(i_ddr3_wr_underrun), .wr_error(i_ddr3_wr_error), .rd_en(o_ddr3_rd_en), .rd_data(i_ddr3_rd_data), .rd_full(i_ddr3_rd_full), .rd_empty(i_ddr3_rd_empty), .rd_count(i_ddr3_rd_count), .rd_overflow(i_ddr3_rd_overflow), .rd_error(i_ddr3_rd_error)); ppfifo_pcie_host_interface phi (.rst(rst), .clk(clk), .i_ing_en(i_pcie_per_fifo_sel & i_pcie_data_write_flg), .i_egr_en(i_pcie_per_fifo_sel & i_pcie_data_read_flg), .o_ing_fin(w_ing_per_fin), .o_egr_fin(w_egr_per_fin), .i_sys_rst(i_sys_rst), .i_master_ready(i_master_ready), .o_ih_reset(o_ih_reset), .o_ih_ready(o_ih_ready), .o_in_command(o_in_command), .o_in_address(o_in_address), .o_in_data(o_in_data), .o_in_data_count(o_in_data_count), .o_oh_ready(o_oh_ready), .i_oh_en(i_oh_en), .o_ih_state(w_ih_state), .o_oh_state(w_oh_state), .i_out_status(i_out_status), .i_out_address(i_out_address), .i_out_data(i_out_data), .i_out_data_count(i_out_data_count), .i_ingress_rdy(w_per_ingress_rdy), .o_ingress_act(w_per_ingress_act), .o_ingress_stb(w_per_ingress_stb), .i_ingress_size(w_per_ingress_size), .i_ingress_data(w_per_ingress_data), .i_egress_rdy(w_per_egress_rdy), .o_egress_act(w_per_egress_act), .o_egress_stb(w_per_egress_stb), .i_egress_size(w_per_egress_size), .o_egress_data(w_per_egress_data)); adapter_ppfifo_2_ppfifo ap2p_to_ddr3 (.clk(clk), .rst(rst), .i_read_ready(w_mem_ingress_rdy), .o_read_activate(w_mem_ingress_act), .i_read_size(w_mem_ingress_size), .i_read_data(w_mem_ingress_data), .o_read_stb(w_mem_ingress_stb), .i_write_ready(w_ddr3_ingress_rdy), .o_write_activate(w_ddr3_ingress_act), .i_write_size(w_ddr3_ingress_size), .o_write_stb(w_ddr3_ingress_stb), .o_write_data(w_ddr3_ingress_data)); adapter_ppfifo_2_ppfifo ap2p_from_ddr3 (.clk(clk), .rst(rst), .i_read_ready(w_ddr3_egress_rdy), .o_read_activate(w_ddr3_egress_act), .i_read_size(w_ddr3_egress_size), .i_read_data(w_ddr3_egress_data), .o_read_stb(w_ddr3_egress_stb), .i_write_ready(w_mem_egress_rdy), .o_write_activate(w_mem_egress_act), .i_write_size(w_mem_egress_size), .o_write_stb(w_mem_egress_stb), .o_write_data(w_mem_egress_data)); assign o_ddr3_cmd_clk = clk; assign o_ddr3_wr_clk = clk; assign o_ddr3_rd_clk = clk; assign o_ddr3_cmd_byte_addr = {o_ddr3_cmd_word_addr, 2'b0}; assign o_pcie_data_clk = clk; assign o_pcie_interrupt_stb = 1'b0; assign o_pcie_interrupt_value = 0; assign w_per_ingress_rdy = (i_pcie_per_fifo_sel & i_pcie_data_write_flg) ? i_pcie_ingress_fifo_rdy : 1'b0; assign w_per_ingress_size = (i_pcie_per_fifo_sel & i_pcie_data_write_flg) ? i_pcie_ingress_fifo_size : 24'h0; assign w_per_ingress_data = (i_pcie_per_fifo_sel & i_pcie_data_write_flg) ? i_pcie_ingress_fifo_data : 32'h0; assign w_mem_ingress_rdy = (i_pcie_mem_fifo_sel & i_pcie_data_write_flg) ? i_pcie_ingress_fifo_rdy : 1'b0; assign w_mem_ingress_size = (i_pcie_mem_fifo_sel & i_pcie_data_write_flg) ? i_pcie_ingress_fifo_size : 24'h0; assign w_mem_ingress_data = (i_pcie_mem_fifo_sel & i_pcie_data_write_flg) ? i_pcie_ingress_fifo_data : 32'h0; assign o_idma_ready = (i_pcie_dma_fifo_sel & i_pcie_data_write_flg) ? i_pcie_ingress_fifo_rdy : 1'b0; assign o_idma_size = (i_pcie_dma_fifo_sel & i_pcie_data_write_flg) ? i_pcie_ingress_fifo_size : 24'h0; assign o_idma_data = (i_pcie_dma_fifo_sel & i_pcie_data_write_flg) ? i_pcie_ingress_fifo_data : 32'h0; assign o_pcie_ingress_fifo_act = (i_pcie_per_fifo_sel & i_pcie_data_write_flg) ? w_per_ingress_act : (i_pcie_mem_fifo_sel & i_pcie_data_write_flg) ? w_mem_ingress_act : (i_pcie_dma_fifo_sel & i_pcie_data_write_flg) ? i_idma_activate : 1'b0; assign o_pcie_ingress_fifo_stb = (i_pcie_per_fifo_sel & i_pcie_data_write_flg) ? w_per_ingress_stb : (i_pcie_mem_fifo_sel & i_pcie_data_write_flg) ? w_mem_ingress_stb : (i_pcie_dma_fifo_sel & i_pcie_data_write_flg) ? i_idma_stb : 1'b0; assign w_per_egress_rdy = (i_pcie_per_fifo_sel & i_pcie_data_read_flg) ? i_pcie_egress_fifo_rdy : 2'b0; assign w_mem_egress_rdy = (i_pcie_mem_fifo_sel & i_pcie_data_read_flg) ? i_pcie_egress_fifo_rdy : 2'b0; assign o_odma_ready = (i_pcie_dma_fifo_sel & i_pcie_data_read_flg) ? i_pcie_egress_fifo_rdy : 2'b0; assign w_per_egress_size = (i_pcie_per_fifo_sel & i_pcie_data_read_flg) ? i_pcie_egress_fifo_size : 24'h0; assign w_mem_egress_size = (i_pcie_mem_fifo_sel & i_pcie_data_read_flg) ? i_pcie_egress_fifo_size : 24'h0; assign o_odma_size = (i_pcie_dma_fifo_sel & i_pcie_data_read_flg) ? i_pcie_egress_fifo_size : 24'h0; assign o_pcie_egress_fifo_act = (i_pcie_per_fifo_sel & i_pcie_data_read_flg) ? w_per_egress_act : (i_pcie_mem_fifo_sel & i_pcie_data_read_flg) ? w_mem_egress_act : (i_pcie_dma_fifo_sel & i_pcie_data_read_flg) ? i_odma_activate : 1'b0; assign o_pcie_egress_fifo_data = (i_pcie_per_fifo_sel & i_pcie_data_read_flg) ? w_per_egress_data : (i_pcie_mem_fifo_sel & i_pcie_data_read_flg) ? w_mem_egress_data : (i_pcie_dma_fifo_sel & i_pcie_data_read_flg) ? i_odma_data : 1'b0; assign o_pcie_egress_fifo_stb = (i_pcie_per_fifo_sel & i_pcie_data_read_flg) ? w_per_egress_stb : (i_pcie_mem_fifo_sel & i_pcie_data_read_flg) ? w_mem_egress_stb : (i_pcie_dma_fifo_sel & i_pcie_data_read_flg) ? i_odma_stb : 1'b0; assign w_mem_adr = i_pcie_data_size[27:0]; assign w_mem_write_en = i_pcie_data_write_flg & i_pcie_mem_fifo_sel; assign w_mem_read_en = i_pcie_data_read_flg & i_pcie_mem_fifo_sel; assign o_pcie_write_fin = (i_pcie_per_fifo_sel & i_pcie_data_write_flg) ? w_ing_per_fin : (i_pcie_mem_fifo_sel & i_pcie_data_write_flg) ? w_mem_fin : (i_pcie_dma_fifo_sel & i_pcie_data_write_flg) ? w_dma_write_fin : 1'b0; assign o_pcie_read_fin = (i_pcie_per_fifo_sel & i_pcie_data_read_flg) ? w_egr_per_fin : (i_pcie_mem_fifo_sel & i_pcie_data_read_flg) ? (w_mem_fin & w_ddr3_egress_inactive) : (i_pcie_dma_fifo_sel & i_pcie_data_read_flg) ? r_dma_read_fin : 1'b0; assign w_dma_write_fin = i_pcie_ingress_fifo_idle; assign o_debug[0] = i_pcie_data_read_flg; assign o_debug[1] = i_pcie_data_write_flg; assign o_debug[2] = i_pcie_dma_fifo_sel; assign o_debug[3] = i_oh_en; assign o_debug[4] = i_pcie_per_fifo_sel; assign o_debug[5] = w_ing_per_fin; assign o_debug[6] = o_pcie_write_fin; assign o_debug[7] = w_per_egress_stb; assign o_debug[8] = i_master_ready; assign o_debug[9] = 1'b0; assign o_debug[10] = o_ih_ready; assign o_debug[11] = o_oh_ready; assign o_debug[15:12] = w_oh_state; assign o_debug[17:16] = w_per_egress_act; assign o_debug[18] = w_per_ingress_stb; assign o_debug[19] = w_per_ingress_act; assign o_debug[20] = w_per_ingress_rdy; assign o_debug[24:21] = w_ih_state; assign o_debug[26:25] = o_in_command; assign o_debug[30:27] = i_dbg_sm_state; assign o_debug[31] = w_egr_per_fin; reg [31:0] r_dma_count; always @(posedge clk) begin if (rst) begin r_dma_count <= 0; r_dma_read_fin <= 0; end else begin if (i_pcie_data_read_flg & i_pcie_dma_fifo_sel) begin if (r_dma_count < i_pcie_data_address) begin if (i_odma_stb) begin r_dma_count <= r_dma_count + 1; end end else begin r_dma_read_fin <= 1; end end else begin r_dma_count <= 0; r_dma_read_fin <= 0; end end endendmodule"}
{"task_id": 45, "completion": "localparam ADDR_WIDTH = log2ceil(FIFO_DEPTH);\n    localparam DEPTH = FIFO_DEPTH;\n    localparam PKT_SIGNALS_WIDTH = 2 + EMPTY_WIDTH;\n    localparam PAYLOAD_WIDTH = (USE_PACKETS == 1) ? \n                   2 + EMPTY_WIDTH + DATA_WIDTH + ERROR_WIDTH + CHANNEL_WIDTH:\n                   DATA_WIDTH + ERROR_WIDTH + CHANNEL_WIDTH;\n\n    genvar i;\n\n    reg [PAYLOAD_WIDTH-1 : 0] mem [DEPTH-1 : 0];\n    reg [ADDR_WIDTH-1 : 0] wr_ptr;\n    reg [ADDR_WIDTH-1 : 0] rd_ptr;\n    reg [DEPTH-1 : 0] mem_used;\n\n    wire [ADDR_WIDTH-1 : 0] next_wr_ptr;\n    wire [ADDR_WIDTH-1 : 0] next_rd_ptr;\n    wire [ADDR_WIDTH-1 : 0] incremented_wr_ptr;\n    wire [ADDR_WIDTH-1 : 0] incremented_rd_ptr;\n\n    wire [ADDR_WIDTH-1 : 0] mem_rd_ptr;\n\n    wire read;\n    wire write;\n\n    reg empty;\n    reg next_empty;\n    reg full;\n    reg next_full;\n\n    wire [PKT_SIGNALS_WIDTH-1 : 0] in_packet_signals;\n    wire [PKT_SIGNALS_WIDTH-1 : 0] out_packet_signals;\n    wire [PAYLOAD_WIDTH-1 : 0] in_payload;\n    reg [PAYLOAD_WIDTH-1 : 0] internal_out_payload;\n    reg [PAYLOAD_WIDTH-1 : 0] out_payload;\n\n    reg internal_out_valid;\n    wire internal_out_ready;\n\n    reg [ADDR_WIDTH : 0] fifo_fill_level;\n    reg [ADDR_WIDTH : 0] fill_level;\n\n    reg [ADDR_WIDTH-1 : 0] sop_ptr = 0;\n    wire [ADDR_WIDTH-1 : 0] curr_sop_ptr;\n    reg [23:0] almost_full_threshold;\n    reg [23:0] almost_empty_threshold;\n    reg [23:0] cut_through_threshold;\n    reg [15:0] pkt_cnt;\n    reg drop_on_error_en;\n    reg error_in_pkt;\n    reg pkt_has_started;\n    reg sop_has_left_fifo;\n    reg fifo_too_small_r;\n    reg pkt_cnt_eq_zero;\n    reg pkt_cnt_eq_one;\n\n    wire wait_for_threshold;\n    reg pkt_mode;\n    wire wait_for_pkt;\n    wire ok_to_forward;\n    wire in_pkt_eop_arrive;\n    wire out_pkt_leave;\n    wire in_pkt_start;\n    wire in_pkt_error;\n    wire drop_on_error;\n    wire fifo_too_small;\n    wire out_pkt_sop_leave;\n    wire [31:0] max_fifo_size;\n    reg fifo_fill_level_lt_cut_through_threshold;\n\n    generate\n        if (EMPTY_WIDTH > 0) begin : gen_blk1\n            assign in_packet_signals = {in_startofpacket, in_endofpacket, in_empty};\n            assign {out_startofpacket, out_endofpacket, out_empty} = out_packet_signals;\n        end \n        else begin : gen_blk1_else\n            assign out_empty = in_error;\n            assign in_packet_signals = {in_startofpacket, in_endofpacket};\n            assign {out_startofpacket, out_endofpacket} = out_packet_signals;\n        end\n    endgenerate\n\n    generate\n        if (USE_PACKETS) begin : gen_blk2\n            if (ERROR_WIDTH > 0) begin : gen_blk3\n                if (CHANNEL_WIDTH > 0) begin : gen_blk4\n                    assign in_payload = {in_packet_signals, in_data, in_error, in_channel};\n                    assign {out_packet_signals, out_data, out_error, out_channel} = out_payload;\n                end\n                else begin : gen_blk4_else\n                    assign out_channel = in_channel;\n                    assign in_payload = {in_packet_signals, in_data, in_error};\n                    assign {out_packet_signals, out_data, out_error} = out_payload;\n                end\n            end\n            else begin : gen_blk3_else\n                assign out_error = in_error;\n                if (CHANNEL_WIDTH > 0) begin : gen_blk5\n                    assign in_payload = {in_packet_signals, in_data, in_channel};\n                    assign {out_packet_signals, out_data, out_channel} = out_payload;\n                end\n                else begin : gen_blk5_else\n                    assign out_channel = in_channel;\n                    assign in_payload = {in_packet_signals, in_data};\n                    assign {out_packet_signals, out_data} = out_payload;\n                end\n            end\n        end\n        else begin : gen_blk2_else\n            assign out_packet_signals = 0;\n            if (ERROR_WIDTH > 0) begin : gen_blk6\n                if (CHANNEL_WIDTH > 0) begin : gen_blk7\n                    assign in_payload = {in_data, in_error, in_channel};\n                    assign {out_data, out_error, out_channel} = out_payload;\n                end\n                else begin : gen_blk7_else\n                    assign out_channel = in_channel;\n                    assign in_payload = {in_data, in_error};\n                    assign {out_data, out_error} = out_payload;\n                end\n            end\n            else begin : gen_blk6_else\n                assign out_error = in_error;\n                if (CHANNEL_WIDTH > 0) begin : gen_blk8\n                    assign in_payload = {in_data, in_channel};\n                    assign {out_data, out_channel} = out_payload;\n                end\n                else begin : gen_blk8_else\n                    assign out_channel = in_channel;\n                    assign in_payload = in_data;\n                    assign out_data = out_payload;\n                end\n            end\n        end\n    endgenerate\n\n    generate if (USE_MEMORY_BLOCKS == 1) begin  : gen_blk9\n        if (EMPTY_LATENCY == 1) begin : gen_blk10\n            always @(posedge clk) begin\n                if (in_valid && in_ready)\n                    mem[wr_ptr] = in_payload;\n\n                internal_out_payload = mem[mem_rd_ptr];\n            end\n        end else begin : gen_blk10_else\n            always @(posedge clk) begin\n                if (in_valid && in_ready)\n                    mem[wr_ptr] <= in_payload;\n\n                internal_out_payload <= mem[mem_rd_ptr];\n            end\n        end\n\n        assign mem_rd_ptr = next_rd_ptr;\n    end else begin : gen_blk9_else\n        for (i = 0; i < DEPTH-1; i = i + 1) begin : shift_reg\n            always @(posedge clk or posedge reset) begin\n                if (reset) begin\n                    mem[i] <= 0;\n                end \n                else if (read || !mem_used[i]) begin\n                    if (!mem_used[i+1])\n                        mem[i] <= in_payload;\n                    else\n                        mem[i] <= mem[i+1];\n                end\n            end\n        end\n\n        always @(posedge clk, posedge reset) begin\n            if (reset) begin\n                mem[DEPTH-1] <= 0;\n            end \n            else begin\n                if (DEPTH == 1) begin\n                    if (write)\n                        mem[DEPTH-1] <= in_payload;\n                end\n                else if (!mem_used[DEPTH-1])\n                    mem[DEPTH-1] <= in_payload;    \n            end\n        end\n    end\n    endgenerate\n\n    assign read  = internal_out_ready && internal_out_valid  && ok_to_forward;\n    assign write = in_ready && in_valid;\n\n    generate if (USE_MEMORY_BLOCKS == 1) begin : gen_blk11\n        assign incremented_wr_ptr = wr_ptr + 1'b1;\n        assign incremented_rd_ptr = rd_ptr + 1'b1;\n        assign next_wr_ptr =  drop_on_error ? curr_sop_ptr : write ?  incremented_wr_ptr : wr_ptr;\n        assign next_rd_ptr = (read) ? incremented_rd_ptr : rd_ptr;\n\n        always @(posedge clk or posedge reset) begin\n            if (reset) begin\n                wr_ptr <= 0;\n                rd_ptr <= 0;\n            end\n            else begin\n                wr_ptr <= next_wr_ptr;\n                rd_ptr <= next_rd_ptr;\n            end\n        end\n    end else begin : gen_blk11_else\n        always @(posedge clk or posedge reset) begin\n            if (reset) begin\n                mem_used[0] <= 0;\n            end \n            else begin\n                if (write ^ read) begin\n                    if (write)\n                        mem_used[0] <= 1;\n                    else if (read) begin\n                        if (DEPTH > 1)\n                            mem_used[0] <= mem_used[1];\n                        else\n                            mem_used[0] <= 0;\n                    end    \n                end\n            end\n        end\n\n        if (DEPTH > 1) begin : gen_blk12\n            always @(posedge clk or posedge reset) begin\n                if (reset) begin\n                    mem_used[DEPTH-1] <= 0;\n                end\n                else begin \n                    if (write ^ read) begin            \n                        mem_used[DEPTH-1] <= 0;\n                        if (write)\n                            mem_used[DEPTH-1] <= mem_used[DEPTH-2];\n                    end\n                end\n            end\n          end\n     \n        for (i = 1; i < DEPTH-1; i = i + 1) begin : storage_logic\n            always @(posedge clk, posedge reset) begin\n                if (reset) begin\n                    mem_used[i] <= 0;\n                end \n                else begin\n                    if (write ^ read) begin\n                        if (write)\n                            mem_used[i] <= mem_used[i-1];\n                        else if (read)\n                            mem_used[i] <= mem_used[i+1];     \n                    end\n                end\n            end\n        end\n    end\n    endgenerate\n\n    generate if (USE_MEMORY_BLOCKS == 1) begin : gen_blk13\n        always @* begin\n            next_full = full;\n            next_empty = empty;\n     \n            if (read && !write) begin\n                next_full = 1'b0;\n     \n                if (incremented_rd_ptr == wr_ptr)\n                    next_empty = 1'b1;\n            end\n            \n            if (write && !read) begin\n                if (!drop_on_error)\n                  next_empty = 1'b0;\n                else if (curr_sop_ptr == rd_ptr)   // drop on error and only 1 pkt in fifo\n                  next_empty = 1'b1;\n     \n                if (incremented_wr_ptr == rd_ptr && !drop_on_error)\n                    next_full = 1'b1;\n            end\n\n            if (write && read && drop_on_error) begin\n                if (curr_sop_ptr == next_rd_ptr)\n                  next_empty = 1'b1;\n            end\n        end\n     \n        always @(posedge clk or posedge reset) begin\n            if (reset) begin\n                empty <= 1;\n                full  <= 0;\n            end\n            else begin \n                empty <= next_empty;\n                full  <= next_full;\n            end\n        end\n    end else begin : gen_blk13_else\n        always @* begin\n            full  = mem_used[DEPTH-1];\n            empty = !mem_used[0];\n\n            if (DEPTH == 1)\n                full = mem_used[0] && !read;\n\n            internal_out_payload = mem[0];\n\n            if (EMPTY_LATENCY == 0) begin\n                empty = !mem_used[0] && !in_valid;\n\n                if (!mem_used[0] && in_valid)\n                    internal_out_payload = in_payload;\n            end\n        end\n    end\n    endgenerate\n\n    assign in_ready = !full;\n    assign internal_out_ready = out_ready || !out_valid;\n\n    generate if (EMPTY_LATENCY > 1) begin : gen_blk14\n        always @(posedge clk or posedge reset) begin\n            if (reset)\n                internal_out_valid <= 0;\n            else begin\n                internal_out_valid <= !empty & ok_to_forward & ~drop_on_error;\n\n                if (read) begin\n                    if (incremented_rd_ptr == wr_ptr)\n                        internal_out_valid <= 1'b0;\n                end\n            end\n        end\n    end else begin : gen_blk14_else\n        always @* begin\n            internal_out_valid = !empty & ok_to_forward;\n        end\n    end\n    endgenerate\n\n    generate if (EMPTY_LATENCY == 3) begin : gen_blk15\n        always @(posedge clk or posedge reset) begin\n            if (reset) begin\n                out_valid   <= 0;\n                out_payload <= 0;\n            end\n            else begin\n                if (internal_out_ready) begin\n                    out_valid   <= internal_out_valid & ok_to_forward;\n                    out_payload <= internal_out_payload;\n                end\n            end\n        end\n    end\n    else begin : gen_blk15_else\n        always @* begin\n            out_valid   = internal_out_valid;\n            out_payload = internal_out_payload;\n        end\n    end\n    endgenerate\n\n    generate if (USE_FILL_LEVEL) begin : gen_blk16\n        wire [31:0] depth32;\n        assign depth32 = DEPTH;\n\n        if (USE_STORE_FORWARD) begin\n            reg [ADDR_WIDTH : 0] curr_packet_len_less_one;\n            always @(posedge clk or posedge reset) begin\n                if (reset) begin\n                    curr_packet_len_less_one <= 0;\n                end else begin\n                    if (write) begin\n                        curr_packet_len_less_one <= curr_packet_len_less_one + 1'b1;\n                        if (in_endofpacket)\n                            curr_packet_len_less_one <= 0;\n                    end\n                end\n            end\n\n            always @(posedge clk or posedge reset) begin\n                if (reset) \n                    fifo_fill_level <= 0;\n                else if (drop_on_error) begin\n                    fifo_fill_level <= fifo_fill_level - curr_packet_len_less_one;\n                    if (read)\n                        fifo_fill_level <= fifo_fill_level - curr_packet_len_less_one - 1'b1;\n                end else if (write && !read) begin\n                    fifo_fill_level <= fifo_fill_level + 1'b1;\n                end else if (read && !write) begin\n                    fifo_fill_level <= fifo_fill_level - 1'b1;\n                end\n            end\n        end else begin\n            always @(posedge clk or posedge reset) begin\n                if (reset) \n                    fifo_fill_level <= 0;\n                else if (next_full & !drop_on_error)\n                    fifo_fill_level <= depth32[ADDR_WIDTH:0];\n                else begin\n                    fifo_fill_level[ADDR_WIDTH]     <= 1'b0;\n                    fifo_fill_level[ADDR_WIDTH-1 : 0] <= next_wr_ptr - next_rd_ptr;\n                end\n            end\n        end\n\n        always @* begin\n            fill_level = fifo_fill_level;\n\n            if (EMPTY_LATENCY == 3)\n                fill_level = fifo_fill_level + {{ADDR_WIDTH{1'b0}}, out_valid};\n        end\n    end\n    else begin : gen_blk16_else\n        always @* begin\n            fill_level = 0;\n        end  \n    end\n    endgenerate\n\n    generate if (USE_ALMOST_FULL_IF) begin : gen_blk17\n      assign almost_full_data = (fill_level >= almost_full_threshold);\n    end\n    else\n      assign almost_full_data = 0;\n    endgenerate\n\n    generate if (USE_ALMOST_EMPTY_IF) begin : gen_blk18\n      assign almost_empty_data = (fill_level <= almost_empty_threshold);\n    end\n    else\n      assign almost_empty_data = 0;\n    endgenerate\n\n    generate if (USE_STORE_FORWARD) begin : gen_blk19\n    assign max_fifo_size = FIFO_DEPTH - 1;\n      always @(posedge clk or posedge reset) begin\n          if (reset) begin\n              almost_full_threshold  <= max_fifo_size[23 : 0];\n              almost_empty_threshold <= 0;\n              cut_through_threshold  <= 0;\n              drop_on_error_en       <= 0;\n              csr_readdata           <= 0;\n              pkt_mode               <= 1'b1;\n          end\n          else begin\n              if (csr_read) begin\n                csr_readdata <= 32'b0;\n                if (csr_address == 5)\n                    csr_readdata <= {31'b0, drop_on_error_en};\n                else if (csr_address == 4)\n                    csr_readdata <= {8'b0, cut_through_threshold};\n                else if (csr_address == 3)\n                    csr_readdata <= {8'b0, almost_empty_threshold};\n                else if (csr_address == 2)\n                    csr_readdata <= {8'b0, almost_full_threshold};\n                else if (csr_address == 0)\n                    csr_readdata <= {{(31 - ADDR_WIDTH){1'b0}}, fill_level};\n             end\n             else if (csr_write) begin\n               if(csr_address == 3'b101)\n                   drop_on_error_en       <= csr_writedata[0];\n               else if(csr_address == 3'b100) begin\n                   cut_through_threshold  <= csr_writedata[23:0];\n                   pkt_mode <= (csr_writedata[23:0] == 0);\n               end\n               else if(csr_address == 3'b011)\n                    almost_empty_threshold <= csr_writedata[23:0];\n               else if(csr_address == 3'b010)\n                  almost_full_threshold  <= csr_writedata[23:0];\n             end     \n          end\n      end\n    end\n    else if (USE_ALMOST_FULL_IF || USE_ALMOST_EMPTY_IF) begin : gen_blk19_else1\n    assign max_fifo_size = FIFO_DEPTH - 1;\n      always @(posedge clk or posedge reset) begin\n          if (reset) begin\n              almost_full_threshold  <= max_fifo_size[23 : 0];\n              almost_empty_threshold <= 0;\n              csr_readdata           <= 0;\n          end\n          else begin\n             if (csr_read) begin\n                csr_readdata <= 32'b0;\n                if (csr_address == 3)\n                    csr_readdata <= {8'b0, almost_empty_threshold};\n                else if (csr_address == 2)\n                    csr_readdata <= {8'b0, almost_full_threshold};\n                else if (csr_address == 0)\n                    csr_readdata <= {{(31 - ADDR_WIDTH){1'b0}}, fill_level};\n             end\n             else if (csr_write) begin\n               if(csr_address == 3'b011)\n                   almost_empty_threshold <= csr_writedata[23:0];\n               else if(csr_address == 3'b010)\n                  almost_full_threshold  <= csr_writedata[23:0];\n             end       \n          end\n      end\n    end\n    else begin : gen_blk19_else2\n      always @(posedge clk or posedge reset) begin\n          if (reset) begin\n              csr_readdata <= 0;\n          end\n          else if (csr_read) begin\n              csr_readdata <= 0;\n\n              if (csr_address == 0) \n                  csr_readdata <= {{(31 - ADDR_WIDTH){1'b0}}, fill_level};\n          end\n      end\n    end\n    endgenerate\n\n    generate if (USE_STORE_FORWARD) begin : gen_blk20\n      assign wait_for_threshold   = (fifo_fill_level_lt_cut_through_threshold) & wait_for_pkt ;\n      assign wait_for_pkt         = pkt_cnt_eq_zero  | (pkt_cnt_eq_one  & out_pkt_leave);\n      assign ok_to_forward        = (pkt_mode ? (~wait_for_pkt | ~pkt_has_started) : \n                                     ~wait_for_threshold) | fifo_too_small_r;\n      assign in_pkt_eop_arrive    = in_valid & in_ready & in_endofpacket;\n      assign in_pkt_start         = in_valid & in_ready & in_startofpacket;\n      assign in_pkt_error         = in_valid & in_ready & |in_error;\n      assign out_pkt_sop_leave    = out_valid & out_ready & out_startofpacket;\n      assign out_pkt_leave        = out_valid & out_ready & out_endofpacket;\n      assign fifo_too_small       = (pkt_mode ? wait_for_pkt : wait_for_threshold) & full & out_ready;\n\n      always @(posedge clk or posedge reset) begin\n        if (reset) begin\n          pkt_cnt           <= 0;\n          pkt_has_started   <= 0;\n          sop_has_left_fifo <= 0;\n          fifo_too_small_r  <= 0;\n          pkt_cnt_eq_zero   <= 1'b1;\n          pkt_cnt_eq_one    <= 1'b0;\n          fifo_fill_level_lt_cut_through_threshold <= 1'b1;\n        end\n        else begin\n          fifo_fill_level_lt_cut_through_threshold <= fifo_fill_level < cut_through_threshold;\n          fifo_too_small_r <= fifo_too_small;\n\n          if( in_pkt_eop_arrive )\n            sop_has_left_fifo <= 1'b0;\n          else if (out_pkt_sop_leave & pkt_cnt_eq_zero )\n            sop_has_left_fifo <= 1'b1;\n\n          if (in_pkt_eop_arrive & ~out_pkt_leave & ~drop_on_error ) begin\n            pkt_cnt <= pkt_cnt + 1'b1;\n            pkt_cnt_eq_zero <= 0;\n            if (pkt_cnt == 0)\n              pkt_cnt_eq_one <= 1'b1;\n            else\n              pkt_cnt_eq_one <= 1'b0;\n          end\n          else if((~in_pkt_eop_arrive | drop_on_error) & out_pkt_leave) begin\n            pkt_cnt <= pkt_cnt - 1'b1;\n            if (pkt_cnt == 1) \n              pkt_cnt_eq_zero <= 1'b1;\n            else\n              pkt_cnt_eq_zero <= 1'b0;\n            if (pkt_cnt == 2) \n              pkt_cnt_eq_one <= 1'b1;\n            else\n              pkt_cnt_eq_one <= 1'b0;\n          end\n\n          if (in_pkt_start)\n            pkt_has_started <= 1'b1;\n          else if (in_pkt_eop_arrive)\n            pkt_has_started <= 1'b0;\n        end\n      end\n\n      always @(posedge clk or posedge reset) begin\n        if (reset) begin\n          sop_ptr <= 0;\n          error_in_pkt <= 0;\n        end\n        else begin\n          if ( in_pkt_start ) \n            sop_ptr <= wr_ptr;\n\n          if (in_pkt_eop_arrive)\n            error_in_pkt <= 1'b0;\n          else if ( in_pkt_error & (pkt_has_started | in_pkt_start))\n            error_in_pkt <= 1'b1;\n        end\n      end\n\n      assign drop_on_error = drop_on_error_en & (error_in_pkt | in_pkt_error) & in_pkt_eop_arrive & \n                            ~sop_has_left_fifo & ~(out_pkt_sop_leave & pkt_cnt_eq_zero);\n\n      assign curr_sop_ptr = (write && in_startofpacket && in_endofpacket) ? wr_ptr : sop_ptr;\n\n    end\n    else begin : gen_blk20_else\n      assign ok_to_forward = 1'b1;\n      assign drop_on_error = 1'b0;\n      if (ADDR_WIDTH <= 1)\n        assign curr_sop_ptr = 1'b0;\n      else\n        assign curr_sop_ptr = {ADDR_WIDTH - 1 { 1'b0 }};\n    end\n    endgenerate\n\n    function integer log2ceil;\n        input integer val;\n        reg[31:0] i;\n\n        begin\n            i = 1;\n            log2ceil = 0;\n\n            while (i < val) begin\n                log2ceil = log2ceil + 1;\n                i = i[30:0] << 1;\n            end\n        end\n    endfunction\nendmodule"}
{"task_id": 1504, "completion": "wire [19:0] sub_wire0;\n\twire [19:0] result = sub_wire0[19:0];\n\n\tlpm_mult\tlpm_mult_component (\n\t\t\t.dataa (dataa),\n\t\t\t.datab (datab),\n\t\t\t.clock (clock),\n\t\t\t.result (sub_wire0),\n\t\t\t.aclr (1'b0),\n\t\t\t.clken (1'b1),\n\t\t\t.sum (1'b0));\n\tdefparam\n\t\tlpm_mult_component.lpm_hint = \"MAXIMIZE_SPEED=5\",\n\t\tlpm_mult_component.lpm_pipeline = 1,\n\t\tlpm_mult_component.lpm_representation = \"UNSIGNED\",\n\t\tlpm_mult_component.lpm_type = \"LPM_MULT\",\n\t\tlpm_mult_component.lpm_widtha = 12,\n\t\tlpm_mult_component.lpm_widthb = 8,\n\t\tlpm_mult_component.lpm_widthp = 20;\n\nendmodule"}
{"task_id": 1232, "completion": "wire             E;\n  reg              EOP;\n  reg              MISO_reg;\n  wire             MOSI;\n  reg              ROE;\n  reg              RRDY;\n  wire             SCLK;\n  reg              SCLK_reg;\n  reg              SSO_reg;\n  wire             SS_n;\n  wire             TMT;\n  reg              TOE;\n  wire             TRDY;\n  wire             control_wr_strobe;\n  reg              data_rd_strobe;\n  reg     [ 15: 0] data_to_cpu;\n  reg              data_wr_strobe;\n  wire             dataavailable;\n  wire             ds_MISO;\n  wire             enableSS;\n  wire             endofpacket;\n  reg     [ 15: 0] endofpacketvalue_reg;\n  wire             endofpacketvalue_wr_strobe;\n  reg              iEOP_reg;\n  reg              iE_reg;\n  reg              iROE_reg;\n  reg              iRRDY_reg;\n  reg              iTMT_reg;\n  reg              iTOE_reg;\n  reg              iTRDY_reg;\n  wire             irq;\n  reg              irq_reg;\n  wire             p1_data_rd_strobe;\n  wire    [ 15: 0] p1_data_to_cpu;\n  wire             p1_data_wr_strobe;\n  wire             p1_rd_strobe;\n  wire    [  1: 0] p1_slowcount;\n  wire             p1_wr_strobe;\n  reg              rd_strobe;\n  wire             readyfordata;\n  reg     [  7: 0] rx_holding_reg;\n  reg     [  7: 0] shift_reg;\n  wire             slaveselect_wr_strobe;\n  wire             slowclock;\n  reg     [  1: 0] slowcount;\n  wire    [ 10: 0] spi_control;\n  reg     [ 15: 0] spi_slave_select_holding_reg;\n  reg     [ 15: 0] spi_slave_select_reg;\n  wire    [ 10: 0] spi_status;\n  reg     [  4: 0] state;\n  reg              stateZero;\n  wire             status_wr_strobe;\n  reg              transmitting;\n  reg              tx_holding_primed;\n  reg     [  7: 0] tx_holding_reg;\n  reg              wr_strobe;\n  wire             write_shift_reg;\n  wire             write_tx_holding;\n  assign p1_rd_strobe = ~rd_strobe & spi_select & ~read_n;\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          rd_strobe <= 0;\n      else \n        rd_strobe <= p1_rd_strobe;\n    end\n\n  assign p1_data_rd_strobe = p1_rd_strobe & (mem_addr == 0);\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          data_rd_strobe <= 0;\n      else \n        data_rd_strobe <= p1_data_rd_strobe;\n    end\n\n  assign p1_wr_strobe = ~wr_strobe & spi_select & ~write_n;\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          wr_strobe <= 0;\n      else \n        wr_strobe <= p1_wr_strobe;\n    end\n\n  assign p1_data_wr_strobe = p1_wr_strobe & (mem_addr == 1);\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          data_wr_strobe <= 0;\n      else \n        data_wr_strobe <= p1_data_wr_strobe;\n    end\n\n  assign control_wr_strobe = wr_strobe & (mem_addr == 3);\n  assign status_wr_strobe = wr_strobe & (mem_addr == 2);\n  assign slaveselect_wr_strobe = wr_strobe & (mem_addr == 5);\n  assign endofpacketvalue_wr_strobe = wr_strobe & (mem_addr == 6);\n  assign TMT = ~transmitting & ~tx_holding_primed;\n  assign E = ROE | TOE;\n  assign spi_status = {EOP, E, RRDY, TRDY, TMT, TOE, ROE, 3'b0};\n  assign dataavailable = RRDY;\n  assign readyfordata = TRDY;\n  assign endofpacket = EOP;\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n        begin\n          iEOP_reg <= 0;\n          iE_reg <= 0;\n          iRRDY_reg <= 0;\n          iTRDY_reg <= 0;\n          iTMT_reg <= 0;\n          iTOE_reg <= 0;\n          iROE_reg <= 0;\n          SSO_reg <= 0;\n        end\n      else if (control_wr_strobe)\n        begin\n          iEOP_reg <= data_from_cpu[9];\n          iE_reg <= data_from_cpu[8];\n          iRRDY_reg <= data_from_cpu[7];\n          iTRDY_reg <= data_from_cpu[6];\n          iTMT_reg <= data_from_cpu[5];\n          iTOE_reg <= data_from_cpu[4];\n          iROE_reg <= data_from_cpu[3];\n          SSO_reg <= data_from_cpu[10];\n        end\n    end\n\n  assign spi_control = {SSO_reg, iEOP_reg, iE_reg, iRRDY_reg, iTRDY_reg, 1'b0, iTOE_reg, iROE_reg, 3'b0};\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          irq_reg <= 0;\n      else \n        irq_reg <= (EOP & iEOP_reg) | ((TOE | ROE) & iE_reg) | (RRDY & iRRDY_reg) | (TRDY & iTRDY_reg) | (TOE & iTOE_reg) | (ROE & iROE_reg);\n    end\n\n  assign irq = irq_reg;\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          spi_slave_select_reg <= 1;\n      else if (write_shift_reg || control_wr_strobe & data_from_cpu[10] & ~SSO_reg)\n          spi_slave_select_reg <= spi_slave_select_holding_reg;\n    end\n\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          spi_slave_select_holding_reg <= 1;\n      else if (slaveselect_wr_strobe)\n          spi_slave_select_holding_reg <= data_from_cpu;\n    end\n\n  assign slowclock = slowcount == 2'h1;\n  assign p1_slowcount = ({2 {(transmitting && !slowclock)}} & (slowcount + 1)) |\n    ({2 {(~((transmitting && !slowclock)))}} & 0);\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          slowcount <= 0;\n      else \n        slowcount <= p1_slowcount;\n    end\n\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          endofpacketvalue_reg <= 0;\n      else if (endofpacketvalue_wr_strobe)\n          endofpacketvalue_reg <= data_from_cpu;\n    end\n\n  assign p1_data_to_cpu = ((mem_addr == 2))? spi_status :\n    ((mem_addr == 3))? spi_control :\n    ((mem_addr == 6))? endofpacketvalue_reg :\n    ((mem_addr == 5))? spi_slave_select_reg :\n    rx_holding_reg;\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          data_to_cpu <= 0;\n      else \n        data_to_cpu <= p1_data_to_cpu;\n    end\n\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n        begin\n          state <= 0;\n          stateZero <= 1;\n        end\n      else if (transmitting & slowclock)\n        begin\n          stateZero <= state == 17;\n          if (state == 17)\n              state <= 0;\n          else \n            state <= state + 1;\n        end\n    end\n\n  assign enableSS = transmitting & ~stateZero;\n  assign MOSI = shift_reg[7];\n  assign SS_n = (enableSS | SSO_reg) ? ~spi_slave_select_reg : {1 {1'b1} };\n  assign SCLK = SCLK_reg;\n  assign TRDY = ~(transmitting & tx_holding_primed);\n  assign write_tx_holding = data_wr_strobe & TRDY;\n  assign write_shift_reg = tx_holding_primed & ~transmitting;\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n        begin\n          shift_reg <= 0;\n          rx_holding_reg <= 0;\n          EOP <= 0;\n          RRDY <= 0;\n          ROE <= 0;\n          TOE <= 0;\n          tx_holding_reg <= 0;\n          tx_holding_primed <= 0;\n          transmitting <= 0;\n          SCLK_reg <= 0;\n          MISO_reg <= 0;\n        end\n      else \n        begin\n          if (write_tx_holding)\n            begin\n              tx_holding_reg <= data_from_cpu;\n              tx_holding_primed <= 1;\n            end\n          if (data_wr_strobe & ~TRDY)\n              TOE <= 1;\n          if ((p1_data_rd_strobe && (rx_holding_reg == endofpacketvalue_reg)) || (p1_data_wr_strobe && (data_from_cpu[7 : 0] == endofpacketvalue_reg)))\n              EOP <= 1;\n          if (write_shift_reg)\n            begin\n              shift_reg <= tx_holding_reg;\n              transmitting <= 1;\n            end\n          if (write_shift_reg & ~write_tx_holding)\n              tx_holding_primed <= 0;\n          if (data_rd_strobe)\n              RRDY <= 0;\n          if (status_wr_strobe)\n            begin\n              EOP <= 0;\n              RRDY <= 0;\n              ROE <= 0;\n              TOE <= 0;\n            end\n          if (slowclock)\n            begin\n              if (state == 17)\n                begin\n                  transmitting <= 0;\n                  RRDY <= 1;\n                  rx_holding_reg <= shift_reg;\n                  SCLK_reg <= 0;\n                  if (RRDY)\n                      ROE <= 1;\n                end\n              else if (state != 0)\n                  if (transmitting)\n                      SCLK_reg <= ~SCLK_reg;\n              if (SCLK_reg ^ 0 ^ 0)\n                begin\n                  if (1)\n                      shift_reg <= {shift_reg[6 : 0], MISO_reg};\n                end\n              else \n                MISO_reg <= ds_MISO;\n            end\n        end\n    end\n  assign ds_MISO = MISO;\nendmodule"}
{"task_id": 1494, "completion": "reg [3:0] bitcount;\n  reg [8:0] shifter;\n  reg uart_tx;\n\n  wire uart_busy = |bitcount[3:1];\n  wire sending = |bitcount;\n\n  reg [28:0] d;\n  wire [28:0] dInc = d[28] ? (115200) : (115200 - 100000000);\n  wire [28:0] dNxt = d + dInc;\n  wire ser_clk = ~d[28];\n  always @(posedge sys_clk_i)\n    if (sys_rst_i) begin\n       d = 0;\n    end else begin\n      d = dNxt;\n    end\n\n  always @(posedge sys_clk_i)\n  begin\n    if (sys_rst_i) begin\n      uart_tx <= 1;\n      bitcount <= 0;\n      shifter <= 0;\n    end else begin\n      if (uart_wr_i & ~uart_busy) begin\n        shifter <= { uart_dat_i[7:0], 1'h0 };\n        bitcount <= (1 + 8 + 2);\n      end\n      if (sending & ser_clk) begin\n        { shifter, uart_tx } <= { 1'h1, shifter };\n        bitcount <= bitcount - 1;\n      end\n    end\n  end\n\nendmodule"}
{"task_id": 1501, "completion": "wire d;    wire [1:0] brch_met0,brch_met1,brch_met2,brch_met3;    wire [1:0] brch_met4,brch_met5,brch_met6,brch_met7;    wire d0,d1,d2,d3;    wire [3:0] n_pm0,n_pm1,n_pm2,n_pm3;    wire [3:0] p_m0, p_m1, p_m2, p_m3;    bmu brch_met (cx[0], cx[1], brch_met0,brch_met1,brch_met2,brch_met3, brch_met4,brch_met5,brch_met6,brch_met7);    add_compare_select acs0 (n_pm0, d0, p_m0, brch_met0, p_m1, brch_met2);    add_compare_select acs1 (n_pm1, d1, p_m2, brch_met4, p_m3, brch_met6);    add_compare_select acs2 (n_pm2, d2, p_m0, brch_met1, p_m1, brch_met3);    add_compare_select acs3 (n_pm3, d3, p_m2, brch_met5, p_m3, brch_met7);    pmsm path_metric_sm (n_pm0, n_pm1, n_pm2, n_pm3, p_m0, p_m1, p_m2, p_m3, clk, reset);    spd survivor_path_dec (d0, d1, d2, d3, p_m0, p_m1, p_m2, p_m3, d, clk, reset);endmodule"}
{"task_id": 1352, "completion": "localparam CG_NUM_A2P_MAILBOX = (CB_P2A_PERF_PROFILE == 3)? 8 : 1;\nlocalparam CG_NUM_P2A_MAILBOX = (CB_A2P_PERF_PROFILE == 3)? 8 : 1;\nlocalparam FIXED_ADDRESS_TRANS = (INTENDED_DEVICE_FAMILY == \"Stratix IV\" || INTENDED_DEVICE_FAMILY == \"Cyclone IV GX\" || INTENDED_DEVICE_FAMILY == \"HardCopy IV\" || INTENDED_DEVICE_FAMILY == \"Arria II GZ\" || INTENDED_DEVICE_FAMILY == \"Arria II GX\" ) ? CB_A2P_ADDR_MAP_IS_FIXED : 0;\n\nwire rxpndgrd_fifo_empty;\nwire [56:0] rxpndgrd_fifo_dato;\nwire rxcpl_freed;\nwire [10:0] rxcpl_dw_freed;\nwire rxcpl_tagram_wrena;\nwire [22:0] rxcpl_tagram_wrdat;\nwire [4:0] rxcpl_tagram_addr;\nwire [22:0] rxcpl_tagram_rddat;\nwire rxpndgrd_fifo_rdreq;\nwire txcpl_sent;\nwire [9:0] txcpl_dw_sent;\nwire [9:0] atrans_table_addr;\nwire [3:0] atrans_bena;\nwire [31:0] atrans_wr_dat;\nwire [31:0] atrans_rd_dat;\nwire CraRead_i = CraRead;\nwire CraWrite_i = CraWrite;\n... \n\nassign MsiControl_o = msi_ena_reg;\nalways @(posedge AvlClk_i or negedge Rstn_i)\nbegin\n    if(~Rstn_i)\n    begin\n        rstn_r <= 1'b0;\n        rstn_rr <= 1'b0;\n    end\n    else\n    begin\n        rstn_r <= 1'b1;\n        rstn_rr <= rstn_r;\n    end\nend\n\nassign rstn_reg = rstn_rr;\n\n/* \u5176\u4ed6\u5b9e\u73b0\u7ec6\u8282\u7701\u7565 */\n\nendmodule"}
{"task_id": 182, "completion": "wire [63:0] rx_axis_tdata;\n    wire [7:0] rx_axis_tkeep;\n    wire rx_axis_tvalid;\n    wire rx_axis_tready;\n    wire rx_axis_tlast;\n    wire rx_axis_tuser;\n\n    wire [63:0] tx_axis_tdata;\n    wire [7:0] tx_axis_tkeep;\n    wire tx_axis_tvalid;\n    wire tx_axis_tready;\n    wire tx_axis_tlast;\n    wire tx_axis_tuser;\n\n    wire rx_eth_hdr_ready;\n    wire rx_eth_hdr_valid;\n    wire [47:0] rx_eth_dest_mac;\n    wire [47:0] rx_eth_src_mac;\n    wire [15:0] rx_eth_type;\n    wire [63:0] rx_eth_payload_axis_tdata;\n    wire [7:0] rx_eth_payload_axis_tkeep;\n    wire rx_eth_payload_axis_tvalid;\n    wire rx_eth_payload_axis_tready;\n    wire rx_eth_payload_axis_tlast;\n    wire rx_eth_payload_axis_tuser;\n\n    wire tx_eth_hdr_ready;\n    wire tx_eth_hdr_valid;\n    wire [47:0] tx_eth_dest_mac;\n    wire [47:0] tx_eth_src_mac;\n    wire [15:0] tx_eth_type;\n    wire [63:0] tx_eth_payload_axis_tdata;\n    wire [7:0] tx_eth_payload_axis_tkeep;\n    wire tx_eth_payload_axis_tvalid;\n    wire tx_eth_payload_axis_tready;\n    wire tx_eth_payload_axis_tlast;\n    wire tx_eth_payload_axis_tuser;\n\n    wire rx_ip_hdr_valid;\n    wire rx_ip_hdr_ready;\n    wire [47:0] rx_ip_eth_dest_mac;\n    wire [47:0] rx_ip_eth_src_mac;\n    wire [15:0] rx_ip_eth_type;\n    wire [3:0] rx_ip_version;\n    wire [3:0] rx_ip_ihl;\n    wire [5:0] rx_ip_dscp;\n    wire [1:0] rx_ip_ecn;\n    wire [15:0] rx_ip_length;\n    wire [15:0] rx_ip_identification;\n    wire [2:0] rx_ip_flags;\n    wire [12:0] rx_ip_fragment_offset;\n    wire [7:0] rx_ip_ttl;\n    wire [7:0] rx_ip_protocol;\n    wire [15:0] rx_ip_header_checksum;\n    wire [31:0] rx_ip_source_ip;\n    wire [31:0] rx_ip_dest_ip;\n    wire [63:0] rx_ip_payload_axis_tdata;\n    wire [7:0] rx_ip_payload_axis_tkeep;\n    wire rx_ip_payload_axis_tvalid;\n    wire rx_ip_payload_axis_tready;\n    wire rx_ip_payload_axis_tlast;\n    wire rx_ip_payload_axis_tuser;\n\n    wire tx_ip_hdr_valid;\n    wire tx_ip_hdr_ready;\n    wire [5:0] tx_ip_dscp;\n    wire [1:0] tx_ip_ecn;\n    wire [15:0] tx_ip_length;\n    wire [7:0] tx_ip_ttl;\n    wire [7:0] tx_ip_protocol;\n    wire [31:0] tx_ip_source_ip;\n    wire [31:0] tx_ip_dest_ip;\n    wire [63:0] tx_ip_payload_axis_tdata;\n    wire [7:0] tx_ip_payload_axis_tkeep;\n    wire tx_ip_payload_axis_tvalid;\n    wire tx_ip_payload_axis_tready;\n    wire tx_ip_payload_axis_tlast;\n    wire tx_ip_payload_axis_tuser;\n\n    wire rx_udp_hdr_valid;\n    wire rx_udp_hdr_ready;\n    wire [47:0] rx_udp_eth_dest_mac;\n    wire [47:0] rx_udp_eth_src_mac;\n    wire [15:0] rx_udp_eth_type;\n    wire [3:0] rx_udp_ip_version;\n    wire [3:0] rx_udp_ip_ihl;\n    wire [5:0] rx_udp_ip_dscp;\n    wire [1:0] rx_udp_ip_ecn;\n    wire [15:0] rx_udp_ip_length;\n    wire [15:0] rx_udp_ip_identification;\n    wire [2:0] rx_udp_ip_flags;\n    wire [12:0] rx_udp_ip_fragment_offset;\n    wire [7:0] rx_udp_ip_ttl;\n    wire [7:0] rx_udp_ip_protocol;\n    wire [15:0] rx_udp_ip_header_checksum;\n    wire [31:0] rx_udp_ip_source_ip;\n    wire [31:0] rx_udp_ip_dest_ip;\n    wire [15:0] rx_udp_source_port;\n    wire [15:0] rx_udp_dest_port;\n    wire [15:0] rx_udp_length;\n    wire [15:0] rx_udp_checksum;\n    wire [63:0] rx_udp_payload_axis_tdata;\n    wire [7:0] rx_udp_payload_axis_tkeep;\n    wire rx_udp_payload_axis_tvalid;\n    wire rx_udp_payload_axis_tready;\n    wire rx_udp_payload_axis_tlast;\n    wire rx_udp_payload_axis_tuser;\n\n    wire tx_udp_hdr_valid;\n    wire tx_udp_hdr_ready;\n    wire [5:0] tx_udp_ip_dscp;\n    wire [1:0] tx_udp_ip_ecn;\n    wire [7:0] tx_udp_ip_ttl;\n    wire [31:0] tx_udp_ip_source_ip;\n    wire [31:0] tx_udp_ip_dest_ip;\n    wire [15:0] tx_udp_source_port;\n    wire [15:0] tx_udp_dest_port;\n    wire [15:0] tx_udp_length;\n    wire [15:0] tx_udp_checksum;\n    wire [63:0] tx_udp_payload_axis_tdata;\n    wire [7:0] tx_udp_payload_axis_tkeep;\n    wire tx_udp_payload_axis_tvalid;\n    wire tx_udp_payload_axis_tready;\n    wire tx_udp_payload_axis_tlast;\n    wire tx_udp_payload_axis_tuser;\n\n    wire [63:0] rx_fifo_udp_payload_axis_tdata;\n    wire [7:0] rx_fifo_udp_payload_axis_tkeep;\n    wire rx_fifo_udp_payload_axis_tvalid;\n    wire rx_fifo_udp_payload_axis_tready;\n    wire rx_fifo_udp_payload_axis_tlast;\n    wire rx_fifo_udp_payload_axis_tuser;\n\n    wire [63:0] tx_fifo_udp_payload_axis_tdata;\n    wire [7:0] tx_fifo_udp_payload_axis_tkeep;\n    wire tx_fifo_udp_payload_axis_tvalid;\n    wire tx_fifo_udp_payload_axis_tready;\n    wire tx_fifo_udp_payload_axis_tlast;\n    wire tx_fifo_udp_payload_axis_tuser;\n\n    wire [47:0] local_mac   = 48'h02_00_00_00_00_00;\n    wire [31:0] local_ip    = {8'd192, 8'd168, 8'd1,   8'd128};\n    wire [31:0] gateway_ip  = {8'd192, 8'd168, 8'd1,   8'd1};\n    wire [31:0] subnet_mask = {8'd255, 8'd255, 8'd255, 8'd0};\n\n    assign rx_ip_hdr_ready = 1;\n    assign rx_ip_payload_axis_tready = 1;\n\n    assign tx_ip_hdr_valid = 0;\n    assign tx_ip_dscp = 0;\n    assign tx_ip_ecn = 0;\n    assign tx_ip_length = 0;\n    assign tx_ip_ttl = 0;\n    assign tx_ip_protocol = 0;\n    assign tx_ip_source_ip = 0;\n    assign tx_ip_dest_ip = 0;\n    assign tx_ip_payload_axis_tdata = 0;\n    assign tx_ip_payload_axis_tkeep = 0;\n    assign tx_ip_payload_axis_tvalid = 0;\n    assign tx_ip_payload_axis_tlast = 0;\n    assign tx_ip_payload_axis_tuser = 0;\n\n    wire match_cond = rx_udp_dest_port == 1234;\n    wire no_match = !match_cond;\n\n    reg match_cond_reg = 0;\n    reg no_match_reg = 0;\n\n    always @(posedge clk) begin\n        if (rst) begin\n            match_cond_reg <= 0;\n            no_match_reg <= 0;\n        end else begin\n            if (rx_udp_payload_axis_tvalid) begin\n                if ((!match_cond_reg && !no_match_reg) ||\n                    (rx_udp_payload_axis_tvalid && rx_udp_payload_axis_tready && rx_udp_payload_axis_tlast)) begin\n                    match_cond_reg <= match_cond;\n                    no_match_reg <= no_match;\n                end\n            end else begin\n                match_cond_reg <= 0;\n                no_match_reg <= 0;\n            end\n        end\n    end\n\n    assign tx_udp_hdr_valid = rx_udp_hdr_valid && match_cond;\n    assign rx_udp_hdr_ready = (tx_eth_hdr_ready && match_cond) || no_match;\n    assign tx_udp_ip_dscp = 0;\n    assign tx_udp_ip_ecn = 0;\n    assign tx_udp_ip_ttl = 64;\n    assign tx_udp_ip_source_ip = local_ip;\n    assign tx_udp_ip_dest_ip = rx_udp_ip_source_ip;\n    assign tx_udp_source_port = rx_udp_dest_port;\n    assign tx_udp_dest_port = rx_udp_source_port;\n    assign tx_udp_length = rx_udp_length;\n    assign tx_udp_checksum = 0;\n\n    assign tx_udp_payload_axis_tdata = tx_fifo_udp_payload_axis_tdata;\n    assign tx_udp_payload_axis_tkeep = tx_fifo_udp_payload_axis_tkeep;\n    assign tx_udp_payload_axis_tvalid = tx_fifo_udp_payload_axis_tvalid;\n    assign tx_fifo_udp_payload_axis_tready = tx_udp_payload_axis_tready;\n    assign tx_udp_payload_axis_tlast = tx_fifo_udp_payload_axis_tlast;\n    assign tx_udp_payload_axis_tuser = tx_fifo_udp_payload_axis_tuser;\n\n    assign rx_fifo_udp_payload_axis_tdata = rx_udp_payload_axis_tdata;\n    assign rx_fifo_udp_payload_axis_tkeep = rx_udp_payload_axis_tkeep;\n    assign rx_fifo_udp_payload_axis_tvalid = rx_udp_payload_axis_tvalid && match_cond_reg;\n    assign rx_udp_payload_axis_tready = (rx_fifo_udp_payload_axis_tready && match_cond_reg) || no_match_reg;\n    assign rx_fifo_udp_payload_axis_tlast = rx_udp_payload_axis_tlast;\n    assign rx_fifo_udp_payload_axis_tuser = rx_udp_payload_axis_tuser;\n\n    reg valid_last = 0;\n    reg [7:0] led_reg = 0;\n\n    always @(posedge clk) begin\n        if (rst) begin\n            led_reg <= 0;\n        end else begin\n            valid_last <= tx_udp_payload_axis_tvalid;\n            if (tx_udp_payload_axis_tvalid && !valid_last) begin\n                led_reg <= tx_udp_payload_axis_tdata;\n            end\n        end\n    end\n\n    assign user_led_g = ~led_reg[1:0];\n    assign user_led_r = 1'b1;\n    assign front_led = 2'b00;\n\n    assign phy_reset_n = !rst;\n\n    assign qsfp_0_txd_1 = 64'h0707070707070707;\n    assign qsfp_0_txc_1 = 8'hff;\n    assign qsfp_0_txd_2 = 64'h0707070707070707;\n    assign qsfp_0_txc_2 = 8'hff;\n    assign qsfp_0_txd_3 = 64'h0707070707070707;\n    assign qsfp_0_txc_3 = 8'hff;\n\n    assign qsfp_1_txd_0 = 64'h0707070707070707;\n    assign qsfp_1_txc_0 = 8'hff;\n    assign qsfp_1_txd_1 = 64'h0707070707070707;\n    assign qsfp_1_txc_1 = 8'hff;\n    assign qsfp_1_txd_2 = 64'h0707070707070707;\n    assign qsfp_1_txc_2 = 8'hff;\n    assign qsfp_1_txd_3 = 64'h0707070707070707;\n    assign qsfp_1_txc_3 = 8'hff;\n\n    eth_mac_10g_fifo #(\n        .ENABLE_PADDING(1),\n        .ENABLE_DIC(1),\n        .MIN_FRAME_LENGTH(64),\n        .TX_FIFO_DEPTH(4096),\n        .TX_FRAME_FIFO(1),\n        .RX_FIFO_DEPTH(4096),\n        .RX_FRAME_FIFO(1)\n    )\n    eth_mac_10g_fifo_inst (\n        .rx_clk(qsfp_0_rx_clk_0),\n        .rx_rst(qsfp_0_rx_rst_0),\n        .tx_clk(qsfp_0_tx_clk_0),\n        .tx_rst(qsfp_0_tx_rst_0),\n        .logic_clk(clk),\n        .logic_rst(rst),\n        .tx_axis_tdata(tx_axis_tdata),\n        .tx_axis_tkeep(tx_axis_tkeep),\n        .tx_axis_tvalid(tx_axis_tvalid),\n        .tx_axis_tready(tx_axis_tready),\n        .tx_axis_tlast(tx_axis_tlast),\n        .tx_axis_tuser(tx_axis_tuser),\n        .rx_axis_tdata(rx_axis_tdata),\n        .rx_axis_tkeep(rx_axis_tkeep),\n        .rx_axis_tvalid(rx_axis_tvalid),\n        .rx_axis_tready(rx_axis_tready),\n        .rx_axis_tlast(rx_axis_tlast),\n        .rx_axis_tuser(rx_axis_tuser),\n        .xgmii_rxd(qsfp_0_rxd_0),\n        .xgmii_rxc(qsfp_0_rxc_0),\n        .xgmii_txd(qsfp_0_txd_0),\n        .xgmii_txc(qsfp_0_txc_0),\n        .tx_fifo_overflow(),\n        .tx_fifo_bad_frame(),\n        .tx_fifo_good_frame(),\n        .rx_error_bad_frame(),\n        .rx_error_bad_fcs(),\n        .rx_fifo_overflow(),\n        .rx_fifo_bad_frame(),\n        .rx_fifo_good_frame(),\n        .ifg_delay(8'd12)\n    );\n\n    eth_axis_rx #(\n        .DATA_WIDTH(64)\n    )\n    eth_axis_rx_inst (\n        .clk(clk),\n        .rst(rst),\n        .s_axis_tdata(rx_axis_tdata),\n        .s_axis_tkeep(rx_axis_tkeep),\n        .s_axis_tvalid(rx_axis_tvalid),\n        .s_axis_tready(rx_axis_tready),\n        .s_axis_tlast(rx_axis_tlast),\n        .s_axis_tuser(rx_axis_tuser),\n        .m_eth_hdr_valid(rx_eth_hdr_valid),\n        .m_eth_hdr_ready(rx_eth_hdr_ready),\n        .m_eth_dest_mac(rx_eth_dest_mac),\n        .m_eth_src_mac(rx_eth_src_mac),\n        .m_eth_type(rx_eth_type),\n        .m_eth_payload_axis_tdata(rx_eth_payload_axis_tdata),\n        .m_eth_payload_axis_tkeep(rx_eth_payload_axis_tkeep),\n        .m_eth_payload_axis_tvalid(rx_eth_payload_axis_tvalid),\n        .m_eth_payload_axis_tready(rx_eth_payload_axis_tready),\n        .m_eth_payload_axis_tlast(rx_eth_payload_axis_tlast),\n        .m_eth_payload_axis_tuser(rx_eth_payload_axis_tuser),\n        .busy(),\n        .error_header_early_termination()\n    );\n\n    eth_axis_tx #(\n        .DATA_WIDTH(64)\n    )\n    eth_axis_tx_inst (\n        .clk(clk),\n        .rst(rst),\n        .s_eth_hdr_valid(tx_eth_hdr_valid),\n        .s_eth_hdr_ready(tx_eth_hdr_ready),\n        .s_eth_dest_mac(tx_eth_dest_mac),\n        .s_eth_src_mac(tx_eth_src_mac),\n        .s_eth_type(tx_eth_type),\n        .s_eth_payload_axis_tdata(tx_eth_payload_axis_tdata),\n        .s_eth_payload_axis_tkeep(tx_eth_payload_axis_tkeep),\n        .s_eth_payload_axis_tvalid(tx_eth_payload_axis_tvalid),\n        .s_eth_payload_axis_tready(tx_eth_payload_axis_tready),\n        .s_eth_payload_axis_tlast(tx_eth_payload_axis_tlast),\n        .s_eth_payload_axis_tuser(tx_eth_payload_axis_tuser),\n        .m_axis_tdata(tx_axis_tdata),\n        .m_axis_tkeep(tx_axis_tkeep),\n        .m_axis_tvalid(tx_axis_tvalid),\n        .m_axis_tready(tx_axis_tready),\n        .m_axis_tlast(tx_axis_tlast),\n        .m_axis_tuser(tx_axis_tuser),\n        .busy()\n    );\n\n    udp_complete_64\n    udp_complete_inst (\n        .clk(clk),\n        .rst(rst),\n        .s_eth_hdr_valid(rx_eth_hdr_valid),\n        .s_eth_hdr_ready(rx_eth_hdr_ready),\n        .s_eth_dest_mac(rx_eth_dest_mac),\n        .s_eth_src_mac(rx_eth_src_mac),\n        .s_eth_type(rx_eth_type),\n        .s_eth_payload_axis_tdata(rx_eth_payload_axis_tdata),\n        .s_eth_payload_axis_tkeep(rx_eth_payload_axis_tkeep),\n        .s_eth_payload_axis_tvalid(rx_eth_payload_axis_tvalid),\n        .s_eth_payload_axis_tready(rx_eth_payload_axis_tready),\n        .s_eth_payload_axis_tlast(rx_eth_payload_axis_tlast),\n        .s_eth_payload_axis_tuser(rx_eth_payload_axis_tuser),\n        .m_eth_hdr_valid(tx_eth_hdr_valid),\n        .m_eth_hdr_ready(tx_eth_hdr_ready),\n        .m_eth_dest_mac(tx_eth_dest_mac),\n        .m_eth_src_mac(tx_eth_src_mac),\n        .m_eth_type(tx_eth_type),\n        .m_eth_payload_axis_tdata(tx_eth_payload_axis_tdata),\n        .m_eth_payload_axis_tkeep(tx_eth_payload_axis_tkeep),\n        .m_eth_payload_axis_tvalid(tx_eth_payload_axis_tvalid),\n        .m_eth_payload_axis_tready(tx_eth_payload_axis_tready),\n        .m_eth_payload_axis_tlast(tx_eth_payload_axis_tlast),\n        .m_eth_payload_axis_tuser(tx_eth_payload_axis_tuser),\n        .s_ip_hdr_valid(tx_ip_hdr_valid),\n        .s_ip_hdr_ready(tx_ip_hdr_ready),\n        .s_ip_dscp(tx_ip_dscp),\n        .s_ip_ecn(tx_ip_ecn),\n        .s_ip_length(tx_ip_length),\n        .s_ip_ttl(tx_ip_ttl),\n        .s_ip_protocol(tx_ip_protocol),\n        .s_ip_source_ip(tx_ip_source_ip),\n        .s_ip_dest_ip(tx_ip_dest_ip),\n        .s_ip_payload_axis_tdata(tx_ip_payload_axis_tdata),\n        .s_ip_payload_axis_tkeep(tx_ip_payload_axis_tkeep),\n        .s_ip_payload_axis_tvalid(tx_ip_payload_axis_tvalid),\n        .s_ip_payload_axis_tready(tx_ip_payload_axis_tready),\n        .s_ip_payload_axis_tlast(tx_ip_payload_axis_tlast),\n        .s_ip_payload_axis_tuser(tx_ip_payload_axis_tuser),\n        .m_ip_hdr_valid(rx_ip_hdr_valid),\n        .m_ip_hdr_ready(rx_ip_hdr_ready),\n        .m_ip_eth_dest_mac(rx_ip_eth_dest_mac),\n        .m_ip_eth_src_mac(rx_ip_eth_src_mac),\n        .m_ip_eth_type(rx_ip_eth_type),\n        .m_ip_version(rx_ip_version),\n        .m_ip_ihl(rx_ip_ihl),\n        .m_ip_dscp(rx_ip_dscp),\n        .m_ip_ecn(rx_ip_ecn),\n        .m_ip_length(rx_ip_length),\n        .m_ip_identification(rx_ip_identification),\n        .m_ip_flags(rx_ip_flags),\n        .m_ip_fragment_offset(rx_ip_fragment_offset),\n        .m_ip_ttl(rx_ip_ttl),\n        .m_ip_protocol(rx_ip_protocol),\n        .m_ip_header_checksum(rx_ip_header_checksum),\n        .m_ip_source_ip(rx_ip_source_ip),\n        .m_ip_dest_ip(rx_ip_dest_ip),\n        .m_ip_payload_axis_tdata(rx_ip_payload_axis_tdata),\n        .m_ip_payload_axis_tkeep(rx_ip_payload_axis_tkeep),\n        .m_ip_payload_axis_tvalid(rx_ip_payload_axis_tvalid),\n        .m_ip_payload_axis_tready(rx_ip_payload_axis_tready),\n        .m_ip_payload_axis_tlast(rx_ip_payload_axis_tlast),\n        .m_ip_payload_axis_tuser(rx_ip_payload_axis_tuser),\n        .s_udp_hdr_valid(tx_udp_hdr_valid),\n        .s_udp_hdr_ready(tx_udp_hdr_ready),\n        .s_udp_ip_dscp(tx_udp_ip_dscp),\n        .s_udp_ip_ecn(tx_udp_ip_ecn),\n        .s_udp_ip_ttl(tx_udp_ip_ttl),\n        .s_udp_ip_source_ip(tx_udp_ip_source_ip),\n        .s_udp_ip_dest_ip(tx_udp_ip_dest_ip),\n        .s_udp_source_port(tx_udp_source_port),\n        .s_udp_dest_port(tx_udp_dest_port),\n        .s_udp_length(tx_udp_length),\n        .s_udp_checksum(tx_udp_checksum),\n        .s_udp_payload_axis_tdata(tx_udp_payload_axis_tdata),\n        .s_udp_payload_axis_tkeep(tx_udp_payload_axis_tkeep),\n        .s_udp_payload_axis_tvalid(tx_udp_payload_axis_tvalid),\n        .s_udp_payload_axis_tready(tx_udp_payload_axis_tready),\n        .s_udp_payload_axis_tlast(tx_udp_payload_axis_tlast),\n        .s_udp_payload_axis_tuser(tx_udp_payload_axis_tuser),\n        .m_udp_hdr_valid(rx_udp_hdr_valid),\n        .m_udp_hdr_ready(rx_udp_hdr_ready),\n        .m_udp_eth_dest_mac(rx_udp_eth_dest_mac),\n        .m_udp_eth_src_mac(rx_udp_eth_src_mac),\n        .m_udp_eth_type(rx_udp_eth_type),\n        .m_udp_ip_version(rx_udp_ip_version),\n        .m_udp_ip_ihl(rx_udp_ip_ihl),\n        .m_udp_ip_dscp(rx_udp_ip_dscp),\n        .m_udp_ip_ecn(rx_udp_ip_ecn),\n        .m_udp_ip_length(rx_udp_ip_length),\n        .m_udp_ip_identification(rx_udp_ip_identification),\n        .m_udp_ip_flags(rx_udp_ip_flags),\n        .m_udp_ip_fragment_offset(rx_udp_ip_fragment_offset),\n        .m_udp_ip_ttl(rx_udp_ip_ttl),\n        .m_udp_ip_protocol(rx_udp_ip_protocol),\n        .m_udp_ip_header_checksum(rx_udp_ip_header_checksum),\n        .m_udp_ip_source_ip(rx_udp_ip_source_ip),\n        .m_udp_ip_dest_ip(rx_udp_ip_dest_ip),\n        .m_udp_source_port(rx_udp_source_port),\n        .m_udp_dest_port(rx_udp_dest_port),\n        .m_udp_length(rx_udp_length),\n        .m_udp_checksum(rx_udp_checksum),\n        .m_udp_payload_axis_tdata(rx_udp_payload_axis_tdata),\n        .m_udp_payload_axis_tkeep(rx_udp_payload_axis_tkeep),\n        .m_udp_payload_axis_tvalid(rx_udp_payload_axis_tvalid),\n        .m_udp_payload_axis_tready(rx_udp_payload_axis_tready),\n        .m_udp_payload_axis_tlast(rx_udp_payload_axis_tlast),\n        .m_udp_payload_axis_tuser(rx_udp_payload_axis_tuser),\n        .ip_rx_busy(),\n        .ip_tx_busy(),\n        .udp_rx_busy(),\n        .udp_tx_busy(),\n        .ip_rx_error_header_early_termination(),\n        .ip_rx_error_payload_early_termination(),\n        .ip_rx_error_invalid_header(),\n        .ip_rx_error_invalid_checksum(),\n        .ip_tx_error_payload_early_termination(),\n        .ip_tx_error_arp_failed(),\n        .udp_rx_error_header_early_termination(),\n        .udp_rx_error_payload_early_termination(),\n        .udp_tx_error_payload_early_termination(),\n        .local_mac(local_mac),\n        .local_ip(local_ip),\n        .gateway_ip(gateway_ip),\n        .subnet_mask(subnet_mask),\n        .clear_arp_cache(1'b0)\n    );\n\n    axis_fifo #(\n        .DEPTH(8192),\n        .DATA_WIDTH(64),\n        .KEEP_ENABLE(1),\n        .KEEP_WIDTH(8),\n        .ID_ENABLE(0),\n        .DEST_ENABLE(0),\n        .USER_ENABLE(1),\n        .USER_WIDTH(1),\n        .FRAME_FIFO(0)\n    )\n    udp_payload_fifo (\n        .clk(clk),\n        .rst(rst),\n        .s_axis_tdata(rx_fifo_udp_payload_axis_tdata),\n        .s_axis_tkeep(rx_fifo_udp_payload_axis_tkeep),\n        .s_axis_tvalid(rx_fifo_udp_payload_axis_tvalid),\n        .s_axis_tready(rx_fifo_udp_payload_axis_tready),\n        .s_axis_tlast(rx_fifo_udp_payload_axis_tlast),\n        .s_axis_tid(0),\n        .s_axis_tdest(0),\n        .s_axis_tuser(rx_fifo_udp_payload_axis_tuser),\n        .m_axis_tdata(tx_fifo_udp_payload_axis_tdata),\n        .m_axis_tkeep(tx_fifo_udp_payload_axis_tkeep),\n        .m_axis_tvalid(tx_fifo_udp_payload_axis_tvalid),\n        .m_axis_tready(tx_fifo_udp_payload_axis_tready),\n        .m_axis_tlast(tx_fifo_udp_payload_axis_tlast),\n        .m_axis_tid(),\n        .m_axis_tdest(),\n        .m_axis_tuser(tx_fifo_udp_payload_axis_tuser),\n        .status_overflow(),\n        .status_bad_frame(),\n        .status_good_frame()\n    );\n\nendmodule"}
{"task_id": 1511, "completion": "reg [U_FIFO_WIDTH - 1:0] fifo [(2^U_FIFO_SQ_DEPTH) - 1:0];\n    reg [U_FIFO_SQ_DEPTH - 1:0] wr_ptr = 0;\n    reg [U_FIFO_SQ_DEPTH - 1:0] rd_ptr = 0;\n    always@(posedge wr_en or negedge rst)\n    begin\n        if(!rst)    \n            wr_ptr <= 0;\n        else if(!full_flg)\n        begin\n            fifo[wr_ptr] <= dataIn;\n            wr_ptr <= wr_ptr + 1'b1;\n        end\n    end\n    always@(posedge rd_en or negedge rst)\n    begin\n        if(!rst)\n            rd_ptr <= 0;\n        else if(!empty_flg)\n        begin\n            rd_ptr <= rd_ptr + 1'b1;\n        end\n    end\n    assign empty_flg = (wr_ptr == rd_ptr)? 1'b1 : 1'b0; \n    assign full_flg = ((wr_ptr + {{U_FIFO_SQ_DEPTH-1{1'b0}}, 1'b1}) == rd_ptr)? 1'b1 : 1'b0; \n    assign dataOut = (empty_flg)? {U_FIFO_WIDTH{1'b0}} : fifo[rd_ptr]; \nendmodule"}
{"task_id": 1495, "completion": "reg                     full0;\n   reg                     full1;\n   reg [DATA_WIDTH-1:0]    data0;\n   reg [DATA_WIDTH-1:0]    data1;\n\n   assign out_valid = full1;\n   assign out_data  = data1;    \n   generate if (PIPELINE_READY == 1) \n     begin : REGISTERED_READY_PLINE\n        assign in_ready  = !full0;\n        always @(posedge clk, posedge reset) begin\n           if (reset) begin\n              data0 <= {DATA_WIDTH{1'b0}};\n              data1 <= {DATA_WIDTH{1'b0}};\n           end else begin\n              if (~full0)\n                data0 <= in_data;\n              if (~full1 || (out_ready && out_valid)) begin\n                 if (full0)\n                   data1 <= data0;\n                 else\n                   data1 <= in_data;\n              end\n           end\n        end\n        always @(posedge clk or posedge reset) begin\n           if (reset) begin\n              full0    <= 1'b0;\n              full1    <= 1'b0;\n           end else begin\n              if (~full0 & ~full1) begin\n                 if (in_valid) begin\n                    full1 <= 1'b1;\n                 end\n              end // ~f1 & ~f0\n              if (full1 & ~full0) begin\n                 if (in_valid & ~out_ready) begin\n                    full0 <= 1'b1;\n                 end\n                 if (~in_valid & out_ready) begin\n                    full1 <= 1'b0;\n                 end\n              end // f1 & ~f0\n              if (full1 & full0) begin\n                 if (out_ready) begin\n                    full0 <= 1'b0;\n                 end\n              end // end go back to one datum stage\n           end\n        end\n     end \n   else \n     begin : UNREGISTERED_READY_PLINE\n\tassign in_ready = (~full1) | out_ready;\n\talways @(posedge clk or posedge reset) begin\n\t   if (reset) begin\n\t      data1 <= 'b0;\n\t      full1 <= 1'b0;\n\t   end\n\t   else begin\n\t      if (in_ready) begin\n\t\t data1 <= in_data;\n\t\t full1 <= in_valid;\n\t      end\n\t   end\n\tend\t\n     end\n   endgenerate\nendmodule"}
{"task_id": 1486, "completion": "reg            nce;\n    reg            nwe;\n    reg            noe;\n    reg            nrst;\n\n    always @ (posedge clk, posedge rst) begin\n      if (rst) begin\n        fl_ce_n  <= #1 1'b1;\n        fl_we_n  <= #1 1'b1;\n        fl_oe_n  <= #1 1'b0;\n        fl_rst_n <= #1 1'b0;\n      end else begin\n        fl_ce_n  <= #1 1'b0;\n        fl_we_n  <= #1 1'b1; // !we;\n        fl_oe_n  <= #1 1'b0; // we;\n        fl_rst_n <= #1 1'b1;\n      end\n    end\n\n    reg            timer_start;\n    reg  [  2-1:0] timer;\n\n    always @ (posedge clk, posedge rst) begin\n      if (rst)\n        timer <= #1 2'h0;\n      else if (timer_start)\n        timer <= #1 DLY-1;\n      else if (|timer)\n        timer <= #1 timer - 2'h1;\n    end\n\n    localparam S_ID = 3'h0;\n    localparam S_R1 = 3'h4;\n    localparam S_R2 = 3'h5;\n    localparam S_R3 = 3'h6;\n    localparam S_R4 = 3'h7;\n\n    reg  [   3-1:0] state;\n\n    always @ (posedge clk, posedge rst) begin\n      if (rst) begin\n        state <= #1 S_ID;\n        timer_start <= #1 1'b0;\n        ack <= #1 1'b0;\n      end else begin\n        if (timer_start) timer_start <= #1 1'b0;\n        case (state)\n          S_ID : begin\n            if (cs) begin\n              fl_adr <= #1 {boot_sel^adr[21], adr[20:2], 2'b00};\n              timer_start <= #1 1'b1;\n              state <= #1 S_R1;\n            end\n          end\n          S_R1 : begin\n            if ((~|timer) && !timer_start) begin\n              fl_adr <= #1 {boot_sel^adr[21], adr[20:2], 2'b01};\n              timer_start <= #1 1'b1;\n              state <= #1 S_R2;\n              if (BE == 1)\n                dat_r[31:24] <= #1 fl_dat_r;\n              else\n                dat_r[ 7: 0] <= #1 fl_dat_r;\n            end\n          end\n          S_R2 : begin\n            if ((~|timer) && !timer_start) begin\n              fl_adr <= #1 {boot_sel^adr[21], adr[20:2], 2'b10};\n              timer_start <= #1 1'b1;\n              state <= #1 S_R3;\n              if (BE == 1)\n                dat_r[23:16] <= #1 fl_dat_r;\n              else\n                dat_r[15: 8] <= #1 fl_dat_r;\n            end\n          end\n          S_R3 : begin\n            if ((~|timer) && !timer_start) begin\n              fl_adr <= #1 {boot_sel^adr[21], adr[20:2], 2'b11};\n              timer_start <= #1 1'b1;\n              state <= #1 S_R4;\n              if (BE == 1)\n                dat_r[15: 8] <= #1 fl_dat_r;\n              else\n                dat_r[23:16] <= #1 fl_dat_r;\n            end\n          end\n          S_R4 : begin\n            if (timer == 2'h1) begin\n              ack <= #1 1'b1;\n            end\n            if ((~|timer) && !timer_start) begin\n              state <= #1 S_ID;\n              ack <= #1 1'b0;\n              if (BE == 1)\n                dat_r[ 7: 0] <= #1 fl_dat_r;\n              else\n                dat_r[31:24] <= #1 fl_dat_r;\n            end\n          end\n        endcase\n      end\n    end\n\n    assign err      = 1'b0;\n    assign fl_dat_w = 8'hxx;\n\nendmodule"}
{"task_id": 1393, "completion": "genvar word_cnt;\n  localparam [2-1:0] C_RESP_OKAY        = 2'b00;\n  localparam [2-1:0] C_RESP_EXOKAY      = 2'b01;\n  localparam [2-1:0] C_RESP_SLVERROR    = 2'b10;\n  localparam [2-1:0] C_RESP_DECERR      = 2'b11;\n  localparam [24-1:0] C_DOUBLE_LEN       = 24'b0000_0000_0000_0000_1111_1111;\n  reg                             first_word;\n  reg  [C_S_AXI_BYTES_LOG-1:0]    current_word_1;\n  reg  [C_S_AXI_BYTES_LOG-1:0]    current_word;\n  wire [C_S_AXI_BYTES_LOG-1:0]    current_word_adjusted;\n  wire [C_RATIO_LOG-1:0]          current_index;\n  wire                            last_beat;\n  wire                            last_word;\n  wire                            new_si_word;\n  reg  [C_S_AXI_BYTES_LOG-1:0]    size_mask;\n  wire [C_S_AXI_BYTES_LOG-1:0]    next_word;\n  reg                             first_mi_word;\n  reg  [8-1:0]                    length_counter_1;\n  reg  [8-1:0]                    length_counter;\n  wire [8-1:0]                    next_length_counter;\n  wire                            load_rresp;\n  reg                             need_to_update_rresp;\n  reg  [2-1:0]                    S_AXI_RRESP_ACC;\n  wire                            first_si_in_mi;\n  wire                            first_mi_in_si;\n  wire                            word_completed;\n  wire                            cmd_ready_i;\n  wire                            pop_si_data;\n  wire                            pop_mi_data;\n  wire                            si_stalling;\n  wire                            M_AXI_RREADY_I;\n  reg  [C_S_AXI_DATA_WIDTH-1:0]   S_AXI_RDATA_II;\n  wire [C_AXI_ID_WIDTH-1:0]       S_AXI_RID_I;\n  reg  [C_S_AXI_DATA_WIDTH-1:0]   S_AXI_RDATA_I;\n  reg  [2-1:0]                    S_AXI_RRESP_I;\n  wire                            S_AXI_RLAST_I;\n  wire                            S_AXI_RVALID_I;\n  wire                            S_AXI_RREADY_I;\n  always @ *\n  begin\n    case (cmd_size)\n      3'b000: size_mask = C_DOUBLE_LEN[8 +: C_S_AXI_BYTES_LOG];\n      3'b001: size_mask = C_DOUBLE_LEN[7 +: C_S_AXI_BYTES_LOG];\n      3'b010: size_mask = C_DOUBLE_LEN[6 +: C_S_AXI_BYTES_LOG];\n      3'b011: size_mask = C_DOUBLE_LEN[5 +: C_S_AXI_BYTES_LOG];\n      3'b100: size_mask = C_DOUBLE_LEN[4 +: C_S_AXI_BYTES_LOG];\n      3'b101: size_mask = C_DOUBLE_LEN[3 +: C_S_AXI_BYTES_LOG];\n      3'b110: size_mask = C_DOUBLE_LEN[2 +: C_S_AXI_BYTES_LOG];\n      3'b111: size_mask = C_DOUBLE_LEN[1 +: C_S_AXI_BYTES_LOG];\n    endcase\n  end\n  assign word_completed = ( cmd_fix ) |\n                          ( cmd_mirror ) |\n                          ( ~cmd_fix & ( ( next_word & size_mask ) == {C_S_AXI_BYTES_LOG{1'b0}} ) ) | \n                          ( ~cmd_fix & last_word );\n  assign M_AXI_RREADY_I =  cmd_valid & (S_AXI_RREADY_I | ~word_completed);\n  assign M_AXI_RREADY   = M_AXI_RREADY_I;\n  assign S_AXI_RVALID_I = M_AXI_RVALID & word_completed & cmd_valid;\n  assign pop_mi_data    = M_AXI_RVALID & M_AXI_RREADY_I;\n  assign pop_si_data    = S_AXI_RVALID_I & S_AXI_RREADY_I;\n  assign cmd_ready_i    = cmd_valid & pop_si_data & last_word;\n  assign cmd_ready      = cmd_ready_i;\n  assign si_stalling    = S_AXI_RVALID_I & ~S_AXI_RREADY_I;\n  always @ *\n  begin\n    if ( first_word | cmd_fix )\n      current_word = cmd_first_word;\n    else\n      current_word = current_word_1;\n  end\n  assign next_word              = ( current_word + cmd_step ) & cmd_mask;\n  assign current_word_adjusted  = current_word + cmd_offset;\n  assign current_index          = current_word_adjusted[C_S_AXI_BYTES_LOG-C_RATIO_LOG +: C_RATIO_LOG];\n  always @ (posedge ACLK) begin\n    if (ARESET) begin\n      first_word      <= 1'b1;\n      current_word_1  <= 'b0;\n    end else begin\n      if ( pop_mi_data ) begin\n        if ( M_AXI_RLAST ) begin\n          first_word <=  1'b1;\n        end else begin\n          first_word <=  1'b0;\n        end\n        current_word_1 <= next_word;\n      end\n    end\n  end\n  always @ *\n  begin\n    if ( first_mi_word )\n      length_counter = cmd_length;\n    else\n      length_counter = length_counter_1;\n  end\n  assign next_length_counter = length_counter - 1'b1;\n  always @ (posedge ACLK) begin\n    if (ARESET) begin\n      first_mi_word    <= 1'b1;\n      length_counter_1 <= 8'b0;\n    end else begin\n      if ( pop_mi_data ) begin\n        if ( M_AXI_RLAST ) begin\n          first_mi_word    <= 1'b1;\n        end else begin\n          first_mi_word    <= 1'b0;\n        end\n        length_counter_1 <= next_length_counter;\n      end\n    end\n  end\n  assign last_beat    = ( length_counter == 8'b0 );\n  assign last_word    = ( last_beat );\n  assign new_si_word  = ( current_word == {C_S_AXI_BYTES_LOG{1'b0}} );\n  assign S_AXI_RID_I    = cmd_id;\n  assign S_AXI_RLAST_I  = M_AXI_RLAST & ~cmd_split;\n  assign first_si_in_mi = cmd_mirror | \n                          first_mi_word |\n                          ( ~cmd_mirror & ( ( current_word & size_mask ) == {C_S_AXI_BYTES_LOG{1'b0}} ) );\n  assign load_rresp     = first_si_in_mi;\n  always @ *\n  begin\n    case (S_AXI_RRESP_ACC)\n      C_RESP_EXOKAY:    need_to_update_rresp = ( M_AXI_RRESP == C_RESP_OKAY     |\n                                                 M_AXI_RRESP == C_RESP_SLVERROR |\n                                                 M_AXI_RRESP == C_RESP_DECERR );\n      C_RESP_OKAY:      need_to_update_rresp = ( M_AXI_RRESP == C_RESP_SLVERROR |\n                                                 M_AXI_RRESP == C_RESP_DECERR );\n      C_RESP_SLVERROR:  need_to_update_rresp = ( M_AXI_RRESP == C_RESP_DECERR );\n      C_RESP_DECERR:    need_to_update_rresp = 1'b0;\n    endcase\n  end\n  always @ *\n  begin\n    if ( load_rresp || need_to_update_rresp ) begin\n      S_AXI_RRESP_I = M_AXI_RRESP;\n    end else begin\n      S_AXI_RRESP_I = S_AXI_RRESP_ACC;\n    end\n  end\n  always @ (posedge ACLK) begin\n    if (ARESET) begin\n      S_AXI_RRESP_ACC <= C_RESP_OKAY;\n    end else begin\n      if ( pop_mi_data ) begin\n        S_AXI_RRESP_ACC <= S_AXI_RRESP_I;\n      end\n    end\n  end\n  generate\n    for (word_cnt = 0; word_cnt < (2 ** C_RATIO_LOG) ; word_cnt = word_cnt + 1) begin : WORD_LANE\n      always @ (posedge ACLK) begin\n        if (ARESET) begin\n          S_AXI_RDATA_II[word_cnt*C_M_AXI_DATA_WIDTH   +: C_M_AXI_DATA_WIDTH]   <= {C_M_AXI_DATA_WIDTH{1'b0}};\n        end else begin\n          if ( pop_si_data ) begin\n            S_AXI_RDATA_II[word_cnt*C_M_AXI_DATA_WIDTH   +: C_M_AXI_DATA_WIDTH]   <= {C_M_AXI_DATA_WIDTH{1'b0}};\n          end else if ( current_index == word_cnt & pop_mi_data ) begin\n            S_AXI_RDATA_II[word_cnt*C_M_AXI_DATA_WIDTH   +: C_M_AXI_DATA_WIDTH]   <= M_AXI_RDATA;\n          end\n        end\n      end\n      always @ *\n      begin\n        if ( ( current_index == word_cnt ) | cmd_mirror ) begin\n          S_AXI_RDATA_I[word_cnt*C_M_AXI_DATA_WIDTH +: C_M_AXI_DATA_WIDTH] = M_AXI_RDATA;\n        end else begin\n          S_AXI_RDATA_I[word_cnt*C_M_AXI_DATA_WIDTH +: C_M_AXI_DATA_WIDTH] = \n                        S_AXI_RDATA_II[word_cnt*C_M_AXI_DATA_WIDTH +: C_M_AXI_DATA_WIDTH];\n        end\n      end\n    end // end for word_cnt\n  endgenerate\n  assign S_AXI_RREADY_I = S_AXI_RREADY;\n  assign S_AXI_RVALID   = S_AXI_RVALID_I;\n  assign S_AXI_RID      = S_AXI_RID_I;\n  assign S_AXI_RDATA    = S_AXI_RDATA_I;\n  assign S_AXI_RRESP    = S_AXI_RRESP_I;\n  assign S_AXI_RLAST    = S_AXI_RLAST_I;\n\nendmodule"}
{"task_id": 590, "completion": "wire [31:0] axi_interconnect_1_M_ARADDR;\n    wire [1:0] axi_interconnect_1_M_ARBURST;\n    wire [3:0] axi_interconnect_1_M_ARCACHE;\n    wire [0:0] axi_interconnect_1_M_ARESETN;\n    wire [11:0] axi_interconnect_1_M_ARID;\n    wire [7:0] axi_interconnect_1_M_ARLEN;\n    wire [1:0] axi_interconnect_1_M_ARLOCK;\n    wire [2:0] axi_interconnect_1_M_ARPROT;\n    wire [0:0] axi_interconnect_1_M_ARREADY;\n    wire [2:0] axi_interconnect_1_M_ARSIZE;\n    wire [0:0] axi_interconnect_1_M_ARVALID;\n    wire [31:0] axi_interconnect_1_M_AWADDR;\n    wire [1:0] axi_interconnect_1_M_AWBURST;\n    wire [3:0] axi_interconnect_1_M_AWCACHE;\n    wire [11:0] axi_interconnect_1_M_AWID;\n    wire [7:0] axi_interconnect_1_M_AWLEN;\n    wire [1:0] axi_interconnect_1_M_AWLOCK;\n    wire [2:0] axi_interconnect_1_M_AWPROT;\n    wire [0:0] axi_interconnect_1_M_AWREADY;\n    wire [2:0] axi_interconnect_1_M_AWSIZE;\n    wire [0:0] axi_interconnect_1_M_AWVALID;\n    wire [11:0] axi_interconnect_1_M_BID;\n    wire [0:0] axi_interconnect_1_M_BREADY;\n    wire [1:0] axi_interconnect_1_M_BRESP;\n    wire [0:0] axi_interconnect_1_M_BVALID;\n    wire [31:0] axi_interconnect_1_M_RDATA;\n    wire [11:0] axi_interconnect_1_M_RID;\n    wire [0:0] axi_interconnect_1_M_RLAST;\n    wire [0:0] axi_interconnect_1_M_RREADY;\n    wire [1:0] axi_interconnect_1_M_RRESP;\n    wire [0:0] axi_interconnect_1_M_RVALID;\n    wire [31:0] axi_interconnect_1_M_WDATA;\n    wire [0:0] axi_interconnect_1_M_WLAST;\n    wire [0:0] axi_interconnect_1_M_WREADY;\n    wire [3:0] axi_interconnect_1_M_WSTRB;\n    wire [0:0] axi_interconnect_1_M_WVALID;\n    wire [31:0] axi_interconnect_1_S_ARADDR;\n    wire [1:0] axi_interconnect_1_S_ARBURST;\n    wire [3:0] axi_interconnect_1_S_ARCACHE;\n    wire [11:0] axi_interconnect_1_S_ARID;\n    wire [7:0] axi_interconnect_1_S_ARLEN;\n    wire [1:0] axi_interconnect_1_S_ARLOCK;\n    wire [2:0] axi_interconnect_1_S_ARPROT;\n    wire [3:0] axi_interconnect_1_S_ARQOS;\n    wire [0:0] axi_interconnect_1_S_ARREADY;\n    wire [2:0] axi_interconnect_1_S_ARSIZE;\n    wire [0:0] axi_interconnect_1_S_ARVALID;\n    wire [31:0] axi_interconnect_1_S_AWADDR;\n    wire [1:0] axi_interconnect_1_S_AWBURST;\n    wire [3:0] axi_interconnect_1_S_AWCACHE;\n    wire [11:0] axi_interconnect_1_S_AWID;\n    wire [7:0] axi_interconnect_1_S_AWLEN;\n    wire [1:0] axi_interconnect_1_S_AWLOCK;\n    wire [2:0] axi_interconnect_1_S_AWPROT;\n    wire [3:0] axi_interconnect_1_S_AWQOS;\n    wire [0:0] axi_interconnect_1_S_AWREADY;\n    wire [2:0] axi_interconnect_1_S_AWSIZE;\n    wire [0:0] axi_interconnect_1_S_AWVALID;\n    wire [11:0] axi_interconnect_1_S_BID;\n    wire [0:0] axi_interconnect_1_S_BREADY;\n    wire [1:0] axi_interconnect_1_S_BRESP;\n    wire [0:0] axi_interconnect_1_S_BVALID;\n    wire [31:0] axi_interconnect_1_S_RDATA;\n    wire [11:0] axi_interconnect_1_S_RID;\n    wire [0:0] axi_interconnect_1_S_RLAST;\n    wire [0:0] axi_interconnect_1_S_RREADY;\n    wire [1:0] axi_interconnect_1_S_RRESP;\n    wire [0:0] axi_interconnect_1_S_RVALID;\n    wire [31:0] axi_interconnect_1_S_WDATA;\n    wire [11:0] axi_interconnect_1_S_WID;\n    wire [0:0] axi_interconnect_1_S_WLAST;\n    wire [0:0] axi_interconnect_1_S_WREADY;\n    wire [3:0] axi_interconnect_1_S_WSTRB;\n    wire [0:0] axi_interconnect_1_S_WVALID;\n    wire [4:0] coprocessor_0_BTN_IN;\n    wire [7:0] coprocessor_0_LED_OUT;\n    wire [7:0] coprocessor_0_SW_IN;\n    wire net_gnd0;\n    wire [0:0] net_gnd1;\n    wire [1:0] net_gnd2;\n    wire [2:0] net_gnd3;\n    wire [3:0] net_gnd4;\n    wire [4:0] net_gnd5;\n    wire [5:0] net_gnd6;\n    wire [7:0] net_gnd8;\n    wire [11:0] net_gnd12;\n    wire [31:0] net_gnd32;\n    wire [63:0] net_gnd64;\n    wire processing_system7_0_DDR_WEB;\n    wire [0:0] processing_system7_0_FCLK_CLK0;\n    wire processing_system7_0_FCLK_RESET0_N;\n    wire processing_system7_0_PS_CLK;\n    wire processing_system7_0_PS_PORB;\n    wire processing_system7_0_PS_SRSTB;\n\n    assign processing_system7_0_PS_SRSTB = processing_system7_0_PS_SRSTB_pin;\n    assign processing_system7_0_PS_CLK = processing_system7_0_PS_CLK_pin;\n    assign processing_system7_0_PS_PORB = processing_system7_0_PS_PORB_pin;\n    assign processing_system7_0_DDR_WEB_pin = processing_system7_0_DDR_WEB;\n    assign coprocessor_0_LED_OUT_pin = coprocessor_0_LED_OUT;\n    assign coprocessor_0_SW_IN = coprocessor_0_SW_IN_pin;\n    assign coprocessor_0_BTN_IN = coprocessor_0_BTN_IN_pin;\n    assign net_gnd0 = 1'b0;\n    assign net_gnd1[0:0] = 1'b0;\n    assign net_gnd12[11:0] = 12'b000000000000;\n    assign net_gnd2[1:0] = 2'b00;\n    assign net_gnd3[2:0] = 3'b000;\n    assign net_gnd32[31:0] = 32'b00000000000000000000000000000000;\n    assign net_gnd4[3:0] = 4'b0000;\n    assign net_gnd5[4:0] = 5'b00000;\n    assign net_gnd6[5:0] = 6'b000000;\n    assign net_gnd64[63:0] = 64'b0000000000000000000000000000000000000000000000000000000000000000;\n    assign net_gnd8[7:0] = 8'b00000000;\n\n    (* CORE_GENERATION_INFO = \"processing_system7_0,processing_system7,{C_TTC0_PERIPHERAL_ENABLE = 1,C_TTC0_TTC0_IO = EMIO,C_MIO_MIO[4]_IOTYPE = LVCMOS 3.3V,...\" *)\n\n    (* BOX_TYPE = \"user_black_box\" *)\n    module_1_processing_system7_0_wrapper\n      processing_system7_0 (\n        .CAN0_PHY_TX (  ),\n        .CAN0_PHY_RX ( net_gnd0 ),\n        .CAN1_PHY_TX (  ),\n        .CAN1_PHY_RX ( net_gnd0 ),\n        ...\n        .IRQ_P2F_CAN1 (  )\n      );\n\n    (* BOX_TYPE = \"user_black_box\" *)\n    module_1_axi_interconnect_1_wrapper\n      axi_interconnect_1 (\n        .INTERCONNECT_ACLK ( processing_system7_0_FCLK_CLK0[0] ),\n        .INTERCONNECT_ARESETN ( processing_system7_0_FCLK_RESET0_N ),\n        ...\n        .DEBUG_MP_MR_WDATACONTROL (  )\n      );\n\n    (* BOX_TYPE = \"user_black_box\" *)\n    module_1_coprocessor_0_wrapper\n      coprocessor_0 (\n        .LED_OUT ( coprocessor_0_LED_OUT ),\n        .SW_IN ( coprocessor_0_SW_IN ),\n        .BTN_IN ( coprocessor_0_BTN_IN ),\n        .S_AXI_ACLK ( processing_system7_0_FCLK_CLK0[0] ),\n        .S_AXI_ARESETN ( axi_interconnect_1_M_ARESETN[0] ),\n        .S_AXI_AWADDR ( axi_interconnect_1_M_AWADDR ),\n        .S_AXI_AWVALID ( axi_interconnect_1_M_AWVALID[0] ),\n        .S_AXI_WDATA ( axi_interconnect_1_M_WDATA ),\n        .S_AXI_WSTRB ( axi_interconnect_1_M_WSTRB ),\n        ...\n        .S_AXI_RLAST ( axi_interconnect_1_M_RLAST[0] )\n      );\n\nendmodule"}
{"task_id": 1529, "completion": "assign WGET = WVAL;\nendmodule"}
{"task_id": 1499, "completion": "reg pkt_metadata_nocut_rdreq, pkt_metadata_out_rdreq;    wire pkt_metadata_nocut_empty, pkt_metadata_out_empty;    wire [339:0] pkt_metadata_nocut_q, pkt_metadata_out_q;    reg [2:0] current_state;    parameter idle_s = 3'd0, idle_s1 = 3'd1, trans_s = 3'd2, trans_s1 = 3'd3;    always @ (posedge clk or negedge reset)    if(!reset) begin        pkt_metadata_nocut_rdreq <= 1'b0;        pkt_metadata_out_rdreq <= 1'b0;        pkt_addr <= 5'b0;        pkt_addr_wr <= 1'b0;        p2k_valid <= 1'b0;        p2k_ingress <= 8'b0;        p2k_rloc_src <= 128'b0;        p2k_eid_dst <= 128'b0;        p2k_metadata <= 72'b0;        metadata_data_wr <= 1'b0;        metadata_data <= 64'b0;        current_state <= idle_s;    end else begin        case(current_state)            idle_s: begin                pkt_addr <= 5'b0;                pkt_addr_wr <= 1'b0;                p2k_valid <= 1'b0;                p2k_ingress <= 8'b0;                p2k_rloc_src <= 128'b0;                p2k_eid_dst <= 128'b0;                p2k_metadata <= 72'b0;                metadata_data_wr <= 1'b0;                metadata_data <= 64'b0;                if(pkt_metadata_nocut_empty == 1'b1) begin                    current_state <= idle_s1;                end else begin                    pkt_metadata_nocut_rdreq <= 1'b1;                    current_state <= trans_s;                end            end            idle_s1: begin                pkt_addr <= 5'b0;                pkt_addr_wr <= 1'b0;                p2k_valid <= 1'b0;                p2k_ingress <= 8'b0;                p2k_rloc_src <= 128'b0;                p2k_eid_dst <= 128'b0;                p2k_metadata <= 72'b0;                metadata_data_wr <= 1'b0;                metadata_data <= 64'b0;                if(pkt_metadata_out_empty == 1'b1) begin                    current_state <= idle_s;                end else begin                    pkt_metadata_out_rdreq <= 1'b1;                    current_state <= trans_s1;                end            end            trans_s: begin                pkt_metadata_nocut_rdreq <= 1'b0;                pkt_addr <= {1'b0, pkt_metadata_nocut_q[339:336]};                pkt_addr_wr <= 1'b1;                p2k_valid <= 1'b1;                p2k_ingress <= pkt_metadata_nocut_q[335:328];                p2k_rloc_src <= pkt_metadata_nocut_q[327:200];                p2k_eid_dst <= pkt_metadata_nocut_q[199:72];                p2k_metadata <= pkt_metadata_nocut_q[71:0];                metadata_data_wr <= 1'b1;                metadata_data <= pkt_metadata_nocut_q[63:0];                current_state <= idle_s1;            end            trans_s1: begin                pkt_metadata_out_rdreq <= 1'b0;                pkt_addr <= {1'b1, pkt_metadata_out_q[339:336]};                pkt_addr_wr <= 1'b1;                p2k_valid <= 1'b1;                p2k_ingress <= pkt_metadata_out_q[335:328];                p2k_rloc_src <= pkt_metadata_out_q[327:200];                p2k_eid_dst <= pkt_metadata_out_q[199:72];                p2k_metadata <= pkt_metadata_out_q[71:0];                metadata_data_wr <= 1'b1;                metadata_data <= pkt_metadata_out_q[63:0];                current_state <= idle_s;            end        endcase    end    fifo_340_16 pkt_metadata_nocut_fifo(        .aclr(!reset),        .clock(clk),        .data(pkt_metadata_nocut),        .rdreq(pkt_metadata_nocut_rdreq),        .wrreq(pkt_metadata_nocut_valid),        .empty(pkt_metadata_nocut_empty),        .q(pkt_metadata_nocut_q)    );    fifo_340_16 pkt_metadata_out_fifo(        .aclr(!reset),        .clock(clk),        .data(pkt_metadata_out),        .rdreq(pkt_metadata_out_rdreq),        .wrreq(pkt_metadata_out_valid),        .empty(pkt_metadata_out_empty),        .q(pkt_metadata_out_q)    );    endmodule"}
{"task_id": 1471, "completion": "wire controlDataNBit;\n   wire ispTracyEnableBit;\n   wire [3:0] encodedIpEnableBits;\n   wire [9:0] er1TdiBit;\n   wire captureDrER1;\n\n   assign JTDO1 = er1TdiBit[0];\n   TYPEB BIT0 (.CLK(JTCK), .RESET_N(JRSTN), .CLKEN(JCE1), .TDI(er1TdiBit[1]), .TDO(er1TdiBit[0]), .DATA_IN(1'b0), .CAPTURE_DR(captureDrER1));\n   TYPEB BIT1 (.CLK(JTCK), .RESET_N(JRSTN), .CLKEN(JCE1), .TDI(er1TdiBit[2]), .TDO(er1TdiBit[1]), .DATA_IN(1'b0), .CAPTURE_DR(captureDrER1));\n   TYPEB BIT2 (.CLK(JTCK), .RESET_N(JRSTN), .CLKEN(JCE1), .TDI(er1TdiBit[3]), .TDO(er1TdiBit[2]), .DATA_IN(1'b1), .CAPTURE_DR(captureDrER1));\n   TYPEA BIT3 (.CLK(JTCK), .RESET_N(JRSTN), .CLKEN(JCE1), .TDI(er1TdiBit[4]), .TDO(er1TdiBit[3]), .DATA_OUT(controlDataNBit), .DATA_IN(controlDataNBit), .CAPTURE_DR(captureDrER1), .UPDATE_DR(JUPDATE));\n   assign CONTROL_DATAN = controlDataNBit;\n   TYPEA BIT4 (.CLK(JTCK), .RESET_N(JRSTN), .CLKEN(JCE1), .TDI(er1TdiBit[5]), .TDO(er1TdiBit[4]), .DATA_OUT(ispTracyEnableBit), .DATA_IN(ispTracyEnableBit), .CAPTURE_DR(captureDrER1), .UPDATE_DR(JUPDATE));\n   assign ISPTRACY_ENABLE = ispTracyEnableBit;\n   TYPEA BIT5 (.CLK(JTCK), .RESET_N(JRSTN), .CLKEN(JCE1), .TDI(er1TdiBit[6]), .TDO(er1TdiBit[5]), .DATA_OUT(encodedIpEnableBits[0]), .DATA_IN(encodedIpEnableBits[0]), .CAPTURE_DR(captureDrER1), .UPDATE_DR(JUPDATE));\n   TYPEA BIT6 (.CLK(JTCK), .RESET_N(JRSTN), .CLKEN(JCE1), .TDI(er1TdiBit[7]), .TDO(er1TdiBit[6]), .DATA_OUT(encodedIpEnableBits[1]), .DATA_IN(encodedIpEnableBits[1]), .CAPTURE_DR(captureDrER1), .UPDATE_DR(JUPDATE));\n   TYPEA BIT7 (.CLK(JTCK), .RESET_N(JRSTN), .CLKEN(JCE1), .TDI(er1TdiBit[8]), .TDO(er1TdiBit[7]), .DATA_OUT(encodedIpEnableBits[2]), .DATA_IN(encodedIpEnableBits[2]), .CAPTURE_DR(captureDrER1), .UPDATE_DR(JUPDATE));\n   TYPEA BIT8 (.CLK(JTCK), .RESET_N(JRSTN), .CLKEN(JCE1), .TDI(er1TdiBit[9]), .TDO(er1TdiBit[8]), .DATA_OUT(encodedIpEnableBits[3]), .DATA_IN(encodedIpEnableBits[3]), .CAPTURE_DR(captureDrER1), .UPDATE_DR(JUPDATE));\n   assign er1TdiBit[9] = JTDI;\n   assign captureDrER1 = !JSHIFT & JCE1;\n   always @ (encodedIpEnableBits, ISPTRACY_ER2_TDO, ER2_TDO)\n   begin\n    case (encodedIpEnableBits)\n      4'h0: begin \n        IP_ENABLE <= 15'b000000000000000;\n        JTDO2 <= ISPTRACY_ER2_TDO;\n      end\n      4'h1: begin\n        IP_ENABLE <= 15'b000000000000001;\n        JTDO2 <= ER2_TDO[0];\n      end\n      4'h2: begin\n        IP_ENABLE <= 15'b000000000000010;\n        JTDO2 <= ER2_TDO[1];\n      end\n      4'h3: begin\n        IP_ENABLE <= 15'b000000000000100;\n        JTDO2 <= ER2_TDO[2];\n      end\n      4'h4: begin\n        IP_ENABLE <= 15'b000000000001000;\n        JTDO2 <= ER2_TDO[3];\n      end\n      4'h5: begin\n        IP_ENABLE <= 15'b000000000010000;\n        JTDO2 <= ER2_TDO[4];\n      end\n      4'h6: begin\n        IP_ENABLE <= 15'b000000000100000;\n        JTDO2 <= ER2_TDO[5];\n      end\n      4'h7: begin\n        IP_ENABLE <= 15'b000000001000000;\n        JTDO2 <= ER2_TDO[6];\n      end\n      4'h8: begin\n        IP_ENABLE <= 15'b000000010000000;\n        JTDO2 <= ER2_TDO[7];\n      end\n      4'h9: begin\n        IP_ENABLE <= 15'b000000100000000;\n        JTDO2 <= ER2_TDO[8];\n      end\n      4'hA: begin\n        IP_ENABLE <= 15'b000001000000000;\n        JTDO2 <= ER2_TDO[9];\n      end\n      4'hB: begin\n        IP_ENABLE <= 15'b000010000000000;\n        JTDO2 <= ER2_TDO[10];\n      end\n      4'hC: begin\n        IP_ENABLE <= 15'b000100000000000;\n        JTDO2 <= ER2_TDO[11];\n      end\n      4'hD: begin\n        IP_ENABLE <= 15'b001000000000000;\n        JTDO2 <= ER2_TDO[12];\n      end\n      4'hE: begin\n        IP_ENABLE <= 15'b010000000000000;\n        JTDO2 <= ER2_TDO[13];\n      end\n      4'hF: begin\n        IP_ENABLE <= 15'b100000000000000;\n        JTDO2 <= ER2_TDO[14];\n      end\n    endcase\n  end\nendmodule"}
{"task_id": 1307, "completion": "localparam AES_CR    = 4'd00;\n    localparam AES_SR    = 4'd01;\n    localparam AES_DINR  = 4'd02;\n    localparam AES_DOUTR = 4'd03;\n    localparam AES_KEYR0 = 4'd04;\n    localparam AES_KEYR1 = 4'd05;\n    localparam AES_KEYR2 = 4'd06;\n    localparam AES_KEYR3 = 4'd07;\n    localparam AES_IVR0  = 4'd08;\n    localparam AES_IVR1  = 4'd09;\n    localparam AES_IVR2  = 4'd10;\n    localparam AES_IVR3  = 4'd11;\n    localparam ENCRYPTION     = 2'b00;\n    localparam KEY_DERIVATION = 2'b01;\n    localparam DECRYPTION     = 2'b10;\n    localparam DECRYP_W_DERIV = 2'b11;\n    localparam ECB = 2'b00;\n    localparam CBC = 2'b01;\n    localparam CTR = 2'b10;\n    localparam COL_0 = 3'b000;\n    localparam COL_1 = 3'b001;\n    localparam COL_2 = 3'b010;\n    localparam COL_3 = 3'b011;\n    localparam G_FUNCTION = 3'b100;\n    localparam COL        = 2'b00;\n    localparam MIXCOL_IN  = 2'b01;\n    localparam MIXCOL_OUT = 2'b10;\n    localparam KEY_0 = 2'b00;\n    localparam KEY_1 = 2'b01;\n    localparam KEY_2 = 2'b10;\n    localparam KEY_3 = 2'b11;\n    localparam SHIFT_ROWS = 2'b00;\n    localparam ADD_RK_OUT = 2'b01;\n    localparam INPUT      = 2'b10;\n    localparam KEY_HOST = 1'b0;\n    localparam KEY_OUT  = 1'b1;\n    localparam KEY_DIS  = 4'b0000;\n    localparam EN_KEY_0 = 4'b0001;\n    localparam EN_KEY_1 = 4'b0010;\n    localparam EN_KEY_2 = 4'b0100;\n    localparam EN_KEY_3 = 4'b1000;\n    localparam KEY_ALL  = 4'b1111;\n    localparam COL_DIS  = 4'b0000;\n    localparam EN_COL_0 = 4'b0001;\n    localparam EN_COL_1 = 4'b0010;\n    localparam EN_COL_2 = 4'b0100;\n    localparam EN_COL_3 = 4'b1000;\n    localparam COL_ALL  = 4'b1111;\n    localparam IV_CNT = 1'b1;\n    localparam IV_BUS = 1'b0;\n    localparam ENABLE = 1'b1;\n    localparam DISABLE = 1'b0;\n    localparam NUMBER_ROUND      = 4'd10;\n    localparam NUMBER_ROUND_INC  = 4'd11;\n    localparam INITIAL_ROUND     = 4'd00;\n    localparam IDLE        = 4'd00;\n    localparam ROUND0_COL0 = 4'd01;\n    localparam ROUND0_COL1 = 4'd02;\n    localparam ROUND0_COL2 = 4'd03;\n    localparam ROUND0_COL3 = 4'd04;\n    localparam ROUND_KEY0  = 4'd05;\n    localparam ROUND_COL0  = 4'd06;\n    localparam ROUND_COL1  = 4'd07;\n    localparam ROUND_COL2  = 4'd08;\n    localparam ROUND_COL3  = 4'd09;\n    localparam READY       = 4'd10;\n    localparam GEN_KEY0    = 4'd11;\n    localparam GEN_KEY1    = 4'd12;\n    localparam GEN_KEY2    = 4'd13;\n    localparam GEN_KEY3    = 4'd14;\n    localparam NOP         = 4'd15;\n    reg [3:0] state, next_state;\n    reg [3:0] rd_count;\n    reg rd_count_en;\n    wire op_key_derivation;\n    wire first_round;\n    wire [1:0] op_mode;\n    wire enc_dec;\n    always @(posedge clk, negedge rst_n) begin\n        if(!rst_n)\n            state <= IDLE;\n        else\n            if(disable_core)\n                state <= IDLE;\n            else\n                state <= next_state;\n    end\n    assign encrypt_decrypt = (op_mode == ENCRYPTION || op_mode == KEY_DERIVATION || state == GEN_KEY0 || state == GEN_KEY1 || state == GEN_KEY2 || state == GEN_KEY3);\n    assign enc_dec = encrypt_decrypt | mode_ctr;\n    assign key_gen = (state == ROUND_KEY0);\n    assign op_key_derivation = (op_mode == KEY_DERIVATION);\n    assign mode_ctr = (aes_mode == CTR);\n    assign mode_cbc = (aes_mode == CBC);\n    assign key_init = start;\n    assign op_mode = (mode_ctr) ? ENCRYPTION : operation_mode;\n    always @(*) begin\n        next_state = state;\n        case(state)\n            IDLE:\n                begin\n                    if(!start)\n                        next_state = IDLE;\n                    else\n                        case(op_mode)\n                            ENCRYPTION    : next_state = ROUND0_COL0;\n                            DECRYPTION    : next_state = ROUND0_COL3;\n                            KEY_DERIVATION: next_state = GEN_KEY0;\n                            DECRYP_W_DERIV: next_state = GEN_KEY0;\n                            default       : next_state = IDLE;\n                        endcase\n                end\n            ROUND0_COL0:\n                begin\n                    next_state = (enc_dec) ? ROUND0_COL1 : ROUND_KEY0; \n                end\n            ROUND0_COL1:\n                begin\n                    next_state = (enc_dec) ? ROUND0_COL2 : ROUND0_COL0;\n                end\n            ROUND0_COL2:\n                begin\n                    next_state = (enc_dec) ? ROUND0_COL3 : ROUND0_COL1;\n                end\n            ROUND0_COL3:\n                begin\n                    next_state = (enc_dec) ? ROUND_KEY0 : ROUND0_COL2;\n                end\n            ROUND_KEY0 :\n                begin\n                    if(!first_round)\n                        begin\n                            next_state = (last_round) ? READY : NOP;\n                        end\n                    else\n                        begin\n                            next_state = (enc_dec) ? ROUND_COL0 : ROUND_COL3;\n                        end\n                end\n            NOP        :\n                begin\n                    next_state = (enc_dec) ? ROUND_COL0 : ROUND_COL3;\n                end\n            ROUND_COL0 :\n                begin\n                    next_state = (enc_dec) ? ROUND_COL1 : ROUND_KEY0;\n                end\n            ROUND_COL1 :\n                begin\n                    next_state = (enc_dec) ? ROUND_COL2 : ROUND_COL0;\n                end\n            ROUND_COL2 :\n                begin\n                    next_state = (enc_dec) ? ROUND_COL3 : ROUND_COL1;\n                end\n            ROUND_COL3 :\n                begin\n                    if(last_round && enc_dec)\n                        next_state = READY;\n                    else\n                    next_state = (enc_dec) ? ROUND_KEY0 : ROUND_COL2;\n                end\n            GEN_KEY0   :\n                begin\n                    next_state = GEN_KEY1;\n                end\n            GEN_KEY1   :\n                begin\n                    next_state = GEN_KEY2;\n                end\n            GEN_KEY2   :\n                begin\n                    next_state = GEN_KEY3;\n                end\n            GEN_KEY3   :\n                begin\n                    if(last_round)\n                        next_state = (op_key_derivation) ? READY : ROUND0_COL3;\n                    else\n                        next_state = GEN_KEY0;\n                end\n            READY      :\n                begin\n                    next_state = IDLE;\n                end\n        endcase\n    end\n    assign end_comp = (state == READY)?ENABLE:DISABLE;\n    always @(*) begin\n        sbox_sel = COL_0;\n        rk_sel = COL;\n        bypass_rk = DISABLE;\n        key_out_sel = KEY_0;\n        col_sel = INPUT;\n        key_sel = KEY_HOST;\n        key_en = KEY_DIS;\n        col_en = COL_DIS;\n        rd_count_en = DISABLE;\n        iv_cnt_en = DISABLE;\n        iv_cnt_sel = IV_BUS;\n        bypass_key_en = DISABLE;\n        key_derivation_en = DISABLE;\n        case(state)\n            ROUND0_COL0:\n                begin\n                    sbox_sel = COL_0;\n                    rk_sel   = COL;\n                    bypass_rk = ENABLE;\n                    bypass_key_en = ENABLE;\n                    key_out_sel = KEY_0;\n                    col_sel = (enc_dec) ? ADD_RK_OUT : SHIFT_ROWS;\n                    col_en =  (enc_dec) ? EN_COL_0 : COL_ALL;\n                end\n            ROUND0_COL1:\n                begin\n                    sbox_sel = COL_1;\n                    rk_sel   = COL;\n                    bypass_rk = ENABLE;\n                    bypass_key_en = ENABLE;\n                    key_out_sel = KEY_1;\n                    col_sel = ADD_RK_OUT;\n                    col_en = EN_COL_1;\n                    if(!enc_dec) begin\n                        key_sel = KEY_OUT;\n                        key_en =  EN_KEY_1;\n                    end\n                end\n            ROUND0_COL2:\n                begin\n                    sbox_sel = COL_2;\n                    rk_sel   = COL;\n                    bypass_rk = ENABLE;\n                    bypass_key_en = ENABLE;\n                    key_out_sel = KEY_2;\n                    col_sel = ADD_RK_OUT;\n                    col_en = EN_COL_2;\n                    if(!enc_dec) begin\n                        key_sel = KEY_OUT;\n                        key_en =  EN_KEY_2;\n                    end\n                end\n            ROUND0_COL3:\n                begin\n                    sbox_sel = COL_3;\n                    rk_sel   = COL;\n                    bypass_key_en = ENABLE;\n                    key_out_sel = KEY_3;\n                    col_sel = (enc_dec) ? SHIFT_ROWS : ADD_RK_OUT;\n                    col_en =  (enc_dec) ? COL_ALL : EN_COL_3;\n                    bypass_rk = ENABLE;\n                    if(!enc_dec) begin\n                        key_sel = KEY_OUT;\n                        key_en =  EN_KEY_3;\n                    end\n                end\n            ROUND_KEY0:\n                begin\n                    sbox_sel = G_FUNCTION;\n                    key_sel = KEY_OUT;\n                    key_en = EN_KEY_0;\n                    rd_count_en = ENABLE;\n                end\n            ROUND_COL0:\n                begin\n                    sbox_sel = COL_0;\n                    rk_sel = (last_round) ? MIXCOL_IN : MIXCOL_OUT;\n                    key_out_sel = KEY_0;\n                    key_sel = KEY_OUT;\n                    if(enc_dec) key_en = EN_KEY_1;\n                    if((mode_cbc && last_round && !enc_dec) || (mode_ctr && last_round))\n                        col_sel = INPUT;\n                    else\n                        if(!enc_dec)\n                            col_sel = (last_round) ? ADD_RK_OUT : SHIFT_ROWS;\n                        else\n                            col_sel = ADD_RK_OUT;\n                    if(enc_dec) col_en = EN_COL_0;\n                    else col_en = (last_round) ? EN_COL_0 : COL_ALL;\n                end\n            ROUND_COL1:\n                begin\n                    sbox_sel = COL_1;\n                    rk_sel   = (last_round) ? MIXCOL_IN : MIXCOL_OUT;\n                    key_out_sel = KEY_1;\n                    key_sel = KEY_OUT;\n                    if(enc_dec) key_en = EN_KEY_2;\n                    else key_en = EN_KEY_1;\n                    if((mode_cbc && last_round && !enc_dec) || (mode_ctr && last_round))\n                        col_sel = INPUT;\n                    else\n                        col_sel = ADD_RK_OUT;\n                    col_en = EN_COL_1;\n                end\n            ROUND_COL2:\n                begin\n                    sbox_sel = COL_2;\n                    rk_sel   = (last_round) ? MIXCOL_IN : MIXCOL_OUT;\n                    key_out_sel = KEY_2;\n                    key_sel = KEY_OUT;\n                    if(enc_dec) key_en = EN_KEY_3;\n                    else key_en = EN_KEY_2;\n                    if((mode_cbc && last_round && !enc_dec) || (mode_ctr && last_round))\n                        col_sel = INPUT;\n                    else\n                        col_sel = ADD_RK_OUT;\n                    col_en = EN_COL_2;\n                end\n            ROUND_COL3:\n                begin\n                    sbox_sel = COL_3;\n                    rk_sel   = (last_round) ? MIXCOL_IN : MIXCOL_OUT;\n                    key_out_sel = KEY_3;\n                    key_sel = KEY_OUT;\n                    if(!enc_dec) key_en = EN_KEY_3;\n                    if((mode_cbc && last_round && !enc_dec) || (mode_ctr && last_round))\n                        col_sel = INPUT;\n                    else begin\n                        if(enc_dec)\n                            col_sel = (last_round) ? ADD_RK_OUT : SHIFT_ROWS;\n                        else\n                            col_sel = ADD_RK_OUT;\n                    end\n                    if(enc_dec) col_en = (last_round) ? EN_COL_3 : COL_ALL;\n                    else col_en = EN_COL_3;\n                    if(mode_ctr && last_round) begin\n                        iv_cnt_en = ENABLE;\n                        iv_cnt_sel = IV_CNT;\n                    end\n                end\n            GEN_KEY0:\n                begin\n                    sbox_sel = G_FUNCTION;\n                    rd_count_en = ENABLE;\n                end\n            GEN_KEY1:\n                begin\n                    key_en = EN_KEY_1 | EN_KEY_0; //Enable key 0 AND key 1\n                    key_sel = KEY_OUT;\n                    bypass_key_en = ENABLE;\n                end\n            GEN_KEY2:\n                begin\n                    key_en = EN_KEY_2;\n                    key_sel = KEY_OUT;\n                    bypass_key_en = ENABLE;\n                end\n            GEN_KEY3:\n                begin\n                    key_en = EN_KEY_3;\n                    key_sel = KEY_OUT;\n                    bypass_key_en = ENABLE;\n                end\n            READY:\n                begin\n                    if(op_mode == KEY_DERIVATION)\n                        key_derivation_en = ENABLE;\n                end\n        endcase\n    end\n    always @(posedge clk, negedge rst_n) begin\n        if(!rst_n)\n            rd_count <= INITIAL_ROUND;\n        else if(state == IDLE || (state == GEN_KEY3 && last_round))\n            rd_count <= INITIAL_ROUND;\n        else if(rd_count_en)\n            rd_count <= rd_count + 1'b1;\n    end\n    assign round = rd_count;\n    assign first_round = (rd_count == INITIAL_ROUND);\n    assign last_round  = (rd_count == NUMBER_ROUND || rd_count == NUMBER_ROUND_INC);\nendmodule"}
{"task_id": 1445, "completion": "wire bclk_reset, clk100_reset;\n   sync_reset log_bclk_res_sync(.glbl_reset(reset), .clk(bclk), .reset(bclk_reset));\n   sync_reset log_clk100_res_sync(.glbl_reset(reset), .clk(clk100), .reset(clk100_reset));\n   reg [7:0] cap_wr_din;\n   reg [9:0] cap_wr_uk;\n   reg cap_wr_ale;\n   reg cap_wr_cle;\n   reg cap_wr_cs;\n   reg cap_wr_rb;\n   reg [7:0] cap_rd_din;\n   reg [9:0] cap_rd_uk;\n   reg cap_rd_ale;\n   reg cap_rd_cle;\n   reg cap_rd_cs;\n   reg cap_rd_rb;\n   reg [7:0] log_din;\n   reg [9:0] log_uk;\n   reg log_ale;\n   reg log_cle;\n   reg log_cs;\n   reg log_rb;\n   reg log_we;\n   reg log_re;\n   reg log_capture_pulse;\n   wire cap_we;\n   wire cap_re;\n   reg cap_wed2, cap_wed1, cap_wedA;\n   reg cap_red2, cap_red1, cap_redA;\n   wire time_we;\n   wire time_re;\n   always @(posedge nand_we) begin\n      cap_wr_din[7:0] <= nand_din[7:0];\n      cap_wr_uk[9:0] <= nand_uk[9:0];\n      cap_wr_ale <= nand_ale;\n      cap_wr_cle <= nand_cle;\n      cap_wr_cs <= nand_cs;\n      cap_wr_rb <= nand_rb;\n   end\n   always @(posedge nand_re) begin\n      cap_rd_din[7:0] <= nand_din[7:0];\n      cap_rd_uk[9:0] <= nand_uk[9:0];\n      cap_rd_ale <= nand_ale;\n      cap_rd_cle <= nand_cle;\n      cap_rd_cs <= nand_cs;\n      cap_rd_rb <= nand_rb;\n   end\n   always @(posedge bclk) begin\n      cap_wed1 <= nand_we;\n      cap_red1 <= nand_re;\n      cap_wed2 <= cap_wed1;\n      cap_red2 <= cap_red1;\n   end\n   assign cap_we = !cap_wed2 & cap_wed1;\n   assign cap_re = !cap_red2 & cap_red1;\n   always @(posedge bclk) begin\n      log_capture_pulse <= cap_we || cap_re;\n      if (cap_we) begin\n         log_din <= cap_wr_din;\n         log_uk <= cap_wr_uk;\n         log_ale <= cap_wr_ale;\n         log_cle <= cap_wr_cle;\n         log_cs <= cap_wr_cs;\n         log_rb <= cap_wr_rb;\n         log_we <= 1'b0;\n         log_re <= 1'b1;\n      end else if (cap_re) begin\n         log_din <= cap_rd_din;\n         log_uk <= cap_rd_uk;\n         log_ale <= cap_rd_ale;\n         log_cle <= cap_rd_cle;\n         log_cs <= cap_rd_cs;\n         log_rb <= cap_rd_rb;\n         log_we <= 1'b1;\n         log_re <= 1'b0;\n      end else begin\n         log_din <= log_din;\n         log_uk <= log_uk;\n         log_ale <= log_ale;\n         log_cle <= log_cle;\n         log_cs <= log_cs;\n         log_rb <= log_rb;\n         log_we <= log_we;\n         log_re <= log_re;\n      end\n   end\n   wire [22:0] ddr3_log_data;\n   reg [40:0] ddr3_log_time;\n   wire [63:0] ddr3_log_entry;\n   reg [63:0] time_t_clk100_cap;\n   always @(posedge bclk) begin\n      if (cap_we || cap_re) begin\n         ddr3_log_time[40:0] <= time_t_clk100_cap[40:0];\n      end else begin\n         ddr3_log_time <= ddr3_log_time;\n      end\n   end\n   assign ddr3_log_data[7:0] = log_din[7:0];\n   assign ddr3_log_data[8] = log_ale;\n   assign ddr3_log_data[9] = log_cle;\n   assign ddr3_log_data[10] = log_we;\n   assign ddr3_log_data[11] = log_re;\n   assign ddr3_log_data[12] = log_cs;\n   assign ddr3_log_data[22:13] = log_uk[9:0];\n   assign ddr3_log_entry[63:0] = {ddr3_log_time, ddr3_log_data};\n   parameter LOG_DATA = 4'b1 << 0;\n   parameter LOG_TIME = 4'b1 << 1;\n   parameter LOG_nSTATES = 4;\n   reg [(LOG_nSTATES - 1):0] cstate;\n   reg [(LOG_nSTATES - 1):0] nstate;\n   always @(posedge bclk or posedge bclk_reset) begin\n      if (bclk_reset) begin\n         cstate <= LOG_DATA;\n      end else if (log_reset) begin\n         cstate <= LOG_DATA;\n      end else begin\n         cstate <= nstate;\n      end\n   end\n   always @(*) begin\n      case (cstate)\n         LOG_DATA: begin\n            if (log_capture_pulse) begin\n               nstate <= LOG_TIME;\n            end else begin\n               nstate <= LOG_DATA;\n            end\n         end\n         LOG_TIME: begin\n            nstate <= LOG_DATA;\n         end\n      endcase\n   end\n   always @(posedge bclk) begin\n      if (log_reset) begin\n         \n      end else begin\n         case (cstate)\n            LOG_DATA: begin\n               if (log_capture_pulse) begin\n                  \n               end\n            end\n         endcase\n      end\n   end\n   reg [29:0] log_address;\n   reg cmd_delay;\n   reg cmd_flush;\n   assign ddr3_cmd_clk = bclk;\n   assign ddr3_wr_data = (cstate == LOG_DATA) ? ddr3_log_entry[31:0] : ddr3_log_entry[63:32];\n   assign ddr3_wr_mask = 4'b0;\n   assign ddr3_wr_en = (((cstate == LOG_DATA) && log_capture_pulse) || (cstate == LOG_TIME)) & log_run;\n   assign ddr3_cmd_instr = 3'b000;\n   assign ddr3_cmd_burstlen = 6'h1;\n   assign ddr3_cmd_en = cmd_delay & log_run | cmd_flush;\n   assign ddr3_cmd_addr = log_address;\n   reg still_resetting;\n   always @(posedge bclk) begin\n      cmd_delay <= (cstate == LOG_TIME);\n      if (log_reset) begin\n         log_address <= 30'h0F00_0000;\n         log_entries <= 27'h0;\n      end else if (cmd_delay) begin\n         if (log_address < 30'h0FFF_FFF8) begin\n            log_address <= log_address + 30'h8;\n         end else begin\n            log_address <= log_address;\n         end\n         log_entries <= log_entries + 27'h1;\n      end else begin\n         log_address <= log_address;\n         log_entries <= log_entries;\n      end\n      if (log_reset) begin\n         log_cmd_error <= 1'b0;\n      end else if (ddr3_cmd_full) begin\n         log_cmd_error <= 1'b1;\n      end else begin\n         log_cmd_error <= log_cmd_error;\n      end\n      if (log_reset) begin\n         log_data_error <= 1'b0;\n         still_resetting <= 1'b1;\n      end else if (still_resetting & ddr3_wr_full) begin\n         still_resetting <= 1'b1;\n         log_data_error <= 1'b0;\n      end else if (!still_resetting & ddr3_wr_full) begin\n         log_data_error <= 1'b1;\n         still_resetting <= 1'b0;\n      end else begin\n         log_data_error <= log_data_error;\n         still_resetting <= 1'b0;\n      end\n   end\n   reg [31:0] time_ns;\n   reg [31:0] time_s;\n   reg log_reset_clk100;\n   reg log_run_clk100;\n   wire time_we_clk100;\n   wire time_re_clk100;\n   reg clk100_wed1, clk100_wed2;\n   reg clk100_red1, clk100_red2;\n   assign time_we_clk100 = clk100_wed2 & !clk100_wed1;\n   assign time_re_clk100 = clk100_red2 & !clk100_red1;\n   always @(posedge clk100) begin\n      log_reset_clk100 <= log_reset;\n      log_run_clk100 <= log_run;\n      clk100_wed1 <= nand_we;\n      clk100_red1 <= nand_re;\n      clk100_wed2 <= clk100_wed1;\n      clk100_red2 <= clk100_red1;\n      if (time_we_clk100 || time_re_clk100) begin\n         time_t_clk100_cap <= {time_s, time_ns};\n      end else begin\n         time_t_clk100_cap <= time_t_clk100_cap;\n      end\n      if (log_reset_clk100) begin\n         time_ns <= 32'b0;\n         time_s <= 32'b0;\n      end else begin\n         if (log_run_clk100) begin\n            if (time_ns < 32'd999_999_999) begin\n               time_ns <= time_ns + 32'd10;\n               time_s <= time_s;\n            end else begin\n               time_ns <= 32'd0;\n               time_s <= time_s + 32'd1;\n            end\n         end else begin\n            time_ns <= time_ns;\n            time_s <= time_s;\n         end\n      end\n   end\n   assign time_t_clk100 = {time_s, time_ns};\n   \nendmodule"}
{"task_id": 1488, "completion": "localparam ADDR_AP_CTRL = 5'h00; localparam ADDR_GIE = 5'h04; localparam ADDR_IER = 5'h08; localparam ADDR_ISR = 5'h0c; localparam ADDR_OPERATION_DATA_0 = 5'h10; localparam ADDR_OPERATION_CTRL = 5'h14; localparam WRIDLE = 2'd0; localparam WRDATA = 2'd1; localparam WRRESP = 2'd2; localparam RDIDLE = 2'd0; localparam RDDATA = 2'd1; localparam ADDR_BITS = 5; reg [1:0] wstate; reg [1:0] wnext; reg [ADDR_BITS-1:0] waddr; wire [31:0] wmask; wire aw_hs; wire w_hs; reg [1:0] rstate; reg [1:0] rnext; reg [31:0] rdata; wire ar_hs; wire [ADDR_BITS-1:0] raddr; wire int_ap_idle; wire int_ap_ready; reg int_ap_done; reg int_ap_start; reg int_auto_restart; reg int_gie; reg [1:0] int_ier; reg [1:0] int_isr; reg [31:0] int_operation; assign AWREADY = (wstate == WRIDLE); assign WREADY = (wstate == WRDATA); assign BRESP = 2'b00;  assign BVALID = (wstate == WRRESP); assign wmask = { {8{WSTRB[3]}}, {8{WSTRB[2]}}, {8{WSTRB[1]}}, {8{WSTRB[0]}} }; assign aw_hs = AWVALID & AWREADY; assign w_hs = WVALID & WREADY; always @(posedge ACLK) begin if (ARESET) wstate <= WRIDLE; else if (ACLK_EN) wstate <= wnext; end always @(*) begin case (wstate) WRIDLE: if (AWVALID) wnext = WRDATA; else wnext = WRIDLE; WRDATA: if (WVALID) wnext = WRRESP; else wnext = WRDATA; WRRESP: if (BREADY) wnext = WRIDLE; else wnext = WRRESP; default: wnext = WRIDLE; endcase end always @(posedge ACLK) begin if (ACLK_EN) begin if (aw_hs) waddr <= AWADDR[ADDR_BITS-1:0]; end end assign ARREADY = (rstate == RDIDLE); assign RDATA = rdata; assign RRESP = 2'b00;  assign RVALID = (rstate == RDDATA); assign ar_hs = ARVALID & ARREADY; assign raddr = ARADDR[ADDR_BITS-1:0]; always @(posedge ACLK) begin if (ARESET) rstate <= RDIDLE; else if (ACLK_EN) rstate <= rnext; end always @(*) begin case (rstate) RDIDLE: if (ARVALID) rnext = RDDATA; else rnext = RDIDLE; RDDATA: if (RREADY & RVALID) rnext = RDIDLE; else rnext = RDDATA; default: rnext = RDIDLE; endcase end always @(posedge ACLK) begin if (ACLK_EN) begin if (ar_hs) begin rdata <= 1'b0; case (raddr) ADDR_AP_CTRL: begin rdata[0] <= int_ap_start; rdata[1] <= int_ap_done; rdata[2] <= int_ap_idle; rdata[3] <= int_ap_ready; rdata[7] <= int_auto_restart; end case ADDR_GIE: begin rdata <= int_gie; end case ADDR_IER: begin rdata <= int_ier; end case ADDR_ISR: begin rdata <= int_isr; end case ADDR_OPERATION_DATA_0: begin rdata <= int_operation[31:0]; end endcase end end end always @(posedge ACLK) begin if (ARESET) int_ap_start <= 1'b0; else if (ACLK_EN) begin if (w_hs && waddr == ADDR_AP_CTRL && WSTRB[0] && WDATA[0]) int_ap_start <= 1'b1; else if (int_ap_ready) int_ap_start <= int_auto_restart; end end always @(posedge ACLK) begin if (ARESET) int_ap_done <= 1'b0; else if (ACLK_EN) begin if (ap_done) int_ap_done <= 1'b1; else if (ar_hs && raddr == ADDR_AP_CTRL) int_ap_done <= 1'b0; end end always @(posedge ACLK) begin if (ARESET) int_auto_restart <= 1'b0; else if (ACLK_EN) begin if (w_hs && waddr == ADDR_AP_CTRL && WSTRB[0]) int_auto_restart <=  WDATA[7]; end end always @(posedge ACLK) begin if (ARESET) int_gie <= 1'b0; else if (ACLK_EN) begin if (w_hs && waddr == ADDR_GIE && WSTRB[0]) int_gie <= WDATA[0]; end end always @(posedge ACLK) begin if (ARESET) int_ier <= 1'b0; else if (ACLK_EN) begin if (w_hs && waddr == ADDR_IER && WSTRB[0]) int_ier <= WDATA[1:0]; end end always @(posedge ACLK) begin if (ARESET) int_isr[0] <= 1'b0; else if (ACLK_EN) begin if (int_ier[0] & ap_done) int_isr[0] <= 1'b1; else if (w_hs && waddr == ADDR_ISR && WSTRB[0]) int_isr[0] <= int_isr[0] ^ WDATA[0]; end end always @(posedge ACLK) begin if (ARESET) int_isr[1] <= 1'b0; else if (ACLK_EN) begin if (int_ier[1] & ap_ready) int_isr[1] <= 1'b1; else if (w_hs && waddr == ADDR_ISR && WSTRB[0]) int_isr[1] <= int_isr[1] ^ WDATA[1]; end end always @(posedge ACLK) begin if (ARESET) int_operation[31:0] <= 0; else if (ACLK_EN) begin if (w_hs && waddr == ADDR_OPERATION_DATA_0) int_operation[31:0] <= (WDATA[31:0] & wmask) | (int_operation[31:0] & ~wmask); end end assign interrupt = int_gie & (|int_isr); assign ap_start = int_ap_start; assign int_ap_idle = ap_idle; assign int_ap_ready = ap_ready; assign operation = int_operation; endmodule"}
{"task_id": 1556, "completion": "always @(posedge clk or negedge nrst) begin\n\t\tif(~nrst) begin\n\t\t\tword <= 72'hAAF0F0AA55F0F0AA55;\n\t\tend\n\t\telse if(ena) begin\n\t\t\tword[71] <= word[0];\n\t\t\tword[70:66] <= word[71:67];\n\t\t\tword[65] <= word[66] ^ word[0];\n\t\t\tword[64:25] <= word[65:26];\n\t\t\tword[24] <= word[25] ^ word[0];\n\t\t\tword[23:19] <= word[24:20];\n\t\t\tword[18] <= word[19] ^ word[0];\n\t\t\tword[17:0] <= word[18:1];\n\t\tend\n\tend\n\nendmodule"}
{"task_id": 1551, "completion": "localparam N = $clog2(BAUDRATE);\n    localparam M2 = (BAUDRATE >> 1);\n    reg [N-1:0] divcounter = 0;\n    always @(posedge clk)\n      if (!rstn)\n        divcounter <= 0;\n      else if (clk_ena)\n        divcounter <= (divcounter == BAUDRATE - 1) ? 0 : divcounter + 1;\n      else\n        divcounter <= BAUDRATE - 1;\n    assign clk_out = (divcounter == M2) ? clk_ena : 0;\nendmodule"}
{"task_id": 1560, "completion": "c_dff\n     #(.width(num_ports*num_ports),\n       .reset_type(reset_type))\n   reqq\n     (.clk(clk),\n      .reset(1'b0),\n      .d(req),\n      .q(req_int));\n\n   wire [0:num_ports*num_ports-1] gnt_int;\n   c_dff\n     #(.width(num_ports*num_ports),\n       .reset_type(reset_type))\n   gntq\n     (.clk(clk),\n      .reset(1'b0),\n      .d(gnt_int),\n      .q(gnt));\n\n   c_wf_alloc\n     #(.num_ports(num_ports),\n       .wf_alloc_type(wf_alloc_type),\n       .error_recovery(error_recovery),\n       .reset_type(reset_type))\n   alloc\n     (.clk(clk),\n      .reset(reset),\n      .update(update),\n      .req(req_int),\n      .gnt(gnt_int));\nendmodule"}
{"task_id": 1574, "completion": "pullup (A);    buf (weak0,weak1) #(100,100) (O,A); endmodule"}
{"task_id": 1580, "completion": "task progress_bar;\n      input [8*32:1] msg;\n      input integer  current;\n      input integer  total;\n      begin\n         if(!(current%(total/10)))\n            $display(\"%0s %0d/%0d\", msg, current, total);\n      end\n   endtask\n\nendmodule"}
{"task_id": 1566, "completion": "wire PdmDes_done;\n    wire [15:0] PdmDes_dout;\n\n    reg en_i_sync;\n    reg [15:0] PdmSer_In;\n\n    assign pwm_audio_shutdown = en_i_sync;\n    \npdm_des pdm_des_Inst (\n        .clk(clk_i),\n        .en(en_i),\n        .dout(PdmDes_dout),\n        .pdm_m_clk_o(pdm_m_clk_o),\n        .pdm_m_data_i(pdm_audio_i)\n    );\n\n    always @(posedge PdmDes_done)\n    if(en_i)\n        en_i_sync <= 1'b1;\n\n    always @(posedge clk_i)\n        PdmSer_In <= PdmDes_dout;\n\n    pdm_ser pdmser_Inst (\n        .clk(clk_i),\n        .en(en_i_sync),\n        .din(PdmSer_In),\n        .done(done_o),\n        .pwm_audio_o(pwm_audio_o)\n    );\n\nendmodule"}
{"task_id": 1515, "completion": "integer cyc = 0;\n   reg [63:0] crc;\n   reg [63:0] sum;\n\n   wire [127:0] pows = 128'h1<<crc[7:0];\n   wire [127:0] npows = ~pows;\n\n   wire [31:0] out  = `CLOG2(crc[7:0]);\n   wire [31:0] out2 = `CLOG2(crc);\n   wire [31:0] out3 = `CLOG2(pows);\n   wire [31:0] out4 = `CLOG2(npows);\n\n   wire [63:0] result = {out4[15:0], out3[15:0], out2[15:0], out[15:0]};\n\n`define EXPECTED_SUM 64'h73c48afee4f0cb57\n\n   always @ (posedge clk) begin\n`ifdef TEST_VERBOSE\n      $write(\"[%0t] cyc==%0d crc=%x result=%x\\n\", $time, cyc, crc, result);\n`endif\n      cyc <= cyc + 1;\n      crc <= {crc[62:0], crc[63] ^ crc[2] ^ crc[0]};\n      sum <= result ^ {sum[62:0], sum[63] ^ sum[2] ^ sum[0]};\n      if (cyc==0) begin\n         crc <= 64'h0;\n         if (`CLOG2(32'h0) != 0) $stop;\n         if (`CLOG2(32'h1) != 0) $stop;\n         if (`CLOG2(32'h4) != 2) $stop;\n         if (`CLOG2(32'h7) != 3) $stop;\n         if (`CLOG2(32'h8) != 3) $stop;\n         if (`CLOG2(32'h9) != 4) $stop;\n         if (`CLOG2({32{1'b1}}) != 32) $stop;\n         if (`CLOG2({1'b1,32'b0}) != 32) $stop;\n         if (`CLOG2({64{1'b1}}) != 64) $stop;\n         if (`CLOG2({1'b1,64'b0}) != 64) $stop;\n         if (`CLOG2({128{1'b1}}) != 128) $stop;\n         if (`CLOG2({1'b1,128'b0}) != 128) $stop;\n         if (`CLOG2({2'b10,128'b0}) != 129) $stop;\n      end\n      else if (cyc==1) begin\n         crc <= 64'h1;\n         if (result[31:0] != {16'd0, 16'd0}) $stop;\n      end\n      else if (cyc==2) begin\n         crc <= 64'h3;\n         if (result[31:0] != {16'd0, 16'd0}) $stop;\n      end\n      else if (cyc==3) begin\n         crc <= {64{1'b1}};\n         if (result[31:0] != {16'd2, 16'd2}) $stop;\n      end\n      else if (cyc==4) begin\n         if (result[31:0] != {16'd64, 16'd8}) $stop;\n      end\n      else if (cyc==8) begin\n         crc <= 64'h5aef0c8d_d70a4497;\n      end\n      else if (cyc<10) begin\n         sum <= 64'h0;\n      end\n      else if (cyc<90) begin\n      end\n      else if (cyc==99) begin\n         $write(\"[%0t] cyc==%0d crc=%x sum=%x\\n\", $time, cyc, crc, sum);\n         if (crc !== 64'hcbc77bb9b3784ea0) $stop;\n         if (sum !== `EXPECTED_SUM) $stop;\n         $write(\"*-* All Finished *-*\\n\");\n         $finish;\n      end\n   end\n\n   function integer clog2_emulate(input [130:0] arg);\n      begin\n         if (arg!=0) arg = arg - 1;\n         for (clog2_emulate=0; arg!=0; clog2_emulate=clog2_emulate+1)\n           arg = (arg >> 1);\n      end\n   endfunction\nendmodule"}
{"task_id": 815, "completion": "localparam WL_IDLE            = 4'h0;\n   localparam WL_INIT            = 4'h1;\n   localparam WL_FINE_INC        = 4'h2;\n   localparam WL_WAIT            = 4'h3;\n   localparam WL_EDGE_CHECK      = 4'h4;\n   localparam WL_DQS_CHECK       = 4'h5;\n   localparam WL_DQS_CNT         = 4'h6;\n   localparam WL_FINE_DEC        = 4'h7;\n   localparam WL_FINE_DEC_WAIT   = 4'h8;\n   localparam WL_CORSE_INC       = 4'h9;\n   localparam WL_CORSE_INC_WAIT  = 4'hA;\n   localparam WL_CORSE_INC_WAIT2 = 4'hB;\n   integer     i, j, k, l, p, q;\n   reg [DQS_CNT_WIDTH:0] dqs_count_r;\n   reg [DQS_CNT_WIDTH:0] regl_dqs_cnt;\n   reg [1:0]             rank_cnt_r;\n   reg [DQS_WIDTH-1:0]   rd_data_rise_wl_r;\n   reg [DQS_WIDTH-1:0]   rd_data_previous_r;\n   reg [DQS_WIDTH-1:0]   rd_data_edge_detect_r;\n   reg                   wr_level_done_r;\n   reg                   wrlvl_rank_done_r;\n   reg                   wr_level_start_r;\n   reg [3:0]             wl_state_r, wl_state_r1;\n   reg                   wl_edge_detect_valid_r;\n   reg [5:0]             wl_tap_count_r;\n   reg [5:0]             fine_dec_cnt;\n   reg                   dq_cnt_inc;\n   reg [2:0]             stable_cnt;\n   reg [3*DQS_WIDTH-1:0] corse_cnt;\n   reg [3*DQS_WIDTH-1:0] wl_corse_cnt;\n   reg                   wr_level_done_r1;\n   reg                   wr_level_done_r2;\n   reg                   wr_level_done_r3;\n   reg                   wr_level_done_r4;\n   reg [6*DQS_WIDTH-1:0] wl_dqs_tap_count_r[0:RANKS-1];\n   reg [5:0]             smallest[0:DQS_WIDTH-1];\n   reg [5:0]             largest[0:DQS_WIDTH-1];\n   reg [5:0]             final_val[0:DQS_WIDTH-1];\n   reg [5:0]             po_dec_cnt[0:DQS_WIDTH-1];\n   reg [3:0]             done_cnt;\n   reg                   done_dqs_dec;\n   assign dbg_wl_edge_detect_valid = wl_edge_detect_valid_r;\n   assign dbg_rd_data_edge_detect  = rd_data_edge_detect_r;\n   assign dbg_wl_tap_cnt = wl_tap_count_r;\n   assign dbg_dqs_count = dqs_count_r;\n   assign dbg_wl_state = wl_state_r;\n   assign po_stg2_wl_cnt = (wr_level_done_r) ? regl_dqs_cnt : dqs_count_r;\n   assign wrlvl_rank_done = wrlvl_rank_done_r;\n   assign done_dqs_tap_inc = done_dqs_dec;\n   always @(posedge clk)\n     wr_level_done = done_dqs_dec;\n   always @(posedge clk) begin\n     wr_level_done_r1 <= #TCQ wr_level_done_r;\n     wr_level_done_r2 <= #TCQ wr_level_done_r1;\n     wr_level_done_r3 <= #TCQ wr_level_done_r2;\n     wr_level_done_r4 <= #TCQ wr_level_done_r3;\n     wl_po_coarse_cnt <= #TCQ wl_corse_cnt;\n     for (l = 0; l < DQS_WIDTH; l = l + 1) begin \n       wl_po_fine_cnt[6*l+:6] <= #TCQ final_val[l];\n     end\n   end\n   always @(posedge clk) begin\n     if (rst || ((regl_dqs_cnt == DQS_WIDTH-1)\n              && (done_cnt == 4'd1)))\n       done_cnt <= #TCQ 'b0;\n     else if ((wr_level_done_r3 && ~wr_level_done_r4)\n              || (done_cnt == 4'd1))\n       done_cnt <= #TCQ 4'b1010;\n     else if (done_cnt > 'b0)\n       done_cnt <= #TCQ done_cnt - 1;\n   end\n   always @(posedge clk) begin\n     if (rst)\n       done_dqs_dec <= #TCQ 1'b0;\n     else if ((regl_dqs_cnt == DQS_WIDTH-1)\n              && (done_cnt == 4'd1))\n       done_dqs_dec <= #TCQ 1'b1;\n   end\n   always @(posedge clk) begin\n     if (rst) begin\n       wl_corse_cnt <= #TCQ 'b0;\n       for (k = 0; k < RANKS; k = k + 1) begin: rst_wl_dqs_tap_count_loop\n         wl_dqs_tap_count_r[k] <= #TCQ 'b0;\n       end\n     end else if ((wl_state_r == WL_DQS_CNT) | (wl_state_r == WL_WAIT)) begin\n         wl_dqs_tap_count_r[rank_cnt_r][(6*dqs_count_r)+:6]\n           <= #TCQ wl_tap_count_r;\n         wl_corse_cnt[3*dqs_count_r+:3] <= #TCQ corse_cnt[3*dqs_count_r+:3];\n     end else if ((SIM_CAL_OPTION == \"FAST_CAL\") & (wl_state_r == WL_DQS_CHECK)) begin\n       for (p = 0; p < RANKS; p = p +1) begin: dqs_tap_rank_cnt   \n         for(q = 0; q < DQS_WIDTH; q = q +1) begin: dqs_tap_dqs_cnt\n           wl_dqs_tap_count_r[p][(6*q)+:6] <= #TCQ wl_tap_count_r;\n           wl_corse_cnt[3*q+:3] <= #TCQ corse_cnt[2:0];\n         end\n       end\n     end\n   end\n   always @(posedge clk) begin\n     if (rst) begin\n       for (j = 0; j < DQS_WIDTH; j = j +1) begin: init_tap\n         smallest[j] <= #TCQ 'b0;\n         largest[j]  <= #TCQ 'b0;\n       end\n     end else if (wl_state_r == WL_DQS_CNT) begin\n       smallest[dqs_count_r] \n       <= #TCQ wl_dqs_tap_count_r[0][6*dqs_count_r+:6];\n       largest[dqs_count_r] \n        <= #TCQ wl_dqs_tap_count_r[RANKS-1][6*dqs_count_r+:6];\n     end else if ((SIM_CAL_OPTION == \"FAST_CAL\") & \n                  wr_level_done_r1 & ~wr_level_done_r2) begin\n       for(i = 0; i < DQS_WIDTH; i = i +1) begin: smallest_dqs\n         smallest[i] \n         <= #TCQ wl_dqs_tap_count_r[0][6*i+:6];\n         largest[i] \n         <= #TCQ wl_dqs_tap_count_r[RANKS-1][6*i+:6];\n       end\n     end\n   end\n    genvar wr_i;\n    generate\n      for (wr_i = 0; wr_i < DQS_WIDTH; wr_i = wr_i +1) begin: gen_final_tap\n       always @(posedge clk) begin\n         if (rst)\n           final_val[wr_i] <= #TCQ 'b0;\n         else if (wr_level_done_r2 && ~wr_level_done_r3)\n           final_val[wr_i] \n             <= #TCQ (smallest[wr_i] + ((largest[wr_i]-smallest[wr_i])/2));\n       end\n      end\n    endgenerate\n   always @(posedge clk) begin\n     if (rst || (done_cnt == 4'd0)) begin\n       dqs_wl_po_stg2_load  <= #TCQ 'b0;\n       dqs_wl_po_stg2_reg_l <= #TCQ 'b0;\n     end else if (wr_level_done_r3 && (regl_dqs_cnt <= DQS_WIDTH-1)\n                  && (done_cnt == 4'd2)) begin\n       dqs_wl_po_stg2_load  <= #TCQ 'b1;\n       dqs_wl_po_stg2_reg_l <= #TCQ {wl_corse_cnt[3*regl_dqs_cnt+:3],final_val[regl_dqs_cnt]};\n     end else begin\n       dqs_wl_po_stg2_load  <= #TCQ 'b0;\n       dqs_wl_po_stg2_reg_l <= #TCQ 'b0;\n     end\n   end\n   always @(posedge clk) begin\n     if (rst || (done_cnt == 4'd0))\n       regl_dqs_cnt    <= #TCQ {DQS_CNT_WIDTH+1{1'b0}};\n     else if (wr_level_done_r3 && (regl_dqs_cnt != DQS_WIDTH-1)\n                  && (done_cnt == 4'd1))\n       regl_dqs_cnt  <= #TCQ regl_dqs_cnt + 1;\n     else\n       regl_dqs_cnt  <= #TCQ regl_dqs_cnt;\n   end\n   always @(posedge clk) begin\n     if (rst) begin\n       dqs_po_stg2_f_incdec   <= #TCQ 1'b0;\n       dqs_po_en_stg2_f       <= #TCQ 1'b0;\n     end else if (wl_state_r == WL_FINE_INC) begin\n       dqs_po_stg2_f_incdec <= #TCQ 1'b1;\n       dqs_po_en_stg2_f     <= #TCQ 1'b1;\n     end else if (wl_state_r == WL_FINE_DEC) begin\n       dqs_po_stg2_f_incdec <= #TCQ 1'b0;\n       dqs_po_en_stg2_f     <= #TCQ 1'b1;\n     end else if ((wl_state_r == WL_WAIT) || \n                  (wl_state_r == WL_FINE_DEC_WAIT) ||\n                  (wl_state_r == WL_CORSE_INC)) begin\n       dqs_po_stg2_f_incdec <= #TCQ 1'b0;\n       dqs_po_en_stg2_f     <= #TCQ 1'b0; \n     end\n   end\n   always @(posedge clk) begin\n     if (rst) begin\n       dqs_wl_po_stg2_c_incdec   <= #TCQ 1'b0;\n       dqs_wl_po_en_stg2_c       <= #TCQ 1'b0;\n     end else if (wl_state_r == WL_CORSE_INC) begin\n       dqs_wl_po_stg2_c_incdec <= #TCQ 1'b1;\n       dqs_wl_po_en_stg2_c     <= #TCQ 1'b1;\n     end else if (wl_state_r == WL_CORSE_INC_WAIT) begin\n       dqs_wl_po_stg2_c_incdec <= #TCQ 1'b0;\n       dqs_wl_po_en_stg2_c     <= #TCQ 1'b0; \n     end\n   end\n   genvar rd_i;\n   generate\n     for(rd_i = 0; rd_i < DQS_WIDTH; rd_i = rd_i +1)begin: gen_rd\n      always @(posedge clk)\n        rd_data_rise_wl_r[rd_i] <=\n        #TCQ |rd_data_rise0[(rd_i*DRAM_WIDTH)+DRAM_WIDTH-1:rd_i*DRAM_WIDTH];\n     end\n   endgenerate\n   always @(posedge clk)begin\n     if ((wl_state_r == WL_INIT) || (wl_state_r == WL_CORSE_INC_WAIT2) ||\n         (wl_state_r == WL_FINE_DEC) || (wl_state_r == WL_FINE_DEC_WAIT) ||\n         (wl_state_r == WL_CORSE_INC) || (wl_state_r == WL_CORSE_INC_WAIT) || \n         ((wl_state_r == WL_EDGE_CHECK) & (wl_edge_detect_valid_r)))\n       rd_data_previous_r         <= #TCQ rd_data_rise_wl_r;\n   end\n   always @(posedge clk)begin\n      if (rst | (wl_state_r == WL_DQS_CNT))\n        stable_cnt <= #TCQ 3'd0;\n      else if ((wl_tap_count_r > 6'd0) & \n         (wl_state_r == WL_EDGE_CHECK) & (wl_edge_detect_valid_r)) begin\n        if ((rd_data_previous_r[dqs_count_r] == rd_data_rise_wl_r[dqs_count_r])\n           & (stable_cnt < 3'd7))\n          stable_cnt <= #TCQ stable_cnt + 1;\n        else if (rd_data_previous_r[dqs_count_r] != rd_data_rise_wl_r[dqs_count_r])\n          stable_cnt <= #TCQ 3'd0;\n      end\n   end\n   always @(posedge clk)begin\n     if (rst || (rd_data_previous_r[dqs_count_r] && (stable_cnt < 3'd7)))\n       rd_data_edge_detect_r     <= #TCQ {DQS_WIDTH{1'b0}};\n     else if (rd_data_edge_detect_r[dqs_count_r] == 1'b1) begin\n       if ((wl_state_r == WL_FINE_DEC) || (wl_state_r == WL_FINE_DEC_WAIT) ||\n           (wl_state_r == WL_CORSE_INC) || (wl_state_r == WL_CORSE_INC_WAIT) ||\n           (wl_state_r == WL_CORSE_INC_WAIT2))\n         rd_data_edge_detect_r <= #TCQ {DQS_WIDTH{1'b0}};\n       else\n         rd_data_edge_detect_r <= #TCQ rd_data_edge_detect_r;\n     end else\n       rd_data_edge_detect_r <= #TCQ (~rd_data_previous_r &\n                                       rd_data_rise_wl_r);\n   end\n   always@(posedge clk) begin\n     wr_level_start_r <= #TCQ wr_level_start;\n   end\n   always @(posedge clk) begin\n      if(rst)begin\n         wrlvl_err              <= #TCQ 1'b0;\n         wr_level_done_r        <= #TCQ 1'b0;\n         wrlvl_rank_done_r      <= #TCQ 1'b0;\n         dqs_count_r            <= #TCQ {DQS_CNT_WIDTH+1{1'b0}};\n         dq_cnt_inc             <= #TCQ 1'b1;\n         rank_cnt_r             <= #TCQ 2'b00;\n         wl_state_r             <= #TCQ WL_IDLE;\n         wl_state_r1            <= #TCQ WL_IDLE;\n         wl_edge_detect_valid_r <= #TCQ 1'b0;\n         wl_tap_count_r         <= #TCQ 6'b0;\n         fine_dec_cnt           <= #TCQ 6'b0;\n         corse_cnt              <= #TCQ {3*DQS_WIDTH{1'b0}};\n      end else begin\n         wl_state_r1            <= #TCQ wl_state_r;\n         case (wl_state_r)\n           WL_IDLE: begin\n              wrlvl_rank_done_r <= #TCQ 1'd0;\n              if(!wr_level_done_r & wr_level_start_r & wl_sm_start)\n                wl_state_r <= #TCQ WL_INIT;\n           end\n           WL_INIT: begin\n              wl_edge_detect_valid_r <= #TCQ 1'b0;\n              wrlvl_rank_done_r      <= #TCQ 1'd0;\n              if(wl_sm_start)\n                 wl_state_r <= #TCQ WL_EDGE_CHECK;\n           end\n           WL_FINE_INC: begin \n              wl_state_r <= #TCQ WL_WAIT;\n              wl_edge_detect_valid_r <= #TCQ 1'b0;\n              wl_tap_count_r <= #TCQ wl_tap_count_r + 1'b1;\n           end\n           WL_FINE_DEC: begin\n              wl_edge_detect_valid_r <= #TCQ 1'b0;\n              wl_tap_count_r <= #TCQ 'd0;\n              wl_state_r   <= #TCQ WL_FINE_DEC_WAIT;\n              if (fine_dec_cnt > 6'd0)\n                fine_dec_cnt <= #TCQ fine_dec_cnt - 1;\n              else\n                fine_dec_cnt <= #TCQ fine_dec_cnt;\n           end\n           WL_FINE_DEC_WAIT: begin\n              if (fine_dec_cnt > 6'd0)\n                wl_state_r   <= #TCQ WL_FINE_DEC;\n              else\n                wl_state_r <= #TCQ WL_CORSE_INC;\n           end\n           WL_CORSE_INC: begin\n              corse_cnt[3*dqs_count_r+:3]  <= #TCQ corse_cnt[3*dqs_count_r+:3] + 1;\n                wl_state_r <= #TCQ WL_CORSE_INC_WAIT;\n           end\n           WL_CORSE_INC_WAIT: begin\n              if (wl_sm_start)\n                wl_state_r <= #TCQ WL_CORSE_INC_WAIT2;\n           end\n           WL_CORSE_INC_WAIT2: begin\n             if (wl_sm_start)\n                wl_state_r <= #TCQ WL_WAIT;\n           end\n           WL_WAIT: begin\n              if (wl_sm_start)\n              wl_state_r <= #TCQ WL_EDGE_CHECK;\n           end\n           WL_EDGE_CHECK: begin\n              if (wl_edge_detect_valid_r == 1'b0) begin\n                wl_state_r <= #TCQ WL_WAIT;\n                wl_edge_detect_valid_r <= #TCQ 1'b1;\n              end\n              else if(rd_data_edge_detect_r[dqs_count_r] &&\n                      wl_edge_detect_valid_r)\n                begin\n                   wl_state_r <= #TCQ WL_DQS_CNT;\n                   wl_tap_count_r <= #TCQ wl_tap_count_r;\n                 end\n              else if (wl_tap_count_r > 6'd62) begin\n                if (corse_cnt[3*dqs_count_r+:3] < 'd3) begin\n                  wl_state_r   <= #TCQ WL_FINE_DEC;\n                  fine_dec_cnt <= #TCQ wl_tap_count_r;\n                end else\n                  wrlvl_err <= #TCQ 1'b1;\n              end else\n                wl_state_r <= #TCQ WL_FINE_INC;\n           end\n           WL_DQS_CNT: begin\n              if ((SIM_CAL_OPTION == \"FAST_CAL\") ||\n                  (dqs_count_r == (DQS_WIDTH-1))) begin\n                dqs_count_r <= #TCQ dqs_count_r;\n                dq_cnt_inc  <= #TCQ 1'b0;\n              end else begin\n                dqs_count_r <= #TCQ dqs_count_r + 1'b1;\n                dq_cnt_inc  <= #TCQ 1'b1;\n              end\n              wl_state_r <= #TCQ WL_DQS_CHECK;\n              wl_edge_detect_valid_r <= #TCQ 1'b0;\n             end\n           WL_DQS_CHECK: begin\n              wl_tap_count_r <= #TCQ 5'b0;\n              if (dq_cnt_inc == 1'b0)begin\n                wrlvl_rank_done_r <= #TCQ 1'd1;\n                wl_state_r <= #TCQ WL_IDLE;\n                if ((SIM_CAL_OPTION == \"FAST_CAL\") ||\n                    (rank_cnt_r == RANKS-1)) begin\n                  wr_level_done_r <= #TCQ 1'd1;\n                  rank_cnt_r <= #TCQ 2'b00;\n                end else begin\n                  wr_level_done_r <= #TCQ 1'd0;\n                  rank_cnt_r <= #TCQ rank_cnt_r + 1'b1;\n                  dqs_count_r <= #TCQ 5'd0;\n                end\n              end else\n                wl_state_r <= #TCQ WL_INIT;\n           end\n         endcase\n     end\n   end // always @ (posedge clk)\nendmodule"}
{"task_id": 1547, "completion": "cycloneiv_lcell_comb #(.lut_mask(16'b0110_0110_1000_1000), .sum_lutc_input(\"cin\")) carry_start  (.cout(CO[0]), .dataa(BB[0]), .datab(1'b1), .datac(1'b1), .datad(1'b1));\n\tgenvar i;\n\tgenerate for (i = 1; i < Y_WIDTH; i = i + 1) begin:slice\n\t    cycloneiv_lcell_comb #(.lut_mask(16'b0101_1010_0101_0000), .sum_lutc_input(\"cin\")) arith_cell (.combout(Y[i]), .cout(CO[i]), .dataa(BB[i]), .datab(1'b1), .datac(1'b1), .datad(1'b1), .cin(C[i]));\n\tend endgenerate\n\n\tassign X = AA ^ BB;\nendmodule"}
{"task_id": 138, "completion": "parameter [0 : 0] dmem_not_imem = 1'b0;  input  CLK;  input  RST_N;  input  [3 : 0] set_verbosity_verbosity;  input  EN_set_verbosity;  output RDY_set_verbosity;  input  EN_server_reset_request_put;  output RDY_server_reset_request_put;  input  EN_server_reset_response_get;  output RDY_server_reset_response_get;  input  [1 : 0] req_op;  input  [2 : 0] req_f3;  input  [6 : 0] req_amo_funct7;  input  [63 : 0] req_addr;  input  [63 : 0] req_st_value;  input  [1 : 0] req_priv;  input  req_sstatus_SUM;  input  req_mstatus_MXR;  input  [63 : 0] req_satp;  input  EN_req;  output valid;  output [63 : 0] addr;  reg [63 : 0] cword;  output [63 : 0] st_amo_val;  output exc;  output [3 : 0] exc_code;  input  EN_server_flush_request_put;  output RDY_server_flush_request_put;  input  EN_server_flush_response_get;  output RDY_server_flush_response_get;  input  EN_tlb_flush;  output RDY_tlb_flush;  output mem_master_awvalid;  output [3 : 0] mem_master_awid;  output [63 : 0] mem_master_awaddr;  output [7 : 0] mem_master_awlen;  output [2 : 0] mem_master_awsize;  output [1 : 0] mem_master_awburst;  output mem_master_awlock;  output [3 : 0] mem_master_awcache;  output [2 : 0] mem_master_awprot;  output [3 : 0] mem_master_awqos;  output [3 : 0] mem_master_awregion;  input  mem_master_awready;  output mem_master_wvalid;  output [63 : 0] mem_master_wdata;  output [7 : 0] mem_master_wstrb;  output mem_master_wlast;  input  mem_master_wready;  input  mem_master_bvalid;  input  [3 : 0] mem_master_bid;  input  [1 : 0] mem_master_bresp;  output mem_master_bready;  output mem_master_arvalid;  output [3 : 0] mem_master_arid;  output [63 : 0] mem_master_araddr;  output [7 : 0] mem_master_arlen;  output [2 : 0] mem_master_arsize;  output [1 : 0] mem_master_arburst;  output mem_master_arlock;  output [3 : 0] mem_master_arcache;  output [2 : 0] mem_master_arprot;  output [3 : 0] mem_master_arqos;  output [3 : 0] mem_master_arregion;  input  mem_master_arready;  input  mem_master_rvalid;  input  [3 : 0] mem_master_rid;  input  [63 : 0] mem_master_rdata;  input  [1 : 0] mem_master_rresp;  input  mem_master_rlast;  output mem_master_rready;  input  set_watch_tohost_watch_tohost;  input  [63 : 0] set_watch_tohost_tohost_addr;  input  EN_set_watch_tohost;  output RDY_set_watch_tohost;  output [63 : 0] mv_tohost_value;  output RDY_mv_tohost_value;  input  EN_ma_ddr4_ready;  output RDY_ma_ddr4_ready;  output [7 : 0] mv_status;  reg [63 : 0] addr, mem_master_araddr, mem_master_awaddr, mem_master_wdata, mv_tohost_value, st_amo_val;  wire [7 : 0] mem_master_arlen, mem_master_awlen, mem_master_wstrb, mv_status;  wire [3 : 0] exc_code, mem_master_arcache, mem_master_arid, mem_master_arqos, mem_master_arregion, mem_master_awcache, mem_master_awid, mem_master_awqos, mem_master_awregion;  wire [2 : 0] mem_master_arprot, mem_master_arsize, mem_master_awprot, mem_master_awsize;  wire [1 : 0] mem_master_arburst, mem_master_awburst;  wire RDY_ma_ddr4_ready, RDY_mv_tohost_value, RDY_server_flush_request_put, RDY_server_flush_response_get, RDY_server_reset_request_put, RDY_server_reset_response_get, RDY_set_verbosity, RDY_set_watch_tohost, RDY_tlb_flush, exc, mem_master_arlock, mem_master_arvalid, mem_master_awlock, mem_master_awvalid, mem_master_bready, mem_master_rready, mem_master_wlast, mem_master_wvalid, valid;  wire [3 : 0] ctr_wr_rsps_pending_crg;  reg [3 : 0] cfg_verbosity;  reg [63 : 0] rg_addr;  reg [6 : 0] rg_amo_funct7;  reg [8 : 0] rg_cset_cword_in_cache;  reg [5 : 0] rg_cset_in_cache;  reg rg_ddr4_ready;  reg rg_error_during_refill;  reg [3 : 0] rg_exc_code;  reg [2 : 0] rg_f3;  reg [63 : 0] rg_ld_val;  reg [31 : 0] rg_lower_word32;  reg rg_lower_word32_full;  reg [63 : 0] rg_lrsc_pa;  reg rg_lrsc_valid;  reg [1 : 0] rg_op;  reg [63 : 0] rg_pa;  reg [63 : 0] rg_pte_pa;  reg [63 : 0] rg_st_amo_val;  reg [4 : 0] rg_state;  reg [63 : 0] rg_tohost_addr;  reg [63 : 0] rg_tohost_value;  reg rg_victim_way;  reg rg_watch_tohost;  reg rg_wr_rsp_err;  // remaining internal signals  reg [63 : 0] old_cword;  wire [63 : 0] IF_NOT_ram_state_and_ctag_cset_b_read__04_BIT__ETC___d447, IF_NOT_ram_state_and_ctag_cset_b_read__04_BIT__ETC___d524;  // // additional internal signals definition and connections  // ... (remaining implementation code follows)  endmodule"}
{"task_id": 1546, "completion": "reg step_executed, step_executed_1;\n    wire start;\n    wire stop;\n    wire cnt_done;\n    wire step;\n    reg [ADDR_WIDTH-1:0] count;\n    reg trace_enb;\n    pulse_gen sync_start(.async_in(controls_input[0]&controls_input[4]), .sync_clk(clk), .pulsed_out(start));\n    pulse_gen sync_stop(.async_in(controls_input[1]&controls_input[4]), .sync_clk(clk), .pulsed_out(stop));\n    pulse_gen sync_step(.async_in(controls_input[5]&controls_input[4]), .sync_clk(clk), .pulsed_out(step));\n    assign cnt_done = (count == (numSample-1)) ? 1'b1 : 1'b0;\n    always @(posedge clk)\n    if (!reset_n)\n        count <= 0;\n    else if((start) || (cnt_done) || (stop))\n        count <= 0;\n    else if(trace_enb | step_executed)\n        count <= count + 1;\n    else \n        count <= count;\n    always @(posedge clk)\n    if (!reset_n)\n        trace_enb_1d <= 0;\n    else \n        trace_enb_1d <= (trace_enb | step_executed);\n    always @(posedge clk)\n    if (!reset_n)\n    begin\n        trace_enb <= 0;    \n        step_executed <= 0;\n        step_executed_1 <= 0;\n    end\n    else\n    begin\n        if(start)         // start asserted\n        begin\n            trace_enb <= 1;\n            step_executed <= 0;\n        end\n        else if(stop)    // stop asserted\n        begin\n            trace_enb <= 0;\n            step_executed <= 0;\n        end\n        else if (cnt_done)\n        begin\n            trace_enb <= 0;\n        end\n        else if(step)\n        begin\n            step_executed <= 1;\n            step_executed_1 <= 0;\n        end       \n        else if(step_executed)\n        begin\n            step_executed <= 0;\n            step_executed_1 <= 1;\n        end\n        else if(step_executed_1)\n        begin\n            step_executed_1 <= 0;\n        end\n        else\n        begin\n            trace_enb <= trace_enb;\n        end       \n    end\nendmodule"}
{"task_id": 1571, "completion": "integer  cyc = 0;\n   reg [63:0]  crc;\n   reg [63:0]  sum;\n   wire [31:0]  in = crc[31:0];\n   wire [6:0] out = line_wb_ind( in[6:0] );\n   wire [63:0] result = {57'h0, out};\n   always @ (posedge clk) begin\n      cyc <= cyc + 1;\n      crc <= {crc[62:0], crc[63] ^ crc[2] ^ crc[0]};\n      sum <= result ^ {sum[62:0], sum[63] ^ sum[2] ^ sum[0]};\n      if (cyc==0) begin\n         crc <= 64'h5aef0c8d_d70a4497;\n         sum <= 64'h0;\n      end\n      else if (cyc<10) begin\n         sum <= 64'h0;\n      end\n      else if (cyc<90) begin\n      end\n      else if (cyc==99) begin\n         if (crc !== 64'hc77bb9b3784ea091) $stop;\n         if (sum !== `EXPECTED_SUM) $stop;\n         $finish;\n      end\n   end\n   function wb_ind_t line_wb_ind( id_t id );\n      if( id[$bits(id_t)-1] == 0 )\n        return {2'b00, id[$bits(wb_ind_t)-3:0]};\n      else\n        return {2'b01, id[$bits(wb_ind_t)-3:0]};\n   endfunction // line_wb_ind\nendmodule"}
{"task_id": 1521, "completion": "wire clock,reset,resetn,mem_clk; wire [31:0] a,b,alu,adr,tom,fromm,pc,ir,dpdata; wire [2:0] q; reg [15:0] digit,count=0; wire wmem; pbdebounce p0(clk,stp,clock); always @(posedge clock) count=count+1; pbdebounce p1(clk,rst,reset); assign resetn=~reset; assign mem_clk=clk; mccpu mc_cpu (clock,resetn,fromm,pc,ir,a,b,alu,wmem,adr,tom,q,regselect,dpdata); mcmem memory (adr[7:2],tom,mem_clk,wmem,fromm); display dp(clk,digit,node,segment); always @* begin case (dptype) 2'b00:digit<=dpdata[15:0]; 2'b01:digit<=dpdata[31:16]; 2'b10:digit<=pc[15:0]; 2'b11:digit<=count; endcase end assign exec=clock; assign initype=ir[31:26]; endmodule"}
{"task_id": 1531, "completion": "input fxclk_in, reset, pll_stop, dcm_progclk, dcm_progdata, dcm_progen, rd_clk, wr_clk, wr_start;\n    input [7:0] read;\n    output [7:0] write;\n\n    reg [3:0] rd_clk_b, wr_clk_b;\n    reg wr_start_b1, wr_start_b2, reset_buf;\n    reg dcm_progclk_buf, dcm_progdata_buf, dcm_progen_buf;\n    reg [4:0] wr_delay;\n    reg [671:0] inbuf, inbuf_tmp;\n    reg [95:0] outbuf;\n    reg [7:0] read_buf, write_buf;\n    \n    wire fxclk, clk, dcm_clk, pll_fb, pll_clk0, dcm_locked, pll_reset;\n    wire [31:0] golden_nonce, nonce2, hash2;\n    \n    wire [255:0] data1, data2;\n    wire [127:0] data3;\n    wire [31:0] target;\n\n    assign target = inbuf[671:640];\n    assign data3 = inbuf[639:512];\n    assign data2 = inbuf[511:256];\n    assign data1 = inbuf[255:0];\n    \n    wire gn_match;\n    wire loadnonce;\n\n    assign loadnonce = 1'b0;\n    assign hash2 = 32'd0;\n\n    hashcore M (.hash_clk(clk), .data1(data1), .data2(data2), .data3(data3), .target(target),\n                 .nonce_msb(4'd0), .nonce_out(nonce2), .golden_nonce_out(golden_nonce),\n                 .golden_nonce_match(gn_match), .loadnonce(loadnonce));\n\n    BUFG bufg_fxclk (\n          .I(fxclk_in),\n          .O(fxclk)\n        );\n\n    BUFG bufg_clk (\n          .I(pll_clk0),\n          .O(clk)\n        );\n\n    DCM_CLKGEN #(\n          .CLKFX_DIVIDE(6),\n          .CLKFX_MULTIPLY(20),\n          .CLKFXDV_DIVIDE(2),\n          .CLKIN_PERIOD(20.8)\n    ) \n    dcm0 (\n          .CLKIN(fxclk),\n          .CLKFX(dcm_clk),\n          .FREEZEDCM(1'b0),\n          .PROGCLK(dcm_progclk_buf),\n          .PROGDATA(dcm_progdata_buf),\n          .PROGEN(dcm_progen_buf),\n          .LOCKED(dcm_locked),\n          .RST(1'b0)\n    );\n\n    PLL_BASE #(\n          .BANDWIDTH(\"LOW\"),\n          .CLKFBOUT_MULT(5),\n          .CLKOUT0_DIVIDE(32),\n          .CLKOUT0_DUTY_CYCLE(0.5),\n          .CLK_FEEDBACK(\"CLKFBOUT\"), \n          .COMPENSATION(\"DCM2PLL\"),\n          .DIVCLK_DIVIDE(1),\n          .REF_JITTER(0.05),\n          .RESET_ON_LOSS_OF_LOCK(\"FALSE\"),\n          .CLKIN_PERIOD(6.25)\n       )\n       pll0 (\n            .CLKFBOUT(pll_fb),\n            .CLKOUT0(pll_clk0),\n            .CLKFBIN(pll_fb),\n            .CLKIN(dcm_clk),\n            .RST(pll_reset)\n    );\n\n    assign write = write_buf;\n    assign pll_reset = pll_stop | ~dcm_locked;\n    \n    always @ (posedge clk)\n    begin\n            if ( (rd_clk_b[3] == rd_clk_b[2]) && (rd_clk_b[2] == rd_clk_b[1]) && (rd_clk_b[1] != rd_clk_b[0]) )\n        begin\n            inbuf_tmp[671:664] <= read_buf;\n            inbuf_tmp[663:0] <= inbuf_tmp[671:8];\n        end;\n        inbuf <= inbuf_tmp;\n            \n        if ( wr_start_b1 && wr_start_b2 )\n        begin\n                wr_delay <= 5'd0;\n        end else \n        begin\n            wr_delay[0] <= 1'b1;\n            wr_delay[4:1] <= wr_delay[3:0];\n        end\n        \n        if ( ! wr_delay[4] ) \n        begin\n            outbuf <= { hash2, nonce2, golden_nonce };\n        end else\n        begin\n            if ( (wr_clk_b[3] == wr_clk_b[2]) && (wr_clk_b[2] == wr_clk_b[1]) && (wr_clk_b[1] != wr_clk_b[0]) ) \n                outbuf[87:0] <= outbuf[95:8];\n        end\n\n        read_buf <= read;\n        write_buf <= outbuf[7:0];\n\n        rd_clk_b[0] <= rd_clk;\n        rd_clk_b[3:1] <= rd_clk_b[2:0];\n\n        wr_clk_b[0] <= wr_clk;\n        wr_clk_b[3:1] <= wr_clk_b[2:0];\n\n        wr_start_b1 <= wr_start;\n        wr_start_b2 <= wr_start_b1;\n\n        reset_buf <= reset;\n    end\n\n    always @ (posedge fxclk)\n    begin\n        dcm_progclk_buf <= dcm_progclk;\n        dcm_progdata_buf <= dcm_progdata;\n        dcm_progen_buf <= dcm_progen;\n    end\n\nendmodule"}
{"task_id": 1583, "completion": "reg  received_esc;\n   wire escape_char, idle_char;\n\n   assign idle_char = (in_data == 8'h4a);\n   assign escape_char = (in_data == 8'h4d);\n\n   always @(posedge clk or negedge reset_n) begin\n      if (!reset_n) begin\n         received_esc <= 0; \n      end else begin\n         if (in_valid & in_ready) begin\n            if (escape_char & ~received_esc) begin\n                 received_esc <= 1;\n            end else if (out_valid) begin\n                 received_esc <= 0;\n            end\n         end\n      end\n   end\n\n   always @* begin\n      in_ready = out_ready;\n      out_valid = in_valid & ~idle_char & (received_esc | ~escape_char);\n      out_data = received_esc ? (in_data ^ 8'h20) : in_data;\n   end\nendmodule"}
{"task_id": 1538, "completion": "parameter   DATA_WIDTH = 16;\n  localparam  DW = DATA_WIDTH - 1;\n  reg             valid_out = 'd0;\n  reg     [15:0]  data_out = 'd0;\n  wire            type_s;\n  wire            signext_s;\n  wire    [DW:0]  data_s;\n  wire    [23:0]  sign_s;\n  wire    [23:0]  data_out_s;\n  assign type_s = dfmt_enable & dfmt_type;\n  assign signext_s = dfmt_enable & dfmt_se;\n  assign data_s = (type_s == 1'b1) ? {~data[DW], data[(DW-1):0]} : data;\n  assign sign_s = (signext_s == 1'b1) ? {{24{data_s[DW]}}} : 24'd0;\n  assign data_out_s = {sign_s[23:(DW+1)], data_s};\n  always @(posedge clk) begin\n    valid_out <= valid;\n    data_out <= data_out_s[15:0];\n  end\nendmodule"}
{"task_id": 1601, "completion": "wire [31:0] idata, ddata;    assign iout = idata;    assign dout = ddata;    assign idata = 32'h00000000;    assign ddata = {24'h000000,leds};    always @(negedge clk) begin        if (drw[0] && de && !rst) begin            leds = din[7:0];            $display(\"MOD_LEDS: %x\", din[7:0]);        end else if (rst) begin            leds = 8'hff;        end    endendmodule"}
{"task_id": 1526, "completion": "interface intf ();   integer index;   endinterface   intf ifa1_intf[4:1]();   intf ifa2_intf[4:1]();   intf ifb1_intf[1:4]();   intf ifb2_intf[1:4]();   int cyc;   sub sub0 (       .n(0),       .clk,       .cyc,       .alh(ifa1_intf[2:1]),       .ahl(ifa2_intf[2:1]),       .blh(ifb1_intf[1:2]),       .bhl(ifb2_intf[1:2])       );   sub sub1 (       .n(1),       .clk,       .cyc,       .alh(ifa1_intf[4:3]),       .ahl(ifa2_intf[4:3]),       .blh(ifb1_intf[3:4]),       .bhl(ifb2_intf[3:4])       );   `ifndef verilator // Backwards slicing not supported   sub sub2 (       .n(2),       .clk,       .cyc,       .alh(ifa1_intf[1:2]),       .ahl(ifa2_intf[1:2]),       .blh(ifb1_intf[2:1]),       .bhl(ifb2_intf[2:1])       );   sub sub3 (       .n(3),       .clk,       .cyc,       .alh(ifa1_intf[3:4]),       .ahl(ifa2_intf[3:4]),       .blh(ifb1_intf[4:3]),       .bhl(ifb2_intf[4:3])       );   `endif   always @(posedge clk) begin      cyc <= cyc + 1;      if (cyc == 1) begin         ifa1_intf[1].index = 'h101;         ifa1_intf[2].index = 'h102;         ifa1_intf[3].index = 'h103;         ifa1_intf[4].index = 'h104;         ifa2_intf[1].index = 'h201;         ifa2_intf[2].index = 'h202;         ifa2_intf[3].index = 'h203;         ifa2_intf[4].index = 'h204;         ifb1_intf[1].index = 'h301;         ifb1_intf[2].index = 'h302;         ifb1_intf[3].index = 'h303;         ifb1_intf[4].index = 'h304;         ifb2_intf[1].index = 'h401;         ifb2_intf[2].index = 'h402;         ifb2_intf[3].index = 'h403;         ifb2_intf[4].index = 'h404;      end   end   endmodule   module sub (   input logic clk,   input int cyc,   input int n,   intf alh[1:2],   intf ahl[2:1],   intf blh[1:2],   intf bhl[2:1]   );   always @(posedge clk) begin      if (cyc == 5) begin         if (n == 0) begin            `checkh(alh[1].index, 'h102);            `checkh(alh[2].index, 'h101);            `checkh(ahl[1].index, 'h201);            `checkh(ahl[2].index, 'h202);            `checkh(blh[1].index, 'h301);            `checkh(blh[2].index, 'h302);            `checkh(bhl[1].index, 'h402);            `checkh(bhl[2].index, 'h401);         end         else if (n == 1) begin            `checkh(alh[1].index, 'h104);            `checkh(alh[2].index, 'h103);            `checkh(ahl[1].index, 'h203);            `checkh(ahl[2].index, 'h204);            `checkh(blh[1].index, 'h303);            `checkh(blh[2].index, 'h304);            `checkh(bhl[1].index, 'h404);            `checkh(bhl[2].index, 'h403);         end         else if (n == 2) begin            `checkh(alh[1].index, 'h101);            `checkh(alh[2].index, 'h102);            `checkh(ahl[1].index, 'h202);            `checkh(ahl[2].index, 'h201);            `checkh(blh[1].index, 'h302);            `checkh(blh[2].index, 'h301);            `checkh(bhl[1].index, 'h401);            `checkh(bhl[2].index, 'h402);         end         else if (n == 3) begin            `checkh(alh[1].index, 'h103);            `checkh(alh[2].index, 'h104);            `checkh(ahl[1].index, 'h204);            `checkh(ahl[2].index, 'h203);            `checkh(blh[1].index, 'h304);            `checkh(blh[2].index, 'h303);            `checkh(bhl[1].index, 'h403);            `checkh(bhl[2].index, 'h404);         end      end      if (cyc == 9 && n == 0) begin         $write(\"*-* All Finished *-*\\n\");         $finish;      end   end   endmodule"}
{"task_id": 1587, "completion": "reg [5:0] serial = 6'b1111_11;\n    reg [3:0] counter = 4'd0;\n    reg [3:0] state = 4'd0;\n    reg [8:0] partial_byte = 9'd0;\n\n    wire start_detect = serial[5] & serial[4] & serial[3] & ~serial[2];\n    wire one_detect = serial[5] & serial[4] & serial[3];\n    wire zero_detect = ~serial[5] & ~serial[4] & ~serial[3];\n\n    always @ (posedge clk)\n    begin\n        serial <= {serial[4:0], rx_serial};\n        counter <= counter + 4'd1;\n        if (tx_flag)\n            tx_flag <= 1'b0;\n        if (state == 4'd0)\n        begin\n            if (start_detect)\n            begin\n                state <= 4'd1;\n                counter <= 4'd0;\n            end\n        end\n        else if (counter == 4'd9)\n        begin\n            state <= state + 4'd1;\n            partial_byte <= {one_detect, partial_byte[8:1]};\n            if (~one_detect & ~zero_detect)\n                state <= 4'd0;\n            else if ((state == 4'd1) & ~zero_detect)\n                state <= 4'd0;\n        end\n        else if (state == 4'd11)\n        begin\n            state <= 4'd0;\n            if (partial_byte[8])\n            {\n                tx_flag <= 1'b1;\n                tx_byte <= partial_byte[7:0];\n            }\n        end\n    end\nendmodule"}
{"task_id": 1489, "completion": "`include \"lm32_functions.v\"\n    \nlm32_cpu cpu (\n    .clk_i                 (clk_i),\n`ifdef CFG_EBR_NEGEDGE_REGISTER_FILE\n    .clk_n_i               (clk_n),\n`endif\n    .rst_i                 (rst_i),\n`ifdef CFG_DEBUG_ENABLED\n `ifdef CFG_ALTERNATE_EBA\n    .at_debug              (at_debug),\n `endif\n`endif\n    `ifdef CFG_INTERRUPTS_ENABLED\n    .interrupt_n           (interrupt_n),\n`endif\n    `ifdef CFG_USER_ENABLED\n    .user_result           (user_result),\n    .user_complete         (user_complete),\n`endif     \n`ifdef CFG_JTAG_ENABLED\n    .jtag_clk              (jtck),\n    .jtag_update           (jtag_update),\n    .jtag_reg_q            (jtag_reg_q),\n    .jtag_reg_addr_q       (jtag_reg_addr_q),\n`endif\n    .D_DAT_I               (D_DAT_I),\n    .D_ACK_I               (D_ACK_I),\n    .D_ERR_I               (D_ERR_I),\n    .D_RTY_I               (D_RTY_I),\n    `ifdef CFG_TRACE_ENABLED\n    .trace_pc              (trace_pc),\n    .trace_pc_valid        (trace_pc_valid),\n    .trace_exception       (trace_exception),\n    .trace_eid             (trace_eid),\n    .trace_eret            (trace_eret),\n`ifdef CFG_DEBUG_ENABLED\n    .trace_bret            (trace_bret),\n`endif\n`endif\n    `ifdef CFG_JTAG_ENABLED\n    .jtag_reg_d            (jtag_reg_d),\n    .jtag_reg_addr_d       (jtag_reg_addr_d),\n`endif\n    `ifdef CFG_USER_ENABLED    \n    .user_valid            (user_valid),\n    .user_opcode           (user_opcode),\n    .user_operand_0        (user_operand_0),\n    .user_operand_1        (user_operand_1),\n`endif    \n    `ifdef CFG_IROM_EXPOSE\n    .irom_clk_rd(irom_clk_rd),\n    .irom_clk_wr(irom_clk_wr),\n    .irom_rst_rd(irom_rst_rd),\n    .irom_rst_wr(irom_rst_wr),\n    .irom_d_rd(irom_d_rd) /* unused */,\n    .irom_d_wr(irom_d_wr),\n    .irom_q_rd(irom_q_rd),\n    .irom_q_wr(irom_q_wr),\n    .irom_addr_rd(irom_addr_rd),\n    .irom_addr_wr(irom_addr_wr),\n    .irom_en_rd(irom_en_rd),\n    .irom_en_wr(irom_en_wr),\n    .irom_write_rd(irom_write_rd),\n    .irom_write_wr(irom_write_wr),\n`endif\n    `ifdef CFG_DRAM_EXPOSE\n    .dram_clk_rd(dram_clk_rd),\n    .dram_clk_wr(dram_clk_wr),\n    .dram_rst_rd(dram_rst_rd),\n    .dram_rst_wr(dram_rst_wr),\n    .dram_d_rd(dram_d_rd) /* unused */,\n    .dram_d_wr(dram_d_wr),\n    .dram_q_rd(dram_q_rd),\n    .dram_q_wr(dram_q_wr) /* unused */,\n    .dram_addr_rd(dram_addr_rd),\n    .dram_addr_wr(dram_addr_wr),\n    .dram_en_rd(dram_en_rd),\n    .dram_en_wr(dram_en_wr),\n    .dram_write_rd(dram_write_rd),\n    .dram_write_wr(dram_write_wr),\n`endif\n    `ifdef CFG_IWB_ENABLED\n    .I_DAT_O               (I_DAT_O),\n    .I_ADR_O               (I_ADR_O),\n    .I_CYC_O               (I_CYC_O),\n    .I_SEL_O               (I_SEL_O),\n    .I_STB_O               (I_STB_O),\n    .I_WE_O                (I_WE_O),\n    .I_CTI_O               (I_CTI_O),\n    .I_LOCK_O              (I_LOCK_O),\n    .I_BTE_O               (I_BTE_O),\n    `endif\n    .D_DAT_O               (D_DAT_O),\n    .D_ADR_O               (D_ADR_O),\n    .D_CYC_O               (D_CYC_O),\n    .D_SEL_O               (D_SEL_O),\n    .D_STB_O               (D_STB_O),\n    .D_WE_O                (D_WE_O),\n    .D_CTI_O               (D_CTI_O),\n    .D_LOCK_O              (D_LOCK_O),\n    .D_BTE_O               (D_BTE_O)\n    );\n   wire TRACE_ACK_O;\n   wire [`LM32_WORD_RNG] TRACE_DAT_O;\n`ifdef CFG_TRACE_ENABLED\n   lm32_trace trace_module (.clk_i\t(clk_i),\n\t\t\t\t.rst_i\t(rst_i),\n\t\t\t\t.stb_i\t(DEBUG_STB_I & DEBUG_ADR_I[13]),\n\t\t\t\t.we_i\t(DEBUG_WE_I),\n\t\t\t\t.sel_i\t(DEBUG_SEL_I),\n\t\t\t\t.dat_i\t(DEBUG_DAT_I),\n\t\t\t\t.adr_i\t(DEBUG_ADR_I),\n\t\t\t\t.trace_pc\t(trace_pc),\n\t\t\t\t.trace_eid\t(trace_eid),\n\t\t\t\t.trace_eret (trace_eret),\n\t\t\t\t.trace_bret (trace_bret),\n\t\t\t\t.trace_pc_valid (trace_pc_valid),\n\t\t\t\t.trace_exception (trace_exception),\n\t\t\t\t.ack_o\t(TRACE_ACK_O),\n\t\t\t\t.dat_o\t(TRACE_DAT_O));   \n`else\n   assign             TRACE_ACK_O = 0;\n   assign             TRACE_DAT_O = 0;   \n`endif   \n`ifdef DEBUG_ROM\n   wire ROM_ACK_O;\n   wire [`LM32_WORD_RNG] ROM_DAT_O;\n\n   assign DEBUG_ACK_O = DEBUG_ADR_I[13] ? TRACE_ACK_O : ROM_ACK_O;\n   assign DEBUG_DAT_O = DEBUG_ADR_I[13] ? TRACE_DAT_O : ROM_DAT_O;\n   \n   lm32_monitor debug_rom (\n\t\t\t\t.clk_i                 (clk_i),\n\t\t\t\t.rst_i                 (rst_i),\n\t\t\t\t.MON_ADR_I             (DEBUG_ADR_I[10:2]),\n\t\t\t\t.MON_STB_I             (DEBUG_STB_I & ~DEBUG_ADR_I[13]),\n\t\t\t\t.MON_CYC_I             (DEBUG_CYC_I & ~DEBUG_ADR_I[13]),\n\t\t\t\t.MON_WE_I              (DEBUG_WE_I),\n\t\t\t\t.MON_SEL_I             (DEBUG_SEL_I),\n\t\t\t\t.MON_DAT_I             (DEBUG_DAT_I),\n\t\t\t\t.MON_RTY_O             (DEBUG_RTY_O),\n\t\t\t\t.MON_ERR_O             (DEBUG_ERR_O),\n\t\t\t\t.MON_ACK_O             (ROM_ACK_O),\n\t\t\t\t.MON_DAT_O             (ROM_DAT_O)\n\t\t\t\t);\n`endif \n   `ifdef CFG_JTAG_ENABLED\n   jtag_cores jtag_cores (\n    // ----- Inputs -----\n`ifdef INCLUDE_LM32\n    .reg_d                 (jtag_reg_d),\n    .reg_addr_d            (jtag_reg_addr_d),\n`endif\n    // ----- Outputs -----\n`ifdef INCLUDE_LM32\n    .reg_update            (jtag_update),\n    .reg_q                 (jtag_reg_q),\n    .reg_addr_q            (jtag_reg_addr_q),\n`endif\n    .jtck                  (jtck),\n    .jrstn                 (jrstn)\n    );\n`endif        \nendmodule"}
{"task_id": 1528, "completion": "parameter Tp = 1;\n\ninput         MRxClk;\ninput         Reset;\ninput         MRxDV;\ninput         ByteCntEq0;\ninput         ByteCntGreat2;\ninput         MRxDEq5;\ninput         Transmitting;\ninput         MRxDEqD;\ninput         IFGCounterEq24;\ninput         ByteCntMaxFrame;\n\noutput [1:0]  StateData;\noutput        StateIdle;\noutput        StateDrop;\noutput        StatePreamble;\noutput        StateSFD;\n\nreg           StateData0;\nreg           StateData1;\nreg           StateIdle;\nreg           StateDrop;\nreg           StatePreamble;\nreg           StateSFD;\n\nwire          StartIdle;\nwire          StartDrop;\nwire          StartData0;\nwire          StartData1;\nwire          StartPreamble;\nwire          StartSFD;\n\nassign StartIdle = ~MRxDV & (StateDrop | StatePreamble | StateSFD | (|StateData));\n\nassign StartPreamble = MRxDV & ~MRxDEq5 & (StateIdle & ~Transmitting);\n\nassign StartSFD = MRxDV & MRxDEq5 & (StateIdle & ~Transmitting | StatePreamble);\n\nassign StartData0 = MRxDV & (StateSFD & MRxDEqD & IFGCounterEq24 | StateData1);\n\nassign StartData1 = MRxDV & StateData0 & (~ByteCntMaxFrame);\n\nassign StartDrop = MRxDV & (StateIdle & Transmitting | StateSFD & ~IFGCounterEq24 & MRxDEqD | StateData0 & ByteCntMaxFrame);\n\nalways @ (posedge MRxClk or posedge Reset)\nbegin\n  if(Reset)\n    begin\n      StateIdle     <=  1'b0;\n      StateDrop     <=  1'b1;\n      StatePreamble <=  1'b0;\n      StateSFD      <=  1'b0;\n      StateData0    <=  1'b0;\n      StateData1    <=  1'b0;\n    end\n  else\n    begin\n      if(StartPreamble | StartSFD | StartDrop)\n        StateIdle <=  1'b0;\n      else\n      if(StartIdle)\n        StateIdle <=  1'b1;\n\n      if(StartIdle)\n        StateDrop <=  1'b0;\n      else\n      if(StartDrop)\n        StateDrop <=  1'b1;\n\n      if(StartSFD | StartIdle | StartDrop)\n        StatePreamble <=  1'b0;\n      else\n      if(StartPreamble)\n        StatePreamble <=  1'b1;\n\n      if(StartPreamble | StartIdle | StartData0 | StartDrop)\n        StateSFD <=  1'b0;\n      else\n      if(StartSFD)\n        StateSFD <=  1'b1;\n\n      if(StartIdle | StartData1 | StartDrop)\n        StateData0 <=  1'b0;\n      else\n      if(StartData0)\n        StateData0 <=  1'b1;\n\n      if(StartIdle | StartData0 | StartDrop)\n        StateData1 <=  1'b0;\n      else\n      if(StartData1)\n        StateData1 <=  1'b1;\n    end\nend\n\nassign StateData[1:0] = {StateData1, StateData0};\n\nendmodule"}
{"task_id": 1539, "completion": "localparam RDPATH_RDY_DLY = 10;\n\n  wire rddata_en;\n  wire rddata_en_rsync;\n  wire rddata_en_srl_out;\n  reg [RDPATH_RDY_DLY-1:0] rdpath_rdy_dly_r;\n\n  assign rddata_en = (mc_data_sel) ? dfi_rddata_en : phy_rddata_en;\n\n  SRLC32E u_rddata_en_srl\n    (\n     .Q   (rddata_en_srl_out),\n     .Q31 (),\n     .A   (rd_active_dly),\n     .CE  (1'b1),\n     .CLK (clk),\n     .D   (rddata_en)\n     );\n\n  always @(posedge clk) begin\n    dfi_rddata_valid <= #TCQ rddata_en_srl_out & mc_data_sel;\n    dfi_rddata_valid_phy <= #TCQ rddata_en_srl_out;\n  end\n\n  always @(posedge clk or posedge rst_rsync) begin\n    if (rst_rsync)\n      rdpath_rdy_dly_r <= #TCQ {{RDPATH_RDY_DLY}{1'b0}};\n    else\n      rdpath_rdy_dly_r[RDPATH_RDY_DLY-1:1]\n        <= #TCQ {rdpath_rdy_dly_r[RDPATH_RDY_DLY-2:0], 1'b1};\n  end\n\n  always @(posedge clk)\n    rdpath_rdy <= rdpath_rdy_dly_r[RDPATH_RDY_DLY-1];\n\nendmodule"}
{"task_id": 1532, "completion": "parameter RegisterInputData = 1;\n  reg [3:0] state;\n  wire  BaudTick  = txd_busy ? baud1tick : 1'b0;\n  wire  txd_ready;\n\n  reg [7:0] txd_dataReg;\n\n  assign txd_ready = (state==0);\n  assign txd_busy  = ~txd_ready;\n\n  always @(posedge clk) if(txd_ready & txd_start) txd_dataReg <= txd_data;\n  wire [7:0] txd_dataD = RegisterInputData ? txd_dataReg : txd_data;\n\n  always @(posedge clk)\n  case(state)\n    4'b0000: if(txd_start) state <= 4'b0001;\n    4'b0001: if(BaudTick) state <= 4'b0100;\n    4'b0100: if(BaudTick) state <= 4'b1000;\n    4'b1000: if(BaudTick) state <= 4'b1001;\n    4'b1001: if(BaudTick) state <= 4'b1010;\n    4'b1010: if(BaudTick) state <= 4'b1011;\n    4'b1011: if(BaudTick) state <= 4'b1100;\n    4'b1100: if(BaudTick) state <= 4'b1101;\n    4'b1101: if(BaudTick) state <= 4'b1110;\n    4'b1110: if(BaudTick) state <= 4'b1111;\n    4'b1111: if(BaudTick) state <= 4'b0010;\n    4'b0010: if(BaudTick) state <= 4'b0011;\n    4'b0011: if(BaudTick) state <= 4'b0000;\n    default: if(BaudTick) state <= 4'b0000;\n  endcase\n\n  reg muxbit;\n  always @( * )\n  case(state[2:0])\n    3'd0: muxbit <= txd_dataD[0];\n    3'd1: muxbit <= txd_dataD[1];\n    3'd2: muxbit <= txd_dataD[2];\n    3'd3: muxbit <= txd_dataD[3];\n    3'd4: muxbit <= txd_dataD[4];\n    3'd5: muxbit <= txd_dataD[5];\n    3'd6: muxbit <= txd_dataD[6];\n    3'd7: muxbit <= txd_dataD[7];\n  endcase\n\n  always @(posedge clk) txd <= (state<4) | (state[3] & muxbit);\nendmodule"}
{"task_id": 1519, "completion": "generate \n        if (USE_V5FXT == 0) begin\n            pcie_gt_wrapper#\n            ( \n                  .NO_OF_LANES(NO_OF_LANES),\n                  .SIM(SIM),\n                  .PLL_DIVSEL_FB(REF_CLK_FREQ ? 1 : 5), \n                  .PLL_DIVSEL_REF(REF_CLK_FREQ ? 1 : 2),\n                  .CLK25_DIVIDER(REF_CLK_FREQ ? 10 : 4),\n                  .TXDIFFBOOST(TXDIFFBOOST)\n            )\n            pcie_gt_wrapper_i\n            ( \n                  .gt_rx_elec_idle         (gt_rx_elec_idle),\n                  .gt_rx_status            (gt_rx_status),\n                  .gt_rx_data              (gt_rx_data),\n                  .gt_rx_phy_status        (gt_rx_phy_status),\n                  .gt_rx_data_k            (gt_rx_data_k),\n                  .gt_rx_valid             (gt_rx_valid),\n                  .gt_rx_chanisaligned     (gt_rx_chanisaligned),\n                  .gt_rx_n                 (gt_rx_n),     \n                  .gt_rx_p                 (gt_rx_p),     \n                  .gt_tx_n                 (gt_tx_n),     \n                  .gt_tx_p                 (gt_tx_p),    \n                  .gt_tx_data              (gt_tx_data),\n                  .gt_tx_data_k            (gt_tx_data_k),\n                  .gt_tx_elec_idle         (gt_tx_elec_idle),\n                  .gt_tx_detect_rx_loopback(gt_tx_detect_rx_loopback),\n                  .gt_tx_compliance        (gt_tx_compliance),\n                  .gt_rx_polarity          (gt_rx_polarity),\n                  .gt_power_down           (gt_power_down),\n                  .gt_deskew_lanes         (gt_deskew_lanes),\n                  .gt_pipe_reset           (gt_pipe_reset),\n                  .gt_rx_present           (gt_rx_present),\n                  .gsr                     (gsr),\n                  .gtreset                 (gtreset),\n                  .refclk                  (refclk),\n                  .refclkout_bufg          (refclkout_bufg),\n                  .gtclk_bufg              (gtclk_bufg), \n                  .plllkdet_out            (plllkdet_out),\n                  .resetdone               (resetdone),\n                  .gt_usrclk               (gt_usrclk2),\n                  .rxbyteisaligned         (rxbyteisaligned), \n                  .rxchanbondseq           (rxchanbondseq), \n                  .pcie_reset              (pcie_reset),\n                  .clock_lock              (clock_lock), \n                  .gt_dclk                 (gt_dclk),\n                  .gt_daddr                (gt_daddr),\n                  .gt_den                  (gt_den),\n                  .gt_dwen                 (gt_dwen),\n                  .gt_di                   (gt_di),\n                  .gt_do                   (gt_do),\n                  .gt_drdy                 (gt_drdy),\n                  .gt_txdiffctrl_0         (gt_txdiffctrl_0),\n                  .gt_txdiffctrl_1         (gt_txdiffctrl_1),\n                  .gt_txbuffctrl_0         (gt_txbuffctrl_0),\n                  .gt_txbuffctrl_1         (gt_txbuffctrl_1),\n                  .gt_txpreemphesis_0      (gt_txpreemphesis_0),\n                  .gt_txpreemphesis_1      (gt_txpreemphesis_1)\n            );\n        end else begin\n            pcie_gtx_wrapper#\n            ( \n                  .NO_OF_LANES(NO_OF_LANES),\n                  .SIM(SIM),\n                  .PLL_DIVSEL_FB(REF_CLK_FREQ ? 2 : 5),  \n                  .PLL_DIVSEL_REF(REF_CLK_FREQ ? 1 : 1),\n                  .CLK25_DIVIDER(REF_CLK_FREQ ? 10 : 4),\n                  .TXDIFFBOOST(TXDIFFBOOST),\n                  .GTDEBUGPORTS(GTDEBUGPORTS)\n            )\n            pcie_gt_wrapper_i\n            ( \n                  .gt_rx_elec_idle         (gt_rx_elec_idle),\n                  .gt_rx_status            (gt_rx_status),\n                  .gt_rx_data              (gt_rx_data),\n                  .gt_rx_phy_status        (gt_rx_phy_status),\n                  .gt_rx_data_k            (gt_rx_data_k),\n                  .gt_rx_valid             (gt_rx_valid),\n                  .gt_rx_chanisaligned     (gt_rx_chanisaligned),\n                  .gt_rx_n                 (gt_rx_n),     \n                  .gt_rx_p                 (gt_rx_p),     \n                  .gt_tx_n                 (gt_tx_n),     \n                  .gt_tx_p                 (gt_tx_p),    \n                  .gt_tx_data              (gt_tx_data),\n                  .gt_tx_data_k            (gt_tx_data_k),\n                  .gt_tx_elec_idle         (gt_tx_elec_idle),\n                  .gt_tx_detect_rx_loopback(gt_tx_detect_rx_loopback),\n                  .gt_tx_compliance        (gt_tx_compliance),\n                  .gt_rx_polarity          (gt_rx_polarity),\n                  .gt_power_down           (gt_power_down),\n                  .gt_deskew_lanes         (gt_deskew_lanes),\n                  .gt_pipe_reset           (gt_pipe_reset),\n                  .gt_rx_present           (gt_rx_present),\n                  .gsr                     (gsr),\n                  .gtreset                 (gtreset),\n                  .refclk                  (refclk),\n                  .refclkout_bufg          (refclkout_bufg),\n                  .gtclk_bufg              (gtclk_bufg), \n                  .plllkdet_out            (plllkdet_out),\n                  .resetdone               (resetdone),\n                  .gt_usrclk               (gt_usrclk),\n                  .gt_usrclk2              (gt_usrclk2),\n                  .txsync_clk              (txsync_clk),\n                  .rxbyteisaligned         (rxbyteisaligned), \n                  .rxchanbondseq           (rxchanbondseq), \n                  .pcie_reset              (pcie_reset),\n                  .clock_lock              (clock_lock), \n                  .trn_lnk_up_n            (trn_lnk_up_n),\n                  .gt_dclk                 (gt_dclk),\n                  .gt_daddr                (gt_daddr),\n                  .gt_den                  (gt_den),\n                  .gt_dwen                 (gt_dwen),\n                  .gt_di                   (gt_di),\n                  .gt_do                   (gt_do),\n                  .gt_drdy                 (gt_drdy),\n                  .gt_txdiffctrl_0         (gt_txdiffctrl_0),\n                  .gt_txdiffctrl_1         (gt_txdiffctrl_1),\n                  .gt_txbuffctrl_0         (gt_txbuffctrl_0),\n                  .gt_txbuffctrl_1         (gt_txbuffctrl_1),\n                  .gt_txpreemphesis_0      (gt_txpreemphesis_0),\n                  .gt_txpreemphesis_1      (gt_txpreemphesis_1)\n            );\n        end\n    endgenerate\nendmodule"}
{"task_id": 1597, "completion": "wire pll_50;    wire dll_50;    wire dll_100;    reg  clk_25 = 0;    DCM #(      .CLKDV_DIVIDE(2.0),      .CLKFX_DIVIDE(32),      .CLKFX_MULTIPLY(24),      .CLKIN_DIVIDE_BY_2(\"FALSE\"),      .CLKIN_PERIOD(15.015),      .CLKOUT_PHASE_SHIFT(\"NONE\"),      .CLK_FEEDBACK(\"NONE\"),      .DESKEW_ADJUST(\"SYSTEM_SYNCHRONOUS\"),      .DFS_FREQUENCY_MODE(\"LOW\"),      .DLL_FREQUENCY_MODE(\"LOW\"),      .DUTY_CYCLE_CORRECTION(\"TRUE\"),      .FACTORY_JF(16'h8080),      .PHASE_SHIFT(0),      .STARTUP_WAIT(\"TRUE\")    ) pll (      .CLKIN(inclk0),      .CLKFX(pll_50)    );    DCM #(      .CLKDV_DIVIDE(2.0),      .CLKFX_DIVIDE(1),      .CLKFX_MULTIPLY(4),      .CLKIN_DIVIDE_BY_2(\"FALSE\"),      .CLKIN_PERIOD(20.020),      .CLKOUT_PHASE_SHIFT(\"NONE\"),      .CLK_FEEDBACK(\"1X\"),      .DESKEW_ADJUST(\"SYSTEM_SYNCHRONOUS\"),      .DFS_FREQUENCY_MODE(\"LOW\"),      .DLL_FREQUENCY_MODE(\"LOW\"),      .DUTY_CYCLE_CORRECTION(\"TRUE\"),      .FACTORY_JF(16'h8080),      .PHASE_SHIFT(0),      .STARTUP_WAIT(\"TRUE\")    ) dll (      .CLKIN(pll_50),      .CLK0(dll_50),      .CLK2X(dll_100),      .CLKFB(c1),      .LOCKED(locked)    );    always @ (posedge c0) begin      clk_25 <= #1 ~clk_25;    end    BUFG  BUFG_100 (.I(dll_100), .O(c0));    BUFG  BUFG_50  (.I(dll_50),  .O(c1));    BUFG  BUFG_25  (.I(clk_25),  .O(c2));  endmodule"}
{"task_id": 151, "completion": "reg     [31:0]  up_rdata     = 'd0;\nreg             up_wack      = 'd0;\nreg             up_rack      = 'd0;\nreg             pwm_gen_clk  = 'd0;\n\nwire            adc_rst;\nwire            up_rstn;\nwire            up_clk;\n\nwire            up_rreq_s;\nwire            up_wreq_s;\nwire    [13:0]  up_raddr_s;\nwire    [13:0]  up_waddr_s;\nwire    [31:0]  up_wdata_s;\nwire    [31:0]  up_adc_common_rdata_s;\nwire    [31:0]  up_control_rdata_s;\nwire    [31:0]  rdata_c0_s;\nwire    [31:0]  rdata_c1_s;\nwire    [31:0]  rdata_c2_s;\nwire    [31:0]  rdata_c3_s;\nwire    [31:0]  rdata_c4_s;\nwire    [31:0]  rdata_c5_s;\nwire    [31:0]  rdata_c6_s;\nwire    [31:0]  rdata_c7_s;\nwire            up_adc_common_wack_s;\nwire            up_adc_common_rack_s;\nwire            up_control_wack_s;\nwire            up_control_rack_s;\nwire            wack_c0_s;\nwire            rack_c0_s;\nwire            wack_c1_s;\nwire            rack_c1_s;\nwire            wack_c2_s;\nwire            rack_c2_s;\nwire            wack_c3_s;\nwire            rack_c3_s;\nwire            wack_c4_s;\nwire            rack_c4_s;\nwire            wack_c5_s;\nwire            rack_c5_s;\nwire            wack_c6_s;\nwire            rack_c6_s;\nwire            wack_c7_s;\nwire            rack_c7_s;\nwire            run_s;\nwire            star_delta_s;\nwire            dir_s;\nwire    [10:0]  pwm_open_s;\nwire    [10:0]  pwm_s;\nwire            dpwm_ah_s;\nwire            dpwm_al_s;\nwire            dpwm_bh_s;\nwire            dpwm_bl_s;\nwire            dpwm_ch_s;\nwire            dpwm_cl_s;\nwire            foc_ctrl_s;\n\nassign up_clk         = s_axi_aclk;\nassign up_rstn        = s_axi_aresetn;\n\nassign adc_clk_o      = ctrl_data_clk;\n\nassign adc_valid_c0   = ctrl_data_valid_i;\nassign adc_valid_c1   = ctrl_data_valid_i;\nassign adc_valid_c2   = ctrl_data_valid_i;\nassign adc_valid_c3   = ctrl_data_valid_i;\nassign adc_valid_c4   = ctrl_data_valid_i;\nassign adc_valid_c5   = ctrl_data_valid_i;\nassign adc_valid_c6   = ctrl_data_valid_i;\nassign adc_valid_c7   = ctrl_data_valid_i;\n\nassign adc_data_c0    = ctrl_data0_i;\nassign adc_data_c1    = ctrl_data1_i;\nassign adc_data_c2    = ctrl_data2_i;\nassign adc_data_c3    = ctrl_data3_i;\nassign adc_data_c4    = ctrl_data4_i;\nassign adc_data_c5    = ctrl_data5_i;\nassign adc_data_c6    = ctrl_data6_i;\nassign adc_data_c7    = ctrl_data7_i;\n\nassign ctrl_rst_o     = !run_s;\n\nassign fmc_en_o       = run_s;\nassign pwm_s          = pwm_open_s ;\n\nassign pwm_ah_o = foc_ctrl_s ? !pwm_a_i : dpwm_ah_s;\nassign pwm_al_o = foc_ctrl_s ? pwm_a_i : dpwm_al_s;\nassign pwm_bh_o = foc_ctrl_s ? !pwm_b_i : dpwm_bh_s;\nassign pwm_bl_o = foc_ctrl_s ? pwm_b_i : dpwm_bl_s;\nassign pwm_ch_o = foc_ctrl_s ? !pwm_c_i : dpwm_ch_s;\nassign pwm_cl_o = foc_ctrl_s ? pwm_c_i : dpwm_cl_s;\n\nalways @(posedge ref_clk)\nbegin\n  pwm_gen_clk <= ~pwm_gen_clk;\nend\n\nalways @(negedge up_rstn or posedge up_clk) begin\n    if(up_rstn == 0) begin\n        up_rdata  <= 'd0;\n        up_wack   <= 'd0;\n        up_rack   <= 'd0;\n    end else begin\n        up_rdata  <= up_control_rdata_s | up_adc_common_rdata_s | rdata_c0_s | rdata_c1_s | rdata_c2_s | rdata_c3_s | rdata_c4_s | rdata_c5_s | rdata_c6_s | rdata_c7_s;\n        up_rack   <= up_control_rack_s | up_adc_common_rack_s | rack_c0_s | rack_c1_s | rack_c2_s | rack_c3_s | rack_c4_s | rack_c5_s | rack_c6_s | rack_c7_s;\n        up_wack   <= up_control_wack_s | up_adc_common_wack_s | wack_c0_s | wack_c1_s | wack_c2_s | wack_c3_s | wack_c4_s | wack_c5_s | wack_c6_s | wack_c7_s;\n    end\nend\n\nmotor_driver\n#( .PWM_BITS(11))\nmotor_driver_inst(\n    .clk_i(ctrl_data_clk),\n    .pwm_clk_i(pwm_gen_clk),\n    .rst_n_i(up_rstn) ,\n    .run_i(run_s),\n    .star_delta_i(star_delta_s),\n    .dir_i(dir_s),\n    .position_i(position_i),\n    .pwm_duty_i(pwm_s),\n    .AH_o(dpwm_ah_s),\n    .BH_o(dpwm_bh_s),\n    .CH_o(dpwm_ch_s),\n    .AL_o(dpwm_al_s),\n    .BL_o(dpwm_bl_s),\n    .CL_o(dpwm_cl_s));\n\ncontrol_registers control_reg_inst(\n    .up_rstn(up_rstn),\n    .up_clk(up_clk),\n    .up_wreq (up_wreq_s),\n    .up_waddr (up_waddr_s),\n    .up_wdata (up_wdata_s),\n    .up_wack (up_control_wack_s),\n    .up_rreq (up_rreq_s),\n    .up_raddr (up_raddr_s),\n    .up_rdata (up_control_rdata_s),\n    .up_rack (up_control_rack_s),\n    .run_o(run_s),\n    .break_o(),\n    .dir_o(dir_s),\n    .star_delta_o(star_delta_s),\n    .sensors_o(sensors_o),\n    .kp_o(),\n    .ki_o(),\n    .kd_o(),\n    .kp1_o(),\n    .ki1_o(),\n    .kd1_o(),\n    .gpo_o(gpo_o),\n    .reference_speed_o(),\n    .oloop_matlab_o(foc_ctrl_s),\n    .err_i(32'h0),\n    .calibrate_adcs_o(),\n    .pwm_open_o(pwm_open_s));\n\nup_adc_channel #(.PCORE_ADC_CHID(0)) adc_channel0(\n    .adc_clk(ref_clk),\n    .adc_rst(adc_rst),\n    .adc_enable(adc_enable_c0),\n    .adc_iqcor_enb(),\n    .adc_dcfilt_enb(),\n    .adc_dfmt_se(),\n    .adc_dfmt_type(),\n    .adc_dfmt_enable(),\n    .adc_dcfilt_offset(),\n    .adc_dcfilt_coeff(),\n    .adc_iqcor_coeff_1(),\n    .adc_iqcor_coeff_2(),\n    .adc_pnseq_sel(),\n    .adc_data_sel(),\n    .adc_pn_err(1'b0),\n    .adc_pn_oos(1'b0),\n    .adc_or(1'b0),\n    .up_adc_pn_err(),\n    .up_adc_pn_oos(),\n    .up_adc_or(),\n    .up_usr_datatype_be(),\n    .up_usr_datatype_signed(),\n    .up_usr_datatype_shift(),\n    .up_usr_datatype_total_bits(),\n    .up_usr_datatype_bits(),\n    .up_usr_decimation_m(),\n    .up_usr_decimation_n(),\n    .adc_usr_datatype_be(1'b0),\n    .adc_usr_datatype_signed(1'b1),\n    .adc_usr_datatype_shift(8'd0),\n    .adc_usr_datatype_total_bits(8'd16),\n    .adc_usr_datatype_bits(8'd16),\n    .adc_usr_decimation_m(16'd1),\n    .adc_usr_decimation_n(16'd1),\n    .up_rstn(up_rstn),\n    .up_clk(up_clk),\n    .up_wreq (up_wreq_s),\n    .up_waddr (up_waddr_s),\n    .up_wdata (up_wdata_s),\n    .up_wack (wack_c0_s),\n    .up_rreq (up_rreq_s),\n    .up_raddr (up_raddr_s),\n    .up_rdata (rdata_c0_s),\n    .up_rack (rack_c0_s));\n\nup_adc_channel #(.PCORE_ADC_CHID(1)) adc_channel1(\n    .adc_clk(ref_clk),\n    .adc_rst(adc_rst),\n    .adc_enable(adc_enable_c1),\n    .adc_iqcor_enb(),\n    .adc_dcfilt_enb(),\n    .adc_dfmt_se(),\n    .adc_dfmt_type(),\n    .adc_dfmt_enable(),\n    .adc_dcfilt_offset(),\n    .adc_dcfilt_coeff(),\n    .adc_iqcor_coeff_1(),\n    .adc_iqcor_coeff_2(),\n    .adc_pnseq_sel(),\n    .adc_data_sel(),\n    .adc_pn_err(1'b0),\n    .adc_pn_oos(1'b0),\n    .adc_or(1'b0),\n    .up_adc_pn_err(),\n    .up_adc_pn_oos(),\n    .up_adc_or(),\n    .up_usr_datatype_be(),\n    .up_usr_datatype_signed(),\n    .up_usr_datatype_shift(),\n    .up_usr_datatype_total_bits(),\n    .up_usr_datatype_bits(),\n    .up_usr_decimation_m(),\n    .up_usr_decimation_n(),\n    .adc_usr_datatype_be(1'b0),\n    .adc_usr_datatype_signed(1'b1),\n    .adc_usr_datatype_shift(8'd0),\n    .adc_usr_datatype_total_bits(8'd16),\n    .adc_usr_datatype_bits(8'd16),\n    .adc_usr_decimation_m(16'd1),\n    .adc_usr_decimation_n(16'd1),\n    .up_rstn(up_rstn),\n    .up_clk(up_clk),\n    .up_wreq (up_wreq_s),\n    .up_waddr (up_waddr_s),\n    .up_wdata (up_wdata_s),\n    .up_wack (wack_c1_s),\n    .up_rreq (up_rreq_s),\n    .up_raddr (up_raddr_s),\n    .up_rdata (rdata_c1_s),\n    .up_rack (rack_c1_s));\n\nup_adc_channel #(.PCORE_ADC_CHID(2)) adc_channel2(\n    .adc_clk(ref_clk),\n    .adc_rst(adc_rst),\n    .adc_enable(adc_enable_c2),\n    .adc_iqcor_enb(),\n    .adc_dcfilt_enb(),\n    .adc_dfmt_se(),\n    .adc_dfmt_type(),\n    .adc_dfmt_enable(),\n    .adc_dcfilt_offset(),\n    .adc_dcfilt_coeff(),\n    .adc_iqcor_coeff_1(),\n    .adc_iqcor_coeff_2(),\n    .adc_pnseq_sel(),\n    .adc_data_sel(),\n    .adc_pn_err(1'b0),\n    .adc_pn_oos(1'b0),\n    .adc_or(1'b0),\n    .up_adc_pn_err(),\n    .up_adc_pn_oos(),\n    .up_adc_or(),\n    .up_usr_datatype_be(),\n    .up_usr_datatype_signed(),\n    .up_usr_datatype_shift(),\n    .up_usr_datatype_total_bits(),\n    .up_usr_datatype_bits(),\n    .up_usr_decimation_m(),\n    .up_usr_decimation_n(),\n    .adc_usr_datatype_be(1'b0),\n    .adc_usr_datatype_signed(1'b1),\n    .adc_usr_datatype_shift(8'd0),\n    .adc_usr_datatype_total_bits(8'd16),\n    .adc_usr_datatype_bits(8'd16),\n    .adc_usr_decimation_m(16'd1),\n    .adc_usr_decimation_n(16'd1),\n    .up_rstn(up_rstn),\n    .up_clk(up_clk),\n    .up_wreq (up_wreq_s),\n    .up_waddr (up_waddr_s),\n    .up_wdata (up_wdata_s),\n    .up_wack (wack_c2_s),\n    .up_rreq (up_rreq_s),\n    .up_raddr (up_raddr_s),\n    .up_rdata (rdata_c2_s),\n    .up_rack (rack_c2_s));\n\nup_adc_channel #(.PCORE_ADC_CHID(3)) adc_channel3(\n    .adc_clk(ref_clk),\n    .adc_rst(adc_rst),\n    .adc_enable(adc_enable_c3),\n    .adc_iqcor_enb(),\n    .adc_dcfilt_enb(),\n    .adc_dfmt_se(),\n    .adc_dfmt_type(),\n    .adc_dfmt_enable(),\n    .adc_dcfilt_offset(),\n    .adc_dcfilt_coeff(),\n    .adc_iqcor_coeff_1(),\n    .adc_iqcor_coeff_2(),\n    .adc_pnseq_sel(),\n    .adc_data_sel(),\n    .adc_pn_err(1'b0),\n    .adc_pn_oos(1'b0),\n    .adc_or(1'b0),\n    .up_adc_pn_err(),\n    .up_adc_pn_oos(),\n    .up_adc_or(),\n    .up_usr_datatype_be(),\n    .up_usr_datatype_signed(),\n    .up_usr_datatype_shift(),\n    .up_usr_datatype_total_bits(),\n    .up_usr_datatype_bits(),\n    .up_usr_decimation_m(),\n    .up_usr_decimation_n(),\n    .adc_usr_datatype_be(1'b0),\n    .adc_usr_datatype_signed(1'b1),\n    .adc_usr_datatype_shift(8'd0),\n    .adc_usr_datatype_total_bits(8'd16),\n    .adc_usr_datatype_bits(8'd16),\n    .adc_usr_decimation_m(16'd1),\n    .adc_usr_decimation_n(16'd1),\n    .up_rstn(up_rstn),\n    .up_clk(up_clk),\n    .up_wreq (up_wreq_s),\n    .up_waddr (up_waddr_s),\n    .up_wdata (up_wdata_s),\n    .up_wack (wack_c3_s),\n    .up_rreq (up_rreq_s),\n    .up_raddr (up_raddr_s),\n    .up_rdata (rdata_c3_s),\n    .up_rack (rack_c3_s));\n\nup_adc_channel #(.PCORE_ADC_CHID(4)) adc_channel4(\n    .adc_clk(ref_clk),\n    .adc_rst(adc_rst),\n    .adc_enable(adc_enable_c4),\n    .adc_iqcor_enb(),\n    .adc_dcfilt_enb(),\n    .adc_dfmt_se(),\n    .adc_dfmt_type(),\n    .adc_dfmt_enable(),\n    .adc_dcfilt_offset(),\n    .adc_dcfilt_coeff(),\n    .adc_iqcor_coeff_1(),\n    .adc_iqcor_coeff_2(),\n    .adc_pnseq_sel(),\n    .adc_data_sel(),\n    .adc_pn_err(1'b0),\n    .adc_pn_oos(1'b0),\n    .adc_or(1'b0),\n    .up_adc_pn_err(),\n    .up_adc_pn_oos(),\n    .up_adc_or(),\n    .up_usr_datatype_be(),\n    .up_usr_datatype_signed(),\n    .up_usr_datatype_shift(),\n    .up_usr_datatype_total_bits(),\n    .up_usr_datatype_bits(),\n    .up_usr_decimation_m(),\n    .up_usr_decimation_n(),\n    .adc_usr_datatype_be(1'b0),\n    .adc_usr_datatype_signed(1'b1),\n    .adc_usr_datatype_shift(8'd0),\n    .adc_usr_datatype_total_bits(8'd16),\n    .adc_usr_datatype_bits(8'd16),\n    .adc_usr_decimation_m(16'd1),\n    .adc_usr_decimation_n(16'd1),\n    .up_rstn(up_rstn),\n    .up_clk(up_clk),\n    .up_wreq (up_wreq_s),\n    .up_waddr (up_waddr_s),\n    .up_wdata (up_wdata_s),\n    .up_wack (wack_c4_s),\n    .up_rreq (up_rreq_s),\n    .up_raddr (up_raddr_s),\n    .up_rdata (rdata_c4_s),\n    .up_rack (rack_c4_s));\n\nup_adc_channel #(.PCORE_ADC_CHID(5)) adc_channel5(\n    .adc_clk(ref_clk),\n    .adc_rst(adc_rst),\n    .adc_enable(adc_enable_c5),\n    .adc_iqcor_enb(),\n    .adc_dcfilt_enb(),\n    .adc_dfmt_se(),\n    .adc_dfmt_type(),\n    .adc_dfmt_enable(),\n    .adc_dcfilt_offset(),\n    .adc_dcfilt_coeff(),\n    .adc_iqcor_coeff_1(),\n    .adc_iqcor_coeff_2(),\n    .adc_pnseq_sel(),\n    .adc_data_sel(),\n    .adc_pn_err(1'b0),\n    .adc_pn_oos(1'b0),\n    .adc_or(1'b0),\n    .up_adc_pn_err(),\n    .up_adc_pn_oos(),\n    .up_adc_or(),\n    .up_usr_datatype_be(),\n    .up_usr_datatype_signed(),\n    .up_usr_datatype_shift(),\n    .up_usr_datatype_total_bits(),\n    .up_usr_datatype_bits(),\n    .up_usr_decimation_m(),\n    .up_usr_decimation_n(),\n    .adc_usr_datatype_be(1'b0),\n    .adc_usr_datatype_signed(1'b1),\n    .adc_usr_datatype_shift(8'd0),\n    .adc_usr_datatype_total_bits(8'd16),\n    .adc_usr_datatype_bits(8'd16),\n    .adc_usr_decimation_m(16'd1),\n    .adc_usr_decimation_n(16'd1),\n    .up_rstn(up_rstn),\n    .up_clk(up_clk),\n    .up_wreq (up_wreq_s),\n    .up_waddr (up_waddr_s),\n    .up_wdata (up_wdata_s),\n    .up_wack (wack_c5_s),\n    .up_rreq (up_rreq_s),\n    .up_raddr (up_raddr_s),\n    .up_rdata (rdata_c5_s),\n    .up_rack (rack_c5_s));\n\nup_adc_channel #(.PCORE_ADC_CHID(6)) adc_channel6(\n    .adc_clk(ref_clk),\n    .adc_rst(adc_rst),\n    .adc_enable(adc_enable_c6),\n    .adc_iqcor_enb(),\n    .adc_dcfilt_enb(),\n    .adc_dfmt_se(),\n    .adc_dfmt_type(),\n    .adc_dfmt_enable(),\n    .adc_dcfilt_offset(),\n    .adc_dcfilt_coeff(),\n    .adc_iqcor_coeff_1(),\n    .adc_iqcor_coeff_2(),\n    .adc_pnseq_sel(),\n    .adc_data_sel(),\n    .adc_pn_err(1'b0),\n    .adc_pn_oos(1'b0),\n    .adc_or(1'b0),\n    .up_adc_pn_err(),\n    .up_adc_pn_oos(),\n    .up_adc_or(),\n    .up_usr_datatype_be(),\n    .up_usr_datatype_signed(),\n    .up_usr_datatype_shift(),\n    .up_usr_datatype_total_bits(),\n    .up_usr_datatype_bits(),\n    .up_usr_decimation_m(),\n    .up_usr_decimation_n(),\n    .adc_usr_datatype_be(1'b0),\n    .adc_usr_datatype_signed(1'b1),\n    .adc_usr_datatype_shift(8'd0),\n    .adc_usr_datatype_total_bits(8'd16),\n    .adc_usr_datatype_bits(8'd16),\n    .adc_usr_decimation_m(16'd1),\n    .adc_usr_decimation_n(16'd1),\n    .up_rstn(up_rstn),\n    .up_clk(up_clk),\n    .up_wreq (up_wreq_s),\n    .up_waddr (up_waddr_s),\n    .up_wdata (up_wdata_s),\n    .up_wack (wack_c6_s),\n    .up_rreq (up_rreq_s),\n    .up_raddr (up_raddr_s),\n    .up_rdata (rdata_c6_s),\n    .up_rack (rack_c6_s));\n\nup_adc_channel #(.PCORE_ADC_CHID(7)) adc_channel7(\n    .adc_clk(ref_clk),\n    .adc_rst(adc_rst),\n    .adc_enable(adc_enable_c7),\n    .adc_iqcor_enb(),\n    .adc_dcfilt_enb(),\n    .adc_dfmt_se(),\n    .adc_dfmt_type(),\n    .adc_dfmt_enable(),\n    .adc_dcfilt_offset(),\n    .adc_dcfilt_coeff(),\n    .adc_iqcor_coeff_1(),\n    .adc_iqcor_coeff_2(),\n    .adc_pnseq_sel(),\n    .adc_data_sel(),\n    .adc_pn_err(1'b0),\n    .adc_pn_oos(1'b0),\n    .adc_or(1'b0),\n    .up_adc_pn_err(),\n    .up_adc_pn_oos(),\n    .up_adc_or(),\n    .up_usr_datatype_be(),\n    .up_usr_datatype_signed(),\n    .up_usr_datatype_shift(),\n    .up_usr_datatype_total_bits(),\n    .up_usr_datatype_bits(),\n    .up_usr_decimation_m(),\n    .up_usr_decimation_n(),\n    .adc_usr_datatype_be(1'b0),\n    .adc_usr_datatype_signed(1'b1),\n    .adc_usr_datatype_shift(8'd0),\n    .adc_usr_datatype_total_bits(8'd16),\n    .adc_usr_datatype_bits(8'd16),\n    .adc_usr_decimation_m(16'd1),\n    .adc_usr_decimation_n(16'd1),\n    .up_rstn(up_rstn),\n    .up_clk(up_clk),\n    .up_wreq (up_wreq_s),\n    .up_waddr (up_waddr_s),\n    .up_wdata (up_wdata_s),\n    .up_wack (wack_c7_s),\n    .up_rreq (up_rreq_s),\n    .up_raddr (up_raddr_s),\n    .up_rdata (rdata_c7_s),\n    .up_rack (rack_c7_s));\n\nup_adc_common i_up_adc_common(\n    .mmcm_rst(),\n    .adc_clk(ref_clk),\n    .adc_rst(adc_rst),\n    .adc_r1_mode(),\n    .adc_ddr_edgesel(),\n    .adc_pin_mode(),\n    .adc_status(1'b1),\n    .adc_sync_status(1'b1),\n    .adc_status_ovf(1'b0),\n    .adc_status_unf(1'b0),\n    .adc_clk_ratio(32'd1),\n    .adc_start_code(),\n    .adc_sync(),\n    .up_status_pn_err(1'b0),\n    .up_status_pn_oos(1'b0),\n    .up_status_or(1'b0),\n    .up_drp_sel(),\n    .up_drp_wr(),\n    .up_drp_addr(),\n    .up_drp_wdata(),\n    .up_drp_rdata(16'd0),\n    .up_drp_ready(1'b0),\n    .up_drp_locked(1'b0),\n    .up_usr_chanmax(),\n    .adc_usr_chanmax(8'd7),\n    .up_adc_gpio_in(32'h0),\n    .up_adc_gpio_out(),\n    .up_rstn (up_rstn),\n    .up_clk (up_clk),\n    .up_wreq (up_wreq_s),\n    .up_waddr (up_waddr_s),\n    .up_wdata (up_wdata_s),\n    .up_wack (up_adc_common_wack_s),\n    .up_rreq (up_rreq_s),\n    .up_raddr (up_raddr_s),\n    .up_rdata (up_adc_common_rdata_s),\n    .up_rack (up_adc_common_rack_s));\n\nup_axi i_up_axi(\n        .up_rstn(up_rstn),\n        .up_clk(up_clk),\n        .up_axi_awvalid(s_axi_awvalid),\n        .up_axi_awaddr(s_axi_awaddr),\n        .up_axi_awready(s_axi_awready),\n        .up_axi_wvalid(s_axi_wvalid),\n        .up_axi_wdata(s_axi_wdata),\n        .up_axi_wstrb(s_axi_wstrb),\n        .up_axi_wready(s_axi_wready),\n        .up_axi_bvalid(s_axi_bvalid),\n        .up_axi_bresp(s_axi_bresp),\n        .up_axi_bready(s_axi_bready),\n        .up_axi_arvalid(s_axi_arvalid),\n        .up_axi_araddr(s_axi_araddr),\n        .up_axi_arready(s_axi_arready),\n        .up_axi_rvalid(s_axi_rvalid),\n        .up_axi_rresp(s_axi_rresp),\n        .up_axi_rdata(s_axi_rdata),\n        .up_axi_rready(s_axi_rready),\n        .up_wreq (up_wreq_s),\n        .up_waddr (up_waddr_s),\n        .up_wdata (up_wdata_s),\n        .up_wack (up_wack),\n        .up_rreq (up_rreq_s),\n        .up_raddr (up_raddr_s),\n        .up_rdata (up_rdata),\n        .up_rack (up_rack));\n\nendmodule"}
{"task_id": 1619, "completion": "reg signed [num_width - 1 : 0] num_orig;\n    reg num_orig_sflag, num_orig_rflag, reg_overflow;\n    reg signed [res_width : 0] num_comp;\n\n    always @(posedge clk) begin\n        num_orig <= fixed_num[num_width - 1] == 0 ? fixed_num : \n            {fixed_num[num_width - 1], ~(fixed_num[num_width - 2 : 0] - 1)};\n        num_comp <= num_orig[num_width - 1] == 0 ? \n            {num_orig[num_width - 1], num_orig[res_width + fixed_pos - 1 : fixed_pos]} : \n            {num_orig[num_width - 1], ~num_orig[res_width + fixed_pos - 1 : fixed_pos] + 1};\n        reg_overflow <= num_orig[num_width - 2 : res_width + fixed_pos] == 0 ? 0 : 1;\n        overflow <= reg_overflow;\n        num_orig_sflag <= num_orig[num_width - 1];\n        num_orig_rflag <= num_orig[fixed_pos - 1];\n        case(num_orig_sflag)\n            0 : round <= num_orig_rflag == 0 ? num_comp : num_comp + 1;\n            1 : round <= num_orig_rflag == 0 ? num_comp : num_comp - 1;\n            default : /* default */;\n        endcase\n    end\n\nendmodule"}
{"task_id": 1590, "completion": "wire [5:0] data_out;\n  wire builder_pll_fb;\n  wire fdce_0_out, fdce_1_out;\n  wire main_locked;\n\n  FDCE FDCE_0 (\n      .D  (data_in),\n      .C  (clk),\n      .CE (1'b1),\n      .CLR(1'b0),\n      .Q  (fdce_0_out)\n  );\n\n  FDCE FDCE_1 (\n      .D  (fdce_0_out),\n      .C  (clk),\n      .CE (1'b1),\n      .CLR(1'b0),\n      .Q  (data_out[0])\n  );\n\n  PLLE2_ADV #(\n      .CLKFBOUT_MULT(4'd12),\n      .CLKFBOUT_PHASE(90.0),\n      .CLKIN1_PERIOD(9.99999),\n      .CLKOUT0_DIVIDE(4'd12),\n      .CLKOUT0_PHASE(90.0),\n      .CLKOUT1_DIVIDE(3'd6),\n      .CLKOUT1_PHASE(0.0),\n      .CLKOUT2_DIVIDE(2'd3),\n      .CLKOUT2_PHASE(90.0),\n      .REF_JITTER1(0.01),\n      .STARTUP_WAIT(\"FALSE\")\n  ) PLLE2_ADV (\n      .CLKFBIN(builder_pll_fb),\n      .CLKIN1(clk),\n      .RST(cpu_reset),\n      .CLKFBOUT(builder_pll_fb),\n      .CLKOUT0(main_clkout_x1),\n      .CLKOUT1(main_clkout_x2),\n      .CLKOUT2(main_clkout_x4),\n      .LOCKED(main_locked)\n  );\n\n  FDCE FDCE_PLLx1_PH90 (\n      .D  (data_in),\n      .C  (main_clkout_x1),\n      .CE (1'b1),\n      .CLR(1'b0),\n      .Q  (data_out[1])\n  );\n\n  FDCE FDCE_PLLx4_PH0_0 (\n      .D  (data_in),\n      .C  (main_clkout_x2),\n      .CE (1'b1),\n      .CLR(1'b0),\n      .Q  (data_out[2])\n  );\n\n  FDCE FDCE_PLLx4_PH0_1 (\n      .D  (data_in),\n      .C  (main_clkout_x2),\n      .CE (1'b1),\n      .CLR(1'b0),\n      .Q  (data_out[3])\n  );\n\n  FDCE FDCE_PLLx4_PH0_2 (\n      .D  (data_in),\n      .C  (main_clkout_x2),\n      .CE (1'b1),\n      .CLR(1'b0),\n      .Q  (data_out[4])\n  );\n\n  FDCE FDCE_PLLx2_PH90_0 (\n      .D  (data_in),\n      .C  (main_clkout_x4),\n      .CE (1'b1),\n      .CLR(1'b0),\n      .Q  (data_out[5])\n  );\nendmodule"}
{"task_id": 1472, "completion": "wire [3:0]   s_rxs_axis_tvalid; reg [3:0]   s_rxs_axis_tready; wire [31:0]  s_rxs_axis_tdata[3:0]; wire [3:0]   s_rxs_axis_tkeep[3:0]; wire [3:0]   s_rxs_axis_tlast; wire [3:0]   s_rxd_axis_tvalid; reg [3:0]   s_rxd_axis_tready; wire [31:0]  s_rxd_axis_tdata[3:0]; wire [3:0]   s_rxd_axis_tkeep[3:0]; wire [3:0]   s_rxd_axis_tlast; assign s_rxs_axis_tvalid[0]=s_rxs0_axis_tvalid; assign s_rxs_axis_tvalid[1]=s_rxs1_axis_tvalid; assign s_rxs_axis_tvalid[2]=s_rxs2_axis_tvalid; assign s_rxs_axis_tvalid[3]=s_rxs3_axis_tvalid; assign s_rxs0_axis_tready=s_rxs_axis_tready[0]; assign s_rxs1_axis_tready=s_rxs_axis_tready[1]; assign s_rxs2_axis_tready=s_rxs_axis_tready[2]; assign s_rxs3_axis_tready=s_rxs_axis_tready[3]; assign s_rxs_axis_tdata[0]=s_rxs0_axis_tdata; assign s_rxs_axis_tdata[1]=s_rxs1_axis_tdata; assign s_rxs_axis_tdata[2]=s_rxs2_axis_tdata; assign s_rxs_axis_tdata[3]=s_rxs3_axis_tdata; assign s_rxs_axis_tlast[0]=s_rxs0_axis_tlast; assign s_rxs_axis_tlast[1]=s_rxs1_axis_tlast; assign s_rxs_axis_tlast[2]=s_rxs2_axis_tlast; assign s_rxs_axis_tlast[3]=s_rxs3_axis_tlast; assign s_rxs_axis_tkeep[0]=s_rxs0_axis_tkeep; assign s_rxs_axis_tkeep[1]=s_rxs1_axis_tkeep; assign s_rxs_axis_tkeep[2]=s_rxs2_axis_tkeep; assign s_rxs_axis_tkeep[3]=s_rxs3_axis_tkeep; assign s_rxd_axis_tvalid[0]=s_rxd0_axis_tvalid; assign s_rxd_axis_tvalid[1]=s_rxd1_axis_tvalid; assign s_rxd_axis_tvalid[2]=s_rxd2_axis_tvalid; assign s_rxd_axis_tvalid[3]=s_rxd3_axis_tvalid; assign s_rxd0_axis_tready=s_rxd_axis_tready[0]; assign s_rxd1_axis_tready=s_rxd_axis_tready[1]; assign s_rxd2_axis_tready=s_rxd_axis_tready[2]; assign s_rxd3_axis_tready=s_rxd_axis_tready[3]; assign s_rxd_axis_tdata[0]=s_rxd0_axis_tdata; assign s_rxd_axis_tdata[1]=s_rxd1_axis_tdata; assign s_rxd_axis_tdata[2]=s_rxd2_axis_tdata; assign s_rxd_axis_tdata[3]=s_rxd3_axis_tdata; assign s_rxd_axis_tlast[0]=s_rxd0_axis_tlast; assign s_rxd_axis_tlast[1]=s_rxd1_axis_tlast; assign s_rxd_axis_tlast[2]=s_rxd2_axis_tlast; assign s_rxd_axis_tlast[3]=s_rxd3_axis_tlast; assign s_rxd_axis_tkeep[0]=s_rxd0_axis_tkeep; assign s_rxd_axis_tkeep[1]=s_rxd1_axis_tkeep; assign s_rxd_axis_tkeep[2]=s_rxd2_axis_tkeep; assign s_rxd_axis_tkeep[3]=s_rxd3_axis_tkeep; localparam  WAIT_FOR_RXS=0, WAIT_FOR_RXS_1=1, WAIT_FOR_RXS_2=2, WAIT_FOR_RXS_EOP=3, WAIT_FOR_RXD=4, WAIT_FOR_RXD_EOP=5, ADD_QUEUE=6; reg [3:0]cur_st,nxt_st; reg [1:0]cur_queue; always@(posedge aclk) if(~aresetn) cur_st<=0; else cur_st<=nxt_st; always@(*) begin nxt_st=cur_st; case(cur_st) WAIT_FOR_RXS: if(s_rxs_axis_tvalid[cur_queue]) nxt_st=WAIT_FOR_RXS_1; else nxt_st=ADD_QUEUE; WAIT_FOR_RXS_1:if(s_rxs_axis_tvalid[cur_queue]) nxt_st=WAIT_FOR_RXS_2; WAIT_FOR_RXS_2:if(s_rxs_axis_tvalid[cur_queue]) nxt_st=WAIT_FOR_RXS_EOP; WAIT_FOR_RXS_EOP: if(s_rxs_axis_tlast[cur_queue]) nxt_st=WAIT_FOR_RXD; WAIT_FOR_RXD: if(s_rxd_axis_tvalid[cur_queue]) nxt_st=WAIT_FOR_RXD_EOP; WAIT_FOR_RXD_EOP: if(s_rxd_axis_tlast[cur_queue]) nxt_st=ADD_QUEUE; ADD_QUEUE: nxt_st=WAIT_FOR_RXS; default:nxt_st=WAIT_FOR_RXS; endcase end always@(posedge aclk) if(~aresetn) cur_queue<=0; else if(cur_st==ADD_QUEUE) begin if(cur_queue==3) cur_queue<=0; else cur_queue<=cur_queue+1; end always@(*) begin s_rxs_axis_tready=0; if(cur_st==WAIT_FOR_RXS_EOP | cur_st==WAIT_FOR_RXS_1 | cur_st==WAIT_FOR_RXS_2) s_rxs_axis_tready[cur_queue]=m_rxs_axis_tready; end always@(*) begin m_rxs_axis_tvalid=0; if(cur_st==WAIT_FOR_RXS_EOP | cur_st==WAIT_FOR_RXS_1 | cur_st==WAIT_FOR_RXS_2) m_rxs_axis_tvalid=s_rxs_axis_tvalid[cur_queue]; end always@(*) begin m_rxs_axis_tdata=0; if(cur_st==WAIT_FOR_RXS_EOP | cur_st==WAIT_FOR_RXS_1) m_rxs_axis_tdata=s_rxs_axis_tdata[cur_queue]; else if(cur_st==WAIT_FOR_RXS_2) begin m_rxs_axis_tdata[15:0]=s_rxs_axis_tdata[cur_queue][15:0]; m_rxs_axis_tdata[31:16]={14'h0,cur_queue}; end end always@(*) begin m_rxs_axis_tkeep=0; if(cur_st==WAIT_FOR_RXS_EOP | cur_st==WAIT_FOR_RXS_1 | cur_st==WAIT_FOR_RXS_2) m_rxs_axis_tkeep=s_rxd_axis_tkeep[cur_queue]; end assign m_rxs_axis_tlast=s_rxs_axis_tlast[cur_queue]; always@(*) begin s_rxd_axis_tready=0; if(cur_st==WAIT_FOR_RXD_EOP) s_rxd_axis_tready[cur_queue]=m_rxd_axis_tready; end always@(*) begin m_rxd_axis_tvalid=0; if(cur_st==WAIT_FOR_RXD_EOP) m_rxd_axis_tvalid=s_rxd_axis_tvalid[cur_queue]; end always@(*) begin m_rxd_axis_tkeep=0; if(cur_st==WAIT_FOR_RXD_EOP) m_rxd_axis_tkeep=s_rxd_axis_tkeep[cur_queue]; end always@(*) begin m_rxd_axis_tdata=0; if(cur_st==WAIT_FOR_RXD_EOP) m_rxd_axis_tdata=s_rxd_axis_tdata[cur_queue]; end assign m_rxd_axis_tlast=s_rxd_axis_tlast[cur_queue];endmodule"}
{"task_id": 296, "completion": "`include \"zap_localparams.vh\"    `include \"zap_defines.vh\"    `include \"zap_functions.vh\"    localparam IDLE                 = 0;    localparam UNCACHEABLE          = 1;    localparam CLEAN_SINGLE         = 2;    localparam FETCH_SINGLE         = 3;    localparam INVALIDATE           = 4;    localparam CLEAN                = 5;    localparam NUMBER_OF_STATES     = 6;    wire cache_cmp   = (i_cache_tag[`CACHE_TAG__TAG] == i_address[`VA__CACHE_TAG]);    wire cache_dirty = i_cache_tag_dirty;    reg [$clog2(NUMBER_OF_STATES)-1:0]      state_ff, state_nxt;    reg [31:0]                              buf_ff [(CACHE_LINE/4)-1:0];    reg [31:0]                              buf_nxt[(CACHE_LINE/4)-1:0];    reg                                     cache_clean_req_nxt,    cache_clean_req_ff;    reg                                     cache_inv_req_nxt,    cache_inv_req_ff;    reg [$clog2(CACHE_LINE/4):0]            adr_ctr_ff, adr_ctr_nxt;    reg                                     rhit, whit;    integer                                 i;    reg    [31:0]                           address;    reg                                     rd;    reg                                     wr;    reg    [31:0]                           din;    reg    [3:0]                            ben;    reg    [CACHE_LINE*8-1:0]               cache_line;    reg                                     cache_tag_dirty;    reg  [`CACHE_TAG_WDT-1:0]               cache_tag;    reg                                     cache_tag_valid;    reg    [31:0]                           phy_addr;    always @* o_cache_clean_req = cache_clean_req_ff;    always @* o_cache_inv_req   = cache_inv_req_ff;    always @ ( posedge i_clk ) if ( state_ff == IDLE ) address         <= i_address ;    always @ ( posedge i_clk ) if ( state_ff == IDLE ) rd              <= i_rd;    always @ ( posedge i_clk ) if ( state_ff == IDLE ) wr              <= i_wr;    always @ ( posedge i_clk ) if ( state_ff == IDLE ) din             <= i_din;    always @ ( posedge i_clk ) if ( state_ff == IDLE ) ben             <= i_ben;    always @ ( posedge i_clk ) if ( state_ff == IDLE ) cache_line      <= i_cache_line;    always @ ( posedge i_clk ) if ( state_ff == IDLE ) cache_tag_dirty <= i_cache_tag_dirty;    always @ ( posedge i_clk ) if ( state_ff == IDLE ) cache_tag       <= i_cache_tag;    always @ ( posedge i_clk ) if ( state_ff == IDLE ) cache_tag_valid <= i_cache_tag_valid;    always @ ( posedge i_clk ) if ( state_ff == IDLE ) phy_addr        <= i_phy_addr;    always @ (posedge i_clk)begin        if ( i_reset )begin                o_wb_cyc_ff             <= 0;                o_wb_stb_ff             <= 0;                o_wb_wen_ff             <= 0;                o_wb_sel_ff             <= 0;                o_wb_dat_ff             <= 0;                o_wb_cti_ff             <= CTI_CLASSIC;                o_wb_adr_ff             <= 0;                cache_clean_req_ff      <= 0;                cache_inv_req_ff        <= 0;                adr_ctr_ff              <= 0;                state_ff                <= IDLE;        end        else        begin                o_wb_cyc_ff             <= o_wb_cyc_nxt;                o_wb_stb_ff             <= o_wb_stb_nxt;                o_wb_wen_ff             <= o_wb_wen_nxt;                o_wb_sel_ff             <= o_wb_sel_nxt;                o_wb_dat_ff             <= o_wb_dat_nxt;                o_wb_cti_ff             <= o_wb_cti_nxt;                o_wb_adr_ff             <= o_wb_adr_nxt;                cache_clean_req_ff      <= cache_clean_req_nxt;                cache_inv_req_ff        <= cache_inv_req_nxt;                adr_ctr_ff              <= adr_ctr_nxt;                state_ff                <= state_nxt;        end    end    always @ ( posedge i_clk )begin        for(i=0;i<CACHE_LINE/4;i=i+1)                buf_ff[i] <= buf_nxt[i];    end    always @*begin:blk1       reg [$clog2(CACHE_LINE)-1:0] a;        a                       = 0;        state_nxt               = state_ff;        adr_ctr_nxt             = adr_ctr_ff;        o_wb_cyc_nxt            = o_wb_cyc_ff;        o_wb_stb_nxt            = o_wb_stb_ff;        o_wb_adr_nxt            = o_wb_adr_ff;        o_wb_dat_nxt            = o_wb_dat_ff;        o_wb_cti_nxt            = o_wb_cti_ff;        o_wb_wen_nxt            = o_wb_wen_ff;        o_wb_sel_nxt            = o_wb_sel_ff;        cache_clean_req_nxt     = cache_clean_req_ff;        cache_inv_req_nxt       = cache_clean_req_ff;        o_fsr                   = 0;        o_far                   = 0;        o_cache_tag             = 0;        o_cache_inv_done        = 0;        o_cache_clean_done      = 0;        o_cache_tag_dirty       = 0;        o_cache_tag_wr_en       = 0;        o_cache_line            = 0;        o_cache_line_ben        = 0;        o_dat                   = 0;        o_ack                   = 0;        o_err                   = 0;        o_err2                  = 0;        o_address               = address;        for(i=0;i<CACHE_LINE/4;i=i+1)                buf_nxt[i] = buf_ff[i];        rhit                     = 0;        whit                     = 0;        case(state_ff)        IDLE:        begin                kill_access;                if ( i_cache_inv )                begin                        o_ack     = 1'd0;                        state_nxt = INVALIDATE;                end                else if ( i_cache_clean )                begin                        o_ack     = 1'd0;                        state_nxt = CLEAN;                end                else if ( !i_rd && !i_wr )                begin                        o_ack = 1'd1;                end                else if ( i_fault )                begin                        o_err = 1'd1;                        o_ack = 1'd1;                        o_fsr = i_fsr;                        o_far = i_far;                end                else if ( i_busy )                begin                        o_err2 = 1'd1;                        o_ack  = 1'd1;                end                else if ( i_rd || i_wr )                begin                        if ( i_cacheable && i_cache_en )                        begin                                case ({cache_cmp,i_cache_tag_valid})                                2'b11:                                begin                                        if ( i_rd )                                        begin                                          o_dat   = adapt_cache_data(i_address, i_cache_line);                                          rhit    = 1'd1;                                          o_ack   = 1'd1;                                        end                                        else if ( i_wr )                                        begin                                          o_ack        = 1'd1;                                          whit         = 1'd1;                                          o_cache_line = {(CACHE_LINE/4){i_din}};                                          o_cache_line_ben  = ben_comp ( i_address, i_ben );                                          o_cache_tag_wr_en               = 1'd1;                                          o_cache_tag[`CACHE_TAG__TAG]    = i_address[`VA__CACHE_TAG];                                          o_cache_tag_dirty               = 1'd1;                                          o_cache_tag[`CACHE_TAG__PA]     = i_phy_addr >> $clog2(CACHE_LINE);                                          o_address                       = i_address;                                        end                                end                                2'b01:                                begin                                        o_ack  = 1'd1;                                        o_err2 = 1'd1;                                        if ( cache_dirty )                                        begin                                            adr_ctr_nxt = 0;                                            state_nxt = CLEAN_SINGLE;                                        end                                        else if ( i_rd | i_wr )                                        begin                                            adr_ctr_nxt = 0;                                            state_nxt = FETCH_SINGLE;                                        end                                end                                 default:                                begin                                                o_ack  = 1'd1;                                                o_err2 = 1'd1;                                                adr_ctr_nxt = 0;                                                state_nxt = FETCH_SINGLE;                                end                                endcase                        end                        else                        begin                                state_nxt       = UNCACHEABLE;                                o_ack           = 1'd0;                                o_wb_stb_nxt    = 1'd1;                                o_wb_cyc_nxt    = 1'd1;                                o_wb_adr_nxt    = i_phy_addr;                                o_wb_dat_nxt    = i_din;                                o_wb_wen_nxt    = i_wr;                                o_wb_sel_nxt    = i_ben;                                o_wb_cti_nxt    = CTI_CLASSIC;                        end                end        end        UNCACHEABLE:        begin                if ( i_wb_ack )                begin                        o_dat           = i_wb_dat;                        o_ack           = 1'd1;                        state_nxt       = IDLE;                        kill_access;                end        end        CLEAN_SINGLE:        begin                o_ack  = 1'd1;                o_err2 = i_rd || i_wr ? 1'd1 : 1'd0;                adr_ctr_nxt = adr_ctr_ff + (o_wb_stb_ff && i_wb_ack);                if ( adr_ctr_nxt <= ((CACHE_LINE/4) - 1) )                begin                        wb_prpr_write( clean_single_d (cache_line, adr_ctr_nxt), {cache_tag[`CACHE_TAG__PA], {CACHE_LINE{1'd0}}} + (adr_ctr_nxt * (32/8)), adr_ctr_nxt != ((CACHE_LINE/4) - 1) ? CTI_BURST : CTI_EOB, 4'b1111);                end                else                begin                        kill_access;                        state_nxt = IDLE;                          o_cache_tag_wr_en                      = 1'd1;                        o_cache_tag[`CACHE_TAG__TAG]           = cache_tag[`VA__CACHE_TAG];                        o_cache_tag_dirty                      = 1'd0;                        o_cache_tag[`CACHE_TAG__PA]            = cache_tag[`CACHE_TAG__PA];                end        end        FETCH_SINGLE:        begin                o_ack  = 1'd1;                o_err2 = i_rd || i_wr ? 1'd1 : 1'd0;                adr_ctr_nxt = adr_ctr_ff + (o_wb_stb_ff && i_wb_ack);                buf_nxt[adr_ctr_ff] = i_wb_ack ? i_wb_dat : buf_ff[adr_ctr_ff];                if ( wr )                begin                        a = address >> 2;                        buf_nxt[a][7:0]   = ben[0] ? din[7:0]   : buf_nxt[a][7:0];                        buf_nxt[a][15:8]  = ben[1] ? din[15:8]  : buf_nxt[a][15:8];                        buf_nxt[a][23:16] = ben[2] ? din[23:16] : buf_nxt[a][23:16];                        buf_nxt[a][31:24] = ben[3] ? din[31:24] : buf_nxt[a][31:24];                end                if ( adr_ctr_nxt <= (CACHE_LINE/4) - 1 )                begin                        wb_prpr_read({phy_addr[31:$clog2(CACHE_LINE)], {$clog2(CACHE_LINE){1'd0}}} + (adr_ctr_nxt * (32/8)), (adr_ctr_nxt != CACHE_LINE/4 - 1) ? CTI_BURST : CTI_EOB);                end                else                begin:blk12                        o_cache_line = 0;                        for(i=0;i<CACHE_LINE/4;i=i+1)                        o_cache_line = o_cache_line | (buf_nxt[i][31:0] << (32 * i));                        o_cache_line_ben  = {CACHE_LINE{1'd1}};                        o_cache_tag_wr_en                       = 1'd1;                        o_cache_tag[`CACHE_TAG__TAG]            = address[`VA__CACHE_TAG];                        o_cache_tag[`CACHE_TAG__PA]             = phy_addr >> $clog2(CACHE_LINE);                        o_cache_tag_dirty                       = !wr ? 1'd0 : 1'd1;                        kill_access;                        state_nxt = IDLE;                end        end        INVALIDATE:        begin                cache_inv_req_nxt = 1'd1;                cache_clean_req_nxt = 1'd0;                if ( i_cache_inv_done )                begin                        cache_inv_req_nxt    = 1'd0;                        state_nxt            = IDLE;                        o_cache_inv_done     = 1'd1;                end        end        CLEAN:        begin                cache_clean_req_nxt = 1'd1;                cache_inv_req_nxt   = 1'd0;                if ( i_cache_clean_done )                begin                        cache_clean_req_nxt  = 1'd0;                        state_nxt            = IDLE;                        o_cache_clean_done   = 1'd1;                end        end        endcase    end    function [31:0] adapt_cache_data (input [$clog2(CACHE_LINE)-1:0] shift, input [CACHE_LINE*8-1:0]       data);        reg [31:0] shamt;        begin                shamt            = (shift >> 2) * 32;                adapt_cache_data = data >> shamt;        end    endfunction    function [CACHE_LINE-1:0] ben_comp ( input [$clog2(CACHE_LINE)-1:0] shift, input [3:0] bv );        reg [31:0] shamt;        begin                shamt    = (shift >> 2) * 4;                ben_comp = bv << shamt;        end    endfunction    function [31:0] clean_single_d ( input [CACHE_LINE*8-1:0] cl, input [31:0]             sh );        reg [31:0] shamt;        begin                shamt          = sh * 32;                clean_single_d = cl >> shamt;        end    endfunction    task  wb_prpr_read;    input [31:0] i_address;    input [2:0]  i_cti;    begin        o_wb_cyc_nxt = 1'd1;        o_wb_stb_nxt = 1'd1;        o_wb_wen_nxt = 1'd0;        o_wb_sel_nxt = 4'b1111;        o_wb_adr_nxt = i_address;        o_wb_cti_nxt = i_cti;        o_wb_dat_nxt = 0;    end    endtask    task  wb_prpr_write;    input   [31:0]  i_data;    input   [31:0]  i_address;    input   [2:0]   i_cti;    input   [3:0]   i_ben;    begin        o_wb_cyc_nxt = 1'd1;        o_wb_stb_nxt = 1'd1;        o_wb_wen_nxt = 1'd1;        o_wb_sel_nxt = i_ben;        o_wb_adr_nxt = i_address;        o_wb_cti_nxt = i_cti;        o_wb_dat_nxt = i_data;    end    endtask    task  kill_access;    begin        o_wb_cyc_nxt = 0;        o_wb_stb_nxt = 0;        o_wb_wen_nxt = 0;        o_wb_adr_nxt = 0;        o_wb_dat_nxt = 0;        o_wb_sel_nxt = 0;        o_wb_cti_nxt = CTI_CLASSIC;    end    endtask    endmodule"}
{"task_id": 1607, "completion": "wire   [DW-1:0] s_int0;   wire [DW-1:0]   s_int1;   oh_csa32 #(.DW(DW)) csa32_0 (.in0(in0[DW-1:0]), .in1(in1[DW-1:0]), .in2(in2[DW-1:0]), .c(cout0[DW-1:0]), .s(s_int0[DW-1:0]));   oh_csa32 #(.DW(DW)) csa32_1 (.in0(in3[DW-1:0]), .in1(in4[DW-1:0]), .in2(in5[DW-1:0]), .c(cout1[DW-1:0]), .s(s_int1[DW-1:0]));   oh_csa42 #(.DW(DW)) csa42 (.in0(s_int0[DW-1:0]), .in1(s_int1[DW-1:0]), .in2(cin0[DW-1:0]), .in3(cin1[DW-1:0]), .cin(cin2[DW-1:0]), .cout(cout2[DW-1:0]), .c(c[DW-1:0]), .s(s[DW-1:0]));endmodule"}
{"task_id": 1585, "completion": "wire jt_capture, jt_drck, jt_reset, jt_sel, jt_shift, jt_tck, jt_tdi, jt_update;\n    wire jt_tdo;\n\n    BSCAN_SPARTAN6 # (.JTAG_CHAIN(1)) jtag_blk (\n        .CAPTURE(jt_capture),\n        .DRCK(jt_drck),\n        .RESET(jt_reset),\n        .RUNTEST(),\n        .SEL(jt_sel),\n        .SHIFT(jt_shift),\n        .TCK(jt_tck),\n        .TDI(jt_tdi),\n        .TDO(jt_tdo),\n        .TMS(),\n        .UPDATE(jt_update)\n    );\n\n    reg captured_data_valid = 1'b0;\n    reg [12:0] dr;\n\n\n    // FIFO from TCK to rx_clk\n    wire full;\n    fifo_generator_v8_2 tck_to_rx_clk_blk (\n        .wr_clk(jt_tck),\n        .rd_clk(rx_clk),\n        .din({7'd0, dr[8:0]}),\n        .wr_en(jt_update & jt_sel & !full),\n        .rd_en(rd_en & !tx_empty),\n        .dout(tx_data),\n        .full(full),\n        .empty(tx_empty)\n    );\n\n    // FIFO from rx_clk to TCK\n    wire [11:0] captured_data;\n    wire empty;\n    fifo_generator_v8_2 rx_clk_to_tck_blk (\n        .wr_clk(rx_clk),\n        .rd_clk(jt_tck),\n        .din({4'd0, rx_data}),\n        .wr_en(wr_en & !tx_full),\n        .rd_en(jt_capture & ~empty & ~jt_reset),\n        .dout(captured_data),\n        .full(tx_full),\n        .empty(empty)\n    );\n\n    assign jt_tdo = captured_data_valid ? captured_data[0] : dr[0];\n\n    always @ (posedge jt_tck or posedge jt_reset)\n    begin\n        if (jt_reset == 1'b1)\n        begin\n            dr <= 13'd0;\n        end\n        else if (jt_capture == 1'b1)\n        begin\n            // Capture-DR\n            captured_data_valid <= !empty;\n            dr <= 13'd0;\n        end\n        else if (jt_shift == 1'b1 & captured_data_valid)\n        begin\n            // Shift-DR\n            captured_data_valid <= 1'b0;\n\n            dr <= {jt_tdi, 1'b1, captured_data[11:1]};\n        end\n        else if (jt_shift == 1'b1)\n        begin\n            dr <= {jt_tdi, dr[12:1]};\n        end\n    end\n\nendmodule"}
{"task_id": 1610, "completion": "wire        enable;\nwire        accumulate;\nwire [33:0] multiplier;\nwire [33:0] multiplier_bar;\nwire [33:0] sum;\nwire [33:0] sum34_b;\n\nreg  [5:0]  count = 'd0;\nreg  [5:0]  count_nxt;\nreg  [67:0] product = 'd0;\nreg  [67:0] product_nxt;\nreg  [1:0]  flags_nxt;\nwire [32:0] sum_acc1;\n\nassign enable         = i_function[0];\nassign accumulate     = i_function[1];\n \nassign multiplier     =  { 2'd0, i_a_in} ;\nassign multiplier_bar = ~{ 2'd0, i_a_in} + 34'd1 ;\n\nassign sum34_b        =  product[1:0] == 2'b01 ? multiplier     :\n                         product[1:0] == 2'b10 ? multiplier_bar :\n                                                 34'd0          ;\n\n`ifdef XILINX_FPGA\n    `ifdef XILINX_SPARTAN6_FPGA\n        xs6_addsub_n #(.WIDTH(34)) \n    `endif\n    `ifdef XILINX_VIRTEX6_FPGA\n        xv6_addsub_n #(.WIDTH(34))  \n    `endif\n        u_xx_addsub_34_sum (\n        .i_a    ( product[67:34]        ),\n        .i_b    ( sum34_b               ),\n        .i_cin  ( 1'd0                  ),\n        .i_sub  ( 1'd0                  ),\n        .o_sum  ( sum                   ),\n        .o_co   (                       )\n    );\n\n    `ifdef XILINX_SPARTAN6_FPGA\n        xs6_addsub_n #(.WIDTH(33)) \n    `endif\n    `ifdef XILINX_VIRTEX6_FPGA\n        xv6_addsub_n #(.WIDTH(33)) \n    `endif\n        u_xx_addsub_33_acc1 (\n        .i_a    ( {1'd0, product[32:1]} ),\n        .i_b    ( {1'd0, i_a_in}        ),\n        .i_cin  ( 1'd0                  ),\n        .i_sub  ( 1'd0                  ),\n        .o_sum  ( sum_acc1              ),\n        .o_co   (                       )\n    );\n\n`else\n    assign sum =  product[67:34] + sum34_b;\n    assign sum_acc1 = {1'd0, product[32:1]} + {1'd0, i_a_in};\n`endif\n\nalways @*\n    begin\n    count_nxt           = count;\n    product_nxt         = product;\n    flags_nxt   = { product[32], product[32:1] == 32'd0 }; \n    if ( count == 6'd0 )\n        product_nxt = {33'd0, 1'd0, i_b_in, 1'd0 } ;\n    else if ( count <= 6'd33 )\n        product_nxt = { sum[33], sum, product[33:1]} ;\n    else if ( count == 6'd34 && accumulate )\n        product_nxt         = { product[64:33], sum_acc1[31:0], 1'd0}; \n    if (count == 6'd0)  \n        count_nxt   = enable ? 6'd1 : 6'd0;\n    else if ((count == 6'd34 && !accumulate) ||  \n             (count == 6'd35 &&  accumulate)  )  \n        count_nxt   = 6'd0;\n    else\n        count_nxt   = count + 1'd1;\n    end\n\nalways @ ( posedge i_clk )\n    if ( !i_core_stall )\n        begin\n        count           <= i_execute ? count_nxt          : count;           \n        product         <= i_execute ? product_nxt        : product;        \n        o_done          <= i_execute ? count == 6'd31     : o_done;          \n        end\n\nassign o_out   = product[32:1]; \nassign o_flags = flags_nxt;\n                     \nendmodule"}
{"task_id": 1057, "completion": "reg         RST;\n  reg [511:0] DIN;\n  reg         DATAEN;\n  always @(posedge CLK) RST  <= RST_IN;\n  always @(posedge CLK) DIN    <= DIN_T;\n  always @(posedge CLK) DATAEN <= (RST) ? 0 : DATAEN_IN;\n\n  wire [`WW] A15,A14,A13,A12,A11,A10,A09,A08,A07,A06,A05,A04,A03,A02,A01,A00; // output\n  wire [`WW] a15,a14,a13,a12,a11,a10,a09,a08,a07,a06,a05,a04,a03,a02,a01,a00; // input\n  assign {a15,a14,a13,a12,a11,a10,a09,a08,a07,a06,a05,a04,a03,a02,a01,a00} = DIN;\n\n  COMPARATOR comp00(a00, a01, A00, A01);\n  COMPARATOR comp01(a02, a03, A02, A03);\n  COMPARATOR comp02(a04, a05, A04, A05);\n  COMPARATOR comp03(a06, a07, A06, A07);\n  COMPARATOR comp04(a08, a09, A08, A09);\n  COMPARATOR comp05(a10, a11, A10, A11);\n  COMPARATOR comp06(a12, a13, A12, A13);\n  COMPARATOR comp07(a14, a15, A14, A15);\n\n  reg [511:0] pdA; // pipeline regester A for data\n  reg         pcA; // pipeline regester A for control\n  always @(posedge CLK) pdA <= {A15,A14,A13,A12,A11,A10,A09,A08,A07,A06,A05,A04,A03,A02,A01,A00};\n  always @(posedge CLK) pcA <= (RST) ? 0 : DATAEN;\n\n  wire [`WW] B15,B14,B13,B12,B11,B10,B09,B08,B07,B06,B05,B04,B03,B02,B01,B00; // output\n  wire [`WW] b15,b14,b13,b12,b11,b10,b09,b08,b07,b06,b05,b04,b03,b02,b01,b00; // input\n  assign {b15,b14,b13,b12,b11,b10,b09,b08,b07,b06,b05,b04,b03,b02,b01,b00} = pdA;\n  COMPARATOR comp10(b00, b02, B00, B02);\n  COMPARATOR comp11(b04, b06, B04, B06);\n  COMPARATOR comp12(b08, b10, B08, B10);\n  COMPARATOR comp13(b12, b14, B12, B14);\n  COMPARATOR comp14(b01, b03, B01, B03);\n  COMPARATOR comp15(b05, b07, B05, B07);\n  COMPARATOR comp16(b09, b11, B09, B11);\n  COMPARATOR comp17(b13, b15, B13, B15);\n\n  reg [511:0] pdB; // pipeline regester B for data\n  reg         pcB; // pipeline regester B for control\n  always @(posedge CLK) pdB <= {B15,B14,B13,B12,B11,B10,B09,B08,B07,B06,B05,B04,B03,B02,B01,B00};\n  always @(posedge CLK) pcB <= (RST) ? 0 : pcA;\n\n  wire [`WW] C15,C14,C13,C12,C11,C10,C09,C08,C07,C06,C05,C04,C03,C02,C01,C00; // output\n  wire [`WW] c15,c14,c13,c12,c11,c10,c09,c08,c07,c06,c05,c04,c03,c02,c01,c00; // input\n  assign {c15,c14,c13,c12,c11,c10,c09,c08,c07,c06,c05,c04,c03,c02,c01,c00} = pdB;\n\n  assign {C00,C03,C04,C07,C08,C11,C12,C15} = {c00,c03,c04,c07,c08,c11,c12,c15};\n  COMPARATOR comp20(c01, c02, C01, C02);\n  COMPARATOR comp21(c05, c06, C05, C06);\n  COMPARATOR comp22(c09, c10, C09, C10);\n  COMPARATOR comp23(c13, c14, C13, C14);\n\n  reg [511:0] pdC; // pipeline regester C for data\n  reg         pcC; // pipeline regester C for control\n  always @(posedge CLK) pdC <= {C15,C14,C13,C12,C11,C10,C09,C08,C07,C06,C05,C04,C03,C02,C01,C00};\n  always @(posedge CLK) pcC <= (RST) ? 0 : pcB;\n\n  wire [`WW] D15,D14,D13,D12,D11,D10,D09,D08,D07,D06,D05,D04,D03,D02,D01,D00; // output\n  wire [`WW] d15,d14,d13,d12,d11,d10,d09,d08,d07,d06,d05,d04,d03,d02,d01,d00; // input\n  assign {d15,d14,d13,d12,d11,d10,d09,d08,d07,d06,d05,d04,d03,d02,d01,d00} = pdC;\n\n  COMPARATOR comp30(d00, d04, D00,  D04);\n  COMPARATOR comp31(d08, d12, D08,  D12);\n  COMPARATOR comp32(d01, d05, D01,  D05);\n  COMPARATOR comp33(d09, d13, D09,  D13);\n  COMPARATOR comp34(d02, d06, D02,  D06);\n  COMPARATOR comp35(d10, d14, D10,  D14);\n  COMPARATOR comp36(d03, d07, D03,  D07);\n  COMPARATOR comp37(d11, d15, D11,  D15);\n\n  reg [511:0] pdD; // pipeline regester D for data\n  reg         pcD; // pipeline regester D for control\n  always @(posedge CLK) pdD <= {D15,D14,D13,D12,D11,D10,D09,D08,D07,D06,D05,D04,D03,D02,D01,D00};\n  always @(posedge CLK) pcD <= (RST) ? 0 : pcC;\n\n  wire [`WW] E15,E14,E13,E12,E11,E10,E09,E08,E07,E06,E05,E04,E03,E02,E01,E00; // output\n  wire [`WW] e15,e14,e13,e12,e11,e10,e09,e08,e07,e06,e05,e04,e03,e02,e01,e00; // input\n  assign {e15,e14,e13,e12,e11,e10,e09,e08,e07,e06,e05,e04,e03,e02,e01,e00} = pdD;\n\n  assign {E00,E01,E06,E07,E08,E09,E14,E15} = {e00,e01,e06,e07,e08,e09,e14,e15};\n  COMPARATOR comp40(e02, e04, E02, E04);\n  COMPARATOR comp41(e10, e12, E10, E12);\n  COMPARATOR comp42(e03, e05, E03, E05);\n  COMPARATOR comp43(e11, e13, E11, E13);\n\n  reg [511:0] pdE; // pipeline regester E for data\n  reg         pcE; // pipeline regester E for control\n  always @(posedge CLK) pdE <= {E15,E14,E13,E12,E11,E10,E09,E08,E07,E06,E05,E04,E03,E02,E01,E00};\n  always @(posedge CLK) pcE <= (RST) ? 0 : pcD;\n\n  wire [`WW] F15,F14,F13,F12,F11,F10,F09,F08,F07,F06,F05,F04,F03,F02,F01,F00; // output\n  wire [`WW] f15,f14,f13,f12,f11,f10,f09,f08,f07,f06,f05,f04,f03,f02,f01,f00; // input\n  assign {f15,f14,f13,f12,f11,f10,f09,f08,f07,f06,f05,f04,f03,f02,f01,f00} = pdE;\n\n  assign {F00,F07,F08,F15} = {f00,f07,f08,f15};\n  COMPARATOR comp50(f01, f02, F01, F02);\n  COMPARATOR comp51(f03, f04, F03, F04);\n  COMPARATOR comp52(f05, f06, F05, F06);\n  COMPARATOR comp53(f09, f10, F09, F10);\n  COMPARATOR comp54(f11, f12, F11, F12);\n  COMPARATOR comp55(f13, f14, F13, F14);\n  \n  reg [511:0] pdF; // pipeline regester F for data\n  reg         pcF; // pipeline regester F for control\n  always @(posedge CLK) pdF <= {F15,F14,F13,F12,F11,F10,F09,F08,F07,F06,F05,F04,F03,F02,F01,F00};\n  always @(posedge CLK) pcF <= (RST) ? 0 : pcE;\n  \n  wire [`WW] G15,G14,G13,G12,G11,G10,G09,G08,G07,G06,G05,G04,G03,G02,G01,G00; // output\n  wire [`WW] g15,g14,g13,g12,g11,g10,g09,g08,g07,g06,g05,g04,g03,g02,g01,g00; // input\n  assign {g15,g14,g13,g12,g11,g10,g09,g08,g07,g06,g05,g04,g03,g02,g01,g00} = pdF;\n\n  COMPARATOR comp60(g00, g08, G00, G08);\n  COMPARATOR comp61(g01, g09, G01, G09);\n  COMPARATOR comp62(g02, g10, G02, G10);\n  COMPARATOR comp63(g03, g11, G03, G11);\n  COMPARATOR comp64(g04, g12, G04, G12);\n  COMPARATOR comp65(g05, g13, G05, G13);\n  COMPARATOR comp66(g06, g14, G06, G14);\n  COMPARATOR comp67(g07, g15, G07, G15);\n\n  reg [511:0] pdG; // pipeline regester G for data\n  reg         pcG; // pipeline regester G for control\n  always @(posedge CLK) pdG <= {G15,G14,G13,G12,G11,G10,G09,G08,G07,G06,G05,G04,G03,G02,G01,G00};\n  always @(posedge CLK) pcG <= (RST) ? 0 : pcF;\n  \n  wire [`WW] H15,H14,H13,H12,H11,H10,H09,H08,H07,H06,H05,H04,H03,H02,H01,H00; // output\n  wire [`WW] h15,h14,h13,h12,h11,h10,h09,h08,h07,h06,h05,h04,h03,h02,h01,h00; // input\n  assign {h15,h14,h13,h12,h11,h10,h09,h08,h07,h06,h05,h04,h03,h02,h01,h00} = pdG;\n\n  assign {H00,H01,H02,H03,H12,H13,H14,H15} = {h00,h01,h02,h03,h12,h13,h14,h15};\n  COMPARATOR comp70(h04, h08, H04, H08);\n  COMPARATOR comp71(h05, h09, H05, H09);\n  COMPARATOR comp72(h06, h10, H06, H10);\n  COMPARATOR comp73(h07, h11, H07, H11);\n\n  reg [511:0] pdH; // pipeline regester H for data\n  reg         pcH; // pipeline regester H for control\n  always @(posedge CLK) pdH <= {H15,H14,H13,H12,H11,H10,H09,H08,H07,H06,H05,H04,H03,H02,H01,H00};\n  always @(posedge CLK) pcH <= (RST) ? 0 : pcG;\n  \n  // Stage I\n  ////////////////////////////////////////////////////////////////////////////////////////////////\n  wire [`WW] I15,I14,I13,I12,I11,I10,I09,I08,I07,I06,I05,I04,I03,I02,I01,I00; // output\n  wire [`WW] i15,i14,i13,i12,i11,i10,i09,i08,i07,i06,i05,i04,i03,i02,i01,i00; // input\n  assign {i15,i14,i13,i12,i11,i10,i09,i08,i07,i06,i05,i04,i03,i02,i01,i00} = pdH;\n\n  assign {I00,I01,I14,I15} = {i00,i01,i14,i15};\n  COMPARATOR comp80(i02, i04, I02, I04);\n  COMPARATOR comp81(i06, i08, I06, I08);\n  COMPARATOR comp82(i10, i12, I10, I12);\n  COMPARATOR comp83(i03, i05, I03, I05);\n  COMPARATOR comp84(i07, i09, I07, I09);\n  COMPARATOR comp85(i11, i13, I11, I13);\n\n  reg [511:0] pdI; // pipeline regester I for data\n  reg         pcI; // pipeline regester I for control\n  always @(posedge CLK) pdI <= {I15,I14,I13,I12,I11,I10,I09,I08,I07,I06,I05,I04,I03,I02,I01,I00};\n  always @(posedge CLK) pcI <= (RST) ? 0 : pcH;\n  \n  always @(posedge CLK) DOUT <= {J15,J14,J13,J12,J11,J10,J09,J08,J07,J06,J05,J04,J03,J02,J01,J00};\n  always @(posedge CLK) DATAEN_OUT <= (RST) ? 0 : pcI;\nendmodule"}
{"task_id": 1605, "completion": "reg      [2:0] conf_wr_d, conf_rd_d;\n    reg      [7:0] slow_counter;\n    reg            slow_counter_d;\n    wire           clk_enable;\n    wire           conf_wr_trigger, conf_rd_trigger;\n    reg            conf_ready;\n    reg            conf_wr_p2s;\n    wire    [13:0] conf_data;\n    reg      [4:0] conf_counter;\n    reg            conf_end;\n    reg            p2s;\n    reg            s2p_act_pre;\n    reg      [1:0] s2p_act;\n    reg     [11:0] s2p;\n    reg            sclk;\n    reg            sclk_mask;\n\n    assign clk1_set_rd = s2p[3:0];\n    assign clk2_set_rd = s2p[7:4];\n    assign clk3_set_rd = s2p[11:8];\n    assign max_sclk = sclk || (sclk_mask ? slow_counter[7] : 1'b0);\n    assign max_sdat = (s2p_act_pre || s2p_act[1]) ? 1'bz : p2s;\n    assign clk_enable = slow_counter_d && !slow_counter[7];\n    assign conf_wr_trigger = !conf_wr_d[2] && conf_wr_d[1];\n    assign conf_rd_trigger = !conf_rd_d[2] && conf_rd_d[1];\n    assign conf_data = conf_wr_p2s ? {2'b10, clk3_set_wr, clk2_set_wr, clk1_set_wr} : 14'hfff;\n\n    always @ (posedge osc_50 or negedge rstn)\n        if(!rstn)\n        begin\n            conf_wr_d <= 3'b0;\n            conf_rd_d <= 3'b0;\n        end\n        else\n        begin\n            conf_wr_d <= {conf_wr_d[1:0], conf_wr};\n            conf_rd_d <= {conf_rd_d[1:0], conf_rd};\n        end\n\n    always @ (posedge osc_50 or negedge rstn)\n        if(!rstn)\n        begin\n            slow_counter <= 8'b0;\n            slow_counter_d <= 1'b0;\n        end\n        else\n        begin\n            slow_counter <= slow_counter + 1;\n            slow_counter_d <= slow_counter[7];\n        end\n\n    always @ (posedge osc_50 or negedge rstn)\n        if(!rstn)\n            conf_ready <= 1'b1;\n        else if (conf_wr_trigger || conf_rd_trigger)\n        begin\n            conf_ready <= 1'b0;\n            conf_wr_p2s <= conf_wr_trigger;\n        end\n        else if (clk_enable && conf_end)\n            conf_ready <= 1'b1;\n\n    always @ (posedge osc_50 or negedge rstn)\n        if(!rstn)\n            conf_counter <= 5'b0;\n        else if (conf_ready)\n            conf_counter <= 5'b0;\n        else if (clk_enable)\n            conf_counter <= conf_counter + 1;\n\n    always @ (posedge osc_50 or negedge rstn)\n        if (!rstn) \n        begin \n            sclk <= 1'b1; p2s <= 1'b1; sclk_mask <= 1'b0; conf_end <= 1'b0; s2p_act_pre <= 1'b0;\n        end\n        else if (clk_enable)\n            case (conf_counter)\n                5'd1    : p2s <= 1'b0;\n                5'd2    : sclk <= 1'b0;\n                5'd3    : begin p2s <= conf_data[13]; sclk_mask <= 1'b1; end\n                5'd4    : begin p2s <= conf_data[12]; s2p_act_pre <= !conf_wr_p2s; end\n                5'd5    : p2s <= conf_data[11];\n                5'd6    : p2s <= conf_data[10];\n                5'd7    : p2s <= conf_data[9]; \n                5'd8    : p2s <= conf_data[8]; \n                5'd9    : p2s <= conf_data[7]; \n                5'd10   : p2s <= conf_data[6]; \n                5'd11   : p2s <= conf_data[5]; \n                5'd12   : p2s <= conf_data[4]; \n                5'd13   : p2s <= conf_data[3]; \n                5'd14   : p2s <= conf_data[2]; \n                5'd15   : p2s <= conf_data[1]; \n                5'd16   : begin p2s <= conf_data[0]; s2p_act_pre <= 1'b0; end \n                5'd17   : begin sclk <= 1'b0; p2s <= 1'b0; sclk_mask <= 1'b0; end \n                5'd18   : sclk <= 1'b1;\n                5'd19   : begin p2s <= 1'b1; conf_end <= 1'b1; end \n                default : begin sclk <= 1'b1; p2s <= 1'b1; sclk_mask <= 1'b0; conf_end <= 1'b0; s2p_act_pre <= 1'b0; end\n            endcase\n\n    always @ (posedge max_sclk)\n        if (s2p_act[0])\n            s2p <= {s2p[10:0], max_sdat};\n\n    always @ (posedge osc_50 or negedge rstn)\n        if (!rstn)\n            s2p_act <= 2'b0;\n        else if (clk_enable)\n            s2p_act <= {s2p_act[0], s2p_act_pre};\nendmodule"}
{"task_id": 1613, "completion": "// Check runtime\n   always @ (posedge clk) begin\n      cyc <= cyc + 1;\n      if (cyc == 0) begin\n         // Setup\n         e <= E01;\n      end\n      else if (cyc == 1) begin\n         `checks(e.name, \"E01\");\n         `checkh(e.next, ELARGE);\n         e <= ELARGE;\n      end\n      else if (cyc == 3) begin\n         `checks(e.name, \"ELARGE\");\n         `checkh(e.next, E01);\n         `checkh(e.prev, E01);\n         e <= E01;\n      end\n      //\n      else if (cyc == 10) begin\n         i_cast <= $cast(e, 60'h1234);\n      end\n      else if (cyc == 11) begin\n         `checkh(i_cast, 0);\n         i_cast <= $cast(e, 60'h1);\n      end\n      else if (cyc == 12) begin\n         `checkh(i_cast, 1);\n         i_cast <= $cast(e, 60'h1234_4567_abcd);\n      end\n      else if (cyc == 13) begin\n         `checkh(i_cast, 1);\n      end\n      //\n      else if (cyc == 20) begin\n         e <= my_t'('h11); // Unknown\n      end\n      else if (cyc == 21) begin\n         `checks(e.name, \"\"); // Unknown\n      end\n      else if (cyc == 99) begin\n         $write(\"*-* All Finished *-*\\n\");\n         $finish;\n      end\n   end\n\nendmodule"}
{"task_id": 1636, "completion": "wire clk_tmp;\n\nreg [15:0] divcounter = 0;\n\nalways @(posedge clk)\n  if (rstn == 0)\n    divcounter <= 0;\n  else if (note == 0)\n    divcounter <= 0;\n  else if (divcounter == note - 1)\n    divcounter <= 0;\n  else\n    divcounter <= divcounter + 1;\n\nassign clk_tmp = (divcounter == 0) ? 1 : 0;\n\nalways @(posedge clk)\n  if (rstn == 0)\n    clk_out <= 0;\n  else if (note == 0)\n    clk_out <= 0;\n  else if (clk_tmp == 1)\n    clk_out <= ~clk_out;\n\nendmodule"}
{"task_id": 1621, "completion": "axi_data_fifo_v2_1_16_fifo_gen #(\n     .C_FAMILY(C_FAMILY),\n     .C_COMMON_CLOCK(1),\n     .C_FIFO_DEPTH_LOG(C_FIFO_DEPTH_LOG),\n     .C_FIFO_WIDTH(C_FIFO_WIDTH),\n     .C_FIFO_TYPE(C_FIFO_TYPE))\n   inst (\n     .clk(ACLK),\n     .rst(ARESET),\n     .wr_clk(1'b0),\n     .wr_en(S_VALID),\n     .wr_ready(S_READY),\n     .wr_data(S_MESG),\n     .rd_clk(1'b0),\n     .rd_en(M_READY),\n     .rd_valid(M_VALID),\n     .rd_data(M_MESG));\n\nendmodule"}
{"task_id": 1609, "completion": "always @ (posedge clk) begin if(reset) clk_cnt<={18'b000000000000000000,1'b1}; else clk_cnt<={clk_cnt[18:0],clk_cnt[19]}; end always @ (posedge clk) begin coefs_0<=9'b111111001; coefs_1<=9'b111111011; coefs_2<=9'b000001101; coefs_3<=9'b000010000; coefs_4<=9'b111101101; coefs_5<=9'b111010110; coefs_6<=9'b000010111; coefs_7<=9'b010011010; coefs_8<=9'b011011110; coefs_9<=9'b010011010; coefs_10<=9'b000010111; coefs_11<=9'b111010110; coefs_12<=9'b111101101; coefs_13<=9'b000010000; coefs_14<=9'b000001101; coefs_15<=9'b111111011; coefs_16<=9'b111111001; end always @(posedge clk) begin if (reset) begin shift_0<=8'h00; shift_1<=8'h00; shift_2<=8'h00; shift_3<=8'h00; shift_4<=8'h00; shift_5<=8'h00; shift_6<=8'h00; shift_7<=8'h00; shift_8<=8'h00; shift_9<=8'h00; shift_10<=8'h00; shift_11<=8'h00; shift_12<=8'h00; shift_13<=8'h00; shift_14<=8'h00; shift_15<=8'h00; shift_16<=8'h00; samp_latch<=8'h00; acc<=18'o000000; pro<=17'h00000; end else begin if(clk_cnt[0]) begin samp_latch<= sample; acc<=18'h00000; end else if(clk_cnt[1]) begin pro<=samp_latch*coefs_0; acc<=18'h00000; end else if (clk_cnt[2]) begin acc<={ pro[16], pro[16], pro }; pro<=shift_15*coefs_16; shift_16<=shift_15; end else if (clk_cnt) begin acc<=acc+{ pro[16], pro[16], pro }; if (clk_cnt[3]) begin pro<=shift_14*coefs_15; shift_15<=shift_14; end else if (clk_cnt[4]) begin pro<=shift_13*coefs_14; shift_14<=shift_13; end else if (clk_cnt[5]) begin pro<=shift_12*coefs_13; shift_12<=shift_11; end else if (clk_cnt[6]) begin pro<=shift_11*coefs_12; shift_11<=shift_10; end else if (clk_cnt[7]) begin pro<=shift_10*coefs_11; shift_10<=shift_9; end else if (clk_cnt[8]) begin pro<=shift_9*coefs_10; shift_9<=shift_8; end else if (clk_cnt[9]) begin pro<=shift_8*coefs_9; shift_8<=shift_7; end else if (clk_cnt[10]) begin pro<=shift_7*coefs_8; shift_7<=shift_6; end else if (clk_cnt[11]) begin pro<=shift_6*coefs_7; shift_6<=shift_5; end else if (clk_cnt[12]) begin pro<=shift_5*coefs_6; shift_5<=shift_4; end else if (clk_cnt[13]) begin pro<=shift_4*coefs_5; shift_4<=shift_3; end else if (clk_cnt[14]) begin pro<=shift_3*coefs_4; shift_3<=shift_2; end else if (clk_cnt[15]) begin pro<=shift_2*coefs_3; shift_2<=shift_1; end else if (clk_cnt[16]) begin pro<=shift_1*coefs_2; shift_1<=shift_0; end else if (clk_cnt[17]) begin pro<=shift_0*coefs_1; shift_0<=samp_latch; end end else begin shift_0<=shift_0; shift_1<=shift_1; shift_2<=shift_2; shift_3<=shift_3; shift_4<=shift_4; shift_5<=shift_5; shift_6<=shift_6; shift_7<=shift_7; shift_8<=shift_8; shift_9<=shift_9; shift_10<=shift_10; shift_11<=shift_11; shift_12<=shift_12; shift_13<=shift_13; shift_14<=shift_14; shift_15<=shift_15; shift_16<=shift_16; samp_latch<=samp_latch; acc<=acc; pro<=pro; end end end always @ (posedge clk) begin if (reset) result<=10'h000; else begin if(clk_cnt[19]) result<=acc[18:9]; else result<=result; end end endmodule"}
{"task_id": 1627, "completion": "reg [dw-1:0] mem [(1<<aw)-1:0];\nreg [aw-1:0] addr_a_reg;\n\nassign do_a = (oe_a) ? mem[addr_a_reg] : {dw{1'b0}};\n\nalways @(posedge clk_a or posedge rst_a)\n\tif (rst_a)\n\t\taddr_a_reg <= #1 {aw{1'b0}};\n\telse if (ce_a)\n\t\taddr_a_reg <= #1 addr_a;\n\nalways @(posedge clk_b)\n\tif (ce_b && we_b)\n\t\tmem[addr_b] <= #1 di_b;\n\nendmodule"}
{"task_id": 692, "completion": "localparam\n    READ        = 2'b01,\n    WRITE       = 2'b00,\n    RMW         = 2'b10,\n    CRT         = 4'h0,\n    DE          = 4'h1,\n    DLP         = 4'h2,\n    HOST        = 4'h3,\n    TEX         = 4'h4,\n    PAL         = 4'h5,\n    MFF         = 4'h6,\n    VGA         = 4'h7,\n    ZDEV        = 4'h8,\n    TC_IDLE     = 1'b0,\n    TC_WAIT     = 1'b1,\n    DE_IDLE     = 1'b0,\n    DE_WAIT     = 1'b1,\n    INIT        = 4'h0,\n    IDLE        = 4'h1,\n    WRITE0      = 4'h2,\n    WRITE1      = 4'h3,\n    WRITE2      = 4'h4,\n    READ_IDLE   = 1'b0,\n    READ_COUNT  = 1'b1;\n  reg [3:0]         current_dev;\n  reg [1:0]         de_capt_cmd;\n  reg [5:0]         de_capt_page;\n  reg [31:0]        de_capt_addr;\n  reg [31:0]        de_capt_zaddr;\n  reg [31:0]        current_addr;\n  reg [5:0]         current_page;\n  reg [5:0]         page_count;\n  reg [7:0]         grants;\n  reg               de_cs, de_ns;\n  reg               tc_cs, tc_ns;\n  reg               pal_cs, pal_ns;\n  reg               int_data_avail;\n  reg               int_data_avail_d;\n  reg               tc_int_data_avail;\n  reg               tc_int_data_avail_d;\n  reg               pal_int_data_avail;\n  reg               pal_int_data_avail_d;\n  reg [4:0]         unload_pipe;\n  reg               unload_first, set_first;\n  reg [4:0]         pipe_first;\n  reg               unload_done;\n  reg               unload_empty;\n  reg               unload_last_int;\n  reg               push_read;\n  reg [5:0]         push_count;\n  reg [6:0]         push_countp1;\n  reg [8:0]         push_dev;\n  reg               de_gnt_d;\n  reg               unload_de_int;\n  reg               unload_z_int;\n  reg               unload_hst_int;\n  reg               unload_mff_int;\n  reg               unload_vga_int;\n  reg               hold_de_int;\n  reg               hold_z_int;\n  reg               hold_hst_int;\n  reg               hold_mff_int;\n  reg               hold_vga_int;\n  reg               pop_read;\n  reg               read_cs;\n  reg               read_ns;\n  reg [5:0]         local_count;\n  reg               load_count;\n  reg               z_pass;\n  reg               z_avail;\n  reg [4:0]         z_to_arb;\n  reg               pal_half_store;\n  wire              de_gnt_int;\n  wire [5:0]       read_count;\n  wire              read_empty;\n  wire              almost_full;\n  wire [3:0]       read_usedw;\n  wire              tc_gnt_in;\n  wire              tc_gnt_int;\n  wire              pal_gnt_int;\n  assign requests = {\n            1'b0,\n            vga_arb_req,\n            1'b0,\n            pal_int_data_avail_d,\n            tc_int_data_avail_d,\n            hst_arb_req,\n            dlp_arb_req,\n            int_data_avail_d,\n            crt_arb_req\n            } & \n            {8{~unload_done}} & ~grants & {vga_mode, {7{~vga_mode}}};\n  assign vga_gnt    = grants[7];\n  assign pal_gnt    = grants[5]; \n  assign pal_gnt_int= grants[5]; \n  assign tc_gnt_int = grants[4]; \n  assign hst_gnt    = grants[3]; \n  assign dlp_gnt    = grants[2]; \n  assign de_gnt_int = grants[1]; \n  assign crt_gnt    = grants[0];\n  always @* begin\n    if (vga_mode) unload_empty = ~|unload_pipe & ~unload_vga_int;\n    else    unload_empty = ~|unload_pipe & ~unload_de_int & ~unload_hst_int & ~hold_de_int & ~hold_hst_int & ~hold_z_int;\n    if (current_dev == MFF || current_dev == ZDEV) begin\n      mc_dat_pop      = unload_pipe[3] & local_ready;\n      local_write_req = unload_pipe[4];\n      unload_done     = unload_pipe[4];\n    end else begin\n      mc_dat_pop      = unload_pipe[0] & local_ready;\n      local_write_req = unload_pipe[1];\n      unload_done     = unload_pipe[1];\n    end\n  end \n  always @* begin\n    tc_ack            = 1'b0;\n    tc_int_data_avail = 1'b0;\n    tc_ns             = tc_cs;\n    case (tc_cs)\n      TC_IDLE: begin\n        if (tc_req) begin\n          tc_ack = 1'b1;\n          tc_ns  = TC_WAIT;\n        end else \n          tc_ns  = TC_IDLE;\n      end \n      TC_WAIT: begin\n        tc_int_data_avail = 1'b1;\n        if (tc_gnt_int) begin\n          tc_ns = TC_IDLE;\n          tc_int_data_avail = 1'b0;\n        end else\n          tc_ns = TC_WAIT;\n      end\n    endcase \n  end \n  always @* begin\n    pal_ack            = 1'b0;\n    pal_int_data_avail = 1'b0;\n    pal_ns             = pal_cs;\n    case (pal_cs)\n      TC_IDLE: begin\n        if (pal_req) begin\n          pal_ack = 1'b1;\n          pal_ns  = TC_WAIT;\n        end else \n          pal_ns  = TC_IDLE;\n      end \n      TC_WAIT: begin\n        pal_int_data_avail = 1'b1;\n        if (pal_gnt_int) begin\n          pal_ns = TC_IDLE;\n          pal_int_data_avail = 1'b0;\n        end else\n          pal_ns = TC_WAIT;\n      end\n    endcase \n  end \n  always @* begin\n    de_gnt         = 1'b0;\n    int_data_avail = 1'b0;\n    de_ns          = de_cs;\n    case (de_cs)\n      DE_IDLE: begin\n        if (de_arb_req) begin\n          de_gnt = 1'b1;\n          de_ns  = DE_WAIT;\n        end else \n          de_ns  = DE_IDLE;\n      end \n      DE_WAIT: begin\n        int_data_avail = 1'b1;\n        if (de_gnt_int) begin\n          de_ns = DE_IDLE;\n          int_data_avail = 1'b0;\n        end else\n          de_ns = DE_WAIT;\n      end\n    endcase \n  end \n  always @(posedge mclock, negedge reset_n) begin\n        if (!reset_n)      z_to_arb <= 5'h0;\n        else if(de_gnt_d) z_to_arb <= z_to_arb_in;\n    end\n  always @* begin\n    current_addr = 32'h0;\n    current_page = 6'h0;\n    case (current_dev)\n      DE, ZDEV: begin\n    if (z_pass && z_to_arb[3]) begin\n          if(z_to_arb[2:1] == 2'b00) current_cmd = WRITE;\n          else             current_cmd = RMW;\n          if (BYTES == 32) begin \n            current_addr = {de_capt_zaddr, 1'b0};\n            current_page = {2'b0, de_capt_page[4:1]};\n          end else if (BYTES == 16) begin \n            current_addr = de_capt_zaddr;\n            current_page = de_capt_page;\n          end else if (BYTES == 8) begin\n            current_addr = de_capt_zaddr>>1;\n            current_page = (line_actv_4) ? 6'b0 : {1'b0, de_capt_page,1'b1};\n          end else begin\n            current_addr = de_capt_zaddr>>2;\n            current_page = (line_actv_4) ? 6'b0 : {de_capt_page,2'b11};\n          end\n        end else begin\n          current_cmd    = de_capt_cmd;\n          if (BYTES == 32) begin \n            current_addr = {de_capt_addr, 1'b0};\n            current_page = {3'b0, de_capt_page[4:1]};\n          end else if (BYTES == 16) begin \n            current_addr = de_capt_addr;\n            current_page = de_capt_page;\n          end else if (BYTES == 8) begin\n            current_addr = de_capt_addr>>1;\n            current_page = (line_actv_4) ? 6'b0 : {1'b0, de_capt_page,1'b1};\n          end else begin\n            current_addr = de_capt_addr>>2;\n            current_page = (line_actv_4) ? 6'b0 : {de_capt_page,2'b11};\n          end\n        end\n      end\n      DLP: begin\n        current_cmd  = 2'b1;\n        current_addr = dlp_arb_addr;\n        if (BYTES == 32) begin\n          current_page = 7'h0;\n        end else if (BYTES == 16) begin\n          current_page = dlp_arb_wcnt;\n        end else if (BYTES == 8) begin\n          current_page = 7'h1;\n        end else begin\n          current_page = 7'h3;\n        end\n      end\n      HOST: begin\n        current_cmd    = hst_arb_read;\n        current_addr   = hst_arb_addr;\n        current_page   = hst_arb_page;\n      end\n      CRT: begin\n        current_cmd    = READ;\n        current_addr   = crt_arb_addr;\n        current_page   = crt_arb_page;\n      end\n      VGA: begin\n        current_cmd    = vga_arb_read ? READ : WRITE;\n        current_addr   = vga_arb_addr >> 1;\n        current_page   = 0;\n      end\n      TEX: begin\n        current_cmd    = READ;\n        current_addr   = tc_address;\n        current_page   = tc_page;\n      end\n      PAL: begin\n        current_cmd    = READ;\n        current_addr   = pal_half_store ? ((pal_address) + 32) : (pal_address);\n        current_page   = 6'h1F;\n      end\n      default: begin\n        current_cmd    = 2'b1;\n        current_addr = {dlp_arb_addr, 4'b0};\n        if (BYTES == 32) begin\n          current_page = 7'h0;\n        end else if (BYTES == 16) begin\n          current_page = 6'h0;\n        end else if (BYTES == 8) begin\n          current_page = 7'h1;\n        end else begin\n          current_page = 7'h3;\n        end\n      end\n    endcase \n    next_dev = CRT[2:0];\n    casex ({vga_mode, current_dev})\n      {1'b1, 4'bxxxx}:     next_dev = VGA[2:0];\n      {1'b0, CRT}: begin\n      case (1'b1)\n        requests[CRT]:  next_dev = CRT[2:0]; \n        requests[DLP]:  next_dev = DLP[2:0]; \n        requests[HOST]: next_dev = HOST[2:0]; \n        requests[PAL]:  next_dev = PAL[2:0]; \n        requests[TEX]:  next_dev = TEX[2:0]; \n        requests[DE]:   next_dev = DE[2:0]; \n        default:   next_dev = CRT[2:0]; \n      endcase\n      end\n      {1'b0, DLP}: begin\n      case (1'b1)\n        requests[CRT]:  next_dev = CRT[2:0]; \n        requests[HOST]: next_dev = HOST[2:0]; \n        requests[PAL]:  next_dev = PAL[2:0]; \n        requests[TEX]:  next_dev = TEX[2:0]; \n        requests[DE]:   next_dev = DE[2:0]; \n        requests[DLP]:  next_dev = DLP[2:0]; \n        default:   next_dev = CRT[2:0]; \n      endcase\n      end\n      {1'b0, HOST}: begin\n      case (1'b1)\n        requests[CRT]:  next_dev = CRT[2:0]; \n        requests[DLP]:  next_dev = DLP[2:0]; \n        requests[PAL]:  next_dev = PAL[2:0]; \n        requests[TEX]:  next_dev = TEX[2:0]; \n        requests[DE]:   next_dev = DE[2:0]; \n        requests[HOST]: next_dev = HOST[2:0]; \n        default:   next_dev = CRT[2:0]; \n      endcase\n      end\n      {1'b0, PAL}: begin\n      case (1'b1)\n        requests[CRT]:  next_dev = CRT[2:0]; \n        requests[DLP]:  next_dev = DLP[2:0]; \n        requests[HOST]: next_dev = HOST[2:0]; \n        requests[TEX]:  next_dev = TEX[2:0]; \n        requests[DE]:   next_dev = DE[2:0]; \n        requests[PAL]:  next_dev = PAL[2:0]; \n        default:   next_dev = CRT[2:0]; \n      endcase\n      end\n      {1'b0, TEX}: begin\n      case (1'b1)\n        requests[CRT]:  next_dev = CRT[2:0]; \n        requests[DLP]:  next_dev = DLP[2:0]; \n        requests[HOST]: next_dev = HOST[2:0]; \n        requests[PAL]:  next_dev = PAL[2:0]; \n        requests[DE]:   next_dev = DE[2:0]; \n        requests[TEX]:  next_dev = TEX[2:0]; \n        default:   next_dev = CRT[2:0]; \n      endcase\n      end\n      {1'b0, DE}, {1'b0, ZDEV}: begin\n      case (1'b1)\n        requests[CRT]:  next_dev = CRT[2:0]; \n        requests[DLP]:  next_dev = DLP[2:0]; \n        requests[HOST]: next_dev = HOST[2:0]; \n        requests[PAL]:  next_dev = PAL[2:0]; \n        requests[TEX]:  next_dev = TEX[2:0]; \n        requests[DE]:   next_dev = DE[2:0]; \n        default:   next_dev = CRT[2:0]; \n      endcase\n      end\n      default: begin\n      case (1'b1)\n        requests[CRT]:  next_dev = CRT[2:0]; \n        requests[DLP]:  next_dev = DLP[2:0]; \n        requests[HOST]: next_dev = HOST[2:0]; \n        requests[PAL]:  next_dev = PAL[2:0]; \n        requests[TEX]:  next_dev = TEX[2:0]; \n        requests[DE]:   next_dev = DE[2:0]; \n        default:   next_dev = CRT[2:0]; \n      endcase\n      end\n    endcase \n  end \n  assign dev_sel    = current_dev;\n  assign unload_de  = (unload_de_int  | hold_de_int)  & local_ready;\n  assign unload_z   = (unload_z_int   | hold_z_int)   & local_ready;\n  assign unload_mff = (unload_mff_int | hold_mff_int) & local_ready;\n  assign unload_hst = (unload_hst_int | hold_hst_int) & local_ready;\n  assign vga_pop    = (unload_vga_int | hold_vga_int) & local_ready;\n  always @* begin\n    load_count = 1'b0;\n    pop_read   = 1'b0;\n    case (read_cs)\n      READ_IDLE: begin\n    if (~read_empty) begin\n      pop_read    = 1'b1;\n      read_ns     = READ_COUNT;\n      load_count  = 1'b1;\n    end else\n      read_ns     = READ_IDLE;\n      end\n      READ_COUNT: begin\n          if (local_rdata_valid && (local_count == read_count)) \n              begin\n                if (~read_empty) begin\n                    pop_read    = 1'b1;\n                    read_ns     = READ_COUNT;\n                    load_count  = 1'b1;\n                end \n                else read_ns  = READ_IDLE;\n          end\n        else read_ns  = READ_COUNT;\n      end\n    endcase \n  end \n  always @(posedge mclock, negedge reset_n)\n    if (!reset_n) begin\n      pal_half_store <= 1'b0;\n    end else begin\n      if (pal_ack) pal_half_store <= pal_half;\n    end\n  always @(posedge mclock, negedge reset_n) begin\n    if (!reset_n) begin\n      hold_de_int      <= 1'b0;\n      hold_z_int      <= 1'b0;\n      hold_mff_int     <= 1'b0;\n      hold_hst_int     <= 1'b0;\n      hold_vga_int     <= 1'b0;\n    end\n    else if (local_ready) begin\n      hold_de_int      <= 1'b0;\n      hold_z_int      <= 1'b0;\n      hold_mff_int     <= 1'b0;\n      hold_hst_int     <= 1'b0;\n      hold_vga_int     <= 1'b0;\n    end\n    else begin\n      hold_de_int      <= unload_de_int  | hold_de_int;\n      hold_z_int       <= unload_z_int   | hold_z_int;\n      hold_mff_int     <= unload_mff_int | hold_mff_int;\n      hold_hst_int     <= unload_hst_int | hold_hst_int;\n      hold_vga_int     <= unload_vga_int | hold_vga_int;\n    end\n  end\n  always @(posedge mclock, negedge reset_n) begin\n    if (!reset_n) begin\n      unload_pipe      <= 5'b0;\n      pipe_first       <= 1'b0;\n    end\n    else if (local_ready) begin\n    if (current_dev == MFF || current_dev == ZDEV) begin\n          unload_pipe <= {unload_pipe[3:0], (unload_de | unload_z)};\n          pipe_first  <= {pipe_first[3:0],  unload_first};\n    end \n    else begin\n          unload_pipe <= {3'b0, unload_pipe[0], (unload_de | unload_hst | vga_pop)};\n          pipe_first  <= {3'b0, pipe_first[0],  unload_first};\n    end\n    end\n  end\n  always @(posedge mclock, negedge reset_n) begin\n    if      (~reset_n) z_avail <= 1'b0;\n    else if (push_z)   z_avail <= 1'b1;\n    else if (unload_z) z_avail <= 1'b0;\n  end\n  always @(posedge mclock, negedge reset_n) begin\n    if (!reset_n) begin\n      arb_state        <= INIT;\n      current_dev      <= CRT;\n      grants           <= 8'b0;\n      mff_ctrl_data    <= 67'b0;\n      de_cs            <= DE_IDLE;\n      tc_cs            <= TC_IDLE;\n      pal_cs           <= TC_IDLE;\n      read_cs          <= READ_IDLE;\n      int_data_avail_d <= 1'b0;\n      tc_int_data_avail_d <= 1'b0;\n      pal_int_data_avail_d <= 1'b0;\n      unload_de_int    <= 1'b0;\n      unload_z_int     <= 1'b0;\n      unload_mff_int   <= 1'b0;\n      unload_hst_int   <= 1'b0;\n      unload_vga_int   <= 1'b0;\n      local_size       <= 6'b0;\n      local_address    <= 'b0;\n      local_read_req   <= 1'b0;\n      local_burstbegin <= 1'b0;\n      page_count       <= 6'b0;\n      push_read        <= 1'b0;\n      push_count       <= 6'b0;\n      push_countp1     <= 6'b0;\n      push_dev         <= 9'b0;\n      de_gnt_d         <= 1'b0;\n      unload_first     <= 1'b0;\n      push_de          <= 1'b0;\n      push_crt         <= 1'b0;\n      push_dlp         <= 1'b0;\n      push_tex         <= 1'b0;\n      push_pal         <= 1'b0;\n      push_hst         <= 1'b0;\n      push_mff         <= 1'b0;\n      mc_busy          <= 1'b0;\n      local_count      <= 6'h0;\n      z_pass           <= 1'b1;\n      set_first        <= 1'b0;\n    end else begin\n      unload_first     <= 1'b0;\n      grants           <= 8'b0;\n      local_read_req   <= 1'b0;\n      push_read        <= 1'b0;\n      unload_hst_int   <= 1'b0;\n      unload_de_int    <= 1'b0;\n      unload_z_int     <= 1'b0;\n      unload_mff_int   <= 1'b0;\n      unload_vga_int   <= 1'b0;\n      push_de          <= read_dev[DE]   & local_rdata_valid;\n      push_crt         <= read_dev[CRT]  & local_rdata_valid;\n      push_dlp         <= read_dev[DLP]  & local_rdata_valid;\n      push_tex         <= read_dev[TEX]  & local_rdata_valid;\n      push_pal         <= read_dev[PAL]  & local_rdata_valid;\n      push_hst         <= read_dev[HOST] & local_rdata_valid;\n      push_mff         <= read_dev[MFF]  & local_rdata_valid;\n      vga_push         <= read_dev[VGA]  & local_rdata_valid;\n      push_z           <= read_dev[ZDEV] & local_rdata_valid;\n      read_cs          <= read_ns;\n      de_cs            <= de_ns;\n      tc_cs            <= tc_ns;\n      pal_cs           <= pal_ns;\n      de_gnt_d         <= de_gnt;\n      int_data_avail_d <= int_data_avail;\n      tc_int_data_avail_d <= tc_int_data_avail;\n      pal_int_data_avail_d <= pal_int_data_avail;\n      if (load_count)  local_count <= 6'h0;\n      else if (local_rdata_valid) local_count <= local_count + 6'h1;\n      if (de_gnt_d) begin\n        de_capt_cmd   <= de_arb_cmd;\n        de_capt_page  <= de_arb_page;\n        de_capt_addr  <= de_arb_addr;\n        de_capt_zaddr <= z_arb_addr;\n      end\n      if ((arb_state == IDLE) && ((current_cmd == READ) || current_cmd == RMW) && !almost_full && local_ready && (requests[current_dev])) local_burstbegin <= 1'b1;\n      else if (current_dev == MFF || current_dev == ZDEV) local_burstbegin <= pipe_first[3];\n      else                     local_burstbegin <= pipe_first[0];\n      case (arb_state)\n        INIT: if (init_done) arb_state <= IDLE;\n              else arb_state <= INIT;\n        IDLE: begin\n          mc_busy <= de_arb_req || ~empty_de;\n          if(requests[current_dev]) begin\n              mff_ctrl_data <= blend_ctrl_data;\n              if (current_dev == DE) z_data <= z_to_arb;\n              else z_data <= 5'b0;\n              local_address <= current_addr[24:0];\n              local_size    <= current_page + 1'b1;\n              page_count    <= current_page + 1'b1;\n              set_first <= 1'b1;\n              case (current_cmd)\n                WRITE: begin\n                         arb_state     <= WRITE0;\n                         if (z_to_arb[3] & z_pass & (current_dev == DE)) current_dev   <= ZDEV;\n                         else grants[current_dev] <= 1'b1;\n                       end\n                READ: begin\n                         if(!almost_full && local_ready) begin\n                             local_read_req      <= 1'b1;\n                             grants[current_dev] <= 1'b1;\n                             push_read          <= 1'b1;\n                             push_dev           <= 1'b1 << current_dev;\n                             push_count         <= current_page;\n                             push_countp1      <= current_page + 7'h1;\n                             arb_state         <= IDLE;\n                         end\n                       end\n                RMW: begin\n                         if(!almost_full && local_ready) begin\n                             local_read_req    <= 1'b1;\n                             grants[current_dev] <= ~z_to_arb[3] || ~z_pass;\n                             push_read      <= 1'b1;\n                             if (z_to_arb[3] & z_pass) begin\n                                 push_dev      <= 'h100;\n                                 current_dev   <= ZDEV;\n                             end \n                             else begin\n                                 push_dev      <= 'h40;\n                                 current_dev   <= MFF;\n                             end\n                             push_count    <= current_page;\n                             push_countp1  <= current_page + 7'h1;\n                             arb_state     <= WRITE0;\n                         end\n                       end\n                default: arb_state     <= IDLE;\n              endcase\n          end\n          else begin\n              current_dev <= next_dev;\n              arb_state   <= IDLE;\n          end\n        end\n        WRITE0: begin\n          if ((!empty_de  && (current_dev == DE)) || (!empty_de && (z_avail || (z_data[2:1] == 2'b00)) && (current_dev == ZDEV)) || ((mff_usedw == push_countp1) && (current_dev == MFF) && !mff_empty) || (current_dev == HOST) || (current_dev == VGA)) begin\n              if (local_ready) begin\n                  unload_first <= set_first;\n                  set_first    <= 1'b0;\n                  unload_de_int  <= ((current_dev == DE) || (current_dev == MFF)) & |page_count & (~z_pass | ~z_data[3]);\n                  unload_z_int  <= ((current_dev == ZDEV)) & |page_count & z_pass;\n                  unload_mff_int <= (current_dev == MFF) & |page_count;\n                  unload_hst_int <= (current_dev == HOST) & |page_count;\n                  unload_vga_int <= (current_dev == VGA) & |page_count;\n                  page_count <= page_count - |page_count;\n                  if (current_dev == MFF || current_dev == ZDEV) arb_state <= WRITE1;\n                  else if (~|page_count) arb_state <= WRITE2;\n              end else arb_state <= WRITE0;\n          end\n          else arb_state <= WRITE0;\n        end\n        WRITE1: begin\n          unload_de_int  <= ((current_dev == DE) || (current_dev == MFF)) & |page_count & (~z_pass | ~z_data[3]);\n          unload_z_int   <= (current_dev == ZDEV) & |page_count & z_pass;\n          unload_mff_int <= (current_dev == MFF) & |page_count;\n          unload_hst_int <= (current_dev == HOST) & |page_count;\n          unload_vga_int <= (current_dev == VGA) & |page_count;\n          if (local_ready) begin\n              page_count <= page_count - |page_count;\n              if (unload_pipe[3]) arb_state <= WRITE2;\n              else arb_state <= WRITE1;\n          end else arb_state <= WRITE1;\n        end\n        WRITE2: begin\n          unload_de_int  <= ((current_dev == DE) || (current_dev == MFF)) & |page_count & (~z_pass | ~z_data[3]);\n          unload_z_int   <= (current_dev == ZDEV) & |page_count & z_pass;\n          unload_mff_int <= (current_dev == MFF) & |page_count;\n          unload_hst_int <= (current_dev == HOST) & |page_count;\n          unload_vga_int <= (current_dev == VGA) & |page_count;\n          if (local_ready) begin\n              page_count <= page_count - |page_count;\n              if (unload_empty) begin\n                  if ((z_data[3]) & (current_dev != HOST)) z_pass <= ~z_pass;\n                  arb_state <= IDLE;\n                  current_dev <= next_dev;\n              end\n              else arb_state <= WRITE2;\n          end else arb_state <= WRITE2;\n        end\n      endcase \n  end\n  sfifo_15x16 u_read\n    (\n     .data         ({push_dev, push_count}),\n     .wrreq        (push_read),\n     .rdreq        (pop_read),\n     .clock        (mclock),\n     .aclr         (~reset_n),\n     .q            ({read_dev, read_count}),\n     .full         (),\n     .empty        (read_empty),\n     .usedw        (read_usedw),\n     .almost_full  (almost_full)\n     );\n     `ifdef RTL_SIM\n    always @(posedge mclock) begin\n            if(!local_write_req && !local_read_req && local_burstbegin) begin\n                $display(\"BURST BEGIN ERROR\");\n                #10000 $stop;\n            end\n        end\n    `endif\nendmodule"}
{"task_id": 1624, "completion": "SB_PLL40_2_PAD #(\n                .FEEDBACK_PATH(\"DELAY\"),\n                .DELAY_ADJUSTMENT_MODE_FEEDBACK(\"FIXED\"),\n                .DELAY_ADJUSTMENT_MODE_RELATIVE(\"FIXED\"),\n                .PLLOUT_SELECT_PORTB(\"GENCLK\"),\n                .SHIFTREG_DIV_MODE(1'b0),\n                .FDA_FEEDBACK(4'b1111),\n                .FDA_RELATIVE(4'b1111),\n                .DIVR(4'b0000),\n                .DIVF(7'b0000000),\n                .DIVQ(3'b001),\n                .FILTER_RANGE(3'b000),\n                .ENABLE_ICEGATE_PORTA(1'b0),\n                .ENABLE_ICEGATE_PORTB(1'b0),\n                .TEST_MODE(1'b0)\n        ) uut (\n                .PACKAGEPIN     (PACKAGEPIN     ),\n                .PLLOUTCOREA    (PLLOUTCORE  [0]),\n                .PLLOUTGLOBALA  (PLLOUTGLOBAL[0]),\n                .PLLOUTCOREB    (PLLOUTCORE  [1]),\n                .PLLOUTGLOBALB  (PLLOUTGLOBAL[1]),\n                .EXTFEEDBACK    (EXTFEEDBACK    ),\n                .DYNAMICDELAY   (DYNAMICDELAY   ),\n                .LOCK           (LOCK           ),\n                .BYPASS         (BYPASS         ),\n                .RESETB         (RESETB         ),\n                .LATCHINPUTVALUE(LATCHINPUTVALUE),\n                .SDO            (SDO            ),\n                .SDI            (SDI            ),\n                .SCLK           (SCLK           )\n        );\nendmodule"}
{"task_id": 1637, "completion": "input why;\n   input nnnot;\n   \n   autoinst_wildcard_sub sub0\n     (\n      .sd_ras_                          (foobar_ras_),\n      .sd0_dqm7_l                       (sd0_dqm7_l),\n      .sd0_dqm6_l                       (sd0_dqm6_l),\n      .sd0_dqm5_l                       (sd0_dqm5_l),\n      .sd0_dqm4_l                       (sd0_dqm4_l),\n      .sd0_dqm3_l                       (sd0_dqm3_l),\n      .sd0_dqm2_l                       (sd0_dqm2_l),\n      .sd0_dqm1_l                       (sd0_dqm1_l),\n      .sd0_dqm0_l                       (sd0_dqm0_l),\n      .sd0_ba1                          (sd0_ba1),\n      .sd0_ba0                          (sd0_ba0),\n      .sd0_adrs11                       (sd0_adrs11),\n      .sd0_adrs10                       (sd0_adrs10),\n      .sd0_adrs9                        (sd0_adrs9),\n      .sd0_adrs8                        (sd0_adrs8),\n      .sd0_adrs7                        (sd0_adrs7),\n      .sd0_adrs6                        (sd0_adrs6),\n      .sd0_adrs5                        (sd0_adrs5),\n      .sd0_adrs4                        (sd0_adrs4),\n      .sd0_adrs3                        (sd0_adrs3),\n      .sd0_adrs2                        (sd0_adrs2),\n      .sd0_adrs1                        (sd0_adrs1),\n      .sd0_adrs0                        (sd0_adrs0),\n      .sd0_clk                          (sd0_clk));\n   \nendmodule"}
{"task_id": 1639, "completion": "parameter DW = 31;\nparameter DATA_DEPTH = 128;\nparameter AW = 6;\nscfifo Sync_FIFO (\n\t.clock(clk),\n\t.sclr(reset),\n\t.data(write_data),\n\t.wrreq(write_en),\n\t.rdreq(read_en),\n\t.empty(fifo_is_empty),\n\t.full(fifo_is_full),\n\t.usedw(words_used),\n\t.q(read_data),\n\t.aclr(),\n\t.almost_empty(),\n\t.almost_full()\n);\ndefparam\n\tSync_FIFO.add_ram_output_register = \"OFF\",\n\tSync_FIFO.intended_device_family = \"Cyclone II\",\n\tSync_FIFO.lpm_numwords = DATA_DEPTH,\n\tSync_FIFO.lpm_showahead = \"ON\",\n\tSync_FIFO.lpm_type = \"scfifo\",\n\tSync_FIFO.lpm_width = DW + 1,\n\tSync_FIFO.lpm_widthu = AW + 1,\n\tSync_FIFO.overflow_checking = \"OFF\",\n\tSync_FIFO.underflow_checking = \"OFF\",\n\tSync_FIFO.use_eab = \"ON\";\nendmodule"}
{"task_id": 1604, "completion": "generate\n\t\tif (MODE == \"LOGIC\") begin\n\t\t\tL6MUX21 FXMUX (.D0(FXA), .D1(FXB), .SD(M1), .Z(OFX1));\n\n\t\t\twire k0;\n\t\t\twire k1;\n\t\t\tPFUMX K0K1MUX (.ALUT(k1), .BLUT(k0), .C0(M0), .Z(OFX0));\n\n\t\t\tLUT4 #(.INIT(LUT0_INITVAL)) LUT_0 (.A(A0), .B(B0), .C(C0), .D(D0), .Z(k0));\n\t\t\tLUT4 #(.INIT(LUT1_INITVAL)) LUT_1 (.A(A0), .B(B0), .C(C0), .D(D0), .Z(k1));\n\n\t\t\tassign F0 = k0;\n\t\t\tassign F1 = k1;\n\t\tend else if (MODE == \"CCU2\") begin\n\t\t\tERROR_UNSUPPORTED_SLICE_MODE error();\n\t\tend else if (MODE == \"DPRAM\") begin\n\t\t\tERROR_UNSUPPORTED_SLICE_MODE error();\n\t\tend else begin\n\t\t\tERROR_UNKNOWN_SLICE_MODE error();\n\t\tend\n\tendgenerate\n\n\twire di0 = (REG0_SD == \"1\") ? DI0 : M0;\n\twire di1 = (REG1_SD == \"1\") ? DI1 : M1;\n\n\tFACADE_FF#(.GSR(GSR), .CEMUX(CEMUX), .CLKMUX(CLKMUX), .LSRMUX(LSRMUX),\n\t\t.LSRONMUX(LSRONMUX), .SRMODE(SRMODE), .REGSET(REG0_REGSET),\n\t\t.REGMODE(REGMODE)) REG_0 (.CLK(CLK), .DI(di0), .LSR(LSR), .CE(CE), .Q(Q0));\n\tFACADE_FF#(.GSR(GSR), .CEMUX(CEMUX), .CLKMUX(CLKMUX), .LSRMUX(LSRMUX),\n\t\t.LSRONMUX(LSRONMUX), .SRMODE(SRMODE), .REGSET(REG1_REGSET),\n\t\t.REGMODE(REGMODE)) REG_1 (.CLK(CLK), .DI(di1), .LSR(LSR), .CE(CE), .Q(Q1));\nendmodule"}
{"task_id": 1611, "completion": "wire \\<const0> ;\n    wire [20:3]\\^rgb_888 ;\n\n    assign rgb_888[23:21] = \\^rgb_888 [18:16];\n    assign rgb_888[20:16] = \\^rgb_888 [20:16];\n    assign rgb_888[15:14] = \\^rgb_888 [9:8];\n    assign rgb_888[13:3] = \\^rgb_888 [13:3];\n    assign rgb_888[2] = \\<const0> ;\n    assign rgb_888[1] = \\<const0> ;\n    assign rgb_888[0] = \\<const0> ;\n    GND GND\n         (.G(\\<const0> ));\n    system_rgb565_to_rgb888_0_0_rgb565_to_rgb888 U0\n         (.clk(clk),\n          .rgb_565(rgb_565),\n          .rgb_888({\\^rgb_888 [18:16],\\^rgb_888 [20:19],\\^rgb_888 [9:8],\\^rgb_888 [13:10],\\^rgb_888 [7:3]}));\nendmodule\n\n(* ORIG_REF_NAME = \"rgb565_to_rgb888\" *) \nmodule system_rgb565_to_rgb888_0_0_rgb565_to_rgb888\n   (rgb_888,\n    rgb_565,\n    clk);\n  output [15:0]rgb_888;\n  input [15:0]rgb_565;\n  input clk;\n\n  wire clk;\n  wire [15:0]rgb_565;\n  wire [15:0]rgb_888;\n\n  FDRE \\rgb_888_reg[10] \n       (.C(clk),\n        .CE(1'b1),\n        .D(rgb_565[5]),\n        .Q(rgb_888[5]),\n        .R(1'b0));\n  FDRE \\rgb_888_reg[11] \n       (.C(clk),\n        .CE(1'b1),\n        .D(rgb_565[6]),\n        .Q(rgb_888[6]),\n        .R(1'b0));\n  FDRE \\rgb_888_reg[12] \n       (.C(clk),\n        .CE(1'b1),\n        .D(rgb_565[7]),\n        .Q(rgb_888[7]),\n        .R(1'b0));\n  FDRE \\rgb_888_reg[13] \n       (.C(clk),\n        .CE(1'b1),\n        .D(rgb_565[8]),\n        .Q(rgb_888[8]),\n        .R(1'b0));\n  FDRE \\rgb_888_reg[14] \n       (.C(clk),\n        .CE(1'b1),\n        .D(rgb_565[9]),\n        .Q(rgb_888[9]),\n        .R(1'b0));\n  FDRE \\rgb_888_reg[15] \n       (.C(clk),\n        .CE(1'b1),\n        .D(rgb_565[10]),\n        .Q(rgb_888[10]),\n        .R(1'b0));\n  FDRE \\rgb_888_reg[19] \n       (.C(clk),\n        .CE(1'b1),\n        .D(rgb_565[11]),\n        .Q(rgb_888[11]),\n        .R(1'b0));\n  FDRE \\rgb_888_reg[20] \n       (.C(clk),\n        .CE(1'b1),\n        .D(rgb_565[12]),\n        .Q(rgb_888[12]),\n        .R(1'b0));\n  FDRE \\rgb_888_reg[21] \n       (.C(clk),\n        .CE(1'b1),\n        .D(rgb_565[13]),\n        .Q(rgb_888[13]),\n        .R(1'b0));\n  FDRE \\rgb_888_reg[22] \n       (.C(clk),\n        .CE(1'b1),\n        .D(rgb_565[14]),\n        .Q(rgb_888[14]),\n        .R(1'b0));\n  FDRE \\rgb_888_reg[23] \n       (.C(clk),\n        .CE(1'b1),\n        .D(rgb_565[15]),\n        .Q(rgb_888[15]),\n        .R(1'b0));\n  FDRE \\rgb_888_reg[3] \n       (.C(clk),\n        .CE(1'b1),\n        .D(rgb_565[0]),\n        .Q(rgb_888[0]),\n        .R(1'b0));\n  FDRE \\rgb_888_reg[4] \n       (.C(clk),\n        .CE(1'b1),\n        .D(rgb_565[1]),\n        .Q(rgb_888[1]),\n        .R(1'b0));\n  FDRE \\rgb_888_reg[5] \n       (.C(clk),\n        .CE(1'b1),\n        .D(rgb_565[2]),\n        .Q(rgb_888[2]),\n        .R(1'b0));\n  FDRE \\rgb_888_reg[6] \n       (.C(clk),\n        .CE(1'b1),\n        .D(rgb_565[3]),\n        .Q(rgb_888[3]),\n        .R(1'b0));\n  FDRE \\rgb_888_reg[7] \n       (.C(clk),\n        .CE(1'b1),\n        .D(rgb_565[4]),\n        .Q(rgb_888[4]),\n        .R(1'b0));\nendmodule"}
{"task_id": 1633, "completion": "`ifdef OR1200_NO_DC\nassign dataout = {dw{1'b0}};\n`ifdef OR1200_BIST\nassign mbist_so_o = mbist_si_i;\n`endif\n`else\n`ifdef OR1200_DC_1W_4KB\nor1200_spram_1024x32_bw dc_ram(\n`endif\n`ifdef OR1200_DC_1W_8KB\nor1200_spram_2048x32_bw dc_ram(\n`endif\n`ifdef OR1200_BIST\n\t.mbist_si_i(mbist_si_i),\n\t.mbist_so_o(mbist_so_o),\n\t.mbist_ctrl_i(mbist_ctrl_i),\n`endif\n\t.clk(clk),\n\t.rst(rst),\n\t.ce(en),\n\t.we(we),\n\t.oe(1'b1),\n\t.addr(addr),\n\t.di(datain),\n\t.doq(dataout)\n);\n`endif\nendmodule"}
{"task_id": 1400, "completion": "`include \"c_functions.v\"\n   `include \"c_constants.v\"\n   `include \"vcr_constants.v\"\n   parameter num_message_classes = 2;\n   parameter num_resource_classes = 2;\n   localparam num_packet_classes = num_message_classes * num_resource_classes;\n   parameter num_vcs_per_class = 1;\n   localparam num_vcs = num_packet_classes * num_vcs_per_class;\n   parameter num_ports = 5;\n   localparam port_idx_width = clogb(num_ports);\n   parameter wf_alloc_type = `WF_ALLOC_TYPE_REP;\n   parameter reset_type = `RESET_TYPE_ASYNC;\n   input clk;\n   input reset;\n   input [0:num_ports*num_vcs*port_idx_width-1] route_port_ip_ivc;\n   input [0:num_ports*num_vcs-1] inc_rc_ip_ivc;\n   input [0:num_ports*num_vcs-1] elig_op_ovc;\n   input [0:num_ports*num_vcs-1] req_ip_ivc;\n   output [0:num_ports*num_vcs-1] gnt_ip_ivc;\n   wire [0:num_ports*num_vcs-1] gnt_ip_ivc;\n   output [0:num_ports*num_vcs*num_vcs-1] gnt_ip_ivc_ovc;\n   wire [0:num_ports*num_vcs*num_vcs-1] gnt_ip_ivc_ovc;\n   output [0:num_ports*num_vcs-1] gnt_op_ovc;\n   wire [0:num_ports*num_vcs-1] gnt_op_ovc;\n   output [0:num_ports*num_vcs*num_ports-1] gnt_op_ovc_ip;\n   wire [0:num_ports*num_vcs*num_ports-1] gnt_op_ovc_ip;\n   output [0:num_ports*num_vcs*num_vcs-1] gnt_op_ovc_ivc;\n   wire [0:num_ports*num_vcs*num_vcs-1] gnt_op_ovc_ivc;\n   generate\n      genvar mc;\n      for(mc = 0; mc < num_message_classes; mc = mc + 1)\n      begin:mcs\n         wire [0:num_ports*num_resource_classes*num_vcs_per_class-1] req_ip_irc_icvc;\n         wire update_alloc;\n         assign update_alloc = |req_ip_irc_icvc;\n         wire [0:num_ports*num_resource_classes*num_vcs_per_class*num_ports*num_resource_classes*num_vcs_per_class-1] req_wf_ip_irc_icvc_op_orc_ocvc;\n         wire [0:num_ports*num_resource_classes*num_vcs_per_class*num_ports*num_resource_classes*num_vcs_per_class-1] gnt_wf_ip_irc_icvc_op_orc_ocvc;\n         c_wf_alloc #(.num_ports(num_ports*num_resource_classes*num_vcs_per_class), .wf_alloc_type(wf_alloc_type), .reset_type(reset_type)) gnt_wf_ip_irc_icvc_op_orc_ocvc_alloc (.clk(clk), .reset(reset), .update(update_alloc), .req(req_wf_ip_irc_icvc_op_orc_ocvc), .gnt(gnt_wf_ip_irc_icvc_op_orc_ocvc));\n         genvar ip;\n         for(ip = 0; ip < num_ports; ip = ip + 1)\n         begin:ips\n            assign req_ip_irc_icvc[ip*num_resource_classes*num_vcs_per_class:(ip+1)*num_resource_classes*num_vcs_per_class-1] = req_ip_ivc[(ip*num_message_classes+mc)*num_resource_classes*num_vcs_per_class:(ip*num_message_classes+mc+1)*num_resource_classes*num_vcs_per_class-1];\n            wire [0:num_resource_classes*num_vcs_per_class*num_ports*num_resource_classes*num_vcs_per_class-1] gnt_wf_irc_icvc_op_orc_ocvc;\n            assign gnt_wf_irc_icvc_op_orc_ocvc = gnt_wf_ip_irc_icvc_op_orc_ocvc[ip*num_resource_classes*num_vcs_per_class*num_ports*num_resource_classes*num_vcs_per_class:(ip+1)*num_resource_classes*num_vcs_per_class*num_ports*num_resource_classes*num_vcs_per_class-1];\n            genvar irc;\n            for(irc = 0; irc < num_resource_classes; irc = irc + 1)\n            begin:ircs\n               wire [0:num_vcs_per_class*num_ports*num_resource_classes*num_vcs_per_class-1] gnt_wf_icvc_op_orc_ocvc;\n               assign gnt_wf_icvc_op_orc_ocvc = gnt_wf_irc_icvc_op_orc_ocvc[irc*num_vcs_per_class*num_ports*num_resource_classes*num_vcs_per_class:(irc+1)*num_vcs_per_class*num_ports*num_resource_classes*num_vcs_per_class-1];\n               wire [0:num_vcs_per_class*num_ports*num_resource_classes*num_vcs_per_class-1] req_wf_icvc_op_orc_ocvc;\n               genvar icvc;\n               for(icvc = 0; icvc < num_vcs_per_class; icvc = icvc + 1)\n               begin:icvcs\n                  wire req;\n                  assign req = req_ip_ivc[ip*num_vcs+(mc*num_resource_classes+irc)*num_vcs_per_class+icvc];\n                  wire [0:port_idx_width-1] route_port;\n                  assign route_port = route_port_ip_ivc[(ip*num_vcs+(mc*num_resource_classes+irc)*num_vcs_per_class+icvc)*port_idx_width:(ip*num_vcs+(mc*num_resource_classes+irc)*num_vcs_per_class+icvc+1)*port_idx_width-1];\n                  wire inc_rc;\n                  assign inc_rc = inc_rc_ip_ivc[ip*num_vcs+(mc*num_resource_classes+irc)*num_vcs_per_class+icvc];\n                  wire [0:num_ports*num_resource_classes*num_vcs_per_class-1] req_wf_op_orc_ocvc;\n                  genvar op;\n                  for(op = 0; op < num_ports; op = op + 1)\n                  begin:ops\n                     wire route;\n                     assign route = (route_port == op);\n                     wire [0:num_resource_classes*num_vcs_per_class-1] req_wf_orc_ocvc;\n                     genvar orc;\n                     for(orc = 0; orc < num_resource_classes; orc = orc + 1)\n                     begin:orcs\n                        wire class_match;\n                        if((orc == irc) && (irc == (num_resource_classes - 1))) assign class_match = 1'b1;\n                        else if(orc == irc) assign class_match = ~inc_rc;\n                        else if(orc == (irc + 1)) assign class_match = inc_rc;\n                        else assign class_match = 1'b0;\n                        wire [0:num_vcs_per_class-1] elig_ocvc;\n                        assign elig_ocvc = elig_op_ovc[((op*num_message_classes+mc)*num_resource_classes+orc)*num_vcs_per_class:((op*num_message_classes+mc)*num_resource_classes+orc+1)*num_vcs_per_class-1];\n                        wire [0:num_vcs_per_class-1] req_wf_ocvc;\n                        assign req_wf_ocvc = {num_vcs_per_class{(req & route & class_match)}} & elig_ocvc;\n                        assign req_wf_orc_ocvc[orc*num_vcs_per_class:(orc+1)*num_vcs_per_class-1] = req_wf_ocvc;\n                     end\n                     assign req_wf_op_orc_ocvc[op*num_resource_classes*num_vcs_per_class:(op+1)*num_resource_classes*num_vcs_per_class-1] = req_wf_orc_ocvc;\n                  end\n                  assign req_wf_icvc_op_orc_ocvc[icvc*num_ports*num_resource_classes*num_vcs_per_class:(icvc+1)*num_ports*num_resource_classes*num_vcs_per_class-1] = req_wf_op_orc_ocvc;\n                  wire [0:num_ports*num_resource_classes*num_vcs_per_class-1] gnt_wf_op_orc_ocvc;\n                  assign gnt_wf_op_orc_ocvc = gnt_wf_icvc_op_orc_ocvc[icvc*num_ports*num_resource_classes*num_vcs_per_class:(icvc+1)*num_ports*num_resource_classes*num_vcs_per_class-1];\n                  wire [0:num_resource_classes*num_vcs_per_class-1] gnt_orc_ocvc;\n                  c_or_nto1 #(.num_ports(num_ports), .width(num_resource_classes*num_vcs_per_class)) gnt_orc_ocvc_or (.data_in(gnt_wf_op_orc_ocvc), .data_out(gnt_orc_ocvc));\n                  wire [0:num_vcs-1] gnt_ovc;\n                  c_align #(.data_width(num_resource_classes*num_vcs_per_class), .dest_width(num_vcs), .offset(mc*num_resource_classes*num_vcs_per_class)) gnt_ovc_alg (.data_in(gnt_orc_ocvc), .dest_in({num_vcs{1'b0}}), .data_out(gnt_ovc));\n                  assign gnt_ip_ivc_ovc[(ip*num_vcs+(mc*num_resource_classes+irc)*num_vcs_per_class+icvc)*num_vcs:(ip*num_vcs+(mc*num_resource_classes+irc)*num_vcs_per_class+icvc+1)*num_vcs-1] = gnt_ovc;\n                  if(irc == (num_resource_classes - 1)) assign gnt_ip_ivc[ip*num_vcs+(mc*num_resource_classes+irc)*num_vcs_per_class+icvc] = |gnt_orc_ocvc[irc*num_vcs_per_class:(irc+1)*num_vcs_per_class-1];\n                  else assign gnt_ip_ivc[ip*num_vcs+(mc*num_resource_classes+irc)*num_vcs_per_class+icvc] = |gnt_orc_ocvc[irc*num_vcs_per_class:(irc+2)*num_vcs_per_class-1];\n               end\n               assign req_wf_irc_icvc_op_orc_ocvc[irc*num_vcs_per_class*num_ports*num_resource_classes*num_vcs_per_class:(irc+1)*num_vcs_per_class*num_ports*num_resource_classes*num_vcs_per_class-1] = req_wf_icvc_op_orc_ocvc;\n            end\n            assign req_wf_ip_irc_icvc_op_orc_ocvc[ip*num_resource_classes*num_vcs_per_class*num_ports*num_resource_classes*num_vcs_per_class:(ip+1)*num_resource_classes*num_vcs_per_class*num_ports*num_resource_classes*num_vcs_per_class-1] = req_wf_irc_icvc_op_orc_ocvc;\n         end\n         wire [0:num_ports*num_resource_classes*num_vcs_per_class*num_ports*num_resource_classes*num_vcs_per_class-1] gnt_wf_op_orc_ocvc_ip_irc_icvc;\n         c_interleaver #(.width(num_ports*num_resource_classes*num_vcs_per_class*num_ports*num_resource_classes*num_vcs_per_class), .num_blocks(num_ports*num_resource_classes*num_vcs_per_class)) gnt_wf_op_orc_ocvc_ip_irc_icvc_intl (.data_in(gnt_wf_ip_irc_icvc_op_orc_ocvc), .data_out(gnt_wf_op_orc_ocvc_ip_irc_icvc));\n         wire [0:num_ports*num_resource_classes*num_vcs_per_class-1] gnt_op_orc_ocvc;\n         genvar op;\n         for(op = 0; op < num_ports; op = op + 1)\n         begin:ops\n            wire [0:num_resource_classes*num_vcs_per_class*num_ports*num_resource_classes*num_vcs_per_class-1] gnt_wf_orc_ocvc_ip_irc_icvc;\n            assign gnt_wf_orc_ocvc_ip_irc_icvc = gnt_wf_op_orc_ocvc_ip_irc_icvc[op*num_resource_classes*num_vcs_per_class*num_ports*num_resource_classes*num_vcs_per_class:(op+1)*num_resource_classes*num_vcs_per_class*num_ports*num_resource_classes*num_vcs_per_class-1];\n            wire [0:num_resource_classes*num_vcs_per_class*num_ports-1] gnt_orc_ocvc_ip;\n            wire [0:num_resource_classes*num_vcs_per_class*num_vcs-1] gnt_orc_ocvc_ivc;\n            genvar orc;\n            for(orc = 0; orc < num_resource_classes; orc = orc + 1)\n            begin:orcs\n               wire [0:num_vcs_per_class*num_ports*num_resource_classes*num_vcs_per_class-1] gnt_wf_ocvc_ip_irc_icvc;\n               assign gnt_wf_ocvc_ip_irc_icvc = gnt_wf_orc_ocvc_ip_irc_icvc[orc*num_vcs_per_class*num_ports*num_resource_classes*num_vcs_per_class:(orc+1)*num_vcs_per_class*num_ports*num_resource_classes*num_vcs_per_class-1];\n               wire [0:num_vcs_per_class*num_ports-1] gnt_ocvc_ip;\n               wire [0:num_vcs_per_class*num_vcs-1] gnt_ocvc_ivc;\n               genvar ocvc;\n               for(ocvc = 0; ocvc < num_vcs_per_class; ocvc = ocvc + 1)\n               begin:ocvcs\n                  wire [0:num_ports*num_resource_classes*num_vcs_per_class-1] gnt_wf_ip_irc_icvc;\n                  assign gnt_wf_ip_irc_icvc = gnt_wf_ocvc_ip_irc_icvc[ocvc*num_ports*num_resource_classes*num_vcs_per_class:(ocvc+1)*num_ports*num_resource_classes*num_vcs_per_class-1];\n                  wire [0:num_ports-1] gnt_wf_ip;\n                  genvar ip;\n                  for(ip = 0; ip < num_ports; ip = ip + 1)\n                  begin:ips\n                     wire [0:num_resource_classes*num_vcs_per_class-1] gnt_wf_irc_icvc;\n                     assign gnt_wf_irc_icvc = gnt_wf_ip_irc_icvc[ip*num_resource_classes*num_vcs_per_class:(ip+1)*num_resource_classes*num_vcs_per_class-1];\n                     if(orc == 0) assign gnt_wf_ip[ip] = |gnt_wf_irc_icvc[orc*num_vcs_per_class:(orc+1)*num_vcs_per_class-1];\n                     else assign gnt_wf_ip[ip] = |gnt_wf_irc_icvc[(orc-1)*num_vcs_per_class:(orc+1)*num_vcs_per_class-1];\n                  end\n                  assign gnt_op_ovc_ip[(op*num_vcs+(mc*num_resource_classes+orc)*num_vcs_per_class+ocvc)*num_ports:(op*num_vcs+(mc*num_resource_classes+orc)*num_vcs_per_class+ocvc+1)*num_ports-1] = gnt_wf_ip;\n                  wire [0:num_resource_classes*num_vcs_per_class-1] gnt_wf_irc_icvc;\n                  c_or_nto1 #(.num_ports(num_ports), .width(num_resource_classes*num_vcs_per_class)) gnt_wf_irc_icvc_or (.data_in(gnt_wf_ip_irc_icvc), .data_out(gnt_wf_irc_icvc));\n                  assign gnt_op_ovc[op*num_vcs+(mc*num_resource_classes+orc)*num_vcs_per_class+ocvc] = |gnt_wf_irc_icvc;\n                  wire [0:num_vcs-1] gnt_wf_ivc;\n                  c_align #(.data_width(num_resource_classes*num_vcs_per_class), .dest_width(num_vcs), .offset(mc*num_resource_classes*num_vcs_per_class)) gnt_wf_ivc_alg (.data_in(gnt_wf_irc_icvc), .dest_in({num_vcs{1'b0}}), .data_out(gnt_wf_ivc));\n                  assign gnt_op_ovc_ivc[(op*num_vcs+(mc*num_resource_classes+orc)*num_vcs_per_class+ocvc)*num_vcs:(op*num_vcs+(mc*num_resource_classes+orc)*num_vcs_per_class+ocvc+1)*num_vcs-1] = gnt_wf_ivc;\n               end\n            end\n         end\n      end\n   endgenerate\nendmodule"}
{"task_id": 1414, "completion": "wire    `control_w  c01, c10, c12, c21, c23, c32, c03, c30,\n                        c45, c54, c56, c65, c67, c76, c47, c74,\n                        c89, c98, c9a, ca9, cab, cba, cb8, c8b,\n                        ccd, cdc, ced, cde, cef, cfe, ccf, cfc,\n                        c04, c40, c48, c84, c8c, cc8, c0c, cc0,\n                        c15, c51, c59, c95, c9d, cd9, c1d, cd1,\n                        c26, c62, c6a, ca6, cae, cea, ce2, c2e,\n                        c37, c73, c7b, cb7, cbf, cfb, cf3, c3f;\n\n    wire    `data_w     d01, d10, d12, d21, d23, d32, d03, d30,\n                        d45, d54, d56, d65, d67, d76, d47, d74,\n                        d89, d98, d9a, da9, dab, dba, db8, d8b,\n                        dcd, ddc, ded, dde, def, dfe, dcf, dfc,\n                        d04, d40, d48, d84, d8c, dc8, d0c, dc0,\n                        d15, d51, d59, d95, d9d, dd9, d1d, dd1,\n                        d26, d62, d6a, da6, dae, dea, de2, d2e,\n                        d37, d73, d7b, db7, dbf, dfb, df3, d3f;\n\n    brouter #(4'b0000) br0000\n                   (.port0_ci(c30),\n                    .port0_di(d30),\n                    .port0_co(c03),\n                    .port0_do(d03),\n                    .port1_ci(c10),\n                    .port1_di(d10),\n                    .port1_co(c01),\n                    .port1_do(d01),\n                    .port2_ci(c40),\n                    .port2_di(d40),\n                    .port2_co(c04),\n                    .port2_do(d04),\n                    .port3_ci(cc0),\n                    .port3_di(dc0),\n                    .port3_co(c0c),\n                    .port3_do(d0c),\n                    .port4_ci(b0000_ci),\n                    .port4_di(b0000_di),\n                    .port4_co(b0000_co),\n                    .port4_do(b0000_do),\n                    .port4_ready(b0000_r),\n                    .clk(clk),\n                    .rst(rst));\n    brouter #(4'b0001) br0001\n                   (.port0_ci(c01),\n                    .port0_di(d01),\n                    .port0_co(c10),\n                    .port0_do(d10),\n                    .port1_ci(c21),\n                    .port1_di(d21),\n                    .port1_co(c12),\n                    .port1_do(d12),\n                    .port2_ci(c51),\n                    .port2_di(d51),\n                    .port2_co(c15),\n                    .port2_do(d15),\n                    .port3_ci(cd1),\n                    .port3_di(dd1),\n                    .port3_co(c1d),\n                    .port3_do(d1d),\n                    .port4_ci(b0001_ci),\n                    .port4_di(b0001_di),\n                    .port4_co(b0001_co),\n                    .port4_do(b0001_do),\n                    .port4_ready(b0001_r),\n                    .clk(clk),\n                    .rst(rst));\n    brouter #(4'b0010) br0010 \n                   (.port0_ci(c12),\n                    .port0_di(d12),\n                    .port0_co(c21),\n                    .port0_do(d21),\n                    .port1_ci(c32),\n                    .port1_di(d32),\n                    .port1_co(c23),\n                    .port1_do(d23),\n                    .port2_ci(c62),\n                    .port2_di(d62),\n                    .port2_co(c26),\n                    .port2_do(d26),\n                    .port3_ci(ce2),\n                    .port3_di(de2),\n                    .port3_co(c2e),\n                    .port3_do(d2e),\n                    .port4_ci(b0010_ci),\n                    .port4_di(b0010_di),\n                    .port4_co(b0010_co),\n                    .port4_do(b0010_do),\n                    .port4_ready(b0010_r),\n                    .clk(clk),\n                    .rst(rst));\n    brouter #(4'b0011) br0011\n                   (.port0_ci(c23),\n                    .port0_di(d23),\n                    .port0_co(c32),\n                    .port0_do(d32),\n                    .port1_ci(c03),\n                    .port1_di(d03),\n                    .port1_co(c30),\n                    .port1_do(d30),\n                    .port2_ci(c73),\n                    .port2_di(d73),\n                    .port2_co(c37),\n                    .port2_do(d37),\n                    .port3_ci(cf3),\n                    .port3_di(df3),\n                    .port3_co(c3f),\n                    .port3_do(d3f),\n                    .port4_ci(b0011_ci),\n                    .port4_di(b0011_di),\n                    .port4_co(b0011_co),\n                    .port4_do(b0011_do),\n                    .port4_ready(b0011_r),\n                    .clk(clk),\n                    .rst(rst));\n    brouter #(4'b0100) br0100\n                   (.port0_ci(c74),\n                    .port0_di(d74),\n                    .port0_co(c47),\n                    .port0_do(d47),\n                    .port1_ci(c54),\n                    .port1_di(d54),\n                    .port1_co(c45),\n                    .port1_do(d45),\n                    .port2_ci(c84),\n                    .port2_di(d84),\n                    .port2_co(c48),\n                    .port2_do(d48),\n                    .port3_ci(c04),\n                    .port3_di(d04),\n                    .port3_co(c40),\n                    .port3_do(d40),\n                    .port4_ci(b0100_ci),\n                    .port4_di(b0100_di),\n                    .port4_co(b0100_co),\n                    .port4_do(b0100_do),\n                    .port4_ready(b0100_r),\n                    .clk(clk),\n                    .rst(rst));\n    brouter #(4'b0101) br0101 \n                   (.port0_ci(c45),\n                    .port0_di(d45),\n                    .port0_co(c54),\n                    .port0_do(d54),\n                    .port1_ci(c65),\n                    .port1_di(d65),\n                    .port1_co(c56),\n                    .port1_do(d56),\n                    .port2_ci(c95),\n                    .port2_di(d95),\n                    .port2_co(c59),\n                    .port2_do(d59),\n                    .port3_ci(c15),\n                    .port3_di(d15),\n                    .port3_co(c51),\n                    .port3_do(d51),\n                    .port4_ci(b0101_ci),\n                    .port4_di(b0101_di),\n                    .port4_co(b0101_co),\n                    .port4_do(b0101_do),\n                    .port4_ready(b0101_r),\n                    .clk(clk),\n                    .rst(rst));\n    brouter #(4'b0110) br0110\n                   (.port0_ci(c56),\n                    .port0_di(d56),\n                    .port0_co(c65),\n                    .port0_do(d65),\n                    .port1_ci(c76),\n                    .port1_di(d76),\n                    .port1_co(c67),\n                    .port1_do(d67),\n                    .port2_ci(ca6),\n                    .port2_di(da6),\n                    .port2_co(c6a),\n                    .port2_do(d6a),\n                    .port3_ci(c26),\n                    .port3_di(d26),\n                    .port3_co(c62),\n                    .port3_do(d62),\n                    .port4_ci(b0110_ci),\n                    .port4_di(b0110_di),\n                    .port4_co(b0110_co),\n                    .port4_do(b0110_do),\n                    .port4_ready(b0110_r),\n                    .clk(clk),\n                    .rst(rst));\n    brouter #(4'b0111) br0111\n                   (.port0_ci(c67),\n                    .port0_di(d67),\n                    .port0_co(c76),\n                    .port0_do(d76),\n                    .port1_ci(c47),\n                    .port1_di(d47),\n                    .port1_co(c74),\n                    .port1_do(d74),\n                    .port2_ci(cb7),\n                    .port2_di(db7),\n                    .port2_co(c7b),\n                    .port2_do(d7b),\n                    .port3_ci(c37),\n                    .port3_di(d37),\n                    .port3_co(c73),\n                    .port3_do(d73),\n                    .port4_ci(b0111_ci),\n                    .port4_di(b0111_di),\n                    .port4_co(b0111_co),\n                    .port4_do(b0111_do),\n                    .port4_ready(b0111_r),\n                    .clk(clk),\n                    .rst(rst));\n    brouter #(4'b1000) br1000 \n                   (.port0_ci(cb8),\n                    .port0_di(db8),\n                    .port0_co(c8b),\n                    .port0_do(d8b),\n                    .port1_ci(c98),\n                    .port1_di(d98),\n                    .port1_co(c89),\n                    .port1_do(d89),\n                    .port2_ci(cc8),\n                    .port2_di(dc8),\n                    .port2_co(c8c),\n                    .port2_do(d8c),\n                    .port3_ci(c48),\n                    .port3_di(d48),\n                    .port3_co(c84),\n                    .port3_do(d84),\n                    .port4_ci(b1000_ci),\n                    .port4_di(b1000_di),\n                    .port4_co(b1000_co),\n                    .port4_do(b1000_do),\n                    .port4_ready(b1000_r),\n                    .clk(clk),\n                    .rst(rst));\n    brouter #(4'b1001) br1001 \n                   (.port0_ci(c89),\n                    .port0_di(d89),\n                    .port0_co(c98),\n                    .port0_do(d98),\n                    .port1_ci(ca9),\n                    .port1_di(da9),\n                    .port1_co(c9a),\n                    .port1_do(d9a),\n                    .port2_ci(cd9),\n                    .port2_di(dd9),\n                    .port2_co(c9d),\n                    .port2_do(d9d),\n                    .port3_ci(c59),\n                    .port3_di(d59),\n                    .port3_co(c95),\n                    .port3_do(d95),\n                    .port4_ci(b1001_ci),\n                    .port4_di(b1001_di),\n                    .port4_co(b1001_co),\n                    .port4_do(b1001_do),\n                    .port4_ready(b1001_r),\n                    .clk(clk),\n                    .rst(rst));\n    brouter #(4'b1010) br1010 \n                   (.port0_ci(c9a),\n                    .port0_di(d9a),\n                    .port0_co(ca9),\n                    .port0_do(da9),\n                    .port1_ci(cba),\n                    .port1_di(dba),\n                    .port1_co(cab),\n                    .port1_do(dab),\n                    .port2_ci(cea),\n                    .port2_di(dea),\n                    .port2_co(cae),\n                    .port2_do(dae),\n                    .port3_ci(c6a),\n                    .port3_di(d6a),\n                    .port3_co(ca6),\n                    .port3_do(da6),\n                    .port4_ci(b1010_ci),\n                    .port4_di(b1010_di),\n                    .port4_co(b1010_co),\n                    .port4_do(b1010_do),\n                    .port4_ready(b1010_r),\n                    .clk(clk),\n                    .rst(rst));\n    brouter #(4'b1011) br1011\n                   (.port0_ci(cab),\n                    .port0_di(dab),\n                    .port0_co(cba),\n                    .port0_do(dba),\n                    .port1_ci(c8b),\n                    .port1_di(d8b),\n                    .port1_co(cb8),\n                    .port1_do(db8),\n                    .port2_ci(cfb),\n                    .port2_di(dfb),\n                    .port2_co(cbf),\n                    .port2_do(dbf),\n                    .port3_ci(c7b),\n                    .port3_di(d7b),\n                    .port3_co(cb7),\n                    .port3_do(db7),\n                    .port4_ci(b1011_ci),\n                    .port4_di(b1011_di),\n                    .port4_co(b1011_co),\n                    .port4_do(b1011_do),\n                    .port4_ready(b1011_r),\n                    .clk(clk),\n                    .rst(rst));\n    brouter #(4'b1100) br1100\n                   (.port0_ci(cfc),\n                    .port0_di(dfc),\n                    .port0_co(ccf),\n                    .port0_do(dcf),\n                    .port1_ci(cdc),\n                    .port1_di(ddc),\n                    .port1_co(ccd),\n                    .port1_do(dcd),\n                    .port2_ci(c0c),\n                    .port2_di(d0c),\n                    .port2_co(cc0),\n                    .port2_do(dc0),\n                    .port3_ci(c8c),\n                    .port3_di(d8c),\n                    .port3_co(cc8),\n                    .port3_do(dc8),\n                    .port4_ci(b1100_ci),\n                    .port4_di(b1100_di),\n                    .port4_co(b1100_co),\n                    .port4_do(b1100_do),\n                    .port4_ready(b1100_r),\n                    .clk(clk),\n                    .rst(rst));\n    brouter #(4'b1101) br1101\n                   (.port0_ci(ccd),\n                    .port0_di(dcd),\n                    .port0_co(cdc),\n                    .port0_do(ddc),\n                    .port1_ci(ced),\n                    .port1_di(ded),\n                    .port1_co(cde),\n                    .port1_do(dde),\n                    .port2_ci(c1d),\n                    .port2_di(d1d),\n                    .port2_co(cd1),\n                    .port2_do(dd1),\n                    .port3_ci(c9d),\n                    .port3_di(d9d),\n                    .port3_co(cd9),\n                    .port3_do(dd9),\n                    .port4_ci(b1101_ci),\n                    .port4_di(b1101_di),\n                    .port4_co(b1101_co),\n                    .port4_do(b1101_do),\n                    .port4_ready(b1101_r),\n                    .clk(clk),\n                    .rst(rst));\n    brouter #(4'b1110) br1110\n                   (.port0_ci(cde),\n                    .port0_di(dde),\n                    .port0_co(ced),\n                    .port0_do(ded),\n                    .port1_ci(cfe),\n                    .port1_di(dfe),\n                    .port1_co(cef),\n                    .port1_do(def),\n                    .port2_ci(c2e),\n                    .port2_di(d2e),\n                    .port2_co(ce2),\n                    .port2_do(de2),\n                    .port3_ci(cae),\n                    .port3_di(dae),\n                    .port3_co(cea),\n                    .port3_do(dea),\n                    .port4_ci(b1110_ci),\n                    .port4_di(b1110_di),\n                    .port4_co(b1110_co),\n                    .port4_do(b1110_do),\n                    .port4_ready(b1110_r),\n                    .clk(clk),\n                    .rst(rst));\n    brouter #(4'b1111) br1111\n                   (.port0_ci(cef),\n                    .port0_di(def),\n                    .port0_co(cfe),\n                    .port0_do(dfe),\n                    .port1_ci(ccf),\n                    .port1_di(dcf),\n                    .port1_co(cfc),\n                    .port1_do(dfc),\n                    .port2_ci(c3f),\n                    .port2_di(d3f),\n                    .port2_co(cf3),\n                    .port2_do(df3),\n                    .port3_ci(cbf),\n                    .port3_di(dbf),\n                    .port3_co(cfb),\n                    .port3_do(dfb),\n                    .port4_ci(b1111_ci),\n                    .port4_di(b1111_di),\n                    .port4_co(b1111_co),\n                    .port4_do(b1111_do),\n                    .port4_ready(b1111_r),\n                    .clk(clk),\n                    .rst(rst));\n\nendmodule"}
{"task_id": 1665, "completion": "int c = 0;\n\n   t2 #(0) i_0(.*);\n   t2 #(-1) i_1(.*);\n   t2 #(-4) i_2(.*);\n   t2 #(-10) i_3(.*);\n   t2 #(+1) i_4(.*);\n   t2 #(+4) i_5(.*);\n   t2 #(+10) i_6(.*);\n\n   always @(posedge clk) begin\n      c <= c + 1;\n      if (c == 5) begin\n         $write(\"*-* All Finished *-*\n\");\n         $finish;\n      end\n   end\nendmodule"}
{"task_id": 1635, "completion": "reg sign;\nreg [10:0] exponent_a;\nreg [10:0] exponent_b;\nreg [51:0] mantissa_a;\nreg [51:0] mantissa_b;\nreg expa_gt_expb;\nreg [10:0] exponent_small;\nreg [10:0] exponent_large;\nreg [51:0] mantissa_small;\nreg [51:0] mantissa_large;\nreg small_is_denorm;\nreg large_is_denorm;\nreg large_norm_small_denorm;\nreg [10:0] exponent_diff;\nreg [55:0] large_add;\nreg [55:0] small_add;\nreg [55:0] small_shift;\nwire small_shift_nonzero = |small_shift[55:0];\nwire small_is_nonzero = (exponent_small > 0) | |mantissa_small[51:0]; \nwire small_fraction_enable = small_is_nonzero & !small_shift_nonzero;\nwire [55:0] small_shift_2 = { 55'b0, 1'b1 };\nreg [55:0] small_shift_3;\nreg [55:0] sum;\nwire sum_overflow = sum[55];\nreg [55:0] sum_2;\nreg [10:0] exponent;\nwire sum_leading_one = sum_2[54];\nreg denorm_to_norm;\nreg [10:0] exponent_2;\n\nalways @(posedge clk) \nbegin\nif (rst) begin\nsign <= 0;\nexponent_a <= 0;\nexponent_b <= 0;\nmantissa_a <= 0;\nmantissa_b <= 0;\nexpa_gt_expb <= 0;\nexponent_small  <= 0;\nexponent_large  <= 0;\nmantissa_small  <= 0;\nmantissa_large  <= 0;\nsmall_is_denorm <= 0;\nlarge_is_denorm <= 0;\nlarge_norm_small_denorm <= 0;\nexponent_diff <= 0;\nlarg_add <= 0;\nsmall_add <= 0;\nsmall_shift <= 0;\nsmall_shift_3 <= 0;\nsum <= 0;\nsum_2 <= 0;\nexponent <= 0;\ndenorm_to_norm <= 0;\nexponent_2 <= 0;\nend\nelse if (enable) begin\nsign <= opa[63];\nexponent_a <= opa[62:52];\nexponent_b <= opb[62:52];\nmantissa_a <= opa[51:0];\nmantissa_b <= opb[51:0];\nexpa_gt_expb <= exponent_a > exponent_b;\nexponent_small  <= expa_gt_expb ? exponent_b : exponent_a;\nexponent_large  <= expa_gt_expb ? exponent_a : exponent_b;\nmantissa_small  <= expa_gt_expb ? mantissa_b : mantissa_a;\nmantissa_large  <= expa_gt_expb ? mantissa_a : mantissa_b;\nsmall_is_denorm <= !(exponent_small > 0);\nlarge_is_denorm <= !(exponent_large > 0);\nlarge_norm_small_denorm <= (small_is_denorm && !large_is_denorm);\nexponent_diff <= exponent_large - exponent_small - large_norm_small_denorm;\nlarge_add <= { 1'b0, !large_is_denorm, mantissa_large, 2'b0 };\nsmall_add <= { 1'b0, !small_is_denorm, mantissa_small, 2'b0 };\nsmall_shift <= small_add >> exponent_diff;\nsmall_shift_3 <= small_fraction_enable ? small_shift_2 : small_shift;\nsum <= large_add + small_shift_3;\nsum_2 <= sum_overflow ? sum >> 1 : sum;\nexponent <= sum_overflow ? exponent_large + 1: exponent_large;\ndenorm_to_norm <= sum_leading_one & large_is_denorm;\nexponent_2 <= denorm_to_norm ? exponent + 1 : exponent;\nend\nend\n\nendmodule"}
{"task_id": 1509, "completion": "input clk;\ninput rst_n;\ninput RD_EN;\ninput WR_EN;\nreg WR,RD;\n\noutput scl;\noutput receive_status;\n\ninout sda;\n\nwire scl_wire;\nwire scl;\n\nwire[7:0] data;\n\nreg[7:0] data_reg;\n\nreg read_status_reg;\nreg write_status_reg;\n\nwire receive_status;\n\nwire [3:0] main_state;\nwire [4:0] i2c_state;\n\nwire sda_en;\nwire sda_in;\nwire sda_out;\n    \nassign sda_in = (!sda_en) ? sda : 1'bz;\nassign sda    = sda_en ? ((sda_out == 1'b1)? 1'bz:1'b0) : 1'bz;\n\nassign scl = scl_wire ? 1'bz: 1'b0;\n\nwire scl_fallingedge;\n\n//----------------- i2c statemachine -------------------------------\n//i2c data in big endian mode\n\nparameter data_7 = 4'h0;\nparameter data_0 = 4'h7;\nparameter data_act = 4'h8;\n\n//----------------- main statemachine ------------------------------\nparameter idle_status =4'h0;\nparameter start_status =4'h1;\nparameter address_status =4'h2;\nparameter read_status =4'h3;\nparameter write_status =4'h4;\nparameter stop_status =4'h5;\n\nalways @(posedge clk or negedge rst_n)\n    begin\n    if(!rst_n)begin    \n        WR         <= 1'b0;\n        RD         <= 1'b0;\n        data_reg   <= 'h0;\n        read_status_reg <= 1'b0;\n        write_status_reg <= 1'b0;\n    end\n    else \n        begin\n            if(RD_EN)\n                begin\n                    if (main_state == read_status)\n                        begin\n                            //try read more bits to fix the issue in i2c speed\n                            if (data_reg == 'h20 && i2c_state == data_7 && scl_fallingedge)\n                                begin\n                            //stop after read 32 data\n                                    RD <= 1'b0;\n                                    read_status_reg <= 1'b1;\n                                end\n                            else\n                                begin\n                                    if (scl_fallingedge && i2c_state == data_0)\n                                        data_reg <= data_reg + 1;\n                                end\n                        end\n                    else if (main_state == idle_status)\n                        begin\n                            if (~read_status_reg)\n                                begin\n                                    RD  <= 1'b1;\n                                    WR <= 1'b0;\n                                    data_reg <= 'h0;\n                                end\n                            else\n                                begin\n                                //read all data done stop here only reset can recovery\n                                    RD <= 1'b0;\n                                    WR <= 1'b0;\n                                    data_reg <= 'h0;\n                                end\n                        end\n                    else\n                        data_reg <= 'h0;\n                end\n            else if(WR_EN)\n                begin\n                    if (main_state == write_status)\n                        begin\n                            if (data_reg == 'h20 && i2c_state == data_7 && scl_fallingedge)\n                                begin\n                                //stop after send 32 data\n                                    WR <= 1'b0;\n                                    write_status_reg <= 1'b1;\n                                end\n                            else\n                                begin\n                                    if (scl_fallingedge && i2c_state == data_0)\n                                        data_reg <= data_reg + 1;\n                                end\n                        end\n                    else if (main_state == idle_status)\n                        begin\n                            if (~write_status_reg)\n                                begin\n                                    RD <= 1'b0;\n                                    WR <= 1'b1;\n                                    data_reg <= 'h0;\n                                end\n                            else\n                                begin\n                                    RD <= 1'b0;\n                                    WR <= 1'b0;\n                                    data_reg <= 'h0;                             \n                                end\n                        end\n                    else\n                        data_reg <= 'h0;\n                end\n            else\n                begin\n                        RD <= 1'b0;\n                        WR <= 1'b0;\n                        data_reg <= 'h0;\n                        write_status_reg <= 1'b0;\n                        read_status_reg <= 1'b0;\n                end\n\n        end\nend\n\nassign data = WR_EN ? data_reg :  8'hz;\n\nI2C_wr_reduced I2C_wr_reduced_instance(\n                    .sda_in(sda_in),\n                    .sda_out(sda_out),\n                    .sda_en(sda_en),\n                    .scl(scl_wire),\n                    .reset_n(rst_n),\n                    .clock(clk),\n                    .WR(WR),\n                    .RD(RD),\n                    .data(data),\n                    .scl_fallingedge(scl_fallingedge),\n                    .main_state(main_state),\n                    .i2c_state(i2c_state),\n                    .debug(receive_status)\n);\n\nendmodule"}
{"task_id": 1614, "completion": "integer  cyc = 0;   reg [63:0]  crc;   reg [63:0]  sum;   bit [4*32-1:0] w4 = {32'h7c709753, 32'hbc8f6059, 32'h3b0db464, 32'h721a8fad};   bit [8*32-2:0] w8m = {31'h7146e1bf, 32'ha8549e42, 32'hca6960bd, 32'h191b7f9b, 32'h93d79866, 32'hf4489e2b, 32'h8e9a3236, 32'h1d2a2d1d};   bit [8*32-1:0] w8 = {32'hc211addc, 32'he5d4a057, 32'h5cbf88fe, 32'h42cf42e2, 32'heb584263, 32'ha585f118, 32'h231531c8, 32'hc73f7b06};   bit [8*32-0:0] w8p = {1'b1, 32'h096aa54b, 32'h48aae18e, 32'hf9502cea, 32'h518c8b61, 32'h9e8641a2, 32'h0dc0249c, 32'hd421a87a, 32'hb8ee9199};   bit [9*32-1:0] w9 = {32'hca800ac1, 32'h0de4823a, 32'ha51663ac, 32'h96351446, 32'h6b0bbcd5, 32'h4a64b530, 32'h4967d59a, 32'hfcc17292, 32'h57926621};   bit [16*32-2:0] w16m = {31'h77ad72c7, 32'h73aa9cbb, 32'h7ecf026d, 32'h985a3ed2, 32'hfe961c1d, 32'h7a01df72, 32'h79e13d71, 32'hb69e2e32, 32'h09fcbc45, 32'hcfd738c1, 32'hc197ac7c, 32'hc316d727, 32'h903034e4, 32'h92a047d1, 32'h6a5357af, 32'ha82ce9c8};   bit [16*32-1:0] w16 = {32'he49548a7, 32'ha02336a2, 32'h2bb48f0d, 32'h9974e098, 32'h34ae644f, 32'hca46dc2c, 32'h9f71a468, 32'h64ae043e, 32'h7bc94d66, 32'h57aba588, 32'h5b9bb4fe, 32'hb87ed644, 32'hd34b5b20, 32'h712928de, 32'h4bdbd28e, 32'ha0576784};   bit [16*32-0:0] w16p = {1'b1, 32'hd278a306, 32'h374ce262, 32'hb608c88e, 32'h43d3e446, 32'h42e26866, 32'h44c31148, 32'hd3db659f, 32'hb3b84b2e, 32'h1aa7a184, 32'h73b28538, 32'h6384e801, 32'h98d58e00, 32'h9c1d1429, 32'hb407730e, 32'he974c1fd, 32'he787c302};   bit [17*32-1:0] w17 = {32'hf1e322ac, 32'hbbdbd761, 32'h760fe07d, 32'h3808cb28, 32'haf313051, 32'h37dc63b9, 32'hdddb418b, 32'he65a9d64, 32'hc1b6ab23, 32'h11131ac1, 32'h0050e0bc, 32'h442e3754, 32'h0eb4556e, 32'hd153064b, 32'h41349f97, 32'hb6f4149f, 32'h34bb1fb1};   function [7:0] bytehash (input [32*32-1:0] data);      integer i;      bytehash = 0;      for (i=0; i<32*32; ++i) begin         bytehash = {bytehash[0], bytehash[7:1]} ^ data[i +: 8];      end      return bytehash;   endfunction   wire [63:0] result = (bytehash(w4) ^ bytehash(w8m) ^ bytehash(w8) ^ bytehash(w8p) ^ bytehash(w9) ^ bytehash(w16m) ^ bytehash(w16) ^ bytehash(w16p) ^ bytehash(w17));   `define EXPECTED_SUM 64'h2bc7c2a98a302891   always @ (posedge clk) begin`ifdef TEST_VERBOSE      $write(\"[%0t] cyc==%0d crc=%x result=%x\\n\", $time, cyc, crc, result);`endif      cyc <= cyc + 1;      crc <= {crc[62:0], crc[63] ^ crc[2] ^ crc[0]};      sum <= result ^ {sum[62:0], sum[63] ^ sum[2] ^ sum[0]};      if (cyc==0) begin         crc <= 64'h5aef0c8d_d70a4497;         `checkhw(w4,3,32'h7c709753);         `checkhw(w4,2,32'hbc8f6059);         `checkhw(w4,1,32'h3b0db464);         `checkhw(w4,0,32'h721a8fad);         `checkhw(w8m,7,31'h7146e1bf);         `checkhw(w8m,6,32'ha8549e42);         `checkhw(w8m,5,32'hca6960bd);         `checkhw(w8m,4,32'h191b7f9b);         `checkhw(w8m,3,32'h93d79866);         `checkhw(w8m,2,32'hf4489e2b);         `checkhw(w8m,1,32'h8e9a3236);         `checkhw(w8m,0,32'h1d2a2d1d);         `checkhw(w8,7,32'hc211addc);         `checkhw(w8,6,32'he5d4a057);         `checkhw(w8,5,32'h5cbf88fe);         `checkhw(w8,4,32'h42cf42e2);         `checkhw(w8,3,32'heb584263);         `checkhw(w8,2,32'ha585f118);         `checkhw(w8,1,32'h231531c8);         `checkhw(w8,0,32'hc73f7b06);         `checkhw(w8p,8,1'b1);         `checkhw(w8p,7,32'h096aa54b);         `checkhw(w8p,6,32'h48aae18e);         `checkhw(w8p,5,32'hf9502cea);         `checkhw(w8p,4,32'h518c8b61);         `checkhw(w8p,3,32'h9e8641a2);         `checkhw(w8p,2,32'h0dc0249c);         `checkhw(w8p,1,32'hd421a87a);         `checkhw(w8p,0,32'hb8ee9199);         `checkhw(w9,8,32'hca800ac1);         `checkhw(w9,7,32'h0de4823a);         `checkhw(w9,6,32'ha51663ac);         `checkhw(w9,5,32'h96351446);         `checkhw(w9,4,32'h6b0bbcd5);         `checkhw(w9,3,32'h4a64b530);         `checkhw(w9,2,32'h4967d59a);         `checkhw(w9,1,32'hfcc17292);         `checkhw(w9,0,32'h57926621);         `checkhw(w16m,15,31'h77ad72c7);         `checkhw(w16m,14,32'h73aa9cbb);         `checkhw(w16m,13,32'h7ecf026d);         `checkhw(w16m,12,32'h985a3ed2);         `checkhw(w16m,11,32'hfe961c1d);         `checkhw(w16m,10,32'h7a01df72);         `checkhw(w16m,9,32'h79e13d71);         `checkhw(w16m,8,32'hb69e2e32);         `checkhw(w16m,7,32'h09fcbc45);         `checkhw(w16m,6,32'hcfd738c1);         `checkhw(w16m,5,32'hc197ac7c);         `checkhw(w16m,4,32'hc316d727);         `checkhw(w16m,3,32'h903034e4);         `checkhw(w16m,2,32'h92a047d1);         `checkhw(w16m,1,32'h6a5357af);         `checkhw(w16m,0,32'ha82ce9c8);      end      else if (cyc<10) begin         sum <= 64'h0;      end      else if (cyc<90) begin         w4   = w4   >>> 1;         w8m  = w8m  >>> 1;         w8   = w8   >>> 1;         w8p  = w8p  >>> 1;         w9   = w9   >>> 1;         w16m = w16m >>> 1;         w16  = w16  >>> 1;         w16p = w16p >>> 1;         w17  = w17  >>> 1;      end      else if (cyc==99) begin         $write(\"[%0t] cyc==%0d crc=%x sum=%x\\n\", $time, cyc, crc, sum);         if (crc !== 64'hc77bb9b3784ea091) $stop;         if (sum !== `EXPECTED_SUM) $stop;         $write(\"*-* All Finished *-*\\n\");         $finish;      end   end   endmodule"}
{"task_id": 1652, "completion": "wire [`ADDER_WIDTH+3-1:0] sum0;\n    wire [`ADDER_WIDTH+2-1:0] sum0_0, sum0_1;\n    wire [`ADDER_WIDTH+1-1:0] sum0_0_0, sum0_0_1, sum0_1_0, sum0_1_1;\n    reg  [`ADDER_WIDTH+0-1:0] sum0_0_0_0, sum0_0_0_1, sum0_0_1_0, sum0_0_1_1, sum0_1_0_0, sum0_1_0_1, sum0_1_1_0, sum0_1_1_1;\n\n    adder_tree_branch L1_0(sum0_0,     sum0_1,     sum0    );\n    defparam L1_0.EXTRA_BITS = 2;\n\n    adder_tree_branch L2_0(sum0_0_0,   sum0_0_1,   sum0_0  );\n    adder_tree_branch L2_1(sum0_1_0,   sum0_1_1,   sum0_1  );\n    defparam L2_0.EXTRA_BITS = 1;\n    defparam L2_1.EXTRA_BITS = 1;\n\n    adder_tree_branch L3_0(sum0_0_0_0, sum0_0_0_1, sum0_0_0);\n    adder_tree_branch L3_1(sum0_0_1_0, sum0_0_1_1, sum0_0_1);\n    adder_tree_branch L3_2(sum0_1_0_0, sum0_1_0_1, sum0_1_0);\n    adder_tree_branch L3_3(sum0_1_1_0, sum0_1_1_1, sum0_1_1);\n    defparam L3_0.EXTRA_BITS = 0;\n    defparam L3_1.EXTRA_BITS = 0;\n    defparam L3_2.EXTRA_BITS = 0;\n    defparam L3_3.EXTRA_BITS = 0;\n\n    always @(posedge clk) begin\n\t\tsum0_0_0_0 <= isum0_0_0_0;\n\t\tsum0_0_0_1 <= isum0_0_0_1;\n\t\tsum0_0_1_0 <= isum0_0_1_0;\n\t\tsum0_0_1_1 <= isum0_0_1_1;\n\t\tsum0_1_0_0 <= isum0_1_0_0;\n\t\tsum0_1_0_1 <= isum0_1_0_1;\n\t\tsum0_1_1_0 <= isum0_1_1_0;\n\t\tsum0_1_1_1 <= isum0_1_1_1;\n\n\t\t`ifdef 3_LEVEL_ADDER\n\t\t\tsum <= sum0;\n\t\t`endif\n\t\t`ifdef 2_LEVEL_ADDER\n\t\t\tsum <= sum0_0;\n\t\t`endif\n    end\n\nendmodule\n\nmodule adder_tree_branch(a,b,sum);\n    parameter EXTRA_BITS = 0;\n\n    input [`ADDER_WIDTH+EXTRA_BITS-1:0] a;\n    input [`ADDER_WIDTH+EXTRA_BITS-1:0] b;\n    output [`ADDER_WIDTH+EXTRA_BITS:0] sum;\n\n    assign sum = a + b;\nendmodule"}
{"task_id": 1316, "completion": "localparam nPHY_WRLAT = 0;\n  localparam MC_ERR_ADDR_WIDTH = ((CS_WIDTH == 1) ? 0 : RANK_WIDTH) + BANK_WIDTH + ROW_WIDTH + COL_WIDTH + DATA_BUF_OFFSET_WIDTH;\n  localparam ECC_WIDTH = (ECC == \"OFF\")? 0 : (DATA_WIDTH <= 4)? 4 : (DATA_WIDTH <= 10)? 5 : (DATA_WIDTH <= 26)? 6 : (DATA_WIDTH <= 57)? 7 : (DATA_WIDTH <= 120)? 8 : (DATA_WIDTH <= 247)? 9 : 10;\n  localparam P_FAMILY = \"virtex6\";\n  localparam P_ECC_TEST_FI_XOR = ECC_TEST;\n  wire correct_en;\n  wire [3:0] raw_not_ecc;\n  wire [3:0] ecc_single;\n  wire [3:0] ecc_multiple;\n  wire [MC_ERR_ADDR_WIDTH-1:0] ecc_err_addr;\n  wire [3:0] app_raw_not_ecc;\n  wire [DQ_WIDTH/8-1:0] fi_xor_we;\n  wire [DQ_WIDTH-1:0] fi_xor_wrdata;\n  wire [DATA_BUF_OFFSET_WIDTH-1:0] wr_data_offset;\n  wire wr_data_en;\n  wire [DATA_BUF_ADDR_WIDTH-1:0] wr_data_addr;\n  wire [DATA_BUF_OFFSET_WIDTH-1:0] rd_data_offset;\n  wire rd_data_en;\n  wire [DATA_BUF_ADDR_WIDTH-1:0] rd_data_addr;\n  wire accept;\n  wire accept_ns;\n  wire [(4*PAYLOAD_WIDTH)-1:0] rd_data;\n  wire rd_data_end;\n  wire use_addr;\n  wire size;\n  wire [ROW_WIDTH-1:0] row;\n  wire [RANK_WIDTH-1:0] rank;\n  wire hi_priority;\n  wire [DATA_BUF_ADDR_WIDTH-1:0] data_buf_addr;\n  wire [COL_WIDTH-1:0] col;\n  wire [2:0] cmd;\n  wire [BANK_WIDTH-1:0] bank;\n  wire [(4*PAYLOAD_WIDTH)-1:0] wr_data;\n  wire [(4*(DATA_WIDTH/8))-1:0] wr_data_mask;\n  mem_intfc #\n    (\n     .TCQ                   (TCQ),\n     .ADDR_CMD_MODE         (ADDR_CMD_MODE),\n     .AL                    (AL),\n     .BANK_WIDTH            (BANK_WIDTH),\n     .BM_CNT_WIDTH          (BM_CNT_WIDTH),\n     .BURST_MODE            (BURST_MODE),\n     .BURST_TYPE            (BURST_TYPE),\n     .CK_WIDTH              (CK_WIDTH),\n     .CKE_WIDTH             (CKE_WIDTH),\n     .CL                    (CL),\n     .COL_WIDTH             (COL_WIDTH),\n     .CS_WIDTH              (CS_WIDTH),\n     .CWL                   (CWL),\n     .DATA_WIDTH            (DATA_WIDTH),\n     .DATA_BUF_ADDR_WIDTH   (DATA_BUF_ADDR_WIDTH),\n     .DATA_BUF_OFFSET_WIDTH (DATA_BUF_OFFSET_WIDTH),\n     .DM_WIDTH              (DM_WIDTH),\n     .USE_DM_PORT           (USE_DM_PORT),\n     .DQ_CNT_WIDTH          (DQ_CNT_WIDTH),\n     .DQ_WIDTH              (DQ_WIDTH),\n     .DQS_CNT_WIDTH         (DQS_CNT_WIDTH),\n     .DQS_WIDTH             (DQS_WIDTH),\n     .DRAM_TYPE             (DRAM_TYPE),\n     .DRAM_WIDTH            (DRAM_WIDTH),\n     .ECC                   (ECC),\n     .ECC_TEST_FI_XOR       (P_ECC_TEST_FI_XOR),\n     .PAYLOAD_WIDTH         (PAYLOAD_WIDTH),\n     .ECC_WIDTH             (ECC_WIDTH),\n     .MC_ERR_ADDR_WIDTH     (MC_ERR_ADDR_WIDTH),\n     .nAL                   (nAL),\n     .nBANK_MACHS           (nBANK_MACHS),\n     .nCK_PER_CLK           (nCK_PER_CLK),\n     .nCS_PER_RANK          (nCS_PER_RANK),\n     .ORDERING              (ORDERING),\n     .PHASE_DETECT          (PHASE_DETECT),\n     .IBUF_LPWR_MODE        (IBUF_LPWR_MODE),\n     .IODELAY_HP_MODE       (IODELAY_HP_MODE),\n     .IODELAY_GRP           (IODELAY_GRP),\n     .OUTPUT_DRV            (OUTPUT_DRV),\n     .REG_CTRL              (REG_CTRL),\n     .RTT_NOM               (RTT_NOM),\n     .RTT_WR                (RTT_WR),\n     .STARVE_LIMIT          (STARVE_LIMIT),\n     .tCK                   (tCK),\n     .tFAW                  (tFAW),\n     .tPRDI                 (tPRDI),\n     .tRAS                  (tRAS),\n     .tRCD                  (tRCD),\n     .tREFI                 (tREFI),\n     .tRFC                  (tRFC),\n     .tRP                   (tRP),\n     .tRRD                  (tRRD),\n     .tRTP                  (tRTP),\n     .tWTR                  (tWTR),\n     .tZQI                  (tZQI),\n     .tZQCS                 (tZQCS),\n     .WRLVL                 (WRLVL),\n     .DEBUG_PORT            (DEBUG_PORT),\n     .CAL_WIDTH             (CAL_WIDTH),\n     .RANK_WIDTH            (RANK_WIDTH),\n     .RANKS                 (RANKS),\n     .ROW_WIDTH             (ROW_WIDTH),\n     .SLOT_0_CONFIG         (SLOT_0_CONFIG),\n     .SLOT_1_CONFIG         (SLOT_1_CONFIG),\n     .SIM_BYPASS_INIT_CAL   (SIM_BYPASS_INIT_CAL),\n     .REFCLK_FREQ           (REFCLK_FREQ),\n     .nDQS_COL0             (nDQS_COL0),\n     .nDQS_COL1             (nDQS_COL1),\n     .nDQS_COL2             (nDQS_COL2),\n     .nDQS_COL3             (nDQS_COL3),\n     .DQS_LOC_COL0          (DQS_LOC_COL0),\n     .DQS_LOC_COL1          (DQS_LOC_COL1),\n     .DQS_LOC_COL2          (DQS_LOC_COL2),\n     .DQS_LOC_COL3          (DQS_LOC_COL3)\n    )\n    u_mem_intfc\n    (\n     .wr_data_offset            (wr_data_offset),\n     .wr_data_en                (wr_data_en),\n     .wr_data_addr              (wr_data_addr),\n     .rd_data_offset            (rd_data_offset),\n     .rd_data_en                (rd_data_en),\n     .rd_data_addr              (rd_data_addr),\n     .ddr_we_n                  (ddr_we_n),\n     .ddr_parity                (ddr_parity),\n     .ddr_reset_n               (ddr_reset_n),\n     .ddr_ras_n                 (ddr_ras_n),\n     .ddr_odt                   (ddr_odt),\n     .ddr_dm                    (ddr_dm),\n     .ddr_cs_n                  (ddr_cs_n),\n     .ddr_cke                   (ddr_cke),\n     .ddr_ck                    (ddr_ck),\n     .ddr_ck_n                  (ddr_ck_n),\n     .ddr_cas_n                 (ddr_cas_n),\n     .ddr_ba                    (ddr_ba),\n     .ddr_addr                  (ddr_addr),\n     .dbg_wr_dqs_tap_set        (dbg_wr_dqs_tap_set),\n     .dbg_wr_dq_tap_set         (dbg_wr_dq_tap_set),\n     .dbg_wr_tap_set_en         (dbg_wr_tap_set_en),\n     .dbg_wrlvl_start           (dbg_wrlvl_start),\n     .dbg_wrlvl_done            (dbg_wrlvl_done),\n     .dbg_wrlvl_err             (dbg_wrlvl_err),\n     .dbg_wl_dqs_inverted       (dbg_wl_dqs_inverted),\n     .dbg_wr_calib_clk_delay    (dbg_wr_calib_clk_delay),\n     .dbg_wl_odelay_dqs_tap_cnt (dbg_wl_odelay_dqs_tap_cnt),\n     .dbg_wl_odelay_dq_tap_cnt  (dbg_wl_odelay_dq_tap_cnt),\n     .dbg_rdlvl_start           (dbg_rdlvl_start),\n     .dbg_rdlvl_done            (dbg_rdlvl_done),\n     .dbg_rdlvl_err             (dbg_rdlvl_err),\n     .dbg_cpt_first_edge_cnt    (dbg_cpt_first_edge_cnt),\n     .dbg_cpt_second_edge_cnt   (dbg_cpt_second_edge_cnt),\n     .dbg_rd_bitslip_cnt        (dbg_rd_bitslip_cnt),\n     .dbg_rd_clkdly_cnt         (dbg_rd_clkdly_cnt),\n     .dbg_rd_active_dly         (dbg_rd_active_dly),\n     .dbg_idel_up_all           (1'b0),\n     .dbg_idel_down_all         (1'b0),\n     .dbg_idel_up_cpt           (dbg_inc_cpt),\n     .dbg_idel_down_cpt         (dbg_dec_cpt),\n     .dbg_idel_up_rsync         (1'b0),\n     .dbg_idel_down_rsync       (1'b0),\n     .dbg_sel_idel_cpt          (dbg_inc_dec_sel),\n     .dbg_sel_all_idel_cpt      (1'b0),\n     .dbg_sel_idel_rsync        ({DQS_CNT_WIDTH{1'b0}}),\n     .dbg_sel_all_idel_rsync    (1'b0),\n     .dbg_cpt_tap_cnt           (dbg_cpt_tap_cnt),\n     .dbg_rsync_tap_cnt         (),\n     .dbg_dqs_tap_cnt           (dbg_dqs_tap_cnt),\n     .dbg_dq_tap_cnt            (dbg_dq_tap_cnt),\n     .dbg_pd_off                (dbg_pd_off),\n     .dbg_pd_maintain_off       (dbg_pd_maintain_off),\n     .dbg_pd_maintain_0_only    (dbg_pd_maintain_0_only),\n     .dbg_pd_inc_cpt            (1'b0),\n     .dbg_pd_dec_cpt            (1'b0),\n     .dbg_pd_inc_dqs            (dbg_inc_rd_dqs),\n     .dbg_pd_dec_dqs            (dbg_dec_rd_dqs),\n     .dbg_pd_disab_hyst         (1'b0),\n     .dbg_pd_disab_hyst_0       (1'b0),\n     .dbg_pd_msb_sel            (4'b0000),\n     .dbg_pd_byte_sel           (dbg_inc_dec_sel),\n     .dbg_inc_rd_fps            (dbg_inc_rd_fps),\n     .dbg_dec_rd_fps            (dbg_dec_rd_fps),\n     .dbg_phy_pd                (),\n     .dbg_phy_read              (),\n     .dbg_phy_rdlvl             (),\n     .dbg_phy_top               (),\n     .bank_mach_next            (bank_mach_next),\n     .accept                    (accept),\n     .accept_ns                 (accept_ns),\n     .rd_data                   (rd_data[APP_DATA_WIDTH-1:0]),\n     .rd_data_end               (rd_data_end),\n     .pd_PSEN                   (pd_PSEN),\n     .pd_PSINCDEC               (pd_PSINCDEC),\n     .dfi_init_complete         (phy_init_done),\n     .ecc_single                (ecc_single),\n     .ecc_multiple              (ecc_multiple),\n     .ecc_err_addr              (ecc_err_addr),\n     .ddr_dqs                   (ddr_dqs),\n     .ddr_dqs_n                 (ddr_dqs_n),\n     .ddr_dq                    (ddr_dq),\n     .use_addr                  (use_addr),\n     .size                      (size),\n     .rst                       (rst),\n     .row                       (row),\n     .rank                      (rank),\n     .hi_priority               (1'b0),\n     .data_buf_addr             (data_buf_addr),\n     .col                       (col),\n     .cmd                       (cmd),\n     .clk_mem                   (clk_mem),\n     .clk                       (clk),\n     .clk_rd_base               (clk_rd_base),\n     .bank                      (bank),\n     .wr_data                   (wr_data),\n     .wr_data_mask              (wr_data_mask),\n     .pd_PSDONE                 (pd_PSDONE),\n     .slot_0_present            (SLOT_0_CONFIG),\n     .slot_1_present            (SLOT_1_CONFIG),\n     .correct_en                (correct_en),\n     .raw_not_ecc               (raw_not_ecc),\n     .fi_xor_we                 (fi_xor_we),\n     .fi_xor_wrdata             (fi_xor_wrdata)\n    );\n  ui_top #\n    (\n     .TCQ            (TCQ),\n     .APP_DATA_WIDTH (APP_DATA_WIDTH),\n     .APP_MASK_WIDTH (APP_MASK_WIDTH),\n     .BANK_WIDTH     (BANK_WIDTH),\n     .COL_WIDTH      (COL_WIDTH),\n     .CWL            (CWL),\n     .ECC            (ECC),\n     .ECC_TEST       (ECC_TEST),\n     .ORDERING       (ORDERING),\n     .RANKS          (RANKS),\n     .RANK_WIDTH     (RANK_WIDTH),\n     .ROW_WIDTH      (ROW_WIDTH),\n     .MEM_ADDR_ORDER (MEM_ADDR_ORDER)\n    )\n   u_ui_top\n     (\n      .wr_data_mask         (wr_data_mask[APP_MASK_WIDTH-1:0]),\n      .wr_data              (wr_data[APP_DATA_WIDTH-1:0]),\n      .use_addr             (use_addr),\n      .size                 (size),\n      .row                  (row),\n      .rank                 (rank),\n      .hi_priority          (hi_priority),\n      .data_buf_addr        (data_buf_addr),\n      .col                  (col),\n      .cmd                  (cmd),\n      .bank                 (bank),\n      .app_wdf_rdy          (app_wdf_rdy),\n      .app_rdy              (app_rdy),\n      .app_rd_data_valid    (app_rd_data_valid),\n      .app_rd_data_end      (app_rd_data_end),\n      .app_rd_data          (app_rd_data),\n      .wr_data_offset       (wr_data_offset),\n      .wr_data_en           (wr_data_en),\n      .wr_data_addr         (wr_data_addr),\n      .rst                  (rst),\n      .rd_data_offset       (rd_data_offset),\n      .rd_data_end          (rd_data_end),\n      .rd_data_en           (rd_data_en),\n      .rd_data_addr         (rd_data_addr),\n      .rd_data              (rd_data[APP_DATA_WIDTH-1:0]),\n      .clk                  (clk),\n      .raw_not_ecc          (raw_not_ecc),\n      .app_ecc_multiple_err (app_ecc_multiple_err),\n      .correct_en           (correct_en),\n      .ecc_multiple         (ecc_multiple),\n      .app_raw_not_ecc      (app_raw_not_ecc),\n      .app_correct_en       (app_correct_en),\n      .app_wdf_wren         (app_wdf_wren),\n      .app_wdf_mask         (app_wdf_mask),\n      .app_wdf_end          (app_wdf_end),\n      .app_wdf_data         (app_wdf_data),\n      .app_sz               (app_sz),\n      .app_hi_pri           (app_hi_pri),\n      .app_en               (app_en),\n      .app_cmd              (app_cmd),\n      .app_addr             (app_addr),\n      .accept_ns            (accept_ns),\n      .accept               (accept)\n      );\n\nendmodule"}
{"task_id": 1676, "completion": "reg serial_send_reg = 0;   assign serial_send = serial_send_reg;   reg [SLAVES-1:0] new_nonces_flag = 0;   function integer clog2;      input integer value;      begin      value = value-1;      for (clog2=0; value>0; clog2=clog2+1)      value = value>>1;      end   endfunction   reg [clog2(SLAVES)+1:0] port_counter = 0;   reg [SLAVES*32-1:0] slave_nonces_shifted = 0;   assign golden_nonce = slave_nonces_shifted[31:0];   reg [SLAVES-1:0] clear_nonces = 0;   always @(posedge uart_clk)     begin        new_nonces_flag <= (new_nonces_flag & ~clear_nonces) | new_nonces;        if (port_counter == SLAVES-1)          port_counter <= 0;        else          port_counter <= port_counter + 1;        if (!serial_busy && new_nonces_flag[port_counter])          begin             slave_nonces_shifted <= slave_nonces >> port_counter*32;             serial_send_reg <= 1;             clear_nonces[port_counter] <= 1;          end        else          begin             serial_send_reg <= 0;             clear_nonces <= 0;          end     end   endmodule"}
{"task_id": 1598, "completion": "wire [99:0] dbg_pd[DQS_WIDTH-1:0];\n  wire [DQS_WIDTH-1:0] dec_cpt;\n  wire [DQS_WIDTH-1:0] dec_dqs;\n  wire [DQS_WIDTH-1:0] dlyce_pd_cpt_w;\n  wire [DQS_WIDTH-1:0] inc_cpt;\n  wire [DQS_WIDTH-1:0] inc_dqs;\n  wire [DQS_WIDTH-1:0] disable_hysteresis;\n  wire [3:0] early_dqs_data[DQS_WIDTH-1:0];\n  wire [DQS_WIDTH-1:0] maintain_off;\n  wire [3:0] msb_sel[DQS_WIDTH-1:0];\n  wire [DQS_WIDTH-1:0] pd_cal_done_byte;\n  wire [DQS_WIDTH-1:0] pd_cal_start_byte;\n  wire [DQS_WIDTH-1:0] pd_cal_start_pulse;\n  reg [DQS_WIDTH-1:0] pd_cal_start_r;\n  wire pd_maintain_0_only;\n  wire pd_off;\n  reg pd_prec_req_r;\n  wire [DQS_WIDTH-1:0] pd_start_raw;\n  reg prech_done_pl;\n  reg reset;\n  wire [1:0] trip_points[DQS_WIDTH-1:0];\n\n  always @(posedge clk or posedge rst)\n    if (rst) \n      reset <= #TCQ 1'b1;\n    else     \n      reset <= #TCQ 1'b0;\n\n  assign dbg_phy_pd[99:0] = dbg_pd[0];  \n  assign dbg_phy_pd[103:100] = early_dqs_data[0];\n  assign dbg_phy_pd[104] = pd_cal_start;\n  assign dbg_phy_pd[105] = pd_cal_done;\n  assign dbg_phy_pd[106] = read_valid;\n  assign dbg_phy_pd[107] = pd_PSEN; \n  assign dbg_phy_pd[108] = pd_PSINCDEC;\n  assign dbg_phy_pd[255:109] = 'b0;\n\n  assign disable_hysteresis = (DEBUG_PORT == \"ON\") ? \n    {{DQS_WIDTH-1{dbg_pd_disab_hyst}},dbg_pd_disab_hyst_0} :\n    {DQS_WIDTH{1'b0}};\n  assign pd_off = (DEBUG_PORT == \"ON\") ? dbg_pd_off : 1'b0;\n\n  generate \n    begin: gen_cal_mode\n      if (PD_CALIB_MODE == \"PARALLEL\") begin \n        assign pd_cal_done = &pd_cal_done_byte;\n        assign pd_cal_start_byte = {DQS_WIDTH{pd_cal_start}};\n        assign pd_prech_req = 1'b0;\n        assign pd_start_raw = 'b0;\n        assign pd_cal_start_pulse = 'b0;\n      end else begin \n        assign pd_cal_done = pd_cal_done_byte[DQS_WIDTH-1];\n        if (DQS_WIDTH == 1) begin\n          assign pd_cal_start_byte[0] = pd_cal_start;\n          assign pd_prech_req = 1'b0;\n        end else begin\n          assign pd_start_raw = {pd_cal_done_byte[DQS_WIDTH-2:0], pd_cal_start};\n          assign pd_prech_req = pd_prec_req_r;\n          assign pd_cal_start_pulse = pd_start_raw & ~pd_cal_start_r;\n          assign pd_cal_start_byte = pd_start_raw & {DQS_WIDTH{prech_done_pl}};\n          always @(posedge clk) begin\n            if (reset) begin\n              prech_done_pl <= #TCQ 1'b0;\n              pd_prec_req_r <= #TCQ 1'b0;\n              pd_cal_start_r <= #TCQ  'b0;\n            end else begin\n              prech_done_pl <= #TCQ prech_done;\n              pd_prec_req_r <= #TCQ |pd_cal_start_pulse;\n              pd_cal_start_r <= #TCQ  pd_start_raw;\n            end\n          end\n        end\n      end\n    end\n  endgenerate\n\n  generate\n    genvar dqs_i;\n    if (PD_DQS0_ONLY == \"ON\") begin: dqs0_on\n      assign pd_maintain_0_only = 1'b1;\n    end else begin: dqs0_off\n      assign pd_maintain_0_only = (DEBUG_PORT == \"ON\") ? dbg_pd_maintain_0_only : 1'b0;\n    end\n\n    for (dqs_i = 0; dqs_i < DQS_WIDTH; dqs_i = dqs_i+1) begin: gen_pd\n      assign early_dqs_data[dqs_i] = {rd_dqs_fall1[dqs_i], rd_dqs_rise1[dqs_i], rd_dqs_fall0[dqs_i], rd_dqs_rise0[dqs_i]};      \n      assign trip_points[dqs_i] = {rd_dqs_rise1[dqs_i], rd_dqs_rise0[dqs_i]};\n      assign inc_cpt[dqs_i] = (DEBUG_PORT == \"ON\") ? dbg_pd_inc_cpt & (dbg_pd_byte_sel == dqs_i) : 1'b0;\n      assign dec_cpt[dqs_i] = (DEBUG_PORT == \"ON\") ? dbg_pd_dec_cpt & (dbg_pd_byte_sel == dqs_i) : 1'b0;\n      assign inc_dqs[dqs_i] = (DEBUG_PORT == \"ON\") ? dbg_pd_inc_dqs & (dbg_pd_byte_sel == dqs_i) : 1'b0;\n      assign dec_dqs[dqs_i] = (DEBUG_PORT == \"ON\") ? dbg_pd_dec_dqs & (dbg_pd_byte_sel == dqs_i) : 1'b0;\n      assign msb_sel[dqs_i] = (dqs_i == 0) ? ((DEBUG_PORT == \"ON\") ? dbg_pd_msb_sel - 1 : PD_MSB_SEL-1) : ((DEBUG_PORT == \"ON\") ? dbg_pd_msb_sel : PD_MSB_SEL);\n      assign maintain_off[dqs_i] = (dqs_i == 0) ? ((DEBUG_PORT == \"ON\") ? dbg_pd_maintain_off : 1'b0) : ((DEBUG_PORT == \"ON\") ? dbg_pd_maintain_off | pd_maintain_0_only : pd_maintain_0_only);\n\n      if ((PD_DQS0_ONLY == \"OFF\") || (dqs_i == 0)) begin: gen_pd_inst\n        phy_pd #(\n         .TCQ            (TCQ),\n         .SIM_CAL_OPTION (SIM_CAL_OPTION),\n         .PD_LHC_WIDTH   (PD_LHC_WIDTH) \n         )\n        u_phy_pd\n          (\n           .dbg_pd             (dbg_pd[dqs_i]),\n           .dqs_dly_val_in     (dlyval_rdlvl_dqs[5*(dqs_i+1)-1:5*dqs_i]),\n           .dqs_dly_val        (dlyval_pd_dqs[5*(dqs_i+1)-1:5*dqs_i]),\n           .pd_en_maintain     (dlyce_pd_cpt_w[dqs_i]),\n           .pd_incdec_maintain (dlyinc_pd_cpt[dqs_i]),\n           .pd_cal_done        (pd_cal_done_byte[dqs_i]),\n           .pd_cal_start       (pd_cal_start_byte[dqs_i]),\n           .dfi_init_complete  (dfi_init_complete),\n           .pd_read_valid      (read_valid),\n           .trip_points        (trip_points[dqs_i]),\n           .dbg_pd_off         (pd_off),\n           .dbg_pd_maintain_off(maintain_off[dqs_i]),\n           .dbg_pd_inc_cpt     (inc_cpt[dqs_i]),\n           .dbg_pd_dec_cpt     (dec_cpt[dqs_i]),\n           .dbg_pd_inc_dqs     (inc_dqs[dqs_i]),\n           .dbg_pd_dec_dqs     (dec_dqs[dqs_i]),\n           .dbg_pd_disab_hyst  (disable_hysteresis[dqs_i]),\n           .dbg_pd_msb_sel     (msb_sel[dqs_i]),\n           .clk                (clk),\n           .rst                (rst)\n           );\n      end else begin: gen_pd_tie\n        assign dbg_pd[dqs_i] = 'b0;\n        assign dlyval_pd_dqs[5*(dqs_i+1)-1:5*dqs_i] = 'b0;\n        assign dlyce_pd_cpt_w[dqs_i] = 1'b0;\n        assign dlyinc_pd_cpt[dqs_i] = 1'b0;\n        assign pd_cal_done_byte[dqs_i] = 1'b1;\n      end\n    end\n  endgenerate\n\n  always @(posedge clk)\n    if (rst)\n      pd_PSEN <= #TCQ 1'b0;\n    else begin\n      if (dlyce_pd_cpt_w[0] || ((DEBUG_PORT == \"ON\") && (dbg_inc_rd_fps || dbg_dec_rd_fps)))\n        pd_PSEN <= #TCQ 1'b1;\n      else\n        pd_PSEN <= #TCQ 1'b0;\n    end\n\n  always @(posedge clk)\n    if (rst) \n      pd_PSINCDEC <= #TCQ 1'b0;\n    else begin \n      if ((DEBUG_PORT == \"ON\") && (dbg_inc_rd_fps || dbg_dec_rd_fps))\n        pd_PSINCDEC <= #TCQ dbg_inc_rd_fps;\n      else\n        pd_PSINCDEC <= #TCQ dlyinc_pd_cpt[0];\n    end\n\n  assign dlyce_pd_cpt[0] = 1'b0;\n  generate\n    if (DQS_WIDTH > 1) begin: gen_dlyce_pd_cpt_gt0\n      assign dlyce_pd_cpt[DQS_WIDTH-1:1] = {dlyce_pd_cpt_w[DQS_WIDTH-1:1]}; \n    end\n  endgenerate\nendmodule"}
{"task_id": 1562, "completion": "wire [15:0] latch0_16;  wire [15:0] latch1_16;  wire [15:0] latch2_16;  wire [15:0] latch3_16;  wire [15:0] lb0;  wire [15:0] lb1;  wire [15:0] lb2;  wire [15:0] lb3;  wire [15:0] nlb0;  wire [15:0] nlb1;  wire [15:0] nlb2;  wire [15:0] nlb3;  wire [15:0] alb0;  wire [15:0] alb1;  wire [15:0] alb2;  wire [15:0] alb3;  wire [15:0] olb0;  wire [15:0] olb1;  wire [15:0] olb2;  wire [15:0] olb3;  wire [15:0] xlb0;  wire [15:0] xlb1;  wire [15:0] xlb2;  wire [15:0] xlb3;  wire [15:0] set0;  wire [15:0] set1;  wire [15:0] set2;  wire [15:0] set3;  wire [15:0] no_set0;  wire [15:0] no_set1;  wire [15:0] no_set2;  wire [15:0] no_set3;  wire [15:0] no_en0;  wire [15:0] no_en1;  wire [15:0] no_en2;  wire [15:0] no_en3;  wire [15:0] new_val0;  wire [15:0] new_val1;  wire [15:0] new_val2;  wire [15:0] new_val3;  wire [15:0] val0_write0, val0_write1, val0_write2, val0_write3;  wire [15:0] val1_write0, val1_write1, val1_write2, val1_write3;  wire [15:0] val0_or0, val0_or1, val0_or2, val0_or3;  wire [15:0] val1_or0, val1_or1, val1_or2, val1_or3;  wire [15:0] final_wr0, final_wr1, final_wr2, final_wr3;  wire [15:1] offset;  wire [15:0] bitmask16;  wire [15:0] dat_mask;  wire write_en;  wire cont;  reg [ 1:0] plane;  reg [ 3:0] plane_dec;  assign bitmask16 = { bitmask, bitmask };  assign dat_mask = wbs_dat_i & bitmask16;  assign latch0_16 = { latch0, latch0 };  assign latch1_16 = { latch1, latch1 };  assign latch2_16 = { latch2, latch2 };  assign latch3_16 = { latch3, latch3 };  assign new_val0 = latch0_16 & ~bitmask16;  assign new_val1 = latch1_16 & ~bitmask16;  assign new_val2 = latch2_16 & ~bitmask16;  assign new_val3 = latch3_16 & ~bitmask16;  assign lb0 = latch0_16 & bitmask16;  assign lb1 = latch1_16 & bitmask16;  assign lb2 = latch2_16 & bitmask16;  assign lb3 = latch3_16 & bitmask16;  assign nlb0 = ~latch0_16 & bitmask16;  assign nlb1 = ~latch1_16 & bitmask16;  assign nlb2 = ~latch2_16 & bitmask16;  assign nlb3 = ~latch3_16 & bitmask16;  assign alb0 = (wbs_dat_i & latch0_16) & bitmask16;  assign alb1 = (wbs_dat_i & latch1_16) & bitmask16;  assign alb2 = (wbs_dat_i & latch2_16) & bitmask16;  assign alb3 = (wbs_dat_i & latch3_16) & bitmask16;  assign olb0 = (wbs_dat_i | latch0_16) & bitmask16;  assign olb1 = (wbs_dat_i | latch1_16) & bitmask16;  assign olb2 = (wbs_dat_i | latch2_16) & bitmask16;  assign olb3 = (wbs_dat_i | latch3_16) & bitmask16;  assign xlb0 = (wbs_dat_i ^ latch0_16) & bitmask16;  assign xlb1 = (wbs_dat_i ^ latch1_16) & bitmask16;  assign xlb2 = (wbs_dat_i ^ latch2_16) & bitmask16;  assign xlb3 = (wbs_dat_i ^ latch3_16) & bitmask16;  assign set0 = raster_op[0] ? (raster_op[1] ? nlb0 : lb0 ) : bitmask16;  assign set1 = raster_op[0] ? (raster_op[1] ? nlb1 : lb1 ) : bitmask16;  assign set2 = raster_op[0] ? (raster_op[1] ? nlb2 : lb2 ) : bitmask16;  assign set3 = raster_op[0] ? (raster_op[1] ? nlb3 : lb3 ) : bitmask16;  assign no_set0 = raster_op[1] ? lb0 : 16'h0;  assign no_set1 = raster_op[1] ? lb1 : 16'h0;  assign no_set2 = raster_op[1] ? lb2 : 16'h0;  assign no_set3 = raster_op[1] ? lb3 : 16'h0;  assign no_en0 = raster_op[1] ? (raster_op[0] ? xlb0 : olb0) : (raster_op[0] ? alb0 : dat_mask);  assign no_en1 = raster_op[1] ? (raster_op[0] ? xlb1 : olb1) : (raster_op[0] ? alb1 : dat_mask);  assign no_en2 = raster_op[1] ? (raster_op[0] ? xlb2 : olb2) : (raster_op[0] ? alb2 : dat_mask);  assign no_en3 = raster_op[1] ? (raster_op[0] ? xlb3 : olb3) : (raster_op[0] ? alb3 : dat_mask);  assign val0_or0 = enable_set_reset[0] ? (set_reset[0] ? set0 : no_set0) : no_en0;  assign val0_or1 = enable_set_reset[1] ? (set_reset[1] ? set1 : no_set1) : no_en1;  assign val0_or2 = enable_set_reset[2] ? (set_reset[2] ? set2 : no_set2) : no_en2;  assign val0_or3 = enable_set_reset[3] ? (set_reset[3] ? set3 : no_set3) : no_en3;  assign val0_write0 = new_val0 | val0_or0;  assign val0_write1 = new_val1 | val0_or1;  assign val0_write2 = new_val2 | val0_or2;  assign val0_write3 = new_val3 | val0_or3;  assign val1_or0[ 7:0] = wbs_dat_i[ 0] ? bitmask : 8'h0;  assign val1_or1[ 7:0] = wbs_dat_i[ 1] ? bitmask : 8'h0;  assign val1_or2[ 7:0] = wbs_dat_i[ 2] ? bitmask : 8'h0;  assign val1_or3[ 7:0] = wbs_dat_i[ 3] ? bitmask : 8'h0;  assign val1_or0[15:8] = wbs_dat_i[ 8] ? bitmask : 8'h0;  assign val1_or1[15:8] = wbs_dat_i[ 9] ? bitmask : 8'h0;  assign val1_or2[15:8] = wbs_dat_i[10] ? bitmask : 8'h0;  assign val1_or3[15:8] = wbs_dat_i[11] ? bitmask : 8'h0;  assign val1_write0 = new_val0 | val1_or0;  assign val1_write1 = new_val1 | val1_or1;  assign val1_write2 = new_val2 | val1_or2;  assign val1_write3 = new_val3 | val1_or3;  assign final_wr0 = write_mode[1] ? val1_write0 : (write_mode[0] ? latch0_16 : val0_write0);  assign final_wr1 = write_mode[1] ? val1_write1 : (write_mode[0] ? latch1_16 : val0_write1);  assign final_wr2 = write_mode[1] ? val1_write2 : (write_mode[0] ? latch2_16 : val0_write2);  assign final_wr3 = write_mode[1] ? val1_write3 : (write_mode[0] ? latch3_16 : val0_write3);  assign offset = memory_mapping1 ? { 1'b0, wbs_adr_i[14:1] } : wbs_adr_i[15:1];  assign wbm_adr_o = { offset, plane };  assign wbs_ack_o = (plane==2'b11 && cont);  assign wbm_dat_o = plane[1] ? (plane[0] ? final_wr3 : final_wr2) : (plane[0] ? final_wr1 : final_wr0);  assign write_en = plane[1] ? (plane[0] ? map_mask[3] : map_mask[2]) : (plane[0] ? map_mask[1] : map_mask[0]);  assign wbm_sel_o = wbs_sel_i;  assign cont = (wbm_ack_i | !write_en) & wbs_stb_i;  assign wbm_stb_o = write_en & wbs_stb_i;  always @(posedge wb_clk_i) plane <= wb_rst_i ? 2'b00 : (cont ? (plane + 2'b01) : plane);  endmodule"}
{"task_id": 1656, "completion": "contact_discoverycud_ram contact_discoverycud_ram_U(\n    .clk( clk ),\n    .addr0( address0 ),\n    .ce0( ce0 ),\n    .d0( d0 ),\n    .we0( we0 ),\n    .q0( q0 ),\n    .addr1( address1 ),\n    .ce1( ce1 ),\n    .q1( q1 ));\n\nendmodule"}
{"task_id": 1657, "completion": "wire[ADDR_WIDTH - 1:0] shiftReg_addr ;\n    wire[DATA_WIDTH - 1:0] shiftReg_data, shiftReg_q;\n    reg[ADDR_WIDTH:0] mOutPtr = {(ADDR_WIDTH+1){1'b1}};\n    reg internal_empty_n = 0, internal_full_n = 1;\n\n    assign if_empty_n = internal_empty_n;\n    assign if_full_n = internal_full_n;\n    assign shiftReg_data = if_din;\n    assign if_dout = shiftReg_q;\n\n    always @ (posedge clk) begin\n        if (reset == 1'b1)\n        begin\n            mOutPtr <= ~{ADDR_WIDTH+1{1'b0}};\n            internal_empty_n <= 1'b0;\n            internal_full_n <= 1'b1;\n        end\n        else begin\n            if (((if_read & if_read_ce) == 1 & internal_empty_n == 1) && \n                ((if_write & if_write_ce) == 0 | internal_full_n == 0))\n            begin\n                mOutPtr <= mOutPtr -1;\n                if (mOutPtr == 0)\n                    internal_empty_n <= 1'b0;\n                internal_full_n <= 1'b1;\n            end \n            else if (((if_read & if_read_ce) == 0 | internal_empty_n == 0) && \n                ((if_write & if_write_ce) == 1 & internal_full_n == 1))\n            begin\n                mOutPtr <= mOutPtr +1;\n                internal_empty_n <= 1'b1;\n                if (mOutPtr == DEPTH-2)\n                    internal_full_n <= 1'b0;\n            end \n        end\n    end\n\n    assign shiftReg_addr = mOutPtr[ADDR_WIDTH] == 1'b0 ? mOutPtr[ADDR_WIDTH-1:0]:{ADDR_WIDTH{1'b0}};\n    assign shiftReg_ce = (if_write & if_write_ce) & internal_full_n;\n\n    FIFO_image_filter_p_src_cols_V_channel1_shiftReg \n    #(\n        .DATA_WIDTH(DATA_WIDTH),\n        .ADDR_WIDTH(ADDR_WIDTH),\n        .DEPTH(DEPTH))\n    U_FIFO_image_filter_p_src_cols_V_channel1_ram (\n        .clk(clk),\n        .data(shiftReg_data),\n        .ce(shiftReg_ce),\n        .a(shiftReg_addr),\n        .q(shiftReg_q));\n\nendmodule"}
{"task_id": 1594, "completion": "integer  cyc = 0;\n   wire  one = '1;\n   wire  z0 = 'z;\n   wire  z1 = 'z;\n   wire  z2 = 'z;\n   wire  z3 = 'z;\n   wire  tog = cyc[0];\n\n   // verilator lint_off PINMISSING\n   t_tri0 tri0a (.line(`__LINE__), .expval(1'b0)); // Pin missing\n   t_tri0 tri0b (.line(`__LINE__), .expval(1'b0),    .tn());\n   t_tri0 tri0z (.line(`__LINE__), .expval(1'b0),    .tn(z0));\n   t_tri0 tri0Z (.line(`__LINE__), .expval(1'b0),    .tn(1'bz));\n   t_tri0 tri0c (.line(`__LINE__), .expval(1'b0),    .tn(1'b0));\n   t_tri0 tri0d (.line(`__LINE__), .expval(1'b1),    .tn(1'b1));  // Warning would be reasonable given tri0 connect\n   t_tri0 tri0e (.line(`__LINE__), .expval(1'b0),    .tn(~one));\n   t_tri0 tri0f (.line(`__LINE__), .expval(1'b1),    .tn(one));\n   t_tri0 tri0g (.line(`__LINE__), .expval(~cyc[0]), .tn(~tog));\n   t_tri0 tri0h (.line(`__LINE__), .expval(cyc[0]),  .tn(tog));\n\n   t_tri1 tri1a (.line(`__LINE__), .expval(1'b1)); // Pin missing\n   t_tri1 tri1b (.line(`__LINE__), .expval(1'b1),    .tn());\n   t_tri1 tri1z (.line(`__LINE__), .expval(1'b1),    .tn(z1));\n   t_tri1 tri1Z (.line(`__LINE__), .expval(1'b1),    .tn(1'bz));\n   t_tri1 tri1c (.line(`__LINE__), .expval(1'b0),    .tn(1'b0));  // Warning would be reasonable given tri1 connect\n   t_tri1 tri1d (.line(`__LINE__), .expval(1'b1),    .tn(1'b1));\n   t_tri1 tri1e (.line(`__LINE__), .expval(1'b0),    .tn(~one));\n   t_tri1 tri1f (.line(`__LINE__), .expval(1'b1),    .tn(one));\n   t_tri1 tri1g (.line(`__LINE__), .expval(~cyc[0]), .tn(~tog));\n   t_tri1 tri1h (.line(`__LINE__), .expval(cyc[0]),  .tn(tog));\n\n   t_tri2 tri2a (.line(`__LINE__), .expval(1'b0)); // Pin missing\n   t_tri2 tri2b (.line(`__LINE__), .expval(1'b0),    .tn());\n   t_tri2 tri2z (.line(`__LINE__), .expval(1'b0),    .tn(z2));\n   t_tri2 tri2Z (.line(`__LINE__), .expval(1'b0),    .tn(1'bz));\n   t_tri2 tri2c (.line(`__LINE__), .expval(1'b0),    .tn(1'b0));\n   t_tri2 tri2d (.line(`__LINE__), .expval(1'b1),    .tn(1'b1));\n   t_tri2 tri2e (.line(`__LINE__), .expval(1'b0),    .tn(~one));\n   t_tri2 tri2f (.line(`__LINE__), .expval(1'b1),    .tn(one));\n   t_tri2 tri2g (.line(`__LINE__), .expval(~cyc[0]), .tn(~tog));\n   t_tri2 tri2h (.line(`__LINE__), .expval(cyc[0]),  .tn(tog));\n\n   t_tri3 tri3a (.line(`__LINE__), .expval(1'b1)); // Pin missing\n   t_tri3 tri3b (.line(`__LINE__), .expval(1'b1),    .tn());\n   t_tri3 tri3z (.line(`__LINE__), .expval(1'b1),    .tn(z3));\n   t_tri3 tri3Z (.line(`__LINE__), .expval(1'b1),    .tn(1'bz));\n   t_tri3 tri3c (.line(`__LINE__), .expval(1'b0),    .tn(1'b0));\n   t_tri3 tri3d (.line(`__LINE__), .expval(1'b1),    .tn(1'b1));\n   t_tri3 tri3e (.line(`__LINE__), .expval(1'b0),    .tn(~one));\n   t_tri3 tri3f (.line(`__LINE__), .expval(1'b1),    .tn(one));\n   t_tri3 tri3g (.line(`__LINE__), .expval(~cyc[0]), .tn(~tog));\n   t_tri3 tri3h (.line(`__LINE__), .expval(cyc[0]),  .tn(tog));\n   // verilator lint_on PINMISSING\n\n   // Test loop\n   always @ (posedge clk) begin\n      cyc <= cyc + 1;\n      if (cyc==99) begin\n\t $write(\"*-* All Finished *-*\\n\");\n\t $finish;\n      end\n   end\n\nendmodule\n\nmodule t_tri0\n  (line, expval, tn);\n   input integer line;\n   input expval;\n   input tn;  // Illegal to be inout; spec requires net connection to any inout\n   tri0  tn;\n   wire  clk = t.clk;\n   always @(posedge clk) if (tn !== expval) begin\n      $display(\"%%Error: from line %0d got=%x exp=%x\",line,tn,expval); $stop;\n   end\nendmodule\n\nmodule t_tri1\n  (line, expval, tn);\n   input integer line;\n   input expval;\n   input tn;\n   tri1  tn;\n   wire  clk = t.clk;\n   always @(posedge clk) if (tn !== expval) begin\n      $display(\"%%Error: from line %0d got=%x exp=%x\",line,tn,expval); $stop;\n   end\nendmodule\n\nmodule t_tri2\n  (line, expval, tn);\n   input integer line;\n   input expval;\n   input tn;\n   pulldown(tn);\n   wire  clk = t.clk;\n   always @(posedge clk) if (tn !== expval) begin\n      $display(\"%%Error: from line %0d got=%x exp=%x\",line,tn,expval); $stop;\n   end\nendmodule\n\nmodule t_tri3\n  (line, expval, tn);\n   input integer line;\n   input expval;\n   input tn;\n   pullup(tn);\n   wire  clk = t.clk;\n   always @(negedge clk) if (tn !== expval) begin\n      $display(\"%%Error: from line %0d got=%x exp=%x\",line,tn,expval); $stop;\n   end\nendmodule"}
{"task_id": 1552, "completion": "axi_crossbar_v2_1_10_axi_crossbar #(\n    .C_FAMILY(\"zynq\"),\n    .C_NUM_SLAVE_SLOTS(1),\n    .C_NUM_MASTER_SLOTS(2),\n    .C_AXI_ID_WIDTH(1),\n    .C_AXI_ADDR_WIDTH(32),\n    .C_AXI_DATA_WIDTH(32),\n    .C_AXI_PROTOCOL(2),\n    .C_NUM_ADDR_RANGES(1),\n    .C_M_AXI_BASE_ADDR(128'H00000000430000000000000043c00000),\n    .C_M_AXI_ADDR_WIDTH(64'H0000001000000010),\n    .C_S_AXI_BASE_ID(32'H00000000),\n    .C_S_AXI_THREAD_ID_WIDTH(32'H0000000c),\n    .C_AXI_SUPPORTS_USER_SIGNALS(0),\n    .C_AXI_AWUSER_WIDTH(1),\n    .C_AXI_ARUSER_WIDTH(1),\n    .C_AXI_WUSER_WIDTH(1),\n    .C_AXI_RUSER_WIDTH(1),\n    .C_AXI_BUSER_WIDTH(1),\n    .C_M_AXI_WRITE_CONNECTIVITY(64'HFFFFFFFFFFFFFFFF),\n    .C_M_AXI_READ_CONNECTIVITY(64'HFFFFFFFFFFFFFFFF),\n    .C_R_REGISTER(0),\n    .C_S_AXI_SINGLE_THREAD(32'H00000001),\n    .C_S_AXI_WRITE_ACCEPTANCE(32'H00000001),\n    .C_S_AXI_READ_ACCEPTANCE(32'H00000001),\n    .C_M_AXI_WRITE_ISSUING(64'H0000000100000001),\n    .C_M_AXI_READ_ISSUING(64'H0000000100000001),\n    .C_S_AXI_ARB_PRIORITY(32'H00000000),\n    .C_M_AXI_SECURE(32'H00000000),\n    .C_CONNECTIVITY_MODE(0)\n  ) inst (\n    .aclk(aclk),\n    .aresetn(aresetn),\n    .s_axi_awid(1'H0),\n    .s_axi_awaddr(s_axi_awaddr),\n    .s_axi_awlen(8'H00),\n    .s_axi_awsize(3'H0),\n    .s_axi_awburst(2'H0),\n    .s_axi_awlock(1'H0),\n    .s_axi_awcache(4'H0),\n    .s_axi_awprot(s_axi_awprot),\n    .s_axi_awqos(4'H0),\n    .s_axi_awuser(1'H0),\n    .s_axi_awvalid(s_axi_awvalid),\n    .s_axi_awready(s_axi_awready),\n    .s_axi_wid(1'H0),\n    .s_axi_wdata(s_axi_wdata),\n    .s_axi_wstrb(s_axi_wstrb),\n    .s_axi_wlast(1'H1),\n    .s_axi_wuser(1'H0),\n    .s_axi_wvalid(s_axi_wvalid),\n    .s_axi_wready(s_axi_wready),\n    .s_axi_bid(),\n    .s_axi_bresp(s_axi_bresp),\n    .s_axi_buser(),\n    .s_axi_bvalid(s_axi_bvalid),\n    .s_axi_bready(s_axi_bready),\n    .s_axi_arid(1'H0),\n    .s_axi_araddr(s_axi_araddr),\n    .s_axi_arlen(8'H00),\n    .s_axi_arsize(3'H0),\n    .s_axi_arburst(2'H0),\n    .s_axi_arlock(1'H0),\n    .s_axi_arcache(4'H0),\n    .s_axi_arprot(s_axi_arprot),\n    .s_axi_arqos(4'H0),\n    .s_axi_aruser(1'H0),\n    .s_axi_arvalid(s_axi_arvalid),\n    .s_axi_arready(s_axi_arready),\n    .s_axi_rid(),\n    .s_axi_rdata(s_axi_rdata),\n    .s_axi_rresp(s_axi_rresp),\n    .s_axi_rlast(),\n    .s_axi_ruser(),\n    .s_axi_rvalid(s_axi_rvalid),\n    .s_axi_rready(s_axi_rready),\n    .m_axi_awid(),\n    .m_axi_awaddr(m_axi_awaddr),\n    .m_axi_awlen(),\n    .m_axi_awsize(),\n    .m_axi_awburst(),\n    .m_axi_awlock(),\n    .m_axi_awcache(),\n    .m_axi_awprot(m_axi_awprot),\n    .m_axi_awregion(),\n    .m_axi_awqos(),\n    .m_axi_awuser(),\n    .m_axi_awvalid(m_axi_awvalid),\n    .m_axi_awready(m_axi_awready),\n    .m_axi_wid(),\n    .m_axi_wdata(m_axi_wdata),\n    .m_axi_wstrb(m_axi_wstrb),\n    .m_axi_wlast(),\n    .m_axi_wuser(),\n    .m_axi_wvalid(m_axi_wvalid),\n    .m_axi_wready(m_axi_wready),\n    .m_axi_bid(2'H0),\n    .m_axi_bresp(m_axi_bresp),\n    .m_axi_buser(2'H0),\n    .m_axi_bvalid(m_axi_bvalid),\n    .m_axi_bready(m_axi_bready),\n    .m_axi_arid(),\n    .m_axi_araddr(m_axi_araddr),\n    .m_axi_arlen(),\n    .m_axi_arsize(),\n    .m_axi_arburst(),\n    .m_axi_arlock(),\n    .m_axi_arcache(),\n    .m_axi_arprot(m_axi_arprot),\n    .m_axi_arregion(),\n    .m_axi_arqos(),\n    .m_axi_aruser(),\n    .m_axi_arvalid(m_axi_arvalid),\n    .m_axi_arready(m_axi_arready),\n    .m_axi_rid(2'H0),\n    .m_axi_rdata(m_axi_rdata),\n    .m_axi_rresp(m_axi_rresp),\n    .m_axi_rlast(2'H3),\n    .m_axi_ruser(2'H0),\n    .m_axi_rvalid(m_axi_rvalid),\n    .m_axi_rready(m_axi_rready)\n  );\nendmodule"}
{"task_id": 1669, "completion": "wire [`ADDER_WIDTH+3-1:0] sum0;\n\twire [`ADDER_WIDTH+2-1:0] sum0_0, sum0_1;\n\twire [`ADDER_WIDTH+1-1:0] sum0_0_0, sum0_0_1, sum0_1_0, sum0_1_1;\n\treg  [`ADDER_WIDTH+0-1:0] sum0_0_0_0, sum0_0_0_1, sum0_0_1_0, sum0_0_1_1, sum0_1_0_0, sum0_1_0_1, sum0_1_1_0, sum0_1_1_1;\n\n\tadder_tree_branch L1_0(sum0_0,     sum0_1,     sum0    );\n\tdefparam L1_0.EXTRA_BITS = 2;\n\n\tadder_tree_branch L2_0(sum0_0_0,   sum0_0_1,   sum0_0  );\n\tadder_tree_branch L2_1(sum0_1_0,   sum0_1_1,   sum0_1  );\n\tdefparam L2_0.EXTRA_BITS = 1;\n\tdefparam L2_1.EXTRA_BITS = 1;\n\n\tadder_tree_branch L3_0(sum0_0_0_0, sum0_0_0_1, sum0_0_0);\n\tadder_tree_branch L3_1(sum0_0_1_0, sum0_0_1_1, sum0_0_1);\n\tadder_tree_branch L3_2(sum0_1_0_0, sum0_1_0_1, sum0_1_0);\n\tadder_tree_branch L3_3(sum0_1_1_0, sum0_1_1_1, sum0_1_1);\n\tdefparam L3_0.EXTRA_BITS = 0;\n\tdefparam L3_1.EXTRA_BITS = 0;\n\tdefparam L3_2.EXTRA_BITS = 0;\n\tdefparam L3_3.EXTRA_BITS = 0;\n\n\talways @(posedge clk) begin\n\t\tsum0_0_0_0 <= isum0_0_0_0;\n\t\tsum0_0_0_1 <= isum0_0_0_1;\n\t\tsum0_0_1_0 <= isum0_0_1_0;\n\t\tsum0_0_1_1 <= isum0_0_1_1;\n\t\tsum0_1_0_0 <= isum0_1_0_0;\n\t\tsum0_1_0_1 <= isum0_1_0_1;\n\t\tsum0_1_1_0 <= isum0_1_1_0;\n\t\tsum0_1_1_1 <= isum0_1_1_1;\n\n\t\t`ifdef 3_LEVEL_ADDER\n\t\t\tsum <= sum0;\n\t\t`endif\n\t\t`ifdef 2_LEVEL_ADDER\n\t\t\tsum <= sum0_0;\n\t\t`endif\n\tend\n\nendmodule\n\nmodule adder_tree_branch(a,b,sum);\n\tparameter EXTRA_BITS = 0;\n\n\tinput [`ADDER_WIDTH+EXTRA_BITS-1:0] a;\n\tinput [`ADDER_WIDTH+EXTRA_BITS-1:0] b;\n\toutput [`ADDER_WIDTH+EXTRA_BITS:0] sum;\n\n\tassign sum = a + b;\nendmodule"}
{"task_id": 1618, "completion": "reg I2C_BIT;    reg SCLK;    reg [5:0] SD_COUNTER;    wire I2C_SCLK1 = (GO == 1 && ((SD_COUNTER >= 5 && SD_COUNTER <=12 || SD_COUNTER == 14) || (SD_COUNTER >= 16 && SD_COUNTER <=23 || SD_COUNTER == 25) || (SD_COUNTER >= 27 && SD_COUNTER <=34 || SD_COUNTER == 36))) ? I2C_CLK : SCLK;    wire I2C_SCLK2 = (GO == 1 && ((SD_COUNTER >= 5 && SD_COUNTER <=12 || SD_COUNTER == 14) || (SD_COUNTER >= 16 && SD_COUNTER <=23 || SD_COUNTER == 25) || (SD_COUNTER >= 33 && SD_COUNTER <=40 || SD_COUNTER == 42) || (SD_COUNTER >= 45 && SD_COUNTER <=52 || SD_COUNTER == 54))) ? I2C_CLK : SCLK;    assign I2C_SCLK = WR ? I2C_SCLK1 : I2C_SCLK2;    wire SDO1 = ((SD_COUNTER == 13 || SD_COUNTER == 14) || (SD_COUNTER == 24 || SD_COUNTER == 25) || (SD_COUNTER == 35 || SD_COUNTER == 36)) ? 1'b0 : 1'b1;    wire SDO2 = ((SD_COUNTER == 13 || SD_COUNTER == 14) || (SD_COUNTER == 24 || SD_COUNTER == 25) || (SD_COUNTER == 41 || SD_COUNTER == 42) || (SD_COUNTER >= 44 && SD_COUNTER <= 52)) ? 1'b0 : 1'b1;    wire SDO = WR ? SDO1 : SDO2;    assign I2C_SDAT = SDO ? I2C_BIT : 1'bz;    reg ACKW1, ACKW2, ACKW3;    reg ACKR1, ACKR2, ACKR3;    assign ACK = WR ? (ACKW1 | ACKW2 | ACKW3) : (ACKR1 | ACKR2 | ACKR3);    always @(posedge iCLK or negedge iRST_N) begin        if (!iRST_N)            SD_COUNTER <= 6'b0;        else if(I2C_EN)        begin            if (GO == 0 || END == 1)                SD_COUNTER <= 6'b0;            else if (SD_COUNTER < 6'd63)                SD_COUNTER <= SD_COUNTER + 6'd1;        end        else            SD_COUNTER <= SD_COUNTER;    end    always @(posedge iCLK or negedge iRST_N) begin        if(!iRST_N)        begin            SCLK <= 1;            I2C_BIT <= 1;            ACKW1 <= 1; ACKW2 <= 1; ACKW3 <= 1;            ACKR1 <= 1; ACKR2 <= 1; ACKR3 <= 1;            END <= 0;            I2C_RDATA <= 8'h0;        end        else if(I2C_EN)        begin            if(GO)            begin                if(WR)                begin                    case(SD_COUNTER)                    6'd0 :    begin                            SCLK <= 1;                            I2C_BIT <= 1;                            ACKW1 <= 1; ACKW2 <= 1; ACKW3 <= 1;                            ACKR1 <= 1; ACKR2 <= 1; ACKR3 <= 1;                            END <= 0;                            end                    6'd1 :    begin                        SCLK <= 1;                        I2C_BIT <= 1;                        ACKW1 <= 1; ACKW2 <= 1; ACKW3 <= 1;                        END <= 0;                        end                    6'd2  : I2C_BIT <= 0;                    6'd3  : SCLK <= 0;                    6'd4  : I2C_BIT <= I2C_WDATA[23];                    6'd5  : I2C_BIT <= I2C_WDATA[22];                    6'd6  : I2C_BIT <= I2C_WDATA[21];                    6'd7  : I2C_BIT <= I2C_WDATA[20];                    6'd8  : I2C_BIT <= I2C_WDATA[19];                    6'd9  : I2C_BIT <= I2C_WDATA[18];                    6'd10 : I2C_BIT <= I2C_WDATA[17];                    6'd11 : I2C_BIT <= I2C_WDATA[16];                    6'd12 : I2C_BIT <= 0;                    6'd13 : ACKW1  = I2C_SDAT;                    6'd14 : I2C_BIT <= 0;                    6'd15 : I2C_BIT <= I2C_WDATA[15];                    6'd16 : I2C_BIT <= I2C_WDATA[14];                    6'd17 : I2C_BIT <= I2C_WDATA[13];                    6'd18 : I2C_BIT <= I2C_WDATA[12];                    6'd19 : I2C_BIT <= I2C_WDATA[11];                    6'd20 : I2C_BIT <= I2C_WDATA[10];                    6'd21 : I2C_BIT <= I2C_WDATA[9];                    6'd22 : I2C_BIT <= I2C_WDATA[8];                    6'd23 : I2C_BIT <= 0;                    6'd24 : ACKW2  = I2C_SDAT;                    6'd25 : I2C_BIT <= 0;                    6'd26 : I2C_BIT <= I2C_WDATA[7];                    6'd27 : I2C_BIT <= I2C_WDATA[6];                    6'd28 : I2C_BIT <= I2C_WDATA[5];                    6'd29 : I2C_BIT <= I2C_WDATA[4];                    6'd30 : I2C_BIT <= I2C_WDATA[3];                    6'd31 : I2C_BIT <= I2C_WDATA[2];                    6'd32 : I2C_BIT <= I2C_WDATA[1];                    6'd33 : I2C_BIT <= I2C_WDATA[0];                    6'd34 : I2C_BIT <= 0;                    6'd35 : ACKW3  = I2C_SDAT;                    6'd36 : I2C_BIT <= 0;                    6'd37 : begin    SCLK <= 0; I2C_BIT <= 0; end                    6'd38 : SCLK <= 1;                    6'd39 : begin I2C_BIT <= 1; END <= 1; end                     default : begin I2C_BIT <= 1; SCLK <= 1; end                    endcase                end                else                begin                    case(SD_COUNTER)                    6'd0 :    begin                        SCLK <= 1;                        I2C_BIT <= 1;                        ACKW1 <= 1; ACKW2 <= 1; ACKW3 <= 1;                        ACKR1 <= 1; ACKR2 <= 1; ACKR3 <= 1;                        END <= 0;                        end                    6'd1 :    begin                        SCLK <= 1;                        I2C_BIT <= 1;                        ACKR1 <= 1; ACKR2 <= 1; ACKR3 <= 1;                        END <= 0;                        end                    6'd2  : I2C_BIT <= 0;                    6'd3  : SCLK <= 0;                    6'd4  : I2C_BIT <= I2C_WDATA[23];                    6'd5  : I2C_BIT <= I2C_WDATA[22];                    6'd6  : I2C_BIT <= I2C_WDATA[21];                    6'd7  : I2C_BIT <= I2C_WDATA[20];                    6'd8  : I2C_BIT <= I2C_WDATA[19];                    6'd9  : I2C_BIT <= I2C_WDATA[18];                    6'd10 : I2C_BIT <= I2C_WDATA[17];                    6'd11 : I2C_BIT <= I2C_WDATA[16];                    6'd12 : I2C_BIT <= 0;                    6'd13 : ACKR1  = I2C_SDAT;                    6'd14 : I2C_BIT <= 0;                    6'd15 : I2C_BIT <= I2C_WDATA[15];                    6'd16 : I2C_BIT <= I2C_WDATA[14];                    6'd17 : I2C_BIT <= I2C_WDATA[13];                    6'd18 : I2C_BIT <= I2C_WDATA[12];                    6'd19 : I2C_BIT <= I2C_WDATA[11];                    6'd20 : I2C_BIT <= I2C_WDATA[10];                    6'd21 : I2C_BIT <= I2C_WDATA[9];                    6'd22 : I2C_BIT <= I2C_WDATA[8];                    6'd23 : I2C_BIT <= 0;                    6'd24 : ACKR2  = I2C_SDAT;                    6'd25 : I2C_BIT <= 0;                    6'd26 : begin    SCLK <= 0; I2C_BIT <= 0; end                    6'd27 : SCLK <= 1;                    6'd28 : begin I2C_BIT <= 1; end                     6'd29 : begin                        SCLK <= 1;                        I2C_BIT <= 1;                        end                    6'd30 : I2C_BIT <= 0;                    6'd31 : SCLK <= 0;                    6'd32 : I2C_BIT <= I2C_WDATA[23];                    6'd33 : I2C_BIT <= I2C_WDATA[22];                    6'd34 : I2C_BIT <= I2C_WDATA[21];                    6'd35 : I2C_BIT <= I2C_WDATA[20];                    6'd36 : I2C_BIT <= I2C_WDATA[19];                    6'd37 : I2C_BIT <= I2C_WDATA[18];                    6'd38 : I2C_BIT <= I2C_WDATA[17];                    6'd39 : I2C_BIT <= 1'b1;                    6'd40 : I2C_BIT <= 0;                    6'd41 : ACKR3  = I2C_SDAT;                    6'd42 : I2C_BIT <= 0;                    6'd43 : I2C_BIT  = 0;                    6'd44 : I2C_BIT  = 0;                    6'd45 : I2C_RDATA[7] <= I2C_SDAT;                    6'd46 : I2C_RDATA[6] <= I2C_SDAT;                    6'd47 : I2C_RDATA[5] <= I2C_SDAT;                    6'd48 : I2C_RDATA[4] <= I2C_SDAT;                    6'd49 : I2C_RDATA[3] <= I2C_SDAT;                    6'd50 : I2C_RDATA[2] <= I2C_SDAT;                    6'd51 : I2C_RDATA[1] <= I2C_SDAT;                    6'd52 : I2C_RDATA[0] <= I2C_SDAT;                    6'd53 : I2C_BIT  = 1;                    6'd54 : I2C_BIT  = 0;                    6'd55 : begin    SCLK <= 0; I2C_BIT <= 0; end                    6'd56 : SCLK <= 1;                    6'd57 : begin I2C_BIT <= 1; END <= 1; end                     default : begin I2C_BIT <= 1; SCLK <= 1; end                    endcase                end            end            else            begin            SCLK <= 1;            I2C_BIT <= 1;            ACKW1 <= 1; ACKW2 <= 1; ACKW3 <= 1;            ACKR1 <= 1; ACKR2 <= 1; ACKR3 <= 1;            END <= 0;            I2C_RDATA <= I2C_RDATA;            end        end    endendmodule"}
{"task_id": 1661, "completion": "parameter breakpoints = 0;                      // Number of breakpoint CSRs\n    parameter watchpoints = 0;                      // Number of watchpoint CSRs\n\n    input clk_i;                                    // Clock\n    input rst_i;                                    // Reset\n\n    input [`LM32_PC_RNG] pc_x;                      // X stage PC\n    input load_x;                                   // Load instruction in X stage\n    input store_x;                                  // Store instruction in X stage\n    input [`LM32_WORD_RNG] load_store_address_x;    // Load or store effective address\n    input csr_write_enable_x;                       // wcsr instruction in X stage\n    input [`LM32_WORD_RNG] csr_write_data;          // Data to write to CSR\n    input [`LM32_CSR_RNG] csr_x;                    // Which CSR to write\n    input jtag_csr_write_enable;                    // JTAG interface CSR write enable\n    input [`LM32_WORD_RNG] jtag_csr_write_data;     // Data to write to CSR\n    input [`LM32_CSR_RNG] jtag_csr;                 // Which CSR to write\n    input eret_q_x;                                 // eret instruction in X stage\n    input bret_q_x;                                 // bret instruction in X stage\n    input stall_x;                                  // Instruction in X stage is stalled\n    input exception_x;                              // An exception has occurred in X stage \n    input q_x;                                      // Indicates the instruction in the X stage is qualified\n    input dcache_refill_request;                    // Indicates data cache wants to be refilled \n    output dc_ss;                                   // Single-step enable\n    reg    dc_ss;\n    output dc_re;                                   // Remap exceptions\n    reg    dc_re;\n    output bp_match;                                // Indicates a breakpoint has matched\n    wire   bp_match;        \n    output wp_match;                                // Indicates a watchpoint has matched\n    wire   wp_match;\n\n    genvar i;                                       // Loop index for generate statements\n\n    reg [`LM32_PC_RNG] bp_a[0:breakpoints-1];       // Instruction breakpoint address\n    reg bp_e[0:breakpoints-1];                      // Instruction breakpoint enable\n    wire [0:breakpoints-1] bp_match_n;               // Indicates if a h/w instruction breakpoint matched\n\n    reg [`LM32_WPC_C_RNG] wpc_c[0:watchpoints-1];   // Watchpoint enable\n    reg [`LM32_WORD_RNG] wp[0:watchpoints-1];       // Watchpoint address\n    wire [0:watchpoints] wp_match_n;               // Indicates if a h/w data watchpoint matched\n\n    wire debug_csr_write_enable;                    // Debug CSR write enable (from either a wcsr instruction of external debugger)\n    wire [`LM32_WORD_RNG] debug_csr_write_data;     // Data to write to debug CSR\n    wire [`LM32_CSR_RNG] debug_csr;                 // Debug CSR to write to\n\n    integer state;                                  // State of single-step FSM\n\n    `include \"lm32_functions.v\"\n\n    generate\n        for (i = 0; i < breakpoints; i = i + 1)\n        begin : bp_comb\n            assign bp_match_n[i] = ((bp_a[i] == pc_x) && (bp_e[i] == `TRUE));\n        end\n    endgenerate\n    generate \n        if (breakpoints > 0) \n            assign bp_match = (|bp_match_n) || (state == `LM32_DEBUG_SS_STATE_RAISE_BREAKPOINT);\n        else\n            assign bp_match = state == `LM32_DEBUG_SS_STATE_RAISE_BREAKPOINT;\n    endgenerate    \n               \n    generate \n        for (i = 0; i < watchpoints; i = i + 1)\n        begin : wp_comb\n            assign wp_match_n[i] = (wp[i] == load_store_address_x) && ((load_x & wpc_c[i][0]) | (store_x & wpc_c[i][1]));\n        end               \n    endgenerate\n    generate\n        if (watchpoints > 0) \n            assign wp_match = |wp_match_n;                \n        else\n            assign wp_match = `FALSE;\n    endgenerate\n                \n    assign debug_csr_write_enable = (csr_write_enable_x == `TRUE) || (jtag_csr_write_enable == `TRUE);\n    assign debug_csr_write_data = jtag_csr_write_enable == `TRUE ? jtag_csr_write_data : csr_write_data;\n    assign debug_csr = jtag_csr_write_enable == `TRUE ? jtag_csr : csr_x;\n\n    generate\n        for (i = 0; i < breakpoints; i = i + 1)\n        begin : bp_seq\n            always @(posedge clk_i `CFG_RESET_SENSITIVITY)\n            begin\n                if (rst_i == `TRUE)\n                begin\n                    bp_a[i] <= #1 {`LM32_PC_WIDTH{1'bx}};\n                    bp_e[i] <= #1 `FALSE;\n                end\n                else\n                begin\n                    if ((debug_csr_write_enable == `TRUE) && (debug_csr == `LM32_CSR_BP0 + i))\n                    begin\n                        bp_a[i] <= #1 debug_csr_write_data[`LM32_PC_RNG];\n                        bp_e[i] <= #1 debug_csr_write_data[0];\n                    end\n                end\n            end    \n        end\n    endgenerate\n\n    generate\n        for (i = 0; i < watchpoints; i = i + 1)\n        begin : wp_seq\n            always @(posedge clk_i `CFG_RESET_SENSITIVITY)\n            begin\n                if (rst_i == `TRUE)\n                begin\n                    wp[i] <= #1 {`LM32_WORD_WIDTH{1'bx}};\n                    wpc_c[i] <= #1 `LM32_WPC_C_DISABLED;\n                end\n                else\n                begin\n                    if (debug_csr_write_enable == `TRUE)\n                    begin\n                        if (debug_csr == `LM32_CSR_DC)\n                            wpc_c[i] <= #1 debug_csr_write_data[3+i*2:2+i*2];\n                        if (debug_csr == `LM32_CSR_WP0 + i)\n                            wp[i] <= #1 debug_csr_write_data;\n                    end\n                end  \n            end\n        end\n    endgenerate\n\n    always @(posedge clk_i `CFG_RESET_SENSITIVITY)\n    begin\n        if (rst_i == `TRUE)\n            dc_re <= #1 `FALSE;\n        else\n        begin\n            if ((debug_csr_write_enable == `TRUE) && (debug_csr == `LM32_CSR_DC))\n                dc_re <= #1 debug_csr_write_data[1];\n        end\n    end    \n\n    always @(posedge clk_i `CFG_RESET_SENSITIVITY)\n    begin\n        if (rst_i == `TRUE)\n        begin\n            state <= #1 `LM32_DEBUG_SS_STATE_IDLE;\n            dc_ss <= #1 `FALSE;\n        end\n        else\n        begin\n            if ((debug_csr_write_enable == `TRUE) && (debug_csr == `LM32_CSR_DC))\n            begin\n                dc_ss <= #1 debug_csr_write_data[0];\n                if (debug_csr_write_data[0] == `FALSE) \n                    state <= #1 `LM32_DEBUG_SS_STATE_IDLE;\n                else \n                    state <= #1 `LM32_DEBUG_SS_STATE_WAIT_FOR_RET;\n            end\n            case (state)\n                `LM32_DEBUG_SS_STATE_WAIT_FOR_RET:\n                begin\n                    if (   (   (eret_q_x == `TRUE)\n                            || (bret_q_x == `TRUE)\n                            )\n                        && (stall_x == `FALSE)\n                    )\n                        state <= #1 `LM32_DEBUG_SS_STATE_EXECUTE_ONE_INSN; \n                end\n                `LM32_DEBUG_SS_STATE_EXECUTE_ONE_INSN:\n                begin\n                    if ((q_x == `TRUE) && (stall_x == `FALSE))\n                        state <= #1 `LM32_DEBUG_SS_STATE_RAISE_BREAKPOINT;\n                end\n                `LM32_DEBUG_SS_STATE_RAISE_BREAKPOINT:\n                begin\n                    `ifdef CFG_DCACHE_ENABLED\n                    if (dcache_refill_request == `TRUE)\n                        state <= #1 `LM32_DEBUG_SS_STATE_EXECUTE_ONE_INSN;\n                    else \n                    `endif\n                    if ((exception_x == `TRUE) && (q_x == `TRUE) && (stall_x == `FALSE))\n                    begin\n                        dc_ss <= #1 `FALSE;\n                        state <= #1 `LM32_DEBUG_SS_STATE_RESTART;\n                    end\n                end\n                `LM32_DEBUG_SS_STATE_RESTART:\n                begin\n                    `ifdef CFG_DCACHE_ENABLED\n                    if (dcache_refill_request == `TRUE)\n                        state <= #1 `LM32_DEBUG_SS_STATE_EXECUTE_ONE_INSN;\n                    else \n                    `endif\n                        state <= #1 `LM32_DEBUG_SS_STATE_IDLE;\n                end\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": 1694, "completion": "(* altera_attribute = {\"-name SYNCHRONIZER_IDENTIFICATION FORCED_IF_ASYNCHRONOUS; -name GLOBAL_SIGNAL OFF\"}*) reg\t[RESET_SYNC_STAGES+NUM_RESET_OUTPUT-2:0] reset_reg /*synthesis dont_merge */;\n\ngenerate\ngenvar i;\n\tfor (i=0; i<RESET_SYNC_STAGES+NUM_RESET_OUTPUT-1; i=i+1)\n\tbegin: reset_stage\n\t\talways @(posedge clk or negedge reset_n)\n\t\tbegin\n\t\t\tif (~reset_n)\n\t\t\t\treset_reg[i] <= 1'b0;\n\t\t\telse\n\t\t\tbegin\n\t\t\t\tif (i==0)\n\t\t\t\t\treset_reg[i] <= 1'b1;\n\t\t\t\telse if (i < RESET_SYNC_STAGES)\n\t\t\t\t\treset_reg[i] <= reset_reg[i-1];\n\t\t\t\telse\n\t\t\t\t\treset_reg[i] <= reset_reg[RESET_SYNC_STAGES-2];\n\t\t\t\t\n\t\t\tend\n\t\tend\n\tendgenerate\n\n\tassign reset_n_sync = reset_reg[RESET_SYNC_STAGES+NUM_RESET_OUTPUT-2:RESET_SYNC_STAGES-1];\n\nendmodule"}
{"task_id": 1549, "completion": "parameter opcod_st = 3'h0;  parameter modrm_st = 3'h1;  parameter offse_st = 3'h2;  parameter immed_st = 3'h3;  parameter execu_st = 3'h4;  reg  [2:0] state;  wire [2:0] next_state;  wire prefix, repz_pr, sovr_pr, lock_pr;  wire next_in_opco, next_in_exec;  reg [7:0] opcode_l, modrm_l;  reg [1:0] pref_l;  reg       lock_l;  zet_next_or_not next_or_not(pref_l, opcode[7:1], cx_zero, zf, ext_int, next_in_opco, next_in_exec);  zet_nstate nstate (state, prefix, need_modrm, need_off, need_imm, end_seq, ftype, of, next_in_opco, next_in_exec, block, div_exc, tflm, intr, iflm, nmir, iflss, next_state);  assign pc = (cs << 4) + ip;  assign opcode = (state == opcod_st) ? data[7:0] : opcode_l;  assign modrm  = (state == modrm_st) ? data[7:0] : modrm_l;  assign bytefetch = (state == offse_st) ? ~off_size                   : ((state == immed_st) ? ~imm_size : 1'b1);  assign exec_st = (state == execu_st);  assign imm_f = ((state == offse_st) & off_size               | (state == immed_st) & imm_size) ? 16'd2                : 16'd1;  assign wr_ip0 = (state == opcod_st) && !pref_l[1] && !sop_l[2] && !lock_l;  assign sovr_pr = (opcode[7:5]==3'b001 && opcode[2:0]==3'b110);  assign repz_pr = (opcode[7:1]==7'b1111_001);  assign lock_pr = (opcode[7:0]==8'b1111_0000);  assign prefix  = sovr_pr || repz_pr || lock_pr;  assign ld_base = (next_state == execu_st);  assign rep     = pref_l[1];  always @(posedge clk)    if (rst)      begin        state <= execu_st;        opcode_l <= `OP_NOP;      end    else if (!block)      case (next_state)        default:  // opcode or prefix          begin            case (state)              opcod_st:                begin                  pref_l <= repz_pr ? { 1'b1, opcode[0] }                          : next_in_opco ? 2'b0 : pref_l;                  sop_l  <= sovr_pr ? { 1'b1, opcode[4:3] }                          : next_in_opco ? 3'b0 : sop_l;                  lock_l <= lock_pr ? 1'b1                          : next_in_opco ? 1'b0 : lock_l;                end              default: begin pref_l <= 2'b0; sop_l <= 3'b0; lock_l <= 1'b0; end            endcase            state <= opcod_st;            off_l <= 16'd0;            modrm_l <= 8'b0000_0110;          end        modrm_st:  // modrm          begin            opcode_l  <= data[7:0];            state <= modrm_st;          end        offse_st:  // offset          begin            case (state)              opcod_st: opcode_l <= data[7:0];              default: modrm_l <= data[7:0];            endcase            state <= offse_st;          end        immed_st:  // immediate          begin            case (state)              opcod_st: opcode_l <= data[7:0];              modrm_st: modrm_l <= data[7:0];              default: off_l <= data;            endcase            state <= immed_st;          end        execu_st:  // execute          begin            case (state)              opcod_st: opcode_l <= data[7:0];              modrm_st: modrm_l <= data[7:0];              offse_st: off_l <= data;              immed_st: imm_l <= data;            endcase            state <= execu_st;          end      endcase  endmodule"}
{"task_id": 466, "completion": "wire [7:0] signal_wire0 = 8'b0;\n\twire signal_wire1 = 1'b0;\n\twire signal_wire2 = 1'b0;\n\twire signal_wire3 = 1'b0;\n\twire signal_wire4 = 1'b0;\n\twire signal_wire5 = 1'b0;\n\twire [15:0] signal_wire6 = 16'b0;\n\twire [1:0] signal_wire7 = 2'b0;\n\twire [2:0] signal_wire8 = 3'b0;\n\twire [6:0] signal_wire9 = 7'b0;\n\twire signal_wire10 = 1'b1;\n\t...\n\taltpcie_hip_pipen1b\taltpcie_hip_pipen1b_inst(\n\t\t.AvlClk_i(AvlClk_i),\n\t\t.CraAddress_i(CraAddress_i),\n\t\t.CraByteEnable_i(CraByteEnable_i),\n\t\t.CraChipSelect_i(CraChipSelect_i),\n\t\t.CraRead(CraRead),\n\t\t.CraWrite(CraWrite),\n\t\t.CraWriteData_i(CraWriteData_i),\n\t\t.Rstn_i(Rstn_i),\n\t\t.RxmIrqNum_i(RxmIrqNum_i),\n\t\t.RxmIrq_i(RxmIrq_i),\n\t\t.RxmReadDataValid_i(RxmReadDataValid_i),\n\t\t.RxmReadData_i(RxmReadData_i),\n\t\t.RxmWaitRequest_i(RxmWaitRequest_i),\n\t\t.TxsAddress_i(TxsAddress_i),\n\t\t.TxsBurstCount_i(TxsBurstCount_i),\n\t\t.TxsByteEnable_i(TxsByteEnable_i),\n\t\t.TxsChipSelect_i(TxsChipSelect_i),\n\t\t.TxsRead_i(TxsRead_i),\n\t\t.TxsWriteData_i(TxsWriteData_i),\n\t\t.TxsWrite_i(TxsWrite_i),\n\t\t...\n\t);\n\t\n\tdefparam\n\t\taltpcie_hip_pipen1b_inst.p_pcie_hip_type = \"0\",\n\t\taltpcie_hip_pipen1b_inst.retry_buffer_last_active_address = \"2047\",\n\t\t...\nendmodule"}
{"task_id": 1649, "completion": "wire [`ADDER_WIDTH+3-1:0] sum0;\n    wire [`ADDER_WIDTH+2-1:0] sum0_0, sum0_1;\n    wire [`ADDER_WIDTH+1-1:0] sum0_0_0, sum0_0_1, sum0_1_0, sum0_1_1;\n    reg  [`ADDER_WIDTH+0-1:0] sum0_0_0_0, sum0_0_0_1, sum0_0_1_0, sum0_0_1_1, sum0_1_0_0, sum0_1_0_1, sum0_1_1_0, sum0_1_1_1;\n\n    adder_tree_branch L1_0(sum0_0,     sum0_1,     sum0    );\n    defparam L1_0.EXTRA_BITS = 2;\n\n    adder_tree_branch L2_0(sum0_0_0,   sum0_0_1,   sum0_0  );\n    adder_tree_branch L2_1(sum0_1_0,   sum0_1_1,   sum0_1  );\n    defparam L2_0.EXTRA_BITS = 1;\n    defparam L2_1.EXTRA_BITS = 1;\n\n    adder_tree_branch L3_0(sum0_0_0_0, sum0_0_0_1, sum0_0_0);\n    adder_tree_branch L3_1(sum0_0_1_0, sum0_0_1_1, sum0_0_1);\n    adder_tree_branch L3_2(sum0_1_0_0, sum0_1_0_1, sum0_1_0);\n    adder_tree_branch L3_3(sum0_1_1_0, sum0_1_1_1, sum0_1_1);\n    defparam L3_0.EXTRA_BITS = 0;\n    defparam L3_1.EXTRA_BITS = 0;\n    defparam L3_2.EXTRA_BITS = 0;\n    defparam L3_3.EXTRA_BITS = 0;\n\n    always @(posedge clk) begin\n        sum0_0_0_0 <= isum0_0_0_0;\n        sum0_0_0_1 <= isum0_0_0_1;\n        sum0_0_1_0 <= isum0_0_1_0;\n        sum0_0_1_1 <= isum0_0_1_1;\n        sum0_1_0_0 <= isum0_1_0_0;\n        sum0_1_0_1 <= isum0_1_0_1;\n        sum0_1_1_0 <= isum0_1_1_0;\n        sum0_1_1_1 <= isum0_1_1_1;\n\n        `ifdef 3_LEVEL_ADDER\n            sum <= sum0;\n        `endif\n        `ifdef 2_LEVEL_ADDER\n            sum <= sum0_0;\n        `endif\n    }\n\nendmodule\n\nmodule adder_tree_branch(a,b,sum);\n\tparameter EXTRA_BITS = 0;\n\n\tinput [`ADDER_WIDTH+EXTRA_BITS-1:0] a;\n\tinput [`ADDER_WIDTH+EXTRA_BITS-1:0] b;\n\toutput [`ADDER_WIDTH+EXTRA_BITS:0] sum;\n\n\tassign sum = a + b;\nendmodule"}
{"task_id": 1695, "completion": "always @(Aval or Bval or cin or op) begin\n      case(op)\n\t2'b00 : {cout, ALUout} = Aval + Bval;\n\t2'b10 : {cout, ALUout} = {1'b0, Aval & Bval};\n\n\t2'b01 : {cout, ALUout} = 9'h100 ^ (Aval + Bval + 9'h001);\n\t2'b11 : {cout, ALUout} = {1'b0, 8'b1 << Bval};\n      endcase\n   end // always @ (Aval or Bval or cin or op)\nendmodule"}
{"task_id": 1660, "completion": "localparam RESET_CRC_CR = 6'h00;\nlocalparam CRC_DR = 3'h0;\nlocalparam CRC_IDR = 3'h1;\nlocalparam CRC_CR = 3'h2;\nlocalparam CRC_INIT = 3'h4;\nlocalparam CRC_POL = 3'h5;\nlocalparam IDLE = 2'b00;\nlocalparam BUSY = 2'b01;\nlocalparam NON_SEQ = 2'b10;\nlocalparam SEQ = 2'b11;\nlocalparam OK = 1'b0;\nlocalparam ERROR = 1'b1;\nreg [2:0] haddr_pp;\nreg [2:0] hsize_pp;\nreg [1:0] htrans_pp;\nreg hwrite_pp;\nreg hselx_pp;\nreg [4:0] crc_cr_ff;\nwire [31:0] crc_cr_rd;\nwire crc_dr_sel;\nwire crc_init_sel;\nwire crc_idr_sel;\nwire crc_poly_sel;\nwire crc_cr_sel;\nwire ahb_enable;\nwire write_en;\nwire read_en;\nwire crc_cr_en;\nwire sample_bus;\nwire buffer_read_en;\nalways @(posedge HCLK) begin\n\tif(!HRESETn) begin\n\t\thselx_pp <= 1'b0;\n\tend else if(sample_bus) begin\n\t\thaddr_pp <= HADDR[4:2];\n\t\thsize_pp <= HSIZE;\n\t\thtrans_pp <= HTRANS;\n\t\thwrite_pp <= HWRITE;\n\t\thselx_pp <= HSElx;\n\tend\nend\nassign ahb_enable = (htrans_pp == NON_SEQ);\nassign write_en = hselx_pp &&  hwrite_pp && ahb_enable;\nassign read_en = hselx_pp && !hwrite_pp && ahb_enable;\nassign crc_dr_sel = (haddr_pp == CRC_DR);\nassign crc_init_sel = (haddr_pp == CRC_INIT);\nassign crc_idr_sel = (haddr_pp == CRC_IDR);\nassign crc_poly_sel = (haddr_pp == CRC_POL);\nassign crc_cr_sel = (haddr_pp == CRC_CR);\nassign buffer_write_en = crc_dr_sel && write_en;\nassign crc_init_en = crc_init_sel && write_en;\nassign crc_idr_en = crc_idr_sel && write_en;\nassign crc_poly_en = crc_poly_sel && write_en;\nassign crc_cr_en = crc_cr_sel && write_en;\nassign buffer_read_en = crc_dr_sel && read_en;\nassign bus_size = hsize_pp;\nassign bus_wr = HWDATA;\nassign HREADYOUT = !((buffer_write_en && buffer_full) || (buffer_read_en && read_wait) || (crc_init_en && reset_pending));\nassign sample_bus = HREADYOUT && HREADY;\nassign HRESP = OK;\nassign crc_cr_rd = {24'h0, crc_cr_ff[4:0], 3'h0};\nassign HRDATA = ({32{crc_dr_sel}} & crc_out) |\n\t\t\t\t({32{crc_init_sel}} & crc_init_out) |\n\t\t\t\t({32{crc_idr_sel}} & {24'h0, crc_idr_out}) |\n\t\t\t\t({32{crc_poly_sel}} & crc_poly_out) |\n\t\t\t\t({32{crc_cr_sel}} & crc_cr_rd);\nalways @(posedge HCLK) begin\n\tif(!HRESETn) crc_cr_ff <= RESET_CRC_CR;\n\telse if(crc_cr_en) crc_cr_ff <= {HWDATA[7], HWDATA[6:5], HWDATA[4:3]};\nend\nassign reset_chain = (crc_cr_en && HWDATA[0]);\nassign crc_poly_size = crc_cr_ff[1:0];\nassign rev_in_type = crc_cr_ff[3:2];\nassign rev_out_type = crc_cr_ff[4];\nendmodule"}
{"task_id": 1690, "completion": "reg [2:0] tri_i_out_demux;\n    assign {scl_i_in,sda_i_in, tri_i_in} = tri_i_out_demux;\n\n    always @(gpio_sel, tri_o_in, scl_o_in, sda_o_in)\n       case (gpio_sel)\n          2'h0: tri_o_out = tri_o_in;\n          2'h1: tri_o_out = tri_o_in;\n          2'h2: tri_o_out = sda_o_in;\n          2'h3: tri_o_out = scl_o_in;\n       endcase\n\n    always @(gpio_sel, tri_i_out)\n    begin\n       tri_i_out_demux = {3{1'b0}};\n       case (gpio_sel)\n          2'h0: tri_i_out_demux[0] = tri_i_out;\n          2'h1: tri_i_out_demux[0] = tri_i_out;\n          2'h2: tri_i_out_demux[1] = tri_i_out;\n          2'h3: tri_i_out_demux[2] = tri_i_out;\n       endcase\n    end\n\n    always @(gpio_sel, tri_t_in, scl_t_in, sda_t_in)\n       case (gpio_sel)\n          2'h0: tri_t_out = tri_t_in;\n          2'h1: tri_t_out = tri_t_in;\n          2'h2: tri_t_out = sda_t_in;\n          2'h3: tri_t_out = scl_t_in;\n       endcase\n\nendmodule"}
{"task_id": 1542, "completion": "integer  cyc = 0;\n   reg [63:0]  crc;\n   reg [63:0]  sum;\n\n   bit [4*32-1:0] w4 = {32'h7c709753, 32'hbc8f6059, 32'h3b0db464, 32'h721a8fad};\n\n   bit [8*32-2:0] w8m = {31'h7146e1bf, 32'ha8549e42, 32'hca6960bd, 32'h191b7f9b, 32'h93d79866, 32'hf4489e2b, 32'h8e9a3236, 32'h1d2a2d1d};\n\n   bit [8*32-1:0] w8 = {32'hc211addc, 32'he5d4a057, 32'h5cbf88fe, 32'h42cf42e2, 32'heb584263, 32'ha585f118, 32'h231531c8, 32'hc73f7b06};\n\n   bit [8*32-0:0] w8p = {1'b1, 32'h096aa54b, 32'h48aae18e, 32'hf9502cea, 32'h518c8b61, 32'h9e8641a2, 32'h0dc0249c, 32'hd421a87a, 32'hb8ee9199};\n\n   bit [9*32-1:0] w9 = {32'hca800ac1,\n\t\t\t32'h0de4823a, 32'ha51663ac, 32'h96351446, 32'h6b0bbcd5, 32'h4a64b530, 32'h4967d59a, 32'hfcc17292, 32'h57926621};\n\n   bit [16*32-2:0] w16m = {31'h77ad72c7, 32'h73aa9cbb, 32'h7ecf026d, 32'h985a3ed2, 32'hfe961c1d, 32'h7a01df72, 32'h79e13d71, 32'hb69e2e32,\n\t\t\t32'h09fcbc45, 32'hcfd738c1, 32'hc197ac7c, 32'hc316d727, 32'h903034e4, 32'h92a047d1, 32'h6a5357af, 32'ha82ce9c8};\n\n   bit [16*32-1:0] w16 = {32'he49548a7, 32'ha02336a2, 32'h2bb48f0d, 32'h9974e098, 32'h34ae644f, 32'hca46dc2c, 32'h9f71a468, 32'h64ae043e,\n\t\t\t32'h7bc94d66, 32'h57aba588, 32'h5b9bb4fe, 32'hb87ed644, 32'hd34b5b20, 32'h712928de, 32'h4bdbd28e, 32'ha0576784};\n\n   bit [16*32-0:0] w16p = {1'b1, 32'hd278a306, 32'h374ce262, 32'hb608c88e, 32'h43d3e446, 32'h42e26866, 32'h44c31148, 32'hd3db659f, 32'hb3b84b2e,\n\t\t\t32'h1aa7a184, 32'h73b28538, 32'h6384e801, 32'h98d58e00, 32'h9c1d1429, 32'hb407730e, 32'he974c1fd, 32'he787c302};\n\n   bit [17*32-1:0] w17 = {32'hf1e322ac,\n\t\t\t32'hbbdbd761, 32'h760fe07d, 32'h3808cb28, 32'haf313051, 32'h37dc63b9, 32'hdddb418b, 32'he65a9d64, 32'hc1b6ab23,\n\t\t\t32'h11131ac1, 32'h0050e0bc, 32'h442e3754, 32'h0eb4556e, 32'hd153064b, 32'h41349f97, 32'hb6f4149f, 32'h34bb1fb1};\n\n   function [7:0] bytehash (input [32*32-1:0] data);\n      integer i;\n      bytehash = 0;\n      for (i=0; i<32*32; ++i) begin\n\t bytehash = {bytehash[0], bytehash[7:1]} ^ data[i +: 8];\n      end\n      return bytehash;\n   endfunction\n\n   wire [63:0] result = (bytehash(w4)\n\t\t\t ^ bytehash(w8m)\n\t\t\t ^ bytehash(w8)\n\t\t\t ^ bytehash(w8p)\n\t\t\t ^ bytehash(w9)\n\t\t\t ^ bytehash(w16m)\n\t\t\t ^ bytehash(w16)\n\t\t\t ^ bytehash(w16p)\n\t\t\t ^ bytehash(w17));\n\n`define EXPECTED_SUM 64'h2bc7c2a98a302891\n\n   always @ (posedge clk) begin\n`ifdef TEST_VERBOSE\n      $write(\"[%0t] cyc==%0d crc=%x result=%x\\n\", $time, cyc, crc, result);\n`endif\n      cyc <= cyc + 1;\n      crc <= {crc[62:0], crc[63] ^ crc[2] ^ crc[0]};\n      sum <= result ^ {sum[62:0], sum[63] ^ sum[2] ^ sum[0]};\n      if (cyc==0) begin\n\t crc <= 64'h5aef0c8d_d70a4497;\n         `checkhw(w4,3,32'h7c709753);\n         `checkhw(w4,2,32'hbc8f6059);\n         `checkhw(w4,1,32'h3b0db464);\n         `checkhw(w4,0,32'h721a8fad);\n         `checkhw(w8m,7,31'h7146e1bf);\n         `checkhw(w8m,6,32'ha8549e42);\n         `checkhw(w8m,5,32'hca6960bd);\n         `checkhw(w8m,4,32'h191b7f9b);\n         `checkhw(w8m,3,32'h93d79866);\n         `checkhw(w8m,2,32'hf4489e2b);\n         `checkhw(w8m,1,32'h8e9a3236);\n         `checkhw(w8m,0,32'h1d2a2d1d);\n         `checkhw(w8,7,32'hc211addc);\n         `checkhw(w8,6,32'he5d4a057);\n         `checkhw(w8,5,32'h5cbf88fe);\n         `checkhw(w8,4,32'h42cf42e2);\n         `checkhw(w8,3,32'heb584263);\n         `checkhw(w8,2,32'ha585f118);\n         `checkhw(w8,1,32'h231531c8);\n         `checkhw(w8,0,32'hc73f7b06);\n         `checkhw(w8p,8,1'b1);\n         `checkhw(w8p,7,32'h096aa54b);\n         `checkhw(w8p,6,32'h48aae18e);\n         `checkhw(w8p,5,32'hf9502cea);\n         `checkhw(w8p,4,32'h518c8b61);\n         `checkhw(w8p,3,32'h9e8641a2);\n         `checkhw(w8p,2,32'h0dc0249c);\n         `checkhw(w8p,1,32'hd421a87a);\n         `checkhw(w8p,0,32'hb8ee9199);\n         `checkhw(w9,8,32'hca800ac1);\n         `checkhw(w9,7,32'h0de4823a);\n         `checkhw(w9,6,32'ha51663ac);\n         `checkhw(w9,5,32'h96351446);\n         `checkhw(w9,4,32'h6b0bbcd5);\n         `checkhw(w9,3,32'h4a64b530);\n         `checkhw(w9,2,32'h4967d59a);\n         `checkhw(w9,1,32'hfcc17292);\n         `checkhw(w9,0,32'h57926621);\n         `checkhw(w16m,15,31'h77ad72c7);\n         `checkhw(w16m,14,32'h73aa9cbb);\n         `checkhw(w16m,13,32'h7ecf026d);\n         `checkhw(w16m,12,32'h985a3ed2);\n         `checkhw(w16m,11,32'hfe961c1d);\n         `checkhw(w16m,10,32'h7a01df72);\n         `checkhw(w16m,9,32'h79e13d71);\n         `checkhw(w16m,8,32'hb69e2e32);\n         `checkhw(w16m,7,32'h09fcbc45);\n         `checkhw(w16m,6,32'hcfd738c1);\n         `checkhw(w16m,5,32'hc197ac7c);\n         `checkhw(w16m,4,32'hc316d727);\n         `checkhw(w16m,3,32'h903034e4);\n         `checkhw(w16m,2,32'h92a047d1);\n         `checkhw(w16m,1,32'h6a5357af);\n         `checkhw(w16m,0,32'ha82ce9c8);\n      end\n      else if (cyc<10) begin\n\t sum <= 64'h0;\n      end\n      else if (cyc<90) begin\n\t w4   = w4   >>> 1;\n\t w8m  = w8m  >>> 1;\n\t w8   = w8   >>> 1;\n\t w8p  = w8p  >>> 1;\n\t w9   = w9   >>> 1;\n\t w16m = w16m >>> 1;\n\t w16  = w16  >>> 1;\n\t w16p = w16p >>> 1;\n\t w17  = w17  >>> 1;\n      end\n      else if (cyc==99) begin\n\t $write(\"[%0t] cyc==%0d crc=%x sum=%x\\n\", $time, cyc, crc, sum);\n\t if (crc !== 64'hc77bb9b3784ea091) $stop;\n\t if (sum !== `EXPECTED_SUM) $stop;\n\t $write(\"*-* All Finished *-*\\n\");\n\t $finish;\n      end\n   end\n\nendmodule"}
{"task_id": 1706, "completion": "reg [12:2] jump_index_addr_reg;\nassign jump_index_addr = jump_index_addr_reg;\n\nreg [31:0] jump_bblock_reg;\nreg [31:0] jump_bblock_reg_tmp;\nassign jump_bblock = jump_bblock_reg;\n\nalways @(posedge core_sp_clk)\nbegin\n\tif(reset) begin\n\t\tjump_index_addr_reg <= 0;\n\t\tjump_bblock_reg <= 32'b00000000000000000000000000000001;\n\tend else begin\n\t\tif ((fifo_pr_bblock == previous_bblock) || ((fifo_pr_bblock+1'b1) == previous_bblock) || ((fifo_pr_bblock-1'b1) == previous_bblock)) begin\n\t\t\tjump_index_addr_reg <= 0;\n\t\t\tjump_bblock_reg_tmp <= 32'b00000000000000000000000000000001;\n\t\tend else begin\n\t\t\tjump_index_addr_reg <= fifo_pr_nhop[12:2];\n\t\t\tjump_bblock_reg_tmp <= previous_bblock;\n\t\tend\n\t\tjump_bblock_reg <= jump_bblock_reg_tmp;\n\tend        \nend\n\nendmodule"}
{"task_id": 1603, "completion": "wire rc_start;\n    wire rc_bop;\n    wire [31:0] rc_baddr;\n    wire [31:0] rc_bsize;\n    wire rc_done;\n    wire ma_req;\n    wire xbm_gnt;\n    wire ma_select;\n    wire [31:0] ma_addr;\n    wire [31:0] ma_data;\n    wire ma_rnw;\n    wire [3:0] ma_be;\n    wire xbm_ack;\n    wire [31:0] xbm_data;\n\n    icapi_regs #(\n        .C_DWIDTH ( C_SPLB_NATIVE_DWIDTH ),\n        .C_MEM_BASEADDR ( C_MEM_BASEADDR ),\n        .C_MEM_HIGHADDR ( C_MEM_HIGHADDR )\n    ) icapi_regs_0 (\n        .Bus2IP_Clk ( Bus2IP_Clk ),\n        .Bus2IP_Reset ( Bus2IP_Reset ),\n        .Bus2IP_Addr ( Bus2IP_Addr ),\n        .Bus2IP_CS ( Bus2IP_CS ),\n        .Bus2IP_RNW ( Bus2IP_RNW ),\n        .Bus2IP_Data ( Bus2IP_Data ),\n        .Bus2IP_BE ( Bus2IP_BE ),\n        .Bus2IP_Burst ( Bus2IP_Burst ),\n        .Bus2IP_BurstLength ( Bus2IP_BurstLength ),\n        .Bus2IP_RdReq ( Bus2IP_RdReq ),\n        .Bus2IP_WrReq ( Bus2IP_WrReq ),\n        .IP2Bus_AddrAck ( IP2Bus_AddrAck ),\n        .IP2Bus_Data ( IP2Bus_Data ),\n        .IP2Bus_RdAck ( IP2Bus_RdAck ),\n        .IP2Bus_WrAck ( IP2Bus_WrAck ),\n        .IP2Bus_Error ( IP2Bus_Error ),\n        .rc_start ( rc_start ),\n        .rc_bop ( rc_bop ),\n        .rc_baddr ( rc_baddr ),\n        .rc_bsize ( rc_bsize ),\n        .rc_done ( rc_done ),\n        .IP2INTC_Irpt ( IP2INTC_Irpt )\n    );\n\n    xbus_masterif #(\n        .C_DWIDTH ( C_MPLB_NATIVE_DWIDTH )\n    ) icapi_masterif_0 (\n        .Bus2IP_Mst_Clk ( Bus2IP_Mst_Clk ),\n        .Bus2IP_Mst_Reset ( Bus2IP_Mst_Reset ),\n        .IP2Bus_MstRd_Req ( IP2Bus_MstRd_Req ),\n        .IP2Bus_MstWr_Req ( IP2Bus_MstWr_Req ),\n        .IP2Bus_Mst_Addr ( IP2Bus_Mst_Addr ),\n        .IP2Bus_Mst_Length ( IP2Bus_Mst_Length ),\n        .IP2Bus_Mst_BE ( IP2Bus_Mst_BE ),\n        .IP2Bus_Mst_Type ( IP2Bus_Mst_Type ),\n        .IP2Bus_Mst_Lock ( IP2Bus_Mst_Lock ),\n        .IP2Bus_Mst_Reset ( IP2Bus_Mst_Reset ),\n        .Bus2IP_Mst_CmdAck ( Bus2IP_Mst_CmdAck ),\n        .Bus2IP_Mst_Cmplt ( Bus2IP_Mst_Cmplt ),\n        .Bus2IP_Mst_Error ( Bus2IP_Mst_Error ),\n        .Bus2IP_Mst_Rearbitrate ( Bus2IP_Mst_Rearbitrate ),\n        .Bus2IP_Mst_Cmd_Timeout ( Bus2IP_Mst_Cmd_Timeout ),\n        .Bus2IP_MstRd_d ( Bus2IP_MstRd_d ),\n        .Bus2IP_MstRd_rem ( Bus2IP_MstRd_rem ),\n        .Bus2IP_MstRd_sof_n ( Bus2IP_MstRd_sof_n ),\n        .Bus2IP_MstRd_eof_n ( Bus2IP_MstRd_eof_n ),\n        .Bus2IP_MstRd_src_rdy_n ( Bus2IP_MstRd_src_rdy_n ),\n        .Bus2IP_MstRd_src_dsc_n ( Bus2IP_MstRd_src_dsc_n ),\n        .IP2Bus_MstRd_dst_rdy_n ( IP2Bus_MstRd_dst_rdy_n ),\n        .IP2Bus_MstRd_dst_dsc_n ( IP2Bus_MstRd_dst_dsc_n ),\n        .IP2Bus_MstWr_d ( IP2Bus_MstWr_d ),\n        .IP2Bus_MstWr_rem ( IP2Bus_MstWr_rem ),\n        .IP2Bus_MstWr_sof_n ( IP2Bus_MstWr_sof_n ),\n        .IP2Bus_MstWr_eof_n ( IP2Bus_MstWr_eof_n ),\n        .IP2Bus_MstWr_src_rdy_n ( IP2Bus_MstWr_src_rdy_n ),\n        .IP2Bus_MstWr_src_dsc_n ( IP2Bus_MstWr_src_dsc_n ),\n        .Bus2IP_MstWr_dst_rdy_n ( Bus2IP_MstWr_dst_rdy_n ),\n        .Bus2IP_MstWr_dst_dsc_n ( Bus2IP_MstWr_dst_dsc_n ),\n        .ma_req ( ma_req ),\n        .xbm_gnt ( xbm_gnt ),\n        .ma_select ( ma_select ),\n        .ma_addr ( ma_addr ),\n        .ma_data ( ma_data ),\n        .ma_rnw ( ma_rnw ),\n        .ma_be ( ma_be ),\n        .xbm_ack ( xbm_ack ),\n        .xbm_data ( xbm_data )\n    );\n\n    icapi #(\n        .C_DWIDTH ( 32 ),\n        .C_RESIM ( C_RESIM ),\n        .C_FAMILY ( C_FAMILY )\n    ) icapi_0 (\n        .clk ( ICAP_Clk ),\n        .rstn ( ~Bus2IP_Reset ),\n        .rc_start ( rc_start ),\n        .rc_bop ( rc_bop ),\n        .rc_baddr ( rc_baddr ),\n        .rc_bsize ( rc_bsize ),\n        .rc_done ( rc_done ),\n        .ma_req ( ma_req ),\n        .xbm_gnt ( xbm_gnt ),\n        .ma_select ( ma_select ),\n        .ma_addr ( ma_addr ),\n        .ma_data ( ma_data ),\n        .ma_rnw ( ma_rnw ),\n        .ma_be ( ma_be ),\n        .xbm_ack ( xbm_ack ),\n        .xbm_data ( xbm_data )\n    );\n\nendmodule"}
{"task_id": 1696, "completion": "wire[ADDR_WIDTH - 1:0] shiftReg_addr ;\n    wire[DATA_WIDTH - 1:0] shiftReg_data, shiftReg_q;\n    reg[ADDR_WIDTH:0] mOutPtr = {(ADDR_WIDTH+1){1'b1}};\n    reg internal_empty_n = 0, internal_full_n = 1;\n\n    assign if_empty_n = internal_empty_n;\n    assign if_full_n = internal_full_n;\n    assign shiftReg_data = if_din;\n    assign if_dout = shiftReg_q;\n\n    always @ (posedge clk) begin\n        if (reset == 1'b1)\n        begin\n            mOutPtr <= ~{ADDR_WIDTH+1{1'b0}};\n            internal_empty_n <= 1'b0;\n            internal_full_n <= 1'b1;\n        end\n        else begin\n            if (((if_read & if_read_ce) == 1 & internal_empty_n == 1) && \n                ((if_write & if_write_ce) == 0 | internal_full_n == 0))\n            begin\n                mOutPtr <= mOutPtr -1;\n                if (mOutPtr == 0)\n                    internal_empty_n <= 1'b0;\n                internal_full_n <= 1'b1;\n            end \n            else if (((if_read & if_read_ce) == 0 | internal_empty_n == 0) && \n                ((if_write & if_write_ce) == 1 & internal_full_n == 1))\n            begin\n                mOutPtr <= mOutPtr +1;\n                internal_empty_n <= 1'b1;\n                if (mOutPtr == DEPTH-2)\n                    internal_full_n <= 1'b0;\n            end \n        end\n    end\n\n    assign shiftReg_addr = mOutPtr[ADDR_WIDTH] == 1'b0 ? mOutPtr[ADDR_WIDTH-1:0]:{ADDR_WIDTH{1'b0}};\n    assign shiftReg_ce = (if_write & if_write_ce) & internal_full_n;\n\n    FIFO_image_filter_src0_data_stream_1_V_shiftReg \n    #(\n        .DATA_WIDTH(DATA_WIDTH),\n        .ADDR_WIDTH(ADDR_WIDTH),\n        .DEPTH(DEPTH))\n    U_FIFO_image_filter_src0_data_stream_1_V_ram (\n        .clk(clk),\n        .data(shiftReg_data),\n        .ce(shiftReg_ce),\n        .a(shiftReg_addr),\n        .q(shiftReg_q));\n\nendmodule"}
{"task_id": 1730, "completion": "reg [3:0] m_cac_state_r;\n\n   reg [2:0] m_cac_sel_r, m_dat_sel_r, m_cac_rw_sel_r;\n\n   reg m_wid1_r;\n   reg [2:0] m_wid3_r;\n   reg [5:2] m_wid4_r_l;\n\n   logic [4:1] logic_four;\n\n   logic [PARAM-1:0] paramed;\n\n`define M 2\n`define L 1\n   parameter MS = 2;\n   parameter LS = 1;\n\n   reg [MS:LS] m_param_r;\n   reg [`M:`L] m_def2_r;\n\n   always @ (posedge clk) begin\n      if (~reset_l) begin\n         m_cac_state_r <= CAC_IDLE;\n         m_cac_sel_r <= CSEL_PF;\n         /*AUTORESET*/\n      end\n      else begin\n         m_wid1_r <= 0;\n         m_wid3_r <= 0;\n         m_wid4_r_l <= 0;\n         m_param_r <= 0;\n         m_def2_r <= 0;\n         logic_four <= 4;\n         paramed <= 1;\n      end\n   end\n\nendmodule"}
{"task_id": 1672, "completion": "reg mgmt_stb_en;\\n\\n    assign mgmt_stb = fml_stb & mgmt_stb_en;\\n    assign mgmt_we = fml_we;\\n    assign mgmt_address = fml_adr[sdram_depth-1:1];\\n\\n    assign fml_ack = data_ack;\\n\\n    always @(posedge sys_clk) begin\\n\\t\\tif(sdram_rst)\\n\\t\\t\\tmgmt_stb_en = 1'b1;\\n\\t\\telse begin\\n\\t\\t\\tif(mgmt_ack)\\n\\t\\t\\t\\tmgmt_stb_en = 1'b0;\\n\\t\\t\\tif(data_ack)\\n\\t\\t\\t\\tmgmt_stb_en = 1'b1;\\n\\t\\tend\\n    end\\n\\nendmodule"}
{"task_id": 1713, "completion": "always @(posedge clk) begin dout <= (dout)+(1); case (({(ctrl)*(sel)})+(0)) 0: dout[31:0] <= din; 1: dout[31:1] <= din; 2: dout[31:2] <= din; 3: dout[31:3] <= din; 4: dout[31:4] <= din; 5: dout[31:5] <= din; 6: dout[31:6] <= din; 7: dout[31:7] <= din; 8: dout[31:8] <= din; 9: dout[31:9] <= din; 10: dout[31:10] <= din; 11: dout[31:11] <= din; 12: dout[31:12] <= din; 13: dout[31:13] <= din; 14: dout[31:14] <= din; 15: dout[31:15] <= din; 16: dout[31:16] <= din; 17: dout[31:17] <= din; 18: dout[31:18] <= din; 19: dout[31:19] <= din; 20: dout[31:20] <= din; 21: dout[31:21] <= din; 22: dout[31:22] <= din; 23: dout[31:23] <= din; 24: dout[31:24] <= din; 25: dout[31:25] <= din; 26: dout[31:26] <= din; 27: dout[31:27] <= din; 28: dout[31:28] <= din; 29: dout[31:29] <= din; 30: dout[31:30] <= din; 31: dout[31:31] <= din; endcase endendmodule"}
{"task_id": 1727, "completion": "function [1:0] func\n     (\n      input [1:0] p0_x,\n      input [1:0] p0_y,\n      input [1:0] p1_x,\n      input [1:0] p1_y,\n      input [1:0] sel);\n\n      reg [1:0]   rx;\n      reg [1:0]   ry;\n\n`ifdef NOT_DEF\n      // This way works\n      rx = sel == 2'b10 ? p1_x : p0_x;\n      ry = sel == 2'b10 ? p1_y : p0_y;\n`else\n      // This way fails to compile\n      if (sel == 2'b10) begin\n         rx = p1_x;\n         ry = p1_y;\n      end\n      else begin\n         rx = p0_x;\n         ry = p0_y;\n      end\n`endif\n      // Note rx and ry are unused\n      //func = rx | ry;  // Also passes\n      func = 0;\n   endfunction\n\n   always @(*) begin\n      two = func(\n                 ten[8 +: 2],\n                 ten[6 +: 2],\n                 ten[4 +: 2],\n                 ten[2 +: 2],\n                 ten[0 +: 2]);\n   end\nendmodule"}
{"task_id": 1733, "completion": "always_comb begin\n      /*AUTORESET*/\n      if (ldBitFromIo | stBitToIo) begin\n         instClass.isBool = 1'b1;\n         instClass.iFunc  = IFUNC_BOOL;\n         instClass.sub.bool = 1'b1;\n         instClass.sub2.sub3.bool = 1'b1;\n      end\n   end\n\n   always_comb begin\n      instClass = '{default:0};     // #1 (see below)\n      /*AUTORESET*/\n      if (ldBitFromIo | stBitToIo) begin\n         instClass.isBool = 1'b1;\n         instClass.iFunc  = IFUNC_BOOL;\n      end\n   end\n\n   always_comb begin\n      instClass.iFunc = IFUNC_ADD;  // #2\n      /*AUTORESET*/\n      if (ldBitFromIo | stBitToIo) begin\n         instClass.isBool = 1'b1;\n         instClass.iFunc  = IFUNC_BOOL;\n      end\n   end\n\n   always_comb begin\n      instClass.sub = '0;\n      instClass.sub2 = '0;\n      /*AUTORESET*/\n      if (ldBitFromIo | stBitToIo) begin\n         instClass.sub.bool = 1'b1;\n         instClass.sub2.sub3.bool = 1'b1;\n         instClass.sub3.sub4.bool = 1'b1;\n      end\n   end\nendmodule"}
{"task_id": 1520, "completion": "reg [dw-1:0] COEFFICIENT_0; reg [dw-1:0] COEFFICIENT_1; reg [dw-1:0] COEFFICIENT_2; reg [dw-1:0] COEFFICIENT_3; reg [dw-1:0] COEFFICIENT_4; reg [dw-1:0] COEFFICIENT_5; reg [dw-1:0] COEFFICIENT_6; reg [dw-1:0] COEFFICIENT_7; reg [dw-1:0] COEFFICIENT_8; reg [dw-1:0] COEFFICIENT_9; reg [dw-1:0] COEFFICIENT_10; reg [dw-1:0] COEFFICIENT_11; reg [dw-1:0] COEFFICIENT_12; always@(posedge clk) begin COEFFICIENT_0 <= 18'd88; COEFFICIENT_1 <= 18'd0; COEFFICIENT_2 <= -18'd97; COEFFICIENT_3 <= -18'd197; COEFFICIENT_4 <= -18'd294; COEFFICIENT_5 <= -18'd380; COEFFICIENT_6 <= -18'd447; COEFFICIENT_7 <= -18'd490; COEFFICIENT_8 <= -18'd504; COEFFICIENT_9 <= -18'd481; COEFFICIENT_10 <= -18'd420; COEFFICIENT_11 <= -18'd319; COEFFICIENT_12 <= -18'd178; end reg [N_VALID_REGS-1:0] VALID_PIPELINE_REGS; always@(posedge clk or posedge reset) begin if(reset) begin VALID_PIPELINE_REGS <= 0; end else begin if(clk_ena) begin VALID_PIPELINE_REGS <= {VALID_PIPELINE_REGS[N_VALID_REGS-2:0], i_valid}; end else begin VALID_PIPELINE_REGS <= VALID_PIPELINE_REGS; end end end wire [dw-1:0] INPUT_PIPELINE_REG_0; wire [dw-1:0] INPUT_PIPELINE_REG_1; wire [dw-1:0] INPUT_PIPELINE_REG_2; wire [dw-1:0] INPUT_PIPELINE_REG_3; wire [dw-1:0] INPUT_PIPELINE_REG_4; wire [dw-1:0] INPUT_PIPELINE_REG_5; wire [dw-1:0] INPUT_PIPELINE_REG_6; wire [dw-1:0] INPUT_PIPELINE_REG_7; wire [dw-1:0] INPUT_PIPELINE_REG_8; wire [dw-1:0] INPUT_PIPELINE_REG_9; wire [dw-1:0] INPUT_PIPELINE_REG_10; wire [dw-1:0] INPUT_PIPELINE_REG_11; wire [dw-1:0] INPUT_PIPELINE_REG_12; wire [dw-1:0] INPUT_PIPELINE_REG_13; wire [dw-1:0] INPUT_PIPELINE_REG_14; wire [dw-1:0] INPUT_PIPELINE_REG_15; wire [dw-1:0] INPUT_PIPELINE_REG_16; wire [dw-1:0] INPUT_PIPELINE_REG_17; wire [dw-1:0] INPUT_PIPELINE_REG_18; wire [dw-1:0] INPUT_PIPELINE_REG_19; wire [dw-1:0] INPUT_PIPELINE_REG_20; wire [dw-1:0] INPUT_PIPELINE_REG_21; wire [dw-1:0] INPUT_PIPELINE_REG_22; wire [dw-1:0] INPUT_PIPELINE_REG_23; wire [dw-1:0] INPUT_PIPELINE_REG_24; input_pipeline in_pipe( .clk(clk), .clk_ena(clk_ena), .in_stream(i_in), .pipeline_reg_0(INPUT_PIPELINE_REG_0), .pipeline_reg_1(INPUT_PIPELINE_REG_1), .pipeline_reg_2(INPUT_PIPELINE_REG_2), .pipeline_reg_3(INPUT_PIPELINE_REG_3), .pipeline_reg_4(INPUT_PIPELINE_REG_4), .pipeline_reg_5(INPUT_PIPELINE_REG_5), .pipeline_reg_6(INPUT_PIPELINE_REG_6), .pipeline_reg_7(INPUT_PIPELINE_REG_7), .pipeline_reg_8(INPUT_PIPELINE_REG_8), .pipeline_reg_9(INPUT_PIPELINE_REG_9), .pipeline_reg_10(INPUT_PIPELINE_REG_10), .pipeline_reg_11(INPUT_PIPELINE_REG_11), .pipeline_reg_12(INPUT_PIPELINE_REG_12), .pipeline_reg_13(INPUT_PIPELINE_REG_13), .pipeline_reg_14(INPUT_PIPELINE_REG_14), .pipeline_reg_15(INPUT_PIPELINE_REG_15), .pipeline_reg_16(INPUT_PIPELINE_REG_16), .pipeline_reg_17(INPUT_PIPELINE_REG_17), .pipeline_reg_18(INPUT_PIPELINE_REG_18), .pipeline_reg_19(INPUT_PIPELINE_REG_19), .pipeline_reg_20(INPUT_PIPELINE_REG_20), .pipeline_reg_21(INPUT_PIPELINE_REG_21), .pipeline_reg_22(INPUT_PIPELINE_REG_22), .pipeline_reg_23(INPUT_PIPELINE_REG_23), .pipeline_reg_24(INPUT_PIPELINE_REG_24), .reset(reset) ); defparam in_pipe.WIDTH = 18; wire [dw-1:0] L0_output_wires_0; wire [dw-1:0] L0_output_wires_1; wire [dw-1:0] L0_output_wires_2; wire [dw-1:0] L0_output_wires_3; wire [dw-1:0] L0_output_wires_4; wire [dw-1:0] L0_output_wires_5; wire [dw-1:0] L0_output_wires_6; wire [dw-1:0] L0_output_wires_7; wire [dw-1:0] L0_output_wires_8; wire [dw-1:0] L0_output_wires_9; wire [dw-1:0] L0_output_wires_10; wire [dw-1:0] L0_output_wires_11; wire [dw-1:0] L0_output_wires_12; adder_with_1_reg L0_adder_0and24(.clk(clk), .clk_ena(clk_ena), .dataa (INPUT_PIPELINE_REG_0), .datab (INPUT_PIPELINE_REG_24), .result(L0_output_wires_0)); adder_with_1_reg L0_adder_1and23(.clk(clk), .clk_ena(clk_ena), .dataa (INPUT_PIPELINE_REG_1), .datab (INPUT_PIPELINE_REG_23), .result(L0_output_wires_1)); adder_with_1_reg L0_adder_2and22(.clk(clk), .clk_ena(clk_ena), .dataa (INPUT_PIPELINE_REG_2), .datab (INPUT_PIPELINE_REG_22), .result(L0_output_wires_2)); adder_with_1_reg L0_adder_3and21(.clk(clk), .clk_ena(clk_ena), .dataa (INPUT_PIPELINE_REG_3), .datab (INPUT_PIPELINE_REG_21), .result(L0_output_wires_3)); adder_with_1_reg L0_adder_4and20(.clk(clk), .clk_ena(clk_ena), .dataa (INPUT_PIPELINE_REG_4), .datab (INPUT_PIPELINE_REG_20), .result(L0_output_wires_4)); adder_with_1_reg L0_adder_5and19(.clk(clk), .clk_ena(clk_ena), .dataa (INPUT_PIPELINE_REG_5), .datab (INPUT_PIPELINE_REG_19), .result(L0_output_wires_5)); adder_with_1_reg L0_adder_6and18(.clk(clk), .clk_ena(clk_ena), .dataa (INPUT_PIPELINE_REG_6), .datab (INPUT_PIPELINE_REG_18), .result(L0_output_wires_6)); adder_with_1_reg L0_adder_7and17(.clk(clk), .clk_ena(clk_ena), .dataa (INPUT_PIPELINE_REG_7), .datab (INPUT_PIPELINE_REG_17), .result(L0_output_wires_7)); adder_with_1_reg L0_adder_8and16(.clk(clk), .clk_ena(clk_ena), .dataa (INPUT_PIPELINE_REG_8), .datab (INPUT_PIPELINE_REG_16), .result(L0_output_wires_8)); adder_with_1_reg L0_adder_9and15(.clk(clk), .clk_ena(clk_ena), .dataa (INPUT_PIPELINE_REG_9), .datab (INPUT_PIPELINE_REG_15), .result(L0_output_wires_9)); adder_with_1_reg L0_adder_10and14(.clk(clk), .clk_ena(clk_ena), .dataa (INPUT_PIPELINE_REG_10), .datab (INPUT_PIPELINE_REG_14), .result(L0_output_wires_10)); adder_with_1_reg L0_adder_11and13(.clk(clk), .clk_ena(clk_ena), .dataa (INPUT_PIPELINE_REG_11), .datab (INPUT_PIPELINE_REG_13), .result(L0_output_wires_11)); one_register L0_byereg_for_12(.clk(clk), .clk_ena(clk_ena), .dataa (INPUT_PIPELINE_REG_12), .result(L0_output_wires_12)); wire [dw-1:0] L1_mult_wires_0; wire [dw-1:0] L1_mult_wires_1; wire [dw-1:0] L1_mult_wires_2; wire [dw-1:0] L1_mult_wires_3; wire [dw-1:0] L1_mult_wires_4; wire [dw-1:0] L1_mult_wires_5; wire [dw-1:0] L1_mult_wires_6; wire [dw-1:0] L1_mult_wires_7; wire [dw-1:0] L1_mult_wires_8; wire [dw-1:0] L1_mult_wires_9; wire [dw-1:0] L1_mult_wires_10; wire [dw-1:0] L1_mult_wires_11; wire [dw-1:0] L1_mult_wires_12; multiplier_with_reg L1_mul_0(.clk(clk), .clk_ena(clk_ena), .dataa (L0_output_wires_0), .datab (COEFFICIENT_0), .result(L1_mult_wires_0)); multiplier_with_reg L1_mul_1(.clk(clk), .clk_ena(clk_ena), .dataa (L0_output_wires_1), .datab (COEFFICIENT_1), .result(L1_mult_wires_1)); multiplier_with_reg L1_mul_2(.clk(clk), .clk_ena(clk_ena), .dataa (L0_output_wires_2), .datab (COEFFICIENT_2), .result(L1_mult_wires_2)); multiplier_with_reg L1_mul_3(.clk(clk), .clk_ena(clk_ena), .dataa (L0_output_wires_3), .datab (COEFFICIENT_3), .result(L1_mult_wires_3)); multiplier_with_reg L1_mul_4(.clk(clk), .clk_ena(clk_ena), .dataa (L0_output_wires_4), .datab (COEFFICIENT_4), .result(L1_mult_wires_4)); multiplier_with_reg L1_mul_5(.clk(clk), .clk_ena(clk_ena), .dataa (L0_output_wires_5), .datab (COEFFICIENT_5), .result(L1_mult_wires_5)); multiplier_with_reg L1_mul_6(.clk(clk), .clk_ena(clk_ena), .dataa (L0_output_wires_6), .datab (COEFFICIENT_6), .result(L1_mult_wires_6)); multiplier_with_reg L1_mul_7(.clk(clk), .clk_ena(clk_ena), .dataa (L0_output_wires_7), .datab (COEFFICIENT_7), .result(L1_mult_wires_7)); multiplier_with_reg L1_mul_8(.clk(clk), .clk_ena(clk_ena), .dataa (L0_output_wires_8), .datab (COEFFICIENT_8), .result(L1_mult_wires_8)); multiplier_with_reg L1_mul_9(.clk(clk), .clk_ena(clk_ena), .dataa (L0_output_wires_9), .datab (COEFFICIENT_9), .result(L1_mult_wires_9)); multiplier_with_reg L1_mul_10(.clk(clk), .clk_ena(clk_ena), .dataa (L0_output_wires_10), .datab (COEFFICIENT_10), .result(L1_mult_wires_10)); multiplier_with_reg L1_mul_11(.clk(clk), .clk_ena(clk_ena), .dataa (L0_output_wires_11), .datab (COEFFICIENT_11), .result(L1_mult_wires_11)); multiplier_with_reg L1_mul_12(.clk(clk), .clk_ena(clk_ena), .dataa (L0_output_wires_12), .datab (COEFFICIENT_12), .result(L1_mult_wires_12)); wire [dw-1:0] L1_output_wires_0; wire [dw-1:0] L1_output_wires_1; wire [dw-1:0] L1_output_wires_2; wire [dw-1:0] L1_output_wires_3; wire [dw-1:0] L1_output_wires_4; wire [dw-1:0] L1_output_wires_5; wire [dw-1:0] L1_output_wires_6; adder_with_1_reg L1_adder_0and1(.clk(clk), .clk_ena(clk_ena), .dataa (L1_mult_wires_0), .datab (L1_mult_wires_1), .result(L1_output_wires_0)); adder_with_1_reg L1_adder_2and3(.clk(clk), .clk_ena(clk_ena), .dataa (L1_mult_wires_2), .datab (L1_mult_wires_3), .result(L1_output_wires_1)); adder_with_1_reg L1_adder_4and5(.clk(clk), .clk_ena(clk_ena), .dataa (L1_mult_wires_4), .datab (L1_mult_wires_5), .result(L1_output_wires_2)); adder_with_1_reg L1_adder_6and7(.clk(clk), .clk_ena(clk_ena), .dataa (L1_mult_wires_6), .datab (L1_mult_wires_7), .result(L1_output_wires_3)); adder_with_1_reg L1_adder_8and9(.clk(clk), .clk_ena(clk_ena), .dataa (L1_mult_wires_8), .datab (L1_mult_wires_9), .result(L1_output_wires_4)); adder_with_1_reg L1_adder_10and11(.clk(clk), .clk_ena(clk_ena), .dataa (L1_mult_wires_10), .datab (L1_mult_wires_11), .result(L1_output_wires_5)); one_register L1_byereg_for_12(.clk(clk), .clk_ena(clk_ena), .dataa (L1_mult_wires_12), .result(L1_output_wires_6)); wire [dw-1:0] L2_output_wires_0; wire [dw-1:0] L2_output_wires_1; wire [dw-1:0] L2_output_wires_2; wire [dw-1:0] L2_output_wires_3; adder_with_1_reg L2_adder_0and1(.clk(clk), .clk_ena(clk_ena), .dataa (L1_output_wires_0), .datab (L1_output_wires_1), .result(L2_output_wires_0)); adder_with_1_reg L2_adder_2and3(.clk(clk), .clk_ena(clk_ena), .dataa (L1_output_wires_2), .datab (L1_output_wires_3), .result(L2_output_wires_1)); adder_with_1_reg L2_adder_4and5(.clk(clk), .clk_ena(clk_ena), .dataa (L1_output_wires_4), .datab (L1_output_wires_5), .result(L2_output_wires_2)); one_register L2_byereg_for_6(.clk(clk), .clk_ena(clk_ena), .dataa (L1_output_wires_6), .result(L2_output_wires_3)); wire [dw-1:0] L3_output_wires_0; wire [dw-1:0] L3_output_wires_1; adder_with_1_reg L3_adder_0and1(.clk(clk), .clk_ena(clk_ena), .dataa (L2_output_wires_0), .datab (L2_output_wires_1), .result(L3_output_wires_0)); adder_with_1_reg L3_adder_2and3(.clk(clk), .clk_ena(clk_ena), .dataa (L2_output_wires_2), .datab (L2_output_wires_3), .result(L3_output_wires_1)); adder_with_1_reg L4_adder_0and1(.clk(clk), .clk_ena(clk_ena), .dataa (L3_output_wires_0), .datab (L3_output_wires_1), .result(L4_output_wires_0)); assign o_out = L4_output_wires_0; assign o_valid = VALID_PIPELINE_REGS[N_VALID_REGS-1]; endmodule"}
{"task_id": 1680, "completion": "reg signed [num_width - 1 : 0] num_orig;\n    reg num_orig_sflag, num_orig_rflag, reg_overflow;\n    reg signed [res_width : 0] num_comp;\n\n    always @(posedge clk) begin\n        num_orig <= fixed_num[num_width - 1] == 0 ? fixed_num : \n            {fixed_num[num_width - 1], ~(fixed_num[num_width - 2 : 0] - 1)};\n        num_comp <= num_orig[num_width - 1] == 0 ? \n            {num_orig[num_width - 1], num_orig[res_width + fixed_pos - 1 : fixed_pos]} : \n            {num_orig[num_width - 1], ~num_orig[res_width + fixed_pos - 1 : fixed_pos] + 1};\n        reg_overflow <= num_orig[num_width - 2 : res_width + fixed_pos] == 0 ? 0 : 1;\n        overflow <= reg_overflow;\n        num_orig_sflag <= num_orig[num_width - 1];\n        num_orig_rflag <= num_orig[fixed_pos - 1];\n        case(num_orig_sflag)\n            0 : round <= num_orig_rflag == 0 ? num_comp : num_comp + 1;\n            1 : round <= num_orig_rflag == 0 ? num_comp : num_comp - 1;\n            default : /* default */;\n        endcase\n    end\n\nendmodule"}
{"task_id": 1739, "completion": "wire signed [12:0] pt;\n\n    wire signed [5:0] ta;\n\n    assign ta = a;\n    assign pt =  b * ta;\n\n    assign p=pt;\n\nendmodule"}
{"task_id": 1431, "completion": "reg [3:0]       dma_state;\n   wire [15:0]     descr;\n   wire [15:0]     fetch_addr;\n   wire [AW-1:0]   srcaddr_out;\n   wire [4:0]      reg_addr;\n   wire            dma_error;\n   wire            incount_zero;\n   wire            outcount_zero;\n\n   `define DMA_IDLE    4'b0000\n   `define DMA_FETCH0  4'b0001\n   `define DMA_FETCH1  4'b0010\n   `define DMA_FETCH2  4'b0011\n   `define DMA_FETCH3  4'b0100\n   `define DMA_FETCH4  4'b0101\n   `define DMA_INNER   4'b0110\n   `define DMA_OUTER   4'b0111\n   `define DMA_DONE    4'b1000\n   `define DMA_ERROR   4'b1001\n   \n   always @ (posedge clk or negedge nreset)\n     if(!nreset)\n       dma_state[3:0] <= `DMA_IDLE;\n     else if(dma_error)\n       dma_state[3:0] <= `DMA_ERROR;\n     else\n       case(dma_state[3:0])\n\t `DMA_IDLE: \n\t   casez({dma_en,manualmode})\n\t     2'b0?  : dma_state[3:0]   <= `DMA_IDLE;\n\t     2'b11  : dma_state[3:0]   <= `DMA_INNER;\n\t     2'b10  : dma_state[3:0]   <= `DMA_FETCH0;\n\t   endcase\n\t `DMA_FETCH0: \n\t   dma_state[3:0] <= reg_wait_in ? `DMA_FETCH0 : `DMA_FETCH1;\n\t `DMA_FETCH1: \n\t   dma_state[3:0] <= reg_wait_in ? `DMA_FETCH1 : `DMA_FETCH2;\n\t `DMA_FETCH2: \n\t   dma_state[3:0] <= reg_wait_in ? `DMA_FETCH2 : `DMA_FETCH3;\n\t `DMA_FETCH3: \n\t   dma_state[3:0] <= reg_wait_in ? `DMA_FETCH3 : `DMA_FETCH3;\n\t `DMA_FETCH4: \n\t   dma_state[3:0] <= reg_wait_in ? `DMA_FETCH4 : `DMA_INNER;\n\t `DMA_INNER:\n\t   casez({update,incount_zero,outcount_zero})\n\t     3'b0?? : dma_state[3:0] <= `DMA_INNER;\n\t     3'b10? : dma_state[3:0] <= `DMA_INNER;\n\t     3'b110 : dma_state[3:0] <= `DMA_OUTER;\n\t     3'b111 : dma_state[3:0] <= `DMA_DONE;\n\t   endcase\n\t `DMA_OUTER:\n\t   dma_state[3:0]   <= update ? `DMA_INNER : `DMA_OUTER;\n\t `DMA_DONE:\n\t   casez({chainmode,manualmode})\n\t     2'b0? : dma_state[3:0]  <= `DMA_DONE;\n\t     2'b11 : dma_state[3:0]  <= `DMA_IDLE;\n\t     2'b10 : dma_state[3:0]  <= `DMA_FETCH0;\n\t   endcase\n\t `DMA_ERROR:\n\t   dma_state[3:0] <= dma_en ? `DMA_ERROR: `DMA_IDLE;\n       endcase\n   assign dma_error     = 1'b0;\n   assign update        = ~wait_in & (master_active | access_in);\n   assign update2d      = update & (dma_state[3:0]==`DMA_OUTER);\n   assign master_active = mastermode & \n\t\t\t   ((dma_state[3:0]==`DMA_INNER) |\n\t\t\t    (dma_state[3:0]==`DMA_OUTER));\n   assign incount_zero  = ~(|count[15:0]);\n   assign outcount_zero = ~(|count[31:16]);\n   assign fetch_access = (dma_state[3:0]==`DMA_FETCH0) |\n\t\t\t    (dma_state[3:0]==`DMA_FETCH1) |\n\t\t\t    (dma_state[3:0]==`DMA_FETCH2);\n   assign  descr[15:0] = (dma_state[3:0]==`DMA_FETCH0) ? next_descr[15:0] :\n\t\t\t\tcurr_descr[15:0];\n   oh_mux3 #(.DW(16))\n   mux3d (.out (fetch_addr[15:0]),\n\t\t  .in0 (descr[15:0]),        .sel0 (dma_state[3:0]==`DMA_FETCH0),\n\t\t  .in1 (descr[15:0]+16'd8),  .sel1 (dma_state[3:0]==`DMA_FETCH1),\n\t\t  .in2 (descr[15:0]+16'd16), .sel2 (dma_state[3:0]==`DMA_FETCH2)\n\t\t  );\n   oh_mux3 #(.DW(5))\n   mux3s (.out (reg_addr[4:0]),\n\t\t  .in0 (`EDMA_CONFIG),  .sel0 (dma_state[3:0]==`DMA_FETCH0),\n\t\t  .in1 (`EDMA_COUNT),   .sel1 (dma_state[3:0]==`DMA_FETCH1),\n\t\t  .in2 (`EDMA_SRCADDR), .sel2 (dma_state[3:0]==`DMA_FETCH2)\n\t\t  );\n   assign srcaddr_out[AW-1:0] = {{(AW-11){1'b0}},  //31-11 \n\t\t\t\t\t    ID,               //10-7\n\t\t\t\t\t    reg_addr[4:0],    //6-2\n\t\t\t\t\t    2'b0};            //1-0\n   emesh2packet #(.AW(AW),\n\t\t\t   .PW(PW))\n   e2p (\n\t\t\t   .packet_out  (fetch_packet[PW-1:0]),\n\t\t\t   .write_out   (1'b0),\n\t\t\t   .datamode_out(2'b11),\n\t\t\t   .ctrlmode_out(5'b0),\n\t\t\t   .dstaddr_out  ({ { (AW-16){1'b0}},fetch_addr[15:0]}),\n\t\t\t   .data_out     ({(AW){1'b0}}),\n\t\t\t   .srcaddr_out  (srcaddr_out[AW-1:0]));\n   endmodule"}
{"task_id": 1746, "completion": "reg [7:0] next_TIMER_VAL;\n   reg next_TIMER_IRQ;\n   \n   always @* begin\n      if (~TIMER_RESETn) begin\n         next_TIMER_VAL <= 8'h00;\n      end\n      else if (TIMER_EN) begin\n         if (TIMER_VAL == TIMER_SAT) begin\n            if (TIMER_ROI) begin\n               next_TIMER_VAL <= 8'h00;\n            end\n            else begin\n               next_TIMER_VAL <= TIMER_VAL;\n            end\n         end\n         else begin\n            next_TIMER_VAL <= TIMER_VAL + 1;\n         end\n      end\n      else begin\n         next_TIMER_VAL <= 8'h00;\n      end\n   end\n\n   always @* begin\n      if (~TIMER_RESETn) begin\n         next_TIMER_IRQ <= 1'b0;\n      end\n      else if (TIMER_CLR_IRQ) begin\n         next_TIMER_IRQ <= 1'b0;\n      end\n      else if ((next_TIMER_VAL == TIMER_SAT) && (next_TIMER_VAL != TIMER_VAL)) begin\n         next_TIMER_IRQ <= 1'b1;\n      end\n   end\n\n   always @(posedge CLK or negedge TIMER_RESETn) begin\n      if (~TIMER_RESETn) begin\n         TIMER_VAL <= `SD 8'h00;\n         TIMER_IRQ <= `SD 1'b0;\n      end\n      else begin\n         TIMER_VAL <= `SD next_TIMER_VAL;\n         TIMER_IRQ <= `SD next_TIMER_IRQ;\n      end\n   end\nendmodule"}
{"task_id": 1724, "completion": "reg [25:0] cuenta_para_1hz;\n  reg [25:0] cuenta_para_2khz;\n  reg clock_2khz;\n  reg [1:0] rotabit;\n  parameter [6:0] cero = 0;\n  parameter [6:0] uno = 0;\n  parameter [6:0] dos = 0;\n  parameter [6:0] tres = 0;\n  always @(posedge clock_50mhz)  begin\n    cuenta_para_1hz = cuenta_para_1hz + 1;\n    if(cuenta_para_1hz == 25_000_000)\n      begin\n          clock_1hz =  ~clock_1hz;\n          cuenta_para_1hz = 0;\n      end\n  end\n  always @(posedge clock_50mhz) begin\n    cuenta_para_2khz = cuenta_para_2khz + 1;\n    if(cuenta_para_2khz == 55_000)\n      begin\n          clock_2khz =  ~clock_2khz;\n          cuenta_para_2khz = 0;\n      end\n  end\n  always @(posedge clock_2khz)\n  begin\n    case(rotabit)\n      0:  rotabit <= 1;\n      1:  rotabit <= 0;\n    endcase\n  end\n  always @(rotabit)\n  begin\n    case(rotabit)\n      0: anodos = 2'b01;\n      1:  anodos= 2'b10;\n    endcase\n  end\n  always @(posedge clock_1hz)\n  begin\n    case(estado)\n      0:  estado <= 1;\n      1:  estado <= 2;\n      2:  estado <= 3;\n      3:  estado <= 4;\n    endcase\n  end\n  always @(estado)\n  begin\n    case(estado)\n      0: segmentos = cero;\n      1: segmentos = uno;\n      2: segmentos = dos;\n      3: segmentos = tres;\n    endcase\n  end\nendmodule"}
{"task_id": 1615, "completion": "parameter FFD       = 1;  reg     [2:0] to_incr         /* synthesis syn_romstyle = \"logic\" */;  reg           add_sub_b       /* synthesis syn_romstyle = \"logic\" */;  reg           add_input_one_d;  reg           add_input_two_n_d;  reg           add_input_three_n_d;  reg           add_input_four_n_d;  reg           add_input_five_n_d;  reg           add_input_six_n_d;  always @(posedge clk)  begin    if (rst) begin      add_input_one_d     <= #FFD 0;      add_input_two_n_d   <= #FFD 1;      add_input_three_n_d <= #FFD 1;      add_input_four_n_d  <= #FFD 1;      add_input_five_n_d  <= #FFD 1;      add_input_six_n_d   <= #FFD 1;    end else begin      add_input_one_d     <= #FFD add_input_one;      add_input_two_n_d   <= #FFD add_input_two_n;      add_input_three_n_d <= #FFD add_input_three_n;      add_input_four_n_d  <= #FFD add_input_four_n;      add_input_five_n_d  <= #FFD add_input_five_n;      add_input_six_n_d   <= #FFD add_input_six_n;    end  end  always @*  begin    case ({add_input_six_n_d, add_input_one_d,    add_input_two_n_d, add_input_three_n_d,     add_input_four_n_d,  add_input_five_n_d})   // synthesis full_case parallel_case    6'b00_0000: begin   to_incr  = 3'b101;                        add_sub_b = 1'b1;                         end                                                6'b00_0001: begin   to_incr  = 3'b100;                        add_sub_b = 1'b1;                         end                                                6'b00_0010: begin   to_incr  = 3'b100;                        add_sub_b = 1'b1;                         end                                                6'b00_0011: begin   to_incr  = 3'b011;                        add_sub_b = 1'b1;                         end                                                6'b00_0100: begin   to_incr  = 3'b100;                        add_sub_b = 1'b1;                         end                                                6'b00_0101: begin   to_incr  = 3'b011;                        add_sub_b = 1'b1;                         end                                                6'b00_0110: begin   to_incr  = 3'b011;                        add_sub_b = 1'b1;                         end                                                6'b00_0111: begin   to_incr  = 3'b010;                      add_sub_b = 1'b1;                         end                                                6'b00_1000: begin   to_incr  = 3'b100;                        add_sub_b = 1'b1;                         end                                                6'b00_1001: begin   to_incr  = 3'b011;                        add_sub_b = 1'b1;                         end                                                6'b00_1010: begin   to_incr  = 3'b011;                        add_sub_b = 1'b1;                         end                                                6'b00_1011: begin   to_incr  = 3'b010;                      add_sub_b = 1'b1;                         end                                                6'b00_1100: begin   to_incr  = 3'b011;                        add_sub_b = 1'b1;                         end                                                6'b00_1101: begin   to_incr  = 3'b010;                      add_sub_b = 1'b1;                         end                                                6'b00_1110: begin   to_incr  = 3'b010;                      add_sub_b = 1'b1;                         end                                                6'b00_1111: begin   to_incr  = 3'b001;                      add_sub_b = 1'b1;                         end                                                6'b01_0000: begin   to_incr  = 3'b110;                        add_sub_b = 1'b1;                end    6'b01_0001: begin   to_incr  = 3'b101;                        add_sub_b = 1'b1;                end    6'b01_0010: begin   to_incr  = 3'b101;                        add_sub_b = 1'b1;                end    6'b01_0011: begin   to_incr  = 3'b100;                        add_sub_b = 1'b1;                end    6'b01_0100: begin   to_incr  = 3'b101;                        add_sub_b = 1'b1;                end    6'b01_0101: begin   to_incr  = 3'b100;                        add_sub_b = 1'b1;                end    6'b01_0110: begin   to_incr  = 3'b100;                        add_sub_b = 1'b1;                end    6'b01_0111: begin   to_incr  = 3'b011;                        add_sub_b = 1'b1;                end    6'b01_1000: begin   to_incr  = 3'b101;                        add_sub_b = 1'b1;                end    6'b01_1001: begin   to_incr  = 3'b100;                        add_sub_b = 1'b1;                end    6'b01_1010: begin   to_incr  = 3'b100;                        add_sub_b = 1'b1;                end    6'b01_1011: begin   to_incr  = 3'b011;                        add_sub_b = 1'b1;                end    6'b01_1100: begin   to_incr  = 3'b100;                        add_sub_b = 1'b1;                end    6'b01_1101: begin   to_incr  = 3'b011;                        add_sub_b = 1'b1;                end    6'b01_1110: begin   to_incr  = 3'b011;                        add_sub_b = 1'b1;                end    6'b01_1111: begin   to_incr  = 3'b010;                        add_sub_b = 1'b1;                end    6'b10_0000: begin   to_incr  = 3'b100;                      add_sub_b = 1'b1;                         end                                                6'b10_0001: begin   to_incr  = 3'b011;                      add_sub_b = 1'b1;                         end                                                6'b10_0010: begin   to_incr  = 3'b011;                      add_sub_b = 1'b1;                         end                                                6'b10_0011: begin   to_incr  = 3'b010;                      add_sub_b = 1'b1;                         end                                                6'b10_0100: begin   to_incr  = 3'b011;                      add_sub_b = 1'b1;                         end                                                6'b10_0101: begin   to_incr  = 3'b010;                      add_sub_b = 1'b1;                         end                                                6'b10_0110: begin   to_incr  = 3'b010;                      add_sub_b = 1'b1;                         end                                                6'b10_0111: begin   to_incr  = 3'b001;                      add_sub_b = 1'b1;                         end                                                6'b10_1000: begin   to_incr  = 3'b011;                      add_sub_b = 1'b1;                         end                                                6'b10_1001: begin   to_incr  = 3'b010;                      add_sub_b = 1'b1;                         end                                                6'b10_1010: begin   to_incr  = 3'b010;                      add_sub_b = 1'b1;                         end                                                6'b10_1011: begin   to_incr  = 3'b001;                      add_sub_b = 1'b1;                         end                                                6'b10_1100: begin   to_incr  = 3'b010;                      add_sub_b = 1'b1;                         end                                                6'b10_1101: begin   to_incr  = 3'b001;                      add_sub_b = 1'b1;                         end                                                6'b10_1110: begin   to_incr  = 3'b001;                      add_sub_b = 1'b1;                         end                                                6'b10_1111: begin   to_incr  = 3'b001;                      add_sub_b = 1'b1;                         end                                                6'b11_0000: begin   to_incr  = 3'b101;                        add_sub_b = 1'b1;                end    6'b11_0001: begin   to_incr  = 3'b100;                        add_sub_b = 1'b1;                end    6'b11_0010: begin   to_incr  = 3'b100;                        add_sub_b = 1'b1;                end    6'b11_0011: begin   to_incr  = 3'b011;                        add_sub_b = 1'b1;                end    6'b11_0100: begin   to_incr  = 3'b100;                        add_sub_b = 1'b1;                end    6'b11_0101: begin   to_incr  = 3'b011;                        add_sub_b = 1'b1;                end    6'b11_0110: begin   to_incr  = 3'b011;                        add_sub_b = 1'b1;                end    6'b11_0111: begin   to_incr  = 3'b010;                        add_sub_b = 1'b1;                end    6'b11_1000: begin   to_incr  = 3'b100;                        add_sub_b = 1'b1;                end    6'b11_1001: begin   to_incr  = 3'b011;                        add_sub_b = 1'b1;                end    6'b11_1010: begin   to_incr  = 3'b011;                        add_sub_b = 1'b1;                end    6'b11_1011: begin   to_incr  = 3'b010;                        add_sub_b = 1'b1;                end    6'b11_1100: begin   to_incr  = 3'b011;                        add_sub_b = 1'b1;                end    6'b11_1101: begin   to_incr  = 3'b010;                        add_sub_b = 1'b1;                end    6'b11_1110: begin   to_incr  = 3'b010;                        add_sub_b = 1'b1;                end    6'b11_1111: begin   to_incr  = 3'b001;                        add_sub_b = 1'b1;                end    default:  begin   to_incr   = 3'b000;                      add_sub_b = 1'b1;              end    endcase  end  reg     [2:0] reg_cor_num;  reg           reg_inc_dec_b;  reg           reg_decr_cor;  always @(posedge clk)  begin    if (rst)    begin      reg_cor_num   <= #FFD 3'b000;   //remove reset to aid timing      reg_inc_dec_b <= #FFD 1'b0;      reg_decr_cor  <= #FFD 1'b0;    end    else    begin      reg_cor_num   <= #FFD to_incr;      reg_inc_dec_b <= #FFD ~(add_input_six_n_d && ~add_input_one_d &&                              add_input_two_n_d && add_input_three_n_d &&                              add_input_four_n_d && add_input_five_n_d && decr_cor);      reg_decr_cor  <= #FFD  (add_input_six_n_d && ~add_input_one_d &&                              add_input_two_n_d && add_input_three_n_d &&                              add_input_four_n_d && add_input_five_n_d) ?                             ~decr_cor : decr_cor;    end  end  assign cor_num   = reg_cor_num;  assign inc_dec_b = reg_inc_dec_b;  endmodule"}
{"task_id": 1725, "completion": "input  clk;\ninput  wb_rst_i;\ninput [7:0] lcr;\ninput  tf_push;\ninput [7:0] wb_dat_i;\ninput  enable;\ninput  tx_reset;\ninput  lsr_mask;\noutput  stx_pad_o;\noutput [2:0] tstate;\noutput [`UART_FIFO_COUNTER_W-1:0] tf_count;\nreg [2:0] tstate;\nreg [4:0] counter;\nreg [2:0] bit_counter;\nreg [6:0] shift_out;\nreg stx_o_tmp;\nreg parity_xor;\nreg tf_pop;\nreg bit_out;\nwire [`UART_FIFO_WIDTH-1:0] tf_data_in;\nwire [`UART_FIFO_WIDTH-1:0] tf_data_out;\nwire tf_push;\nwire tf_overrun;\nwire [`UART_FIFO_COUNTER_W-1:0] tf_count;\nassign tf_data_in = wb_dat_i;\nuart_tfifo fifo_tx(\n  .clk(clk),\n  .wb_rst_i(wb_rst_i),\n  .data_in(tf_data_in),\n  .data_out(tf_data_out),\n  .push(tf_push),\n  .pop(tf_pop),\n  .overrun(tf_overrun),\n  .count(tf_count),\n  .fifo_reset(tx_reset),\n  .reset_status(lsr_mask)\n);\nparameter s_idle = 3'd0;\nparameter s_send_start = 3'd1;\nparameter s_send_byte = 3'd2;\nparameter s_send_parity = 3'd3;\nparameter s_send_stop = 3'd4;\nparameter s_pop_byte = 3'd5;\nalways @(posedge clk or posedge wb_rst_i)\nbegin\n  if (wb_rst_i)\n  begin\n    tstate <= #1 s_idle;\n    stx_o_tmp <= #1 1'b1;\n    counter <= #1 5'b0;\n    shift_out <= #1 7'b0;\n    bit_out <= #1 1'b0;\n    parity_xor <= #1 1'b0;\n    tf_pop <= #1 1'b0;\n    bit_counter <= #1 3'b0;\n  end\n  else\n  if (enable)\n  begin\n    case (tstate)\n      s_idle : if (~|tf_count)\n      begin\n        tstate <= #1 s_idle;\n        stx_o_tmp <= #1 1'b1;\n      end\n      else\n      begin\n        tf_pop <= #1 1'b0;\n        stx_o_tmp <= #1 1'b1;\n        tstate <= #1 s_pop_byte;\n      end\n      s_pop_byte : begin\n        tf_pop <= #1 1'b1;\n        case (lcr[/*`UART_LC_BITS*/1:0])\n          2'b00 : begin\n            bit_counter <= #1 3'b100;\n            parity_xor <= #1 ^tf_data_out[4:0];\n          end\n          2'b01 : begin\n            bit_counter <= #1 3'b101;\n            parity_xor <= #1 ^tf_data_out[5:0];\n          end\n          2'b10 : begin\n            bit_counter <= #1 3'b110;\n            parity_xor <= #1 ^tf_data_out[6:0];\n          end\n          2'b11 : begin\n            bit_counter <= #1 3'b111;\n            parity_xor <= #1 ^tf_data_out[7:0];\n          end\n        endcase\n        {shift_out[6:0], bit_out} <= #1 tf_data_out;\n        tstate <= #1 s_send_start;\n      end\n      s_send_start : begin\n        tf_pop <= #1 1'b0;\n        if (~|counter)\n          counter <= #1 5'b01111;\n        else if (counter == 5'b00001)\n        begin\n          counter <= #1 0;\n          tstate <= #1 s_send_byte;\n        end\n        else\n          counter <= #1 counter - 1'b1;\n        stx_o_tmp <= #1 1'b0;\n      end\n      s_send_byte : begin\n        if (~|counter)\n          counter <= #1 5'b01111;\n        else if (counter == 5'b00001)\n        begin\n          if (bit_counter > 3'b0)\n          begin\n            bit_counter <= #1 bit_counter - 1'b1;\n            {shift_out[5:0],bit_out} <= #1 {shift_out[6:1], shift_out[0]};\n            tstate <= #1 s_send_byte;\n          end\n          else if (~lcr[`UART_LC_PE])\n          begin\n            tstate <= #1 s_send_stop;\n          end\n          else\n          begin\n            case ({lcr[`UART_LC_EP],lcr[`UART_LC_SP]})\n              2'b00: bit_out <= #1 ~parity_xor;\n              2'b01: bit_out <= #1 1'b1;\n              2'b10: bit_out <= #1 parity_xor;\n              2'b11: bit_out <= #1 1'b0;\n            endcase\n            tstate <= #1 s_send_parity;\n          end\n          counter <= #1 0;\n        end\n        else\n          counter <= #1 counter - 1'b1;\n        stx_o_tmp <= #1 bit_out;\n      end\n      s_send_parity : begin\n        if (~|counter)\n          counter <= #1 5'b01111;\n        else if (counter == 5'b00001)\n        begin\n          counter <= #1 4'b0;\n          tstate <= #1 s_send_stop;\n        end\n        else\n          counter <= #1 counter - 1'b1;\n        stx_o_tmp <= #1 bit_out;\n      end\n      s_send_stop : begin\n        if (~|counter)\n        begin\n          casex ({lcr[`UART_LC_SB],lcr[`UART_LC_BITS]})\n            3'b0xx: counter <= #1 5'b01101;\n            3'b100: counter <= #1 5'b10101;\n            default: counter <= #1 5'b11101;\n          endcase\n        end\n        else if (counter == 5'b00001)\n        begin\n          counter <= #1 0;\n          tstate <= #1 s_idle;\n        end\n        else\n          counter <= #1 counter - 1'b1;\n        stx_o_tmp <= #1 1'b1;\n      end\n      default : tstate <= #1 s_idle;\n    endcase\n  end\n  else\n    tf_pop <= #1 1'b0;\nend\nassign stx_pad_o = lcr[`UART_LC_BC] ? 1'b0 : stx_o_tmp;\nendmodule"}
{"task_id": 262, "completion": "`define DLY #1\n    localparam LOW_WATER_MARK_SLAVE  = 13'd450;\n    localparam LOW_WATER_MARK_MASTER = 13'd450;\n    localparam HIGH_WATER_MARK_SLAVE  = 13'd8;\n    localparam HIGH_WATER_MARK_MASTER = 13'd14;\n    localparam SH_CNT_MAX   = EXAMPLE_SIMULATION ? 16'd64 : (BACKWARD_COMP_MODE2) ? 16'd64 : 16'd60000;\n    localparam SH_INVALID_CNT_MAX = 16'd16;\n    wire                    tied_to_ground_i;\n    wire    [280:0]          tied_to_ground_vec_i;\n    wire     [1:0]          open_rxbufstatus_i;\n    wire                    open_txbufstatus_i;\n    wire                    tx_plllkdet_i;\n    wire                    rx_plllkdet_i;\n    wire                    resetdone_i;\n    wire                    rx_resetdone_i;\n    wire                    tx_resetdone_i;\n    wire                    rx_resetdone_t;\n    wire                    mmcm_reset_i;\n    wire                    enchansync_all_i;\n    wire                    gtrxreset_t;\n    wire                    gttxreset_t;\n    wire                    txusrclk_gtx_reset_comb;\n    wire                    stableclk_gtx_reset_comb;\n    wire                    gtx_reset_comb;\n    reg   [1:0]             txheader_r;\n    reg   [1:0]             tx_hdr_r;\n    reg [1:0] cdr_reset_fsm_r = 2'd0;\n    reg [7:0] cdr_reset_fsm_cntr_r = 8'd0;\n    reg allow_block_sync_propagation = 1'b0;\n    reg cdr_reset_fsm_lnkreset = 1'b0;\n    localparam IDLE = 2'b00;\n    localparam ASSERT_RXRESET = 2'b01;\n    localparam DONE = 2'b10;\n    wire allow_block_sync_propagation_inrxclk;\n    wire blocksync_all_lanes_instableclk;\n    wire                    blocksync_out_i;\n    wire blocksync_all_lanes_inrxclk;\n    reg  blocksync_all_lanes_inrxclk_q = 1'b0;\n    wire hpreset_or_pma_init_in;\n    wire hpreset_in;\n    wire hp_reset_i;\n    wire  [1:0]             rxbuferr_out_i;\n    wire  [1:0]             link_reset_0_c;\n    wire                    link_reset_c;\n    wire                    qpllreset_i;\n    wire                    gtxreset_i;\n    reg                    rxdatavalid_to_fifo_i;\n    reg  [1:0]             rxheader_to_fifo_i;\n    wire                      tied_to_vcc_i;\n    reg    [7:0]              reset_counter = 8'd0;\n    (* KEEP = \"TRUE\" *) wire  rx_fsm_resetdone_i;\n    (* KEEP = \"TRUE\" *) wire  tx_fsm_resetdone_i;\n    (* KEEP = \"TRUE\" *) wire  rx_fsm_resetdone_ii;\n    (* KEEP = \"TRUE\" *) wire  tx_fsm_resetdone_ii;\n    wire                    rx_fsm_resetdone_i_i;\n    wire                    tx_fsm_resetdone_i_i;\n    wire                    rx_fsm_resetdone_i_j;\n    wire                    tx_fsm_resetdone_i_j;\n    wire                    rxlossofsync_out_i;\n    reg                     rxlossofsync_out_q;\n    reg   [63:0]            pos_rxdata_from_gtx_i;\n    reg   [1:0]             rxheader_from_gtx_i;\n    reg                     rxdatavalid_i;\n    /* (\u7701\u7565\u5b9a\u4e49\u4e0e\u5904\u7406\u903b\u8f91) */\nendmodule"}
{"task_id": 1720, "completion": "function integer log2;\n\tinput [31:0] value;\n\treg [31:0] temp;\nbegin\n\ttemp = value;\n\tfor (log2=0; temp>0; log2=log2+1)\n\t\ttemp = temp>>1;\n\tend\nendfunction\n\n\tlocalparam LOGW = log2(W);\n\n\twire [W-1:0] x1[N-1:0]; \n\twire [W-1:0] y1[N-1:0]; \n\twire [W-1:0] x2, y2;\n\twire [2*W-1:0] min_val_out;\n\t\n\tassign x2 = g_input[2*W-1:W];\n\tassign y2 = g_input[W-1:0];\n\tassign min_val_out = o;\n\t\n\twire [W+1:0] dist[N-1:0];\n\t\n\twire [W-1:0] min_val_x[N-1:0];\n\twire [W-1:0] min_val_y[N-1:0];\n\twire [W+1:0] min_dist[N-1:0];\n\twire gt_dist[N-1:1];\n\n\tgenvar i;\n\t\n\tgenerate\n\tfor (i=0;i<N;i=i+1)\n\tbegin:D_ASN\n\t\tassign x1[i] = e_input[2*W*(i+1)-1:2*W*(i+1)-W];\n\t\tassign y1[i] = e_input[2*W*(i+1)-W-1:2*W*i];\n\tend\n\tendgenerate\n\n\tgenerate\n\tfor (i=0;i<N;i=i+1)\n\tbegin:dist_inst\n\t\ttaxicab_distance\n\t\t#(\n\t\t\t.N(W)\n\t\t)\n\t\ttaxicab_distance_\n\t\t(\n\t\t\t.x1(x1[i]), .y1(y1[i]), .x2(x2), .y2(y2),\n\t\t\t.dist(dist[i])\n\t\t);\n\tend\n\tendgenerate\n\n\tassign min_val_x[0] = x1[0];\n\tassign min_val_y[0] = y1[0];\n\tassign min_dist[0] = dist[0];\n\n\tgenerate\n\tfor (i=1;i<N;i=i+1)\n\tbegin:comp_inst\n\t\tCOMP\n\t\t#(\n\t\t\t.N(W+2)\n\t\t)\n\t\tCOMP_\n\t\t(\n\t\t\t.A(min_dist[i-1]),\n\t\t\t.B(dist[i]),\n\t\t\t.O(gt_dist[i])\n\t\t);\n\tend\n\tendgenerate\n\n\tgenerate\n\tfor (i=1;i<N;i=i+1)\n\tbegin:mux_inst\n\t\tMUX\n\t\t#(\n\t\t\t.N(2*W)\n\t\t)\n\t\tMUX_1\n\t\t(\n\t\t\t.A({x1[i], y1[i]}),\n\t\t\t.B({min_val_x[i-1], min_val_y[i-1]}),\n\t\t\t.S(gt_dist[i]),\n\t\t\t.O({min_val_x[i], min_val_y[i]})\n\t\t);\n\t\t\n\t\tMUX\n\t\t#(\n\t\t\t.N(W+2)\n\t\t)\n\t\tMUX_2\n\t\t(\n\t\t\t.A(dist[i]),\n\t\t\t.B(min_dist[i-1]),\n\t\t\t.S(gt_dist[i]),\n\t\t\t.O(min_dist[i])\n\t\t);\n\tend\n\tendgenerate\n\n\tassign o = {min_val_x[N-1], min_val_y[N-1]};\n\nendmodule"}
{"task_id": 1768, "completion": "wire unsigned [22:0] int_AB;\n\n  assign int_AB = a + b;\n\nalways @(a, b, int_AB, c) begin\n  #1;\n  if (int_AB !== c) begin\n     $display(\"ERROR\");\n     $finish;\n  end\nend\n\nendmodule"}
{"task_id": 1644, "completion": "wire rc_start;\n    wire rc_bop;\n    wire [31:0] rc_baddr;\n    wire [31:0] rc_bsize;\n    wire rc_done;\n    wire ma_req;\n    wire xbm_gnt;\n    wire ma_select;\n    wire [31:0] ma_addr;\n    wire [31:0] ma_data;\n    wire ma_rnw;\n    wire [3:0] ma_be;\n    wire xbm_ack;\n    wire [31:0] xbm_data;\n    icapi_regs #(\n        .C_DWIDTH ( C_SPLB_NATIVE_DWIDTH ),\n        .C_MEM_BASEADDR ( C_MEM_BASEADDR ),\n        .C_MEM_HIGHADDR ( C_MEM_HIGHADDR )\n    ) icapi_regs_0 (\n        .Bus2IP_Clk ( Bus2IP_Clk ),\n        .Bus2IP_Reset ( Bus2IP_Reset ),\n        .Bus2IP_Addr ( Bus2IP_Addr ),\n        .Bus2IP_CS ( Bus2IP_CS ),\n        .Bus2IP_RNW ( Bus2IP_RNW ),\n        .Bus2IP_Data ( Bus2IP_Data ),\n        .Bus2IP_BE ( Bus2IP_BE ),\n        .Bus2IP_Burst ( Bus2IP_Burst ),\n        .Bus2IP_BurstLength ( Bus2IP_BurstLength ),\n        .Bus2IP_RdReq ( Bus2IP_RdReq ),\n        .Bus2IP_WrReq ( Bus2IP_WrReq ),\n        .IP2Bus_AddrAck ( IP2Bus_AddrAck ),\n        .IP2Bus_Data ( IP2Bus_Data ),\n        .IP2Bus_RdAck ( IP2Bus_RdAck ),\n        .IP2Bus_WrAck ( IP2Bus_WrAck ),\n        .IP2Bus_Error ( IP2Bus_Error ),\n        .rc_start ( rc_start ),\n        .rc_bop ( rc_bop ),\n        .rc_baddr ( rc_baddr ),\n        .rc_bsize ( rc_bsize ),\n        .rc_done ( rc_done ),\n        .IP2INTC_Irpt ( IP2INTC_Irpt )\n    );\n    xbus_masterif #(\n        .C_DWIDTH ( C_MPLB_NATIVE_DWIDTH )\n    ) icapi_masterif_0 (\n        .Bus2IP_Mst_Clk ( Bus2IP_Mst_Clk ),\n        .Bus2IP_Mst_Reset ( Bus2IP_Mst_Reset ),\n        .IP2Bus_MstRd_Req ( IP2Bus_MstRd_Req ),\n        .IP2Bus_MstWr_Req ( IP2Bus_MstWr_Req ),\n        .IP2Bus_Mst_Addr ( IP2Bus_Mst_Addr ),\n        .IP2Bus_Mst_Length ( IP2Bus_Mst_Length ),\n        .IP2Bus_Mst_BE ( IP2Bus_Mst_BE ),\n        .IP2Bus_Mst_Type ( IP2Bus_Mst_Type ),\n        .IP2Bus_Mst_Lock ( IP2Bus_Mst_Lock ),\n        .IP2Bus_Mst_Reset ( IP2Bus_Mst_Reset ),\n        .Bus2IP_Mst_CmdAck ( Bus2IP_Mst_CmdAck ),\n        .Bus2IP_Mst_Cmplt ( Bus2IP_Mst_Cmplt ),\n        .Bus2IP_Mst_Error ( Bus2IP_Mst_Error ),\n        .Bus2IP_Mst_Rearbitrate ( Bus2IP_Mst_Rearbitrate ),\n        .Bus2IP_Mst_Cmd_Timeout ( Bus2IP_Mst_Cmd_Timeout ),\n        .Bus2IP_MstRd_d ( Bus2IP_MstRd_d ),\n        .Bus2IP_MstRd_rem ( Bus2IP_MstRd_rem ),\n        .Bus2IP_MstRd_sof_n ( Bus2IP_MstRd_sof_n ),\n        .Bus2IP_MstRd_eof_n ( Bus2IP_MstRd_eof_n ),\n        .Bus2IP_MstRd_src_rdy_n ( Bus2IP_MstRd_src_rdy_n ),\n        .Bus2IP_MstRd_src_dsc_n ( Bus2IP_MstRd_src_dsc_n ),\n        .IP2Bus_MstRd_dst_rdy_n ( IP2Bus_MstRd_dst_rdy_n ),\n        .IP2Bus_MstRd_dst_dsc_n ( IP2Bus_MstRd_dst_dsc_n ),\n        .IP2Bus_MstWr_d ( IP2Bus_MstWr_d ),\n        .IP2Bus_MstWr_rem ( IP2Bus_MstWr_rem ),\n        .IP2Bus_MstWr_sof_n ( IP2Bus_MstWr_sof_n ),\n        .IP2Bus_MstWr_eof_n ( IP2Bus_MstWr_eof_n ),\n        .IP2Bus_MstWr_src_rdy_n ( IP2Bus_MstWr_src_rdy_n ),\n        .IP2Bus_MstWr_src_dsc_n ( IP2Bus_MstWr_src_dsc_n ),\n        .Bus2IP_MstWr_dst_rdy_n ( Bus2IP_MstWr_dst_rdy_n ),\n        .Bus2IP_MstWr_dst_dsc_n ( Bus2IP_MstWr_dst_dsc_n ),\n        .ma_req ( ma_req ),\n        .xbm_gnt ( xbm_gnt ),\n        .ma_select ( ma_select ),\n        .ma_addr ( ma_addr ),\n        .ma_data ( ma_data ),\n        .ma_rnw ( ma_rnw ),\n        .ma_be ( ma_be ),\n        .xbm_ack ( xbm_ack ),\n        .xbm_data ( xbm_data )\n    );\n    icapi #(\n        .C_DWIDTH ( 32 ),\n        .C_RESIM ( C_RESIM ),\n        .C_FAMILY ( C_FAMILY )\n    ) icapi_0 (\n        .clk ( ICAP_Clk ),\n        .rstn ( ~Bus2IP_Reset ),\n        .rc_start ( rc_start ),\n        .rc_bop ( rc_bop ),\n        .rc_baddr ( rc_baddr ),\n        .rc_bsize ( rc_bsize ),\n        .rc_done ( rc_done ),\n        .ma_req ( ma_req ),\n        .xbm_gnt ( xbm_gnt ),\n        .ma_select ( ma_select ),\n        .ma_addr ( ma_addr ),\n        .ma_data ( ma_data ),\n        .ma_rnw ( ma_rnw ),\n        .ma_be ( ma_be ),\n        .xbm_ack ( xbm_ack ),\n        .xbm_data ( xbm_data )\n    );\nendmodule"}
{"task_id": 410, "completion": "reg [127:0] fifo [511:0];\n    reg [8:0] wr_pointer;\n    reg [8:0] rd_pointer;\n    reg [8:0] count;\n\n    assign full = (count == 512);\n    assign empty = (count == 0);\n\n    always @(posedge wr_clk or posedge rst) begin\n        if (rst) begin\n            wr_pointer <= 0;\n            count <= 0;\n        end else if (wr_en && !full) begin\n            fifo[wr_pointer] <= din;\n            wr_pointer <= wr_pointer + 1;\n            count <= count + 1;\n        end\n    end\n\n    always @(posedge rd_clk or posedge rst) begin\n        if (rst) begin\n            rd_pointer <= 0;\n            dout <= 0;\n        end else if (rd_en && !empty) begin\n            dout <= fifo[rd_pointer];\n            rd_pointer <= rd_pointer + 1;\n            count <= count - 1;\n        end\n    end\nendmodule"}
{"task_id": 1762, "completion": "always@*begin if(operation == 1'b0) begin if(shift_region_flag == 2'b00 || shift_region_flag == 2'b11) begin data_out = data; end else begin if((shift_region_flag == 2'b01) && (data[W-1] == 1'b0)) begin data_out = {1'b1,data[W-2:0]}; end else if((shift_region_flag == 2'b01) && (data[W-1] == 1'b1)) begin data_out = {1'b0,data[W-2:0]}; end else begin data_out = data; end end end else begin if(shift_region_flag == 2'b00 || shift_region_flag == 2'b11) begin data_out = data; end else begin if((shift_region_flag == 2'b10) && (data[W-1] == 1'b0)) begin data_out = {1'b1,data[W-2:0]}; end else if((shift_region_flag == 2'b10) && (data[W-1] == 1'b1)) begin data_out = {1'b0,data[W-2:0]}; end else begin data_out = data; end end endendendmodule"}
{"task_id": 1784, "completion": "assign pad = oe ? op : 1'bz;\n\nendmodule"}
{"task_id": 1782, "completion": "wire [23:0] SRAM_SNES_ADDR;\n\nassign IS_ROM = ((!SNES_ADDR[22] & SNES_ADDR[15])\n                 |(SNES_ADDR[22]));\n\nassign IS_SAVERAM = (!SNES_ADDR[22]\n                     & &SNES_ADDR[21:20]\n                     & &SNES_ADDR[14:13]\n                     & !SNES_ADDR[15]\n                    );\n\nassign SRAM_SNES_ADDR = (IS_SAVERAM\n                             ? 24'hFF0000 + ((SNES_ADDR[14:0] - 15'h6000)\n                                             & SAVERAM_MASK)\n                             : (({1'b0, SNES_ADDR[22:0]} & ROM_MASK)\n                                + 24'hC00000)\n                        );\n\nassign ROM_ADDR = SRAM_SNES_ADDR;\n\nassign ROM_HIT = IS_ROM | IS_SAVERAM;\n\nendmodule"}
{"task_id": 1758, "completion": "parameter INIT_0 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\n    parameter INIT_1 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\n    parameter INIT_2 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\n    parameter INIT_3 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\n    parameter INIT_4 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\n    parameter INIT_5 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\n    parameter INIT_6 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\n    parameter INIT_7 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\n    parameter INIT_8 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\n    parameter INIT_9 = 256'h0000000000000000000000000000000000000000000000000000000000000000;\n    parameter INIT_A = 256'h0000000000000000000000000000000000000000000000000000000000000000;\n    parameter INIT_B = 256'h0000000000000000000000000000000000000000000000000000000000000000;\n    parameter INIT_C = 256'h0000000000000000000000000000000000000000000000000000000000000000;\n    parameter INIT_D = 256'h0000000000000000000000000000000000000000000000000000000000000000;\n    parameter INIT_E = 256'h0000000000000000000000000000000000000000000000000000000000000000;\n    parameter INIT_F = 256'h0000000000000000000000000000000000000000000000000000000000000000;\n\n  wire [15:0] rd;\n\n  SB_RAM40_4K #(\n    .WRITE_MODE(3),\n    .READ_MODE(3),\n    .INIT_0(INIT_0),\n    .INIT_1(INIT_1),\n    .INIT_2(INIT_2),\n    .INIT_3(INIT_3),\n    .INIT_4(INIT_4),\n    .INIT_5(INIT_5),\n    .INIT_6(INIT_6),\n    .INIT_7(INIT_7),\n    .INIT_8(INIT_8),\n    .INIT_9(INIT_9),\n    .INIT_A(INIT_A),\n    .INIT_B(INIT_B),\n    .INIT_C(INIT_C),\n    .INIT_D(INIT_D),\n    .INIT_E(INIT_E),\n    .INIT_F(INIT_F)\n  ) _ram (\n    .RDATA(rd),\n    .RADDR(RADDR),\n    .RCLK(RCLK), .RCLKE(RCLKE), .RE(RE),\n    .WCLK(WCLK), .WCLKE(WCLKE), .WE(WE),\n    .WADDR(WADDR),\n    .MASK(16'h0000), .WDATA({4'b0, WDATA[1], 7'b0, WDATA[0], 3'b0}));\n\n  assign RDATA[0] = rd[3];\n  assign RDATA[1] = rd[11];\n\nendmodule"}
{"task_id": 1795, "completion": "wire unsigned [45:0] int_AB;\n\n  assign int_AB = a * b;\n\nalways @(a, b, int_AB, c) begin\n  #1;\n  if (int_AB !== c) begin\n     $display(\"ERROR\");\n     $finish;\n  end\nend\n\nendmodule"}
{"task_id": 1777, "completion": "module t_extend_class_v (/*AUTOARG*/\n   // Outputs\n   out,\n   // Inputs\n   in\n   );\n   input [31:0]  in;\n   output logic [31:0] out;\n   always @* begin\n      out = $c(\"this->m_myobjp->my_math(\", in, \")\");\n   end\n `systemc_header\n#include \"t_extend_class_c.h\" // Header for contained object\n `systemc_interface\n   t_extend_class_c* m_myobjp; // Pointer to object we are embedding\n `systemc_ctor\n   m_myobjp = new t_extend_class_c(); // Construct contained object\n `systemc_dtor\n   delete m_myobjp; // Destruct contained object\n `verilog\nendmodule"}
{"task_id": 1721, "completion": "localparam ADDR_WIDTH = $clog2(FIFO_DEPTH);\nreg [DATA_WIDTH-1:0] mem [0:FIFO_DEPTH-1];\nreg [ADDR_WIDTH:0] wr_ptr;\nreg [ADDR_WIDTH:0] rd_ptr;\nreg [ADDR_WIDTH:0] ptr_diff;\n\nassign empty = (wr_ptr == rd_ptr);\nassign full = (wr_ptr[ADDR_WIDTH-1:0] == rd_ptr[ADDR_WIDTH-1:0]) && (wr_ptr[ADDR_WIDTH] != rd_ptr[ADDR_WIDTH]);\nassign data_out = mem[rd_ptr[ADDR_WIDTH-1:0]];\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        wr_ptr <= 0;\n    end else if (wr_en && !full) begin\n        mem[wr_ptr[ADDR_WIDTH-1:0]] <= data_in;\n        wr_ptr <= wr_ptr + 1;\n    end\nend\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        rd_ptr <= 0;\n    end else if (rd_en && !empty) begin\n        rd_ptr <= rd_ptr + 1;\n    end\nend\n\nendmodule"}
{"task_id": 1780, "completion": "// synthesis black_box\n\n    BLKMEMDP_V6_1 #(\n        5,    // c_addra_width\n        5,    // c_addrb_width\n        \"0\",    // c_default_data\n        32,    // c_depth_a\n        32,    // c_depth_b\n        0,    // c_enable_rlocs\n        1,    // c_has_default_data\n        1,    // c_has_dina\n        1,    // c_has_dinb\n        1,    // c_has_douta\n        1,    // c_has_doutb\n        0,    // c_has_ena\n        0,    // c_has_enb\n        0,    // c_has_limit_data_pitch\n        0,    // c_has_nda\n        0,    // c_has_ndb\n        0,    // c_has_rdya\n        0,    // c_has_rdyb\n        0,    // c_has_rfda\n        0,    // c_has_rfdb\n        0,    // c_has_sinita\n        0,    // c_has_sinitb\n        1,    // c_has_wea\n        1,    // c_has_web\n        18,    // c_limit_data_pitch\n        \"mif_file_16_1\",    // c_mem_init_file\n        0,    // c_pipe_stages_a\n        0,    // c_pipe_stages_b\n        0,    // c_reg_inputsa\n        0,    // c_reg_inputsb\n        \"0\",    // c_sinita_value\n        \"0\",    // c_sinitb_value\n        32,    // c_width_a\n        32,    // c_width_b\n        0,    // c_write_modea\n        0,    // c_write_modeb\n        \"0\",    // c_ybottom_addr\n        1,    // c_yclka_is_rising\n        1,    // c_yclkb_is_rising\n        1,    // c_yena_is_high\n        1,    // c_yenb_is_high\n        \"hierarchy1\",    // c_yhierarchy\n        0,    // c_ymake_bmm\n        \"16kx1\",    // c_yprimitive_type\n        1,    // c_ysinita_is_high\n        1,    // c_ysinitb_is_high\n        \"1024\",    // c_ytop_addr\n        0,    // c_yuse_single_primitive\n        1,    // c_ywea_is_high\n        1,    // c_yweb_is_high\n        1)    // c_yydisable_warnings\n    inst (\n        .ADDRA(addra),\n        .ADDRB(addrb),\n        .CLKA(clka),\n        .CLKB(clkb),\n        .DINA(dina),\n        .DINB(dinb),\n        .DOUTA(douta),\n        .DOUTB(doutb),\n        .WEA(wea),\n        .WEB(web),\n        .ENA(),\n        .ENB(),\n        .NDA(),\n        .NDB(),\n        .RFDA(),\n        .RFDB(),\n        .RDYA(),\n        .RDYB(),\n        .SINITA(),\n        .SINITB());\n\nendmodule"}
{"task_id": 1786, "completion": "wire next;\n    wire next_pending;\n    wire a_push;\n    wire incr_burst;\n    reg [C_ID_WIDTH-1:0] s_arid_r;\n\n    axi_protocol_converter_v2_1_8_b2s_cmd_translator #(\n      .C_AXI_ADDR_WIDTH(C_AXI_ADDR_WIDTH)\n    ) cmd_translator_0 (\n      .clk(clk),\n      .reset(reset),\n      .s_axaddr(s_araddr),\n      .s_axlen(s_arlen),\n      .s_axsize(s_arsize),\n      .s_axburst(s_arburst),\n      .s_axhandshake(s_arvalid & a_push),\n      .incr_burst(incr_burst),\n      .m_axaddr(m_araddr),\n      .next(next),\n      .next_pending(next_pending)\n    );\n\n    axi_protocol_converter_v2_1_8_b2s_rd_cmd_fsm ar_cmd_fsm_0 (\n      .clk(clk),\n      .reset(reset),\n      .s_arready(s_arready),\n      .s_arvalid(s_arvalid),\n      .s_arlen(s_arlen),\n      .m_arvalid(m_arvalid),\n      .m_arready(m_arready),\n      .next(next),\n      .next_pending(next_pending),\n      .data_ready(~r_full),\n      .a_push(a_push),\n      .r_push(r_push)\n    );\n\n    assign r_arid = s_arid_r;\n    assign r_rlast = ~next_pending;\n\n    always @(posedge clk) begin\n      s_arid_r <= s_arid;\n    end\n\nendmodule"}
{"task_id": 1653, "completion": "reg [2:0] read_safe_counter;\n    always @(posedge sys_clk) begin\n        if(sdram_rst) begin\n            read_safe_counter <= 3'd0;\n            read_safe <= 1'b1;\n        end else begin\n            if(read) begin\n                read_safe_counter <= 3'd7;\n                read_safe <= 1'b0;\n            end else if(write) begin\n                read_safe_counter <= {2'b11, ~tim_cas};\n                read_safe <= 1'b0;\n            end else begin\n                if(read_safe_counter == 3'd1)\n                    read_safe <= 1'b1;\n                if(~read_safe)\n                    read_safe_counter <= read_safe_counter - 3'd1;\n            end\n        end\n    end\n\n    reg [3:0] write_safe_counter;\n    always @(posedge sys_clk) begin\n        if(sdram_rst) begin\n            write_safe_counter <= 4'd0;\n            write_safe <= 1'b1;\n        end else begin\n            if(read) begin\n                write_safe_counter <= {3'b100, ~tim_cas};\n                write_safe <= 1'b0;\n            end else if(write) begin\n                write_safe_counter <= 4'd7;\n                write_safe <= 1'b0;\n            end else begin\n                if(write_safe_counter == 4'd1)\n                    write_safe <= 1'b1;\n                if(~write_safe)\n                    write_safe_counter <= write_safe_counter - 4'd1;\n            end\n        end\n    end\n\n    reg ack_read2;\n    reg ack_read1;\n    reg ack_read0;\n\n    always @(posedge sys_clk) begin\n        if(sdram_rst) begin\n            ack_read2 <= 1'b0;\n            ack_read1 <= 1'b0;\n            ack_read0 <= 1'b0;\n        end else begin\n            if(tim_cas) begin\n                ack_read2 <= read;\n                ack_read1 <= ack_read2;\n                ack_read0 <= ack_read1;\n            end else begin\n                ack_read1 <= read;\n                ack_read0 <= ack_read1;\n            end\n        end\n    end\n\n    reg ack0;\n    always @(posedge sys_clk) begin\n        if(sdram_rst) begin\n            ack0 <= 1'b0;\n            ack <= 1'b0;\n        end else begin\n            ack0 <= ack_read0;\n            ack <= ack0|write;\n        end\n    end\n\n    reg [3:0] counter_writedirection;\n    always @(posedge sys_clk) begin\n        if(sdram_rst) begin\n            counter_writedirection <= 4'd0;\n            direction <= 1'b0;\n        end else begin\n            if(write) begin\n                counter_writedirection <= 4'b1001;\n                direction <= 1'b1;\n            end else begin\n                if(counter_writedirection == 4'b0001)\n                    direction <= 1'b0;\n                if(direction)\n                    counter_writedirection <= counter_writedirection - 4'd1;\n            end\n        end\n    end\n\n    assign direction_r = write|(|counter_writedirection);\n\n    hpdmc_banktimer banktimer0(\n\t\t.sys_clk(sys_clk),\n\t\t.sdram_rst(sdram_rst),\n\t\t.tim_cas(tim_cas),\n\t\t.tim_wr(tim_wr),\n\t\t.read(read & concerned_bank[0]),\n\t\t.write(write & concerned_bank[0]),\n\t\t.precharge_safe(precharge_safe[0])\n    );\n    hpdmc_banktimer banktimer1(\n\t\t.sys_clk(sys_clk),\n\t\t.sdram_rst(sdram_rst),\n\t\t.tim_cas(tim_cas),\n\t\t.tim_wr(tim_wr),\n\t\t.read(read & concerned_bank[1]),\n\t\t.write(write & concerned_bank[1]),\n\t\t.precharge_safe(precharge_safe[1])\n    );\n    hpdmc_banktimer banktimer2(\n\t\t.sys_clk(sys_clk),\n\t\t.sdram_rst(sdram_rst),\n\t\t.tim_cas(tim_cas),\n\t\t.tim_wr(tim_wr),\n\t\t.read(read & concerned_bank[2]),\n\t\t.write(write & concerned_bank[2]),\n\t\t.precharge_safe(precharge_safe[2])\n    );\n    hpdmc_banktimer banktimer3(\n\t\t.sys_clk(sys_clk),\n\t\t.sdram_rst(sdram_rst),\n\t\t.tim_cas(tim_cas),\n\t\t.tim_wr(tim_wr),\n\t\t.read(read & concerned_bank[3]),\n\t\t.write(write & concerned_bank[3]),\n\t\t.precharge_safe(precharge_safe[3])\n    );\n\nendmodule"}
{"task_id": 1717, "completion": "function integer clog2;\n        input integer value;\n        begin\n            value = value-1;\n            for (clog2=0; value>0; clog2=clog2+1)\n                value = value>>1;\n        end\n    endfunction\n\n    `define USE_DYN_PLL\n\n    `ifdef SPEED_MHZ\n        parameter SPEED_MHZ = `SPEED_MHZ;\n    `else\n        parameter SPEED_MHZ = 50;\n    `endif\n\n    `ifdef SPEED_LIMIT\n        parameter SPEED_LIMIT = `SPEED_LIMIT;\n    `else\n        parameter SPEED_LIMIT = 150;\n    `endif\n\n    `ifdef SERIAL_CLK\n        parameter comm_clk_frequency = `SERIAL_CLK;\n    `else\n        parameter comm_clk_frequency = 12_500_000;\n    `endif\n\n    `ifdef BAUD_RATE\n        parameter BAUD_RATE = `BAUD_RATE;\n    `else\n        parameter BAUD_RATE = 115_200;\n    `endif\n\n    `ifdef LOCAL_MINERS\n        parameter LOCAL_MINERS = `LOCAL_MINERS;\n    `else\n        parameter LOCAL_MINERS = 4;\n    `endif\n\n    `ifdef ADDRBITS\n        parameter ADDRBITS = `ADDRBITS;\n    `else\n        parameter ADDRBITS = 12 - clog2(LOCAL_MINERS);\n    `endif\n\n    `ifdef EXT_PORTS\n        parameter EXT_PORTS = `EXT_PORTS;\n    `else\n        parameter EXT_PORTS = 1;\n    `endif\n\n    localparam SLAVES = LOCAL_MINERS + EXT_PORTS;\n\n    input osc_clk;\n    wire hash_clk, uart_clk, pbkdf_clk;\n\n    `ifdef USE_DYN_PLL\n        wire first_dcm_locked, dcm_progclk, dcm_progdata, dcm_progen, dcm_reset, dcm_progdone, dcm_locked;\n        wire [2:1] dcm_status;\n    `endif\n\n    `ifndef SIM\n        `ifdef USE_DYN_PLL\n            dyn_pll # (.SPEED_MHZ(SPEED_MHZ)) dyn_pll_blk\n                (osc_clk, \n                pbkdf_clk, \n                hash_clk, \n                uart_clk,\n                first_dcm_locked,\n                dcm_progclk,\n                dcm_progdata,\n                dcm_progen,\n                dcm_reset,\n                dcm_progdone,\n                dcm_locked,\n                dcm_status);\n        `else\n            main_pll # (.SPEED_MHZ(SPEED_MHZ)) pll_blk (.CLKIN_IN(osc_clk), .CLKFX_OUT(hash_clk), .CLKDV_OUT(uart_clk));\n            assign pbkdf_clk = uart_clk;\n        `endif\n    `else\n        assign hash_clk = osc_clk;\n        assign uart_clk = osc_clk;\n        assign pbkdf_clk = osc_clk;\n        `ifdef USE_DYN_PLL\n            assign first_dcm_locked = 1'b1;\n            assign dcm_progdone = 1'b1;\n            assign dcm_locked = 1'b1;\n            assign dcm_status = 0;\n        `endif\n    `endif\n\n    `ifdef USE_DYN_PLL\n        reg [7:0] dyn_pll_speed = SPEED_MHZ;\n        reg dyn_pll_start = 0;\n        parameter OSC_MHZ = 100;\n        dyn_pll_ctrl # (.SPEED_MHZ(SPEED_MHZ), .SPEED_LIMIT(SPEED_LIMIT), .OSC_MHZ(OSC_MHZ)) dyn_pll_ctrl_blk\n            (uart_clk, first_dcm_locked, dyn_pll_speed, dyn_pll_start, dcm_progclk, dcm_progdata, dcm_progen, dcm_reset, dcm_locked, dcm_status);\n    `endif\n\n    input TMP_SCL, TMP_SDA, TMP_ALERT;\n\n    input [3:0]dip;\n    wire reset, nonce_chip;\n    assign reset = dip[0];\n    assign nonce_chip = dip[1];\n\n    input RxD;\n    output TxD;\n\n    wire [SLAVES*32-1:0] slave_nonces;\n    wire [SLAVES*32-1:0] slave_debug_sr;\n    wire [SLAVES-1:0] new_nonces;\n\n    wire serial_send;\n    wire serial_busy;\n    wire [31:0] golden_nonce;\n    serial_transmit #(.comm_clk_frequency(comm_clk_frequency), .baud_rate(BAUD_RATE)) sertx (.clk(uart_clk), .TxD(TxD), .send(serial_send), .busy(serial_busy), .word(golden_nonce));\n\n    hub_core #(.SLAVES(SLAVES)) hc (.uart_clk(uart_clk), .new_nonces(new_nonces), .golden_nonce(golden_nonce), .serial_send(serial_send), .serial_busy(serial_busy), .slave_nonces(slave_nonces));\n\n    wire [255:0] data1, data2;\n    wire [127:0] data3;\n    wire [31:0] target;\n    reg [31:0] targetreg = 32'h000007ff;\n    wire rx_done;\n\n    reg rx_done_toggle = 1'b0;\n    always @ (posedge uart_clk)\n        rx_done_toggle <= rx_done_toggle ^ rx_done;\n\n    reg rx_done_toggle_d1 = 1'b0;\n    reg rx_done_toggle_d2 = 1'b0;\n    reg rx_done_toggle_d3 = 1'b0;\n\n    wire loadnonce;\n    assign loadnonce = rx_done_toggle_d3 ^ rx_done_toggle_d2;\n\n    always @ (posedge pbkdf_clk)\n    begin\n        rx_done_toggle_d1 <= rx_done_toggle;\n        rx_done_toggle_d2 <= rx_done_toggle_d1;\n        rx_done_toggle_d3 <= rx_done_toggle_d2;\n        if (loadnonce)\n            targetreg <= target;\n    end\n    wire [31:0] mod_target;\n\n    `ifdef USE_DYN_PLL\n        always @ (posedge uart_clk)\n        begin\n            dyn_pll_start <= 0;\n            if (rx_done && target[31:24] != dyn_pll_speed && target[31:24] != 0 && target[23:16] != 0 && target[31:24] == ~target[23:16])\n            begin\n                dyn_pll_speed <= target[31:24];\n                dyn_pll_start <= 1;\n            end\n        end\n        assign mod_target = { 16'd0, targetreg[15:0] };\n    `else\n        assign mod_target = { 16'd0, targetreg[15:0] };\n    `endif\n\n    serial_receive #(.comm_clk_frequency(comm_clk_frequency), .baud_rate(BAUD_RATE)) serrx (.clk(uart_clk), .RxD(RxD), .data1(data1), .data2(data2), .data3(data3), .data4(target), .rx_done(rx_done));\n\n    generate\n        genvar i;\n        for (i = 0; i < LOCAL_MINERS; i = i + 1)\n        begin: miners\n            wire [31:0] nonce_out;\n            wire [2:0] nonce_core = i;\n            wire gn_match;\n            wire salsa_din, salsa_dout, salsa_busy, salsa_result, salsa_reset, salsa_start, salsa_shift;\n            wire [3:0] dummy;\n\n            pbkdfengine P (.hash_clk(hash_clk), .pbkdf_clk(pbkdf_clk), .data1(data1), .data2(data2), .data3(data3), .target(mod_target), .nonce_msb({nonce_chip, nonce_core}), .nonce_out(nonce_out), .golden_nonce_out(slave_nonces[i*32+31:i*32]), .golden_nonce_match(gn_match), .loadnonce(loadnonce), .salsa_din(salsa_din), .salsa_dout(salsa_dout), .salsa_busy(salsa_busy), .salsa_result(salsa_result), .salsa_reset(salsa_reset), .salsa_start(salsa_start), .salsa_shift(salsa_shift));\n\n            salsaengine #(.ADDRBITS(ADDRBITS)) S (.hash_clk(hash_clk), .reset(salsa_reset), .din(salsa_din), .dout(salsa_dout), .shift(salsa_shift), .start(salsa_start), .busy(salsa_busy), .result(salsa_result));\n\n            reg gn_match_toggle = 1'b0;\n            always @ (posedge pbkdf_clk)\n                gn_match_toggle <= gn_match_toggle ^ gn_match;\n\n            reg gn_match_toggle_d1 = 1'b0;\n            reg gn_match_toggle_d2 = 1'b0;\n            reg gn_match_toggle_d3 = 1'b0;\n\n            assign new_nonces[i] = gn_match_toggle_d3 ^ gn_match_toggle_d2;\n\n            always @ (posedge uart_clk)\n            begin\n                gn_match_toggle_d1 <= gn_match_toggle;\n                gn_match_toggle_d2 <= gn_match_toggle_d1;\n                gn_match_toggle_d3 <= gn_match_toggle_d2;\n            end\n        end\n    endgenerate\n\n    output [EXT_PORTS-1:0] extminer_txd;\n    input [EXT_PORTS-1:0] extminer_rxd;\n    assign extminer_txd = {EXT_PORTS{RxD}};\n\n    generate\n        genvar j;\n        for (j = LOCAL_MINERS; j < SLAVES; j = j + 1)\n        begin: ports\n            slave_receive #(.comm_clk_frequency(comm_clk_frequency), .baud_rate(BAUD_RATE)) slrx (.clk(uart_clk), .RxD(extminer_rxd[j-LOCAL_MINERS]), .nonce(slave_nonces[j*32+31:j*32]), .new_nonce(new_nonces[j]));\n        end\n    endgenerate\n\n    output [3:0] led;\n    assign led[1] = ~RxD;\n    assign led[3] = ~first_dcm_locked | ~dcm_locked | dcm_status[2];\n\n    `define FLASHCLOCK\n\n    `ifdef FLASHCLOCK\n        reg [26:0] hash_count = 0;\n        reg [3:0] sync_hash_count = 0;\n        always @ (posedge uart_clk)\n            if (rx_done)\n                sync_hash_count[0] <= ~sync_hash_count[0];\n        always @ (posedge hash_clk)\n        begin\n            sync_hash_count[3:1] <= sync_hash_count[2:0];\n            hash_count <= hash_count + 1'b1;\n            if (sync_hash_count[3] != sync_hash_count[2])\n                hash_count <= 0;\n        end\n        assign led[2] = hash_count[26];\n    `else\n        assign led[2] = ~TxD;\n    `endif\n\n    pwm_fade pf (.clk(uart_clk), .trigger(|new_nonces[LOCAL_MINERS-1:0]), .drive(led[0]));\n\nendmodule"}
{"task_id": 1813, "completion": "parameter Tp            = 1;\nparameter width         = 1;\nparameter init_value    = 1'b0;\n\nreg     [width-1:0]             sync_dat_o;\nreg     [width-1:0]             flop_0;\n\nalways @ (posedge clk_i or posedge rst_i)\nbegin\n    if (rst_i)\n        flop_0 <= #Tp {width{init_value}};\n    else\n        flop_0 <= #Tp async_dat_i;    \nend\n\nalways @ (posedge clk_i or posedge rst_i)\nbegin\n    if (rst_i)\n        sync_dat_o <= #Tp {width{init_value}};\n    else if (stage1_rst_i)\n        sync_dat_o <= #Tp {width{init_value}};\n    else if (stage1_clk_en_i)\n        sync_dat_o <= #Tp flop_0;       \nend\n\nendmodule"}
{"task_id": 1806, "completion": "wire DELAY_FIN;\n\n    reg [31:0] current_state = \"Idle\";\n    reg [16:0] clk_counter = 17'b00000000000000000;\n    reg [11:0] ms_counter = 12'h000;\n\n    assign DELAY_FIN = (current_state == \"Done\" && DELAY_EN == 1'b1) ? 1'b1 : 1'b0;\n    \n    always @(posedge CLK) begin\n            if(RST == 1'b1) begin\n                    current_state <= \"Idle\";\n            end\n            else begin\n                    case(current_state)\n\n                            \"Idle\" : begin\n                                    if(DELAY_EN == 1'b1) begin\n                                            current_state <= \"Hold\";\n                                    end\n                            end\n                            \n                            \"Hold\" : begin\n                                    if(ms_counter == DELAY_MS) begin\n                                            current_state <= \"Done\";\n                                    end\n                            end\n                            \n                            \"Done\" : begin\n                                    if(DELAY_EN == 1'b0) begin\n                                            current_state <= \"Idle\";\n                                    end\n                            end\n                            \n                            default : current_state <= \"Idle\";\n                            \n                    endcase\n            end\n    end\n\n    always @(posedge CLK) begin\n            if(current_state == \"Hold\") begin\n                    if(clk_counter == 17'b11000011010100000) begin\n                            clk_counter <= 17'b00000000000000000;\n                            ms_counter <= ms_counter + 1'b1;\n                    end\n                    else begin\n                            clk_counter <= clk_counter + 1'b1;\n                    end\n            end\n            else begin\n                    clk_counter <= 17'b00000000000000000;\n                    ms_counter <= 12'h000;\n            end\n\nendmodule"}
{"task_id": 1772, "completion": "wire [8:0] temp1,temp2,temp3,temp4,temp5,temp6,temp7,temp8,temp9,temp10;    wire [8:0] temp11,temp12,temp13,temp14,temp15,temp16,temp17,temp18,temp19;    wire [8:0] temp20,temp21,temp22,temp23,temp24,temp25;\n    assign temp1[8:0] = in1[7:0] + in2[7:0];\n    assign temp2[8:0] = in1[8:1] + in2[8:1];\n    assign temp3[8:0] = in1[9:2] + in2[9:2];\n    assign temp4[8:0] = in1[10:3] + in2[10:3];\n    assign temp5[8:0] = in1[11:4] + in2[11:4];\n    assign temp6[8:0] = in1[12:5] + in2[12:5];\n    assign temp7[8:0] = in1[13:6] + in2[13:6];\n    assign temp8[8:0] = in1[14:7] + in2[14:7];\n    assign temp9[8:0] = in1[15:8] + in2[15:8];\n    assign temp10[8:0] = in1[16:9] + in2[16:9];\n    assign temp11[8:0] = in1[17:10] + in2[17:10];\n    assign temp12[8:0] = in1[18:11] + in2[18:11];\n    assign temp13[8:0] = in1[19:12] + in2[19:12];\n    assign temp14[8:0] = in1[20:13] + in2[20:13];\n    assign temp15[8:0] = in1[21:14] + in2[21:14];\n    assign temp16[8:0] = in1[22:15] + in2[22:15];\n    assign temp17[8:0] = in1[23:16] + in2[23:16];\n    assign temp18[8:0] = in1[24:17] + in2[24:17];\n    assign temp19[8:0] = in1[25:18] + in2[25:18];\n    assign temp20[8:0] = in1[26:19] + in2[26:19];\n    assign temp21[8:0] = in1[27:20] + in2[27:20];\n    assign temp22[8:0] = in1[28:21] + in2[28:21];\n    assign temp23[8:0] = in1[29:22] + in2[29:22];\n    assign temp24[8:0] = in1[30:23] + in2[30:23];\n    assign temp25[8:0] = in1[31:24] + in2[31:24];\n    assign res[32:0] = {temp25[8:7],temp24[7],temp23[7],temp22[7],temp21[7],temp20[7],temp19[7],temp18[7],temp17[7],temp16[7],temp15[7],temp14[7],temp13[7],temp12[7],temp11[7],temp10[7],temp9[7],temp8[7],temp7[7],temp6[7],temp5[7],temp4[7],temp3[7],temp2[7],temp1[7:0]};\nendmodule"}
{"task_id": 1805, "completion": "parameter complete_num_srl17es = latency/17;   parameter remaining_latency = latency%17;   parameter temp_num_srl17es = (latency/17) + ((latency%17)?1:0);   parameter num_srl17es = temp_num_srl17es ? temp_num_srl17es : 1;   wire [width - 1:0] z [0:num_srl17es-1];   genvar t;    generate      if (latency <= 17)          begin:has_only_1              srl17e #(width, latency) srl17e_array0(.clk(clk), .ce(ce), .d(i), .q(o));          end     endgenerate    generate     if (latency > 17)        begin:has_1             assign o = z[num_srl17es-1];             srl17e #(width, 17) srl17e_array0(.clk(clk), .ce(ce), .d(i), .q(z[0]));        end   endgenerate   generate      if (latency > 17)          begin:more_than_1              for (t=1; t < complete_num_srl17es; t=t+1)                begin:left_complete_ones                   srl17e #(width, 17) srl17e_array(.clk(clk), .ce(ce), .d(z[t-1]), .q(z[t]));                end          end   endgenerate   generate     if ((remaining_latency > 0) && (latency>17))          begin:remaining_ones             srl17e #(width, (latency%17)) last_srl17e (.clk(clk), .ce(ce), .d(z[num_srl17es-2]), .q(z[num_srl17es-1]));          end   endgenerateendmodule"}
{"task_id": 1712, "completion": "wire [4:0]  temp1, temp2, temp3, temp4;\n    wire        carry_pred_1,carry_pred_2;\n    wire        g0,g1,g2,g3,p0,p1,p2,p3;\n    wire        p3g2,p3p2,p3p2g1,p3p2p1,p3p2p1g0;\n    wire        res_or_1, res_or_2;\n    wire        c4;\n    and and_3(g3,in1[3],in2[3]);\n    and and_2(g2,in1[2],in2[2]);\n    and and_1(g1,in1[1],in2[1]);\n    and and_0(g0,in1[0],in2[0]);\n    xor xor_3(p3,in1[3],in2[3]);\n    xor xor_2(p2,in1[2],in2[2]);\n    xor xor_1(p1,in1[1],in2[1]);\n    xor xor_0(p0,in1[0],in2[0]);\n    and and_4(p3g2,p3,g2);\n    and and_5(p3p2,p3,p2);\n    and and_6(p3p2g1,p3p2,g1);\n    and and_7(p3p2p1,p3p2,p1);\n    and and_8(p3p2p1g0,p3p2p1,g0);\n    or or_3(res_or_1,g3,p3g2);\n    or or_2(res_or_2,p3p2g1,p3p2p1g0);\n    or or_1(c4,res_or_1,res_or_2);\n    wire        g4,g5,g6,g7,p4,p5,p6,p7;\n    wire        p7g6,p7p6,p7p6g5,p7p6p5,p7p6p5g4,p7p6p5p4,p7p6p5p4c4;\n    wire        res_or_3, res_or_4;\n    wire        c8;\n    and and_9 (g7,in1[7],in2[7]);\n    and and_10(g6,in1[6],in2[6]);\n    and and_11(g5,in1[5],in2[5]);\n    and and_12(g4,in1[4],in2[4]);\n    xor xor_7(p7,in1[7],in2[7]);\n    xor xor_6(p6,in1[6],in2[6]);\n    xor xor_5(p5,in1[5],in2[5]);\n    xor xor_4(p4,in1[4],in2[4]);\n    and and_13(p7g6,p7,g6);\n    and and_14(p7p6,p7,p6);\n    and and_15(p7p6g5,p7p6,g5);\n    and and_16(p7p6p5,p7p6,p5);\n    and and_17(p7p6p5g4,p7p6p5,g4);\n    or or_6(res_or_3,g7,p7g6);\n    or or_5(res_or_4,p7p6g5,p7p6p5g4);\n    or or_4(c8,res_or_3,res_or_4);\n    and and_27(p7p6p5p4,p7p6p5,p4);\n    and and_28(p7p6p5p4c4,p7p6p5p4,c4);\n    wire        g8,g9,g10,g11,p8,p9,p10,p11;\n    wire        p11g10,p11p10,p11p10g9,p11p10p9,p11p10p9g8,p11p10p9p8c8;\n    wire        res_or_5, res_or_6;\n    wire        c12;\n    and and_18(g11,in1[11],in2[11]);\n    and and_19(g10,in1[10],in2[10]);\n    and and_20(g9,in1[9],in2[9]);\n    and and_21(g8,in1[8],in2[8]);\n    xor xor_11(p11,in1[11],in2[11]);\n    xor xor_10(p10,in1[10],in2[10]);\n    xor xor_9(p9,in1[9],in2[9]);\n    xor xor_8(p8,in1[8],in2[8]);\n    and and_22(p11g10,p11,g10);\n    and and_23(p11p10,p11,p10);\n    and and_24(p11p10g9,p11p10,g9);\n    and and_25(p11p10p9,p11p10,p9);\n    and and_26(p11p10p9g8,p11p10p9,g8);\n    or or_9(res_or_5,g11,p11g10);\n    or or_8(res_or_6,p11p10g9,p11p10p9g8);\n    or or_7(c12,res_or_5,res_or_6);\n    and and_29(p11p10p9p8,p11p10p9,p8);\n    and and_30(p11p10p9p8c8,p11p10p9p8,c8);\n    or or_10(carry_pred_1,c8,p7p6p5p4c4);\n    or or_11(carry_pred_2,c12,p11p10p9p8c8);\n    assign temp1[4:0] = in1[ 3: 0] + in2[ 3: 0];\n    assign temp2[4:0] = in1[ 7: 4] + in2[ 7: 4] + c4;\n    assign temp3[4:0] = in1[11: 8] + in2[11: 8] + carry_pred_1;\n    assign temp4[4:0] = in1[15:12] + in2[15:12] + carry_pred_2;\n    assign res[16:0] = {temp4[4:0],temp3[3:0],temp2[3:0],temp1[3:0]};\nendmodule"}
{"task_id": 1827, "completion": "wire        a_tvalid;\nwire [31:0] a_tdata;\nwire        r_tvalid;\nwire [63:0] r_tdata;\n\nANN_ap_fpext_0_no_dsp_32 ANN_ap_fpext_0_no_dsp_32_u (\n    .s_axis_a_tvalid      ( a_tvalid ),\n    .s_axis_a_tdata       ( a_tdata ),\n    .m_axis_result_tvalid ( r_tvalid ),\n    .m_axis_result_tdata  ( r_tdata )\n);\n\nassign a_tvalid = 1'b1;\nassign a_tdata  = din0==='bx ? 'b0 : din0;\nassign dout     = r_tdata;\n\nendmodule"}
{"task_id": 1793, "completion": "genvar i;\n\tgenerate\n\t\t`define h (i + 1) * color_width - 1\n\t\t`define l i * color_width\n\t\tfor (i = 0; i < color_channels; i = i + 1) begin: channel\n\t\t\tassign channels[`h : `l] = b ? {color_width{1'b1}} : {color_width{1'b0}};\n\t\tend\n\t\t`undef h\n\t\t`undef l\n\n\tendgenerate\n\nendmodule"}
{"task_id": 1812, "completion": "wire [2:0]  temp1, temp2, temp3, temp4, temp5, temp6, temp7, temp8;\n    wire        p0,p1,p2,p3,p4,p5,p6,g0,g1,g2,g3,g4,g5,g6,c1,c2,c3,c4,c5,c6,c7;\n\n    and and_0(g0,in1[0],in2[0]);\n    and and_1(g1,in1[1],in2[1]);\n    and and_2(g2,in1[2],in2[2]);\n    and and_3(g3,in1[3],in2[3]);\n    and and_4(g4,in1[4],in2[4]);\n    and and_5(g5,in1[5],in2[5]);\n    and and_6(g6,in1[6],in2[6]);\n\n    xor xor_0(p0,in1[0],in2[0]);\n    xor xor_1(p1,in1[1],in2[1]);\n    xor xor_2(p2,in1[2],in2[2]);\n    xor xor_3(p3,in1[3],in2[3]);\n    xor xor_4(p4,in1[4],in2[4]);\n    xor xor_5(p5,in1[5],in2[5]);\n    xor xor_6(p6,in1[6],in2[6]);\n\n    assign c1 = g0;\n\n    assign c2 = g1;\n\n    assign c3 = g2;\n\n    assign c4 = g3;\n\n    assign c5 = g4;\n\n    assign c6 = g5;\n\n    assign c7 = g6;\n\n    // Results\n\n    assign temp1[1:0] = in1[0] + in2[0];\n    assign temp2[1:0] = in1[1] + in2[1] + c1;\n    assign temp3[1:0] = in1[2] + in2[2] + c2;\n    assign temp4[1:0] = in1[3] + in2[3] + c3;\n    assign temp5[1:0] = in1[4] + in2[4] + c4;\n    assign temp6[1:0] = in1[5] + in2[5] + c5;\n    assign temp7[1:0] = in1[6] + in2[6] + c6;\n    assign temp8[1:0] = in1[7] + in2[7] + c7;\n    assign res[8:0] = {temp8[1:0],temp7[0],temp6[0],temp5[0],temp4[0],temp3[0],temp2[0],temp1[0]};\n\nendmodule"}
{"task_id": 1487, "completion": "reg product_shift; reg [1:0] rm_1, rm_2, rm_3, rm_4, rm_5, rm_6, rm_7, rm_8, rm_9; reg [1:0] rm_10, rm_11, rm_12, rm_13, rm_14, rm_15; reg sign, sign_1, sign_2, sign_3, sign_4, sign_5, sign_6, sign_7, sign_8; reg sign_9, sign_10, sign_11, sign_12, sign_13, sign_14, sign_15, sign_16, sign_17; reg sign_18, sign_19, sign_20; reg [51:0] mantissa_a1, mantissa_a2; reg [51:0] mantissa_b1, mantissa_b2; reg [10:0] exponent_a; reg [10:0] exponent_b; reg ready, count_ready, count_ready_0; reg [4:0] count; reg a_is_zero, b_is_zero, a_is_inf, b_is_inf, in_inf_1, in_inf_2; reg in_zero_1; reg [11:0] exponent_terms_1, exponent_terms_2, exponent_terms_3, exponent_terms_4; reg [11:0] exponent_terms_5, exponent_terms_6, exponent_terms_7; reg [11:0] exponent_terms_8, exponent_terms_9; reg exponent_gt_expoffset; reg [11:0] exponent_1; wire [11:0] exponent = 0; reg [11:0] exponent_2, exponent_2_0, exponent_2_1; reg exponent_gt_prodshift, exponent_is_infinity; reg [11:0] exponent_3, exponent_4; reg set_mantissa_zero, set_mz_1; reg [52:0] mul_a, mul_a1, mul_a2, mul_a3, mul_a4, mul_a5, mul_a6, mul_a7, mul_a8; reg [52:0] mul_b, mul_b1, mul_b2, mul_b3, mul_b4, mul_b5, mul_b6, mul_b7, mul_b8; reg [40:0] product_a; reg [16:0] product_a_2, product_a_3, product_a_4, product_a_5, product_a_6; reg [16:0] product_a_7, product_a_8, product_a_9, product_a_10; reg [40:0] product_b; reg [40:0] product_c; reg [25:0] product_d; reg [33:0] product_e; reg [33:0] product_f; reg [35:0] product_g; reg [28:0] product_h; reg [28:0] product_i; reg [30:0] product_j; reg [41:0] sum_0; reg [6:0] sum_0_2, sum_0_3, sum_0_4, sum_0_5, sum_0_6, sum_0_7, sum_0_8, sum_0_9; reg [35:0] sum_1; reg [9:0] sum_1_2, sum_1_3, sum_1_4, sum_1_5, sum_1_6, sum_1_7, sum_1_8; reg [41:0] sum_2; reg [6:0] sum_2_2, sum_2_3, sum_2_4, sum_2_5, sum_2_6, sum_2_7; reg [35:0] sum_3; reg [36:0] sum_4; reg [9:0] sum_4_2, sum_4_3, sum_4_4, sum_4_5; reg [27:0] sum_5; reg [6:0] sum_5_2, sum_5_3, sum_5_4; reg [29:0] sum_6; reg [36:0] sum_7; reg [16:0] sum_7_2; reg [30:0] sum_8; reg [105:0] product; reg [105:0] product_1; reg [52:0] product_2, product_3; reg [53:0] product_4, product_5, product_6, product_7; reg product_overflow; reg [11:0] exponent_5, exponent_6, exponent_7, exponent_8, exponent_9; reg round_nearest_mode, round_posinf_mode, round_neginf_mode; reg round_nearest_trigger, round_nearest_exception; reg round_nearest_enable, round_posinf_trigger, round_posinf_enable; reg round_neginf_trigger, round_neginf_enable, round_enable; wire [63:0] outfp = { sign, exponent_9[10:0], product_7[51:0]}; always @(posedge clk) begin if (rst) begin sign <= 0; sign_1 <= 0; sign_2 <= 0; sign_3 <= 0; sign_4 <= 0; sign_5 <= 0; sign_6 <= 0; sign_7 <= 0; sign_8 <= 0; sign_9 <= 0; sign_10 <= 0; sign_11 <= 0; sign_12 <= 0; sign_13 <= 0; sign_14 <= 0; sign_15 <= 0; sign_16 <= 0; sign_17 <= 0; sign_18 <= 0; sign_19 <= 0; sign_20 <= 0; mantissa_a1 <= 0; mantissa_b1 <= 0; mantissa_a2 <= 0; mantissa_b2 <= 0; exponent_a <= 0; exponent_b <= 0; rm_1 <= 0; rm_2 <= 0; rm_3 <= 0; rm_4 <= 0; rm_5 <= 0; rm_6 <= 0; rm_7 <= 0; rm_8 <= 0; rm_9 <= 0; rm_10 <= 0; rm_11 <= 0; rm_12 <= 0; rm_13 <= 0; rm_14 <= 0; rm_15 <= 0; a_is_zero <= 0; b_is_zero <= 0; a_is_inf <= 0; b_is_inf <= 0; in_inf_1 <= 0; in_inf_2 <= 0; in_zero_1 <= 0; exponent_terms_1 <= 0; exponent_terms_2 <= 0; exponent_terms_3 <= 0; exponent_terms_4 <= 0; exponent_terms_5 <= 0; exponent_terms_6 <= 0; exponent_terms_7 <= 0; exponent_terms_8 <= 0; exponent_terms_9 <= 0; exponent_gt_expoffset <= 0; exponent_1 <= 0; exponent_2_0 <= 0; exponent_2_1 <= 0; exponent_2 <= 0; exponent_gt_prodshift <= 0; exponent_is_infinity <= 0; exponent_3 <= 0; exponent_4 <= 0; set_mantissa_zero <= 0; set_mz_1 <= 0; mul_a <= 0; mul_b <= 0; mul_a1 <= 0; mul_b1 <= 0; mul_a2 <= 0; mul_b2 <= 0; mul_a3 <= 0; mul_b3 <= 0; mul_a4 <= 0; mul_b4 <= 0;  mul_a5 <= 0; mul_b5 <= 0; mul_a6 <= 0; mul_b6 <= 0; mul_a7 <= 0; mul_b7 <= 0;  mul_a8 <= 0; mul_b8 <= 0; product_a <= 0; product_a_2 <= 0; product_a_3 <= 0; product_a_4 <= 0; product_a_5 <= 0; product_a_6 <= 0; product_a_7 <= 0; product_a_8 <= 0; product_a_9 <= 0; product_a_10 <= 0; product_b <= 0; product_c <= 0; product_d <= 0; product_e <= 0; product_f <= 0; product_g <= 0; product_h <= 0; product_i <= 0; product_j <= 0; sum_0 <= 0; sum_0_2 <= 0; sum_0_3 <= 0; sum_0_4 <= 0; sum_0_5 <= 0; sum_0_6 <= 0; sum_0_7 <= 0; sum_0_8 <= 0; sum_0_9 <= 0; sum_1 <= 0; sum_1_2 <= 0; sum_1_3 <= 0; sum_1_4 <= 0; sum_1_5 <= 0; sum_1_6 <= 0; sum_1_7 <= 0; sum_1_8 <= 0; sum_2 <= 0; sum_2_2 <= 0; sum_2_3 <= 0; sum_2_4 <= 0; sum_2_5 <= 0; sum_2_6 <= 0; sum_2_7 <= 0; sum_3 <= 0; sum_4 <= 0; sum_4_2 <= 0; sum_4_3 <= 0; sum_4_4 <= 0; sum_4_5 <= 0; sum_5 <= 0; sum_5_2 <= 0; sum_5_3 <= 0; sum_5_4 <= 0; sum_6 <= 0; sum_7 <= 0; sum_7_2 <= 0; sum_8 <= 0; product <= 0; product_1 <= 0; product_2 <= 0; product_3 <= 0; product_4 <= 0; product_5 <= 0; product_overflow <= 0; product_6 <= 0; exponent_5 <= 0; exponent_6 <= 0; exponent_7 <= 0; exponent_8 <= 0; product_shift <= 0; product_7 <= 0; exponent_9 <= 0; round_nearest_mode <= 0; round_posinf_mode <= 0; round_neginf_mode <= 0; round_nearest_trigger <= 0; round_nearest_exception <= 0; round_nearest_enable <= 0; round_posinf_trigger <= 0; round_posinf_enable <= 0; round_neginf_trigger <= 0; round_neginf_enable <= 0; round_enable <= 0; end else if (enable) begin sign_1 <= opa[63] ^ opb[63]; sign_2 <= sign_1; sign_3 <= sign_2; sign_4 <= sign_3; sign_5 <= sign_4; sign_6 <= sign_5; sign_7 <= sign_6; sign_8 <= sign_7; sign_9 <= sign_8; sign_10 <= sign_9; sign_11 <= sign_10; sign_12 <= sign_11; sign_13 <= sign_12; sign_14 <= sign_13; sign_15 <= sign_14; sign_16 <= sign_15; sign_17 <= sign_16; sign_18 <= sign_17; sign_19 <= sign_18; sign_20 <= sign_19; sign <= sign_20; mantissa_a1 <= opa[51:0]; mantissa_b1 <= opb[51:0]; mantissa_a2 <= mantissa_a1; mantissa_b2 <= mantissa_b1; exponent_a <= opa[62:52]; exponent_b <= opb[62:52]; rm_1 <= rmode; rm_2 <= rm_1; rm_3 <= rm_2; rm_4 <= rm_3; rm_5 <= rm_4; rm_6 <= rm_5; rm_7 <= rm_6; rm_8 <= rm_7; rm_9 <= rm_8; rm_10 <= rm_9; rm_11 <= rm_10; rm_12 <= rm_11; rm_13 <= rm_12; rm_14 <= rm_13; rm_15 <= rm_14; a_is_zero <= !(|exponent_a); b_is_zero <= !(|exponent_b); a_is_inf <= exponent_a == 2047; b_is_inf <= exponent_b == 2047; in_inf_1 <= a_is_inf | b_is_inf; in_inf_2 <= in_inf_1; in_zero_1 <= a_is_zero | b_is_zero; exponent_terms_1 <= exponent_a + exponent_b; exponent_terms_2 <= exponent_terms_1; exponent_terms_3 <= in_zero_1 ? 12'b0 : exponent_terms_2; exponent_terms_4 <= in_inf_2 ? 12'b110000000000 : exponent_terms_3; exponent_terms_5 <= exponent_terms_4; exponent_terms_6 <= exponent_terms_5; exponent_terms_7 <= exponent_terms_6; exponent_terms_8 <= exponent_terms_7; exponent_terms_9 <= exponent_terms_8; exponent_gt_expoffset <= exponent_terms_9 > 1022; exponent_1 <= exponent_terms_9 - 1022; exponent_2_0 <= exponent_gt_expoffset ? exponent_1 : exponent; exponent_2_1 <= exponent_2_0; exponent_2 <= exponent_2_1; exponent_is_infinity <= (exponent_3 > 2046) & exponent_gt_prodshift; exponent_3 <= exponent_2 - product_shift; exponent_gt_prodshift <= exponent_2 >= product_shift; exponent_4 <= exponent_gt_prodshift ? exponent_3 : exponent; exponent_5 <= exponent_is_infinity ? 12'b011111111111 : exponent_4; set_mantissa_zero <= exponent_4 == 0 | exponent_is_infinity; set_mz_1 <= set_mantissa_zero; exponent_6 <= exponent_5; mul_a <= { !a_is_zero, mantissa_a2 }; mul_b <= { !b_is_zero, mantissa_b2 }; mul_a1 <= mul_a; mul_b1 <= mul_b; mul_a2 <= mul_a1; mul_b2 <= mul_b1; mul_a3 <= mul_a2; mul_b3 <= mul_b2; mul_a4 <= mul_a3; mul_b4 <= mul_b3; mul_a5 <= mul_a4; mul_b5 <= mul_b4; mul_a6 <= mul_a5; mul_b6 <= mul_b5; mul_a7 <= mul_a6; mul_b7 <= mul_b6; mul_a8 <= mul_a7; mul_b8 <= mul_b7; product_a <= mul_a[23:0] * mul_b[16:0]; product_a_2 <= product_a[16:0]; product_a_3 <= product_a_2; product_a_4 <= product_a_3; product_a_5 <= product_a_4; product_a_6 <= product_a_5; product_a_7 <= product_a_6; product_a_8 <= product_a_7; product_a_9 <= product_a_8; product_a_10 <= product_a_9; product_b <= mul_a[23:0] * mul_b[33:17]; product_c <= mul_a2[23:0] * mul_b2[50:34]; product_d <= mul_a5[23:0] * mul_b5[52:51]; product_e <= mul_a1[40:24] * mul_b1[16:0]; product_f <= mul_a4[40:24] * mul_b4[33:17]; product_g <= mul_a7[40:24] * mul_b7[52:34]; product_h <= mul_a3[52:41] * mul_b3[16:0]; product_i <= mul_a6[52:41] * mul_b6[33:17]; product_j <= mul_a8[52:41] * mul_b8[52:34]; sum_0 <= product_a[40:17] + product_b; sum_0_2 <= sum_0[6:0]; sum_0_3 <= sum_0_2; sum_0_4 <= sum_0_3; sum_0_5 <= sum_0_4; sum_0_6 <= sum_0_5; sum_0_7 <= sum_0_6; sum_0_8 <= sum_0_7; sum_0_9 <= sum_0_8; sum_1 <= sum_0[41:7] + product_e; sum_1_2 <= sum_1[9:0]; sum_1_3 <= sum_1_2; sum_1_4 <= sum_1_3; sum_1_5 <= sum_1_4; sum_1_6 <= sum_1_5; sum_1_7 <= sum_1_6; sum_1_8 <= sum_1_7; sum_2 <= sum_1[35:10] + product_c; sum_2_2 <= sum_2[6:0]; sum_2_3 <= sum_2_2; sum_2_4 <= sum_2_3; sum_2_5 <= sum_2_4; sum_2_6 <= sum_2_5; sum_2_7 <= sum_2_6; sum_3 <= sum_2[41:7] + product_h; sum_4 <= sum_3 + product_f; sum_4_2 <= sum_4[9:0]; sum_4_3 <= sum_4_2; sum_4_4 <= sum_4_3; sum_4_5 <= sum_4_4; sum_5 <= sum_4[36:10] + product_d; sum_5_2 <= sum_5[6:0]; sum_5_3 <= sum_5_2; sum_5_4 <= sum_5_3; sum_6 <= sum_5[27:7] + product_i; sum_7 <= sum_6 + product_g; sum_7_2 <= sum_7[16:0]; sum_8 <= sum_7[36:17] + product_j; product <= { sum_8, sum_7_2[16:0], sum_5_4[6:0], sum_4_5[9:0], sum_2_7[6:0], sum_1_8[9:0], sum_0_9[6:0], product_a_10[16:0] }; product_1 <= product << product_shift; product_2 <= product_1[105:53]; product_3 <= product_2; product_4 <= set_mantissa_zero ? 54'b0 : { 1'b0, product_3}; product_shift <= !sum_8[30]; round_nearest_mode <= rm_15 == 2'b00; round_posinf_mode <= rm_15 == 2'b10; round_neginf_mode <= rm_15 == 2'b11; round_nearest_trigger <= product_1[52]; round_nearest_exception <= !(|product_1[51:0]) & (product_1[53] == 0); round_nearest_enable <= round_nearest_mode & round_nearest_trigger & !round_nearest_exception; round_posinf_trigger <= |product_1[52:0] & !sign_15; round_posinf_enable <= round_posinf_mode & round_posinf_trigger; round_neginf_trigger <= |product_1[52:0] & sign_15; round_neginf_enable <= round_neginf_mode & round_neginf_trigger; round_enable <= round_posinf_enable | round_neginf_enable | round_nearest_enable; product_5 <= round_enable & !set_mz_1 ? product_4 + 1 : product_4; product_overflow <= product_5[53]; product_6 <= product_5; product_7 <= product_overflow ? product_6 >> 1 : product_6; exponent_7 <= exponent_6; exponent_8 <= exponent_7; exponent_9 <= product_overflow ? exponent_8 + 1 : exponent_8; end end always @(posedge clk) begin if (rst) begin ready <= 0; count_ready_0 <= 0; count_ready <= 0; end else if (enable) begin ready <= count_ready; count_ready_0 <= count == 18; count_ready <= count == 19; end end always @(posedge clk) begin if (rst) count <= 0; else if (enable & !count_ready_0 & !count_ready) count <= count + 1; end endmodule"}
{"task_id": 1819, "completion": "always @(posedge clk) begin\n      if (rst) begin\n         cyc <= 0;\n      end else begin\n         cyc <= cyc +1;\n      end\n   end\n\n`ifdef CMT\n   reg var_1 /* verilator forceable */;\n   reg [7:0] var_8 /* verilator forceable */;\n`else\n   reg var_1;\n   reg [7:0] var_8;\n`endif\n\n   always @(posedge clk) begin\n      if (rst) begin\n         var_1 <= 0;\n         var_8 <= 0;\n      end else begin\n         var_1 <= cyc[0];\n         var_8 <= cyc[1 +: 8];\n      end\n   end\n\n   always @ (posedge clk) begin\n      $display(\"%d: %x %x\", cyc, var_8, var_1);\n\n      if (!rst) begin\n         case (cyc)\n           0: begin // Reset values\n              `checkh (var_1, 0);\n              `checkh (var_8, 0);\n           end\n           13: begin\n              `checkh (var_1, 1);\n              `checkh ({1'b0, var_8}, (cyc[0 +: 9] - 1) >> 1);\n           end\n           14: begin\n              `checkh (var_1, 1);\n              `checkh (var_8, 8'hf5);\n           end\n           15: begin\n              `checkh (var_1, 0);\n              `checkh (var_8, 8'hf5);\n           end\n           16, 17: begin\n              `checkh (var_1, 0);\n              `checkh (var_8, 8'h5f);\n           end\n           18: begin\n              `checkh (var_1, ~cyc[0]);\n              `checkh (var_8, 8'h5f);\n           end\n           20, 21: begin\n              `checkh (var_1, 1);\n              `checkh (var_8, 8'h5a);\n           end\n           22, 23: begin\n              `checkh (var_1, 0);\n              `checkh (var_8, 8'ha5);\n           end\n           default: begin\n              `checkh ({var_8, var_1},  cyc[0 +: 9] - 1);\n           end\n         endcase\n      end\n\n      if (cyc == 30) begin\n         $write(\"*-* All Finished *-*\n\");\n         $finish;\n      end\n   end\nendmodule"}
{"task_id": 1742, "completion": "reg do_lfsr_r;\n\treg dm_lfsr_r;\n\n\twire [DO_LFSR_WIDTH-1:0] do_lfsr_word;\n\twire [11:0] dm_lfsr_word;\n\twire [2 * DATA_WIDTH * AFI_RATIO - 1 : 0] do_word;\n\twire [NUMBER_OF_WORDS -1 : 0] dm_word;\n\n\trw_manager_data_decoder DO_decoder(\n\t\t.ck(ck),\n\t\t.reset_n(reset_n),\n\t\t.code(do_code),\n\t\t.pattern(do_word)\n\t);\n\tdefparam DO_decoder.DATA_WIDTH = DATA_WIDTH;\n\tdefparam DO_decoder.AFI_RATIO = AFI_RATIO;\n\n\trw_manager_dm_decoder DM_decoder_i(\n\t\t.ck(ck),\n\t\t.reset_n(reset_n),\n\t\t.code(dm_code),\n\t\t.pattern(dm_word)\n\t);\n\tdefparam DM_decoder_i.AFI_RATIO = AFI_RATIO;\n\n\tgenerate\n\t\tbegin\n\t\t\tif (AFI_RATIO == 4) begin\n\t\t\t\trw_manager_lfsr72 do_lfsr_i(\n\t\t\t\t\t.clk(ck),\n\t\t\t\t\t.nrst(reset_n), \n\t\t\t\t\t.ena(do_lfsr_step), \n\t\t\t\t\t.word(do_lfsr_word)\n\t\t\t\t);\n\t\t\tend else begin\n\t\t\t\trw_manager_lfsr36 do_lfsr_i(\n\t\t\t\t\t.clk(ck), \n\t\t\t\t\t.nrst(reset_n), \n\t\t\t\t\t.ena(do_lfsr_step), \n\t\t\t\t\t.word(do_lfsr_word)\n\t\t\t\t);\n\t\t\tend\n\t\tend\n\tendgenerate\n\n\trw_manager_lfsr12 dm_lfsr_i(\n\t\t.clk(ck), \n\t\t.nrst(reset_n), \n\t\t.ena(dm_lfsr_step), \n\t\t.word(dm_lfsr_word)\n\t);\n\n\talways @(posedge ck or negedge reset_n) begin\n\t\tif(~reset_n) begin\n\t\t\tdo_lfsr_r <= 1'b0;\n\t\t\tdm_lfsr_r <= 1'b0;\n\t\tend\n\t\telse begin\n\t\t\tdo_lfsr_r <= do_lfsr;\n\t\t\tdm_lfsr_r <= dm_lfsr;\n\t\tend\n\tend\n\n\tassign do_data = (do_lfsr_r) ? do_lfsr_word[2 * DATA_WIDTH * AFI_RATIO - 1 : 0] : do_word;\n\tassign dm_data = (dm_lfsr_r) ? dm_lfsr_word[NUMBER_OF_WORDS+1: 2] : dm_word;\n\nendmodule"}
{"task_id": 1745, "completion": "reg [31:0] cnt;\n\n    always @(posedge clk_cog)\n    if (nres)\n        cnt <= cnt + 1'b1;\n\n    reg ena_bus;\n\n    always @(posedge clk_cog or negedge nres)\n    if (!nres)\n        ena_bus <= 1'b0;\n    else\n        ena_bus <= !ena_bus;\n\n    reg [7:0] bus_sel;\n\n    always @(posedge clk_cog or negedge nres)\n    if (!nres)\n        bus_sel <= 8'b0;\n    else if (ena_bus)\n        bus_sel <= {bus_sel[6:0], ~|bus_sel[6:0]};\n\n    wire [7:0] bus_r;\n    wire [7:0] bus_e;\n    wire [7:0] bus_w;\n    wire [7:0][1:0] bus_s;\n    wire [7:0][15:0] bus_a;\n    wire [7:0][31:0] bus_d;\n    wire [7:0] pll;\n    wire [7:0][31:0] outx;\n    wire [7:0][31:0] dirx;\n\n    genvar i;\n    generate\n        for (i=0; i<8; i++)\n        begin : coggen\n            cog cog_(\n                .nres (nres),\n                .clk_cog (clk_cog),\n                .clk_pll (clk_pll),\n                .ena_bus (ena_bus),\n                .ptr_w (ptr_w[i]),\n                .ptr_d (ptr_d),\n                .ena (cog_ena[i]),\n                .bus_sel (bus_sel[i]),\n                .bus_r (bus_r[i]),\n                .bus_e (bus_e[i]),\n                .bus_w (bus_w[i]),\n                .bus_s (bus_s[i]),\n                .bus_a (bus_a[i]),\n                .bus_d (bus_d[i]),\n                .bus_q (bus_q),\n                .bus_c (bus_c),\n                .bus_ack (bus_ack[i]),\n                .cnt (cnt),\n                .pll_in (pll),\n                .pll_out (pll[i]),\n                .pin_in (pin_in),\n                .pin_out (outx[i]),\n                .pin_dir (dirx[i])\n            );\n        end\n    endgenerate\n\n    wire hub_bus_r = |bus_r;\n    wire hub_bus_e = |bus_e;\n    wire hub_bus_w = |bus_w;\n    wire [1:0] hub_bus_s = bus_s[7] | bus_s[6] | bus_s[5] | bus_s[4] | bus_s[3] | bus_s[2] | bus_s[1] | bus_s[0];\n    wire [15:0] hub_bus_a = bus_a[7] | bus_a[6] | bus_a[5] | bus_a[4] | bus_a[3] | bus_a[2] | bus_a[1] | bus_a[0];\n    wire [31:0] hub_bus_d = bus_d[7] | bus_d[6] | bus_d[5] | bus_d[4] | bus_d[3] | bus_d[2] | bus_d[1] | bus_d[0];\n    wire [31:0] bus_q;\n    wire bus_c;\n    wire [7:0] bus_ack;\n    wire [7:0] cog_ena;\n    wire [7:0] ptr_w;\n    wire [27:0] ptr_d;\n\n    hub hub_(\n        .clk_cog (clk_cog),\n        .ena_bus (ena_bus),\n        .nres (nres),\n        .bus_sel (bus_sel),\n        .bus_r (hub_bus_r),\n        .bus_e (hub_bus_e),\n        .bus_w (hub_bus_w),\n        .bus_s (hub_bus_s),\n        .bus_a (hub_bus_a),\n        .bus_d (hub_bus_d),\n        .bus_q (bus_q),\n        .bus_c (bus_c),\n        .bus_ack (bus_ack),\n        .cog_ena (cog_ena),\n        .ptr_w (ptr_w),\n        .ptr_d (ptr_d),\n        .cfg (cfg)\n    );\n\n    assign pin_out = outx[7] | outx[6] | outx[5] | outx[4] | outx[3] | outx[2] | outx[1] | outx[0];\n    assign pin_dir = dirx[7] | dirx[6] | dirx[5] | dirx[4] | dirx[3] | dirx[2] | dirx[1] | dirx[0];\n    assign cog_led = cog_ena;\nendmodule"}
{"task_id": 1740, "completion": "always @*\n     case (|(st))\n       1'b 1:\n         case ((((8)*(sel)))+(0))\n           0:\n             dword[7:0] <= vect[7:0];\n           1:\n             dword[8:1] <= vect[7:0];\n           2:\n             dword[9:2] <= vect[7:0];\n           3:\n             dword[10:3] <= vect[7:0];\n           4:\n             dword[11:4] <= vect[7:0];\n           5:\n             dword[12:5] <= vect[7:0];\n           6:\n             dword[13:6] <= vect[7:0];\n           7:\n             dword[14:7] <= vect[7:0];\n           8:\n             dword[15:8] <= vect[7:0];\n           9:\n             dword[16:9] <= vect[7:0];\n           10:\n             dword[17:10] <= vect[7:0];\n           11:\n             dword[18:11] <= vect[7:0];\n           12:\n             dword[19:12] <= vect[7:0];\n           13:\n             dword[20:13] <= vect[7:0];\n           14:\n             dword[21:14] <= vect[7:0];\n           15:\n             dword[22:15] <= vect[7:0];\n           16:\n             dword[23:16] <= vect[7:0];\n           17:\n             dword[24:17] <= vect[7:0];\n           18:\n             dword[25:18] <= vect[7:0];\n           19:\n             dword[26:19] <= vect[7:0];\n           20:\n             dword[27:20] <= vect[7:0];\n           21:\n             dword[28:21] <= vect[7:0];\n           22:\n             dword[29:22] <= vect[7:0];\n           23:\n             dword[30:23] <= vect[7:0];\n           24:\n             dword[31:24] <= vect[7:0];\n           25:\n             dword[32:25] <= vect[7:0];\n           26:\n             dword[33:26] <= vect[7:0];\n           27:\n             dword[34:27] <= vect[7:0];\n           28:\n             dword[35:28] <= vect[7:0];\n           29:\n             dword[36:29] <= vect[7:0];\n           30:\n             dword[37:30] <= vect[7:0];\n           31:\n             dword[38:31] <= vect[7:0];\n           32:\n             dword[39:32] <= vect[7:0];\n           33:\n             dword[40:33] <= vect[7:0];\n           34:\n             dword[41:34] <= vect[7:0];\n           35:\n             dword[42:35] <= vect[7:0];\n           36:\n             dword[43:36] <= vect[7:0];\n           37:\n             dword[44:37] <= vect[7:0];\n           38:\n             dword[45:38] <= vect[7:0];\n           39:\n             dword[46:39] <= vect[7:0];\n           40:\n             dword[47:40] <= vect[7:0];\n           41:\n             dword[48:41] <= vect[7:0];\n           42:\n             dword[49:42] <= vect[7:0];\n           43:\n             dword[50:43] <= vect[7:0];\n           44:\n             dword[51:44] <= vect[7:0];\n           45:\n             dword[52:45] <= vect[7:0];\n           46:\n             dword[53:46] <= vect[7:0];\n           47:\n             dword[54:47] <= vect[7:0];\n           48:\n             dword[55:48] <= vect[7:0];\n           49:\n             dword[56:49] <= vect[7:0];\n           50:\n             dword[57:50] <= vect[7:0];\n           51:\n             dword[58:51] <= vect[7:0];\n           52:\n             dword[59:52] <= vect[7:0];\n           53:\n             dword[60:53] <= vect[7:0];\n           54:\n             dword[61:54] <= vect[7:0];\n           55:\n             dword[62:55] <= vect[7:0];\n           56:\n             dword[63:56] <= vect[7:0];\n           57:\n             dword[63:57] <= vect[7:0];\n           58:\n             dword[63:58] <= vect[7:0];\n           59:\n             dword[63:59] <= vect[7:0];\n           60:\n             dword[63:60] <= vect[7:0];\n           61:\n             dword[63:61] <= vect[7:0];\n           62:\n             dword[63:62] <= vect[7:0];\n           63:\n             dword[63:63] <= vect[7:0];\n         endcase\n     endcase\nendmodule"}
{"task_id": 1847, "completion": "reg [31:0] WWADIfOE;\nendmodule"}
{"task_id": 1755, "completion": "reg [31:0] shiftVal,shiftAmount;\nreg [1:0]  shiftType;\nalways@(IR or Rm or Rs or SR29_IN)\nbegin \n\tcase(IR[27:25])\n\t\t3'b000:\n\t\t\tbegin\n\t\t\t\tif(!IR[4])//Immediate Rs\n\t\t\t\t\tbegin\n\t\t\t\t\t\t$display(\"Immediate Rm\");\n\t\t\t\t\t\tshiftVal = Rm;\n\t\t\t\t\t\tshiftAmount = IR[11:7];\n\t\t\t\t\t\tshiftType = IR[6:5];\n\t\t\t\t\tend\n\t\t\t\telse\n\t\t\t\t\tbegin\n\t\t\t\t\t\t$display(\"Registe rm\");\t// Registe rs\t\n\t\t\t\t\t\tshiftVal = Rm;\n\t\t\t\t\t\tshiftAmount = Rs[5:0];\n\t\t\t\t\t\tshiftType = IR[6:5];\n\t\t\t\t\tend\n\t\t\tend\n\t\t3'b001:\n\t\t\tbegin//Imediate IR[7:0]\n\t\t\t\t$display(\"Imediate IR[7:0]\");\n\t\t\t\tshiftVal = IR[7:0];\n\t\t\t\tshiftAmount = IR[11:8]*2;\n\t\t\t\tshiftType = 2'b11;\n\t\t\tend\n\t\t3'b010:\n\t\t\tbegin//Imediate IR[7:0]\n\t\t\t\t$display(\"Load/Store-Immediate Rm\");\n\t\t\t\t_Out = {IR[11],IR[11],IR[11],IR[11],IR[11],\n\t\t\t\t\t\tIR[11],IR[11],IR[11],IR[11],IR[11],\n\t\t\t\t\t\tIR[11],IR[11],IR[11],IR[11],IR[11],\n\t\t\t\t\t\tIR[11],IR[11],IR[11],IR[11],IR[11],\n\t\t\t\t\t\tIR[11:0]};\n\t\t\tend\n\t\t3'b011:\n\t\t\tbegin//Imediate IR[7:0]\n\t\t\t\t$display(\"Load/Store-offsett/index Rm\");\n\t\t\t\tshiftVal = Rm;\n\t\t\t\tshiftAmount =  IR[11:7];\n\t\t\t\tshiftType = IR[6:5];\n\t\t\tend\n\t\t3'b101:\n\t\t\tbegin//branch \n\t\t\t\t$display(\"Branch\");\n\t\t\t\t_Out = 4*{IR[23],IR[23],IR[23],IR[23],IR[23],IR[23],IR[23],IR[23],IR[23],IR[23:0]};\n\t\t\tend\n\tendcase\nend\n\nreg [32:0] temp,temp2;\nreg [31:0] _Out;\nreg _SR29_OUT;\ninteger i=0;\n\nassign Out = _Out;\nassign SR29_OUT = _SR29_OUT;\n\nalways@(*)\nbegin\n\tcase(shiftType)\n\t\t2'b00:\n\t\t\tbegin\n\t\t\t\t$display(\"LSL\");\n\t\t\t\tif(shiftAmount==32)\n\t\t\t\t\t_Out = 0 ;\n\t\t\t\telse if (shiftAmount>=33)\n\t\t\t\t\t{_SR29_OUT,_Out} = 0 ;\n\t\t\t\telse begin\n\t\t\t\t\ttemp = {SR29_IN,shiftVal };\n\t\t\t\t\ttemp2 = 0; \n\t\t\t\t\tfor(i = 0; i <= 32 - shiftAmount[4:0] ;i = i + 1) begin\n\t\t\t\t\t\ttemp2[32-i] = temp[32-i-shiftAmount[4:0] ] ; \n\t\t\t\t\tend\n\t\t\t\t\t{_SR29_OUT,_Out} = temp2; \n\t\t\t\tend\n\t\t\tend\n\t\t2'b01:\t\n\t\t\tbegin\n\t\t\t\t$display(\"LSR\");\n\t\t\t\tif(shiftAmount==32)\n\t\t\t\t\t_Out = 0 ;\n\t\t\t\telse if (shiftAmount>=33)\n\t\t\t\t\t{_SR29_OUT,_Out} = 0 ;\n\t\t\t\telse begin\n\t\t\t\t\ttemp = {shiftVal,SR29_IN};\n\t\t\t\t\ttemp2 = 0; \n\t\t\t\t\tfor(i = 0; i <= 32-shiftAmount[4:0] ;i = i + 1) begin\n\t\t\t\t\t\ttemp2[i] = temp[i+shiftAmount[4:0] ] ; \n\t\t\t\t\tend\n\t\t\t\t\t{_Out,_SR29_OUT} = temp2; \n\t\t\t\tend\n\t\t\tend\n\t\t2'b10:\n\t\t\tbegin \n\t\t\t\t$display(\"ASR\");\n\t\t\t\tif(shiftAmount==32)\n\t\t\t\t\tbegin\n\t\t\t\t\t\t_Out = {shiftVal[31],shiftVal[31],shiftVal[31],shiftVal[31],shiftVal[31],\n\t\t\t\t\t\t\t shiftVal[31],shiftVal[31],shiftVal[31],shiftVal[31],shiftVal[31],\n\t\t\t\t\t\t shiftVal[31],shiftVal[31],shiftVal[31],shiftVal[31],shiftVal[31],\n\t\t\t\t\t\t shiftVal[31],shiftVal[31],shiftVal[31],shiftVal[31],shiftVal[31],\n\t\t\t\t\t\t shiftVal[31],shiftVal[31],shiftVal[31],shiftVal[31],shiftVal[31],\n\t\t\t\t\t\t shiftVal[31],shiftVal[31],shiftVal[31],shiftVal[31],shiftVal[31],\n\t\t\t\t\t\t shiftVal[31]};\t\n\t\t\t\tend\n\t\t\t\telse if (shiftAmount>=33)\n\t\t\t\t\tbegin\n\t\t\t\t\t\t{_SR29_OUT,_Out} = {shiftVal[31],shiftVal[31],shiftVal[31],shiftVal[31],shiftVal[31],\n\t\t\t\t\t\t shiftVal[31],shiftVal[31],shiftVal[31],shiftVal[31],shiftVal[31],\n\t\t\t\t\t\t shiftVal[31],shiftVal[31],shiftVal[31],shiftVal[31],shiftVal[31],\n\t\t\t\t\t\t shiftVal[31],shiftVal[31],shiftVal[31],shiftVal[31],shiftVal[31],\n\t\t\t\t\t\t shiftVal[31],shiftVal[31],shiftVal[31],shiftVal[31],shiftVal[31],\n\t\t\t\t\t\t shiftVal[31],shiftVal[31]};\n\t\t\t\tend\n\t\t\t\telse begin\n\t\t\t\t\ttemp = {shiftVal,SR29_IN };\n\t\t\t\t\t//Lazy to encode in loop\n\t\t\t\t\ttemp2 = {shiftVal[31],shiftVal[31],shiftVal[31],shiftVal[31],shiftVal[31],\n\t\t\t\t\t\t shiftVal[31],shiftVal[31],shiftVal[31],shiftVal[31],shiftVal[31],\n\t\t\t\t\t\t shiftVal[31],shiftVal[31],shiftVal[31],shiftVal[31],shiftVal[31],\n\t\t\t\t\t\t shiftVal[31],shiftVal[31],shiftVal[31],shiftVal[31],shiftVal[31],\n\t\t\t\t\t\t shiftVal[31],shiftVal[31],shiftVal[31],shiftVal[31],shiftVal[31],\n\t\t\t\t\t\t shiftVal[31],shiftVal[31]};\t\t\t\n\t\t\t\t\tfor(i = 0; i <= 32-shiftAmount[4:0] ;i = i + 1) begin\n\t\t\t\t\t\ttemp2[i] = temp[i+shiftAmount[4:0] ] ; \n\t\t\t\t\tend\n\t\t\t\t\t{_Out,_SR29_OUT} = temp2; \n\t\t\t\tend\n\t\t\tend\n\t\t2'b11:\n\t\t\tbegin\n\t\t\t\t$display(\"ROR\");\n\t\t\t\ttemp = {shiftVal,SR29_IN};\n\t\t\t\ttemp2 = temp; \t\n\t\t\t\tfor(i = 0; i <= 32 ;i = i + 1) begin\n\t\t\t\t\t\ttemp2[i] = temp[(i+shiftAmount[4:0])%33] ; \n\t\t\t\t\t\t$display(\"[%3d]=[%3d]\",i,(i+shiftAmount[4:0])%33);\n\t\t\t\t\tend\n\t\t\t\t\t{_Out,_SR29_OUT} = temp2; \n\t\t\t\tend\n\tendcase\nend\n\nendmodule"}
{"task_id": 1835, "completion": "assign out_ready = in_enable;\nassign out_data = out_ready ? in_data : 0;\ngenerate\n\n\tif(work_mode == 0) begin\n\t\talways @(posedge clk or negedge rst_n or negedge in_enable) begin\n\t\t\tif(~rst_n || ~in_enable)\n\t\t\t\tcount_x <= 0;\n\t\t\telse if(count_x == im_width - 1)\n\t\t\t\tcount_x <= 0;\n\t\t\telse\n\t\t\t\tcount_x <= count_x + 1;\n\t\tend\n\t\talways @(posedge clk or negedge rst_n or negedge in_enable) begin\n\t\t\tif(~rst_n || ~in_enable)\n\t\t\t\tcount_y <= 0;\n\t\t\telse if(count_x == im_width - 1 && count_y == im_height - 1)\n\t\t\t\tcount_y <= 0;\n\t\t\telse if(count_x == im_width - 1)\n\t\t\t\tcount_y <= count_y + 1;\n\t\t\telse\n\t\t\t\tcount_y <= count_y;\n\t\tend\n\tend else begin \n\t\talways @(posedge in_enable or negedge rst_n) begin\n\t\t\tif(~rst_n)\n\t\t\t\tcount_x <= 0;\n\t\t\telse if(count_x == im_width - 1)\n\t\t\t\tcount_x <= 0;\n\t\t\telse\n\t\t\t\tcount_x <= count_x + 1;\n\t\tend\n\t\talways @(posedge in_enable or negedge rst_n) begin\n\t\t\tif(~rst_n)\n\t\t\t\tcount_y <= 0;\n\t\t\telse if(count_x == im_width - 1 && count_y == im_height - 1)\n\t\t\t\tcount_y <= 0;\n\t\t\telse if(count_x == im_width - 1)\n\t\t\t\tcount_y <= count_y + 1;\n\t\t\telse\n\t\t\t\tcount_y <= count_y;\n\t\tend\n\tend\nendgenerate\nendmodule"}
{"task_id": 1823, "completion": "parameter [14:0] BASE_ADDR = 15'h0190;\nparameter DEC_WD = 3;\nparameter [DEC_WD-1:0] CNTRL1 = 'h0,\n                       CNTRL2 = 'h2,\n                       CNTRL3 = 'h4,\n                       CNTRL4 = 'h6;\nparameter DEC_SZ = (1 << DEC_WD);\nparameter [DEC_SZ-1:0] BASE_REG = {{DEC_SZ-1{1'b0}}, 1'b1};\nparameter [DEC_SZ-1:0] CNTRL1_D = (BASE_REG << CNTRL1),\n                       CNTRL2_D = (BASE_REG << CNTRL2),\n                       CNTRL3_D = (BASE_REG << CNTRL3),\n                       CNTRL4_D = (BASE_REG << CNTRL4);\n\nwire reg_sel = per_en & (per_addr[13:DEC_WD-1] == BASE_ADDR[14:DEC_WD]);\nwire [DEC_WD-1:0] reg_addr = {per_addr[DEC_WD-2:0], 1'b0};\nwire [DEC_SZ-1:0] reg_dec = (CNTRL1_D & {DEC_SZ{(reg_addr == CNTRL1)}}) |\n                               (CNTRL2_D & {DEC_SZ{(reg_addr == CNTRL2)}}) |\n                               (CNTRL3_D & {DEC_SZ{(reg_addr == CNTRL3)}}) |\n                               (CNTRL4_D & {DEC_SZ{(reg_addr == CNTRL4)}});\n\nwire reg_write = |per_we & reg_sel;\nwire reg_read = ~|per_we & reg_sel;\nwire [DEC_SZ-1:0] reg_wr = reg_dec & {DEC_SZ{reg_write}};\nwire [DEC_SZ-1:0] reg_rd = reg_dec & {DEC_SZ{reg_read}};\n\nreg [15:0] cntrl1;\nwire cntrl1_wr = reg_wr[CNTRL1];\nalways @ (posedge mclk or posedge puc_rst)\n  if (puc_rst) cntrl1 <= 16'h0000;\n  else if (cntrl1_wr) cntrl1 <= per_din;\n\nreg [15:0] cntrl2;\nwire cntrl2_wr = reg_wr[CNTRL2];\nalways @ (posedge mclk or posedge puc_rst)\n  if (puc_rst) cntrl2 <= 16'h0000;\n  else if (cntrl2_wr) cntrl2 <= per_din;\n\nreg [15:0] cntrl3;\nwire cntrl3_wr = reg_wr[CNTRL3];\nalways @ (posedge mclk or posedge puc_rst)\n  if (puc_rst) cntrl3 <= 16'h0000;\n  else if (cntrl3_wr) cntrl3 <= per_din;\n\nreg [15:0] cntrl4;\nwire cntrl4_wr = reg_wr[CNTRL4];\nalways @ (posedge mclk or posedge puc_rst)\n  if (puc_rst) cntrl4 <= 16'h0000;\n  else if (cntrl4_wr) cntrl4 <= per_din;\n\nwire [15:0] cntrl1_rd = cntrl1 & {16{reg_rd[CNTRL1]}};\nwire [15:0] cntrl2_rd = cntrl2 & {16{reg_rd[CNTRL2]}};\nwire [15:0] cntrl3_rd = cntrl3 & {16{reg_rd[CNTRL3]}};\nwire [15:0] cntrl4_rd = cntrl4 & {16{reg_rd[CNTRL4]}};\nwire [15:0] per_dout = cntrl1_rd |\n                          cntrl2_rd |\n                          cntrl3_rd |\n                          cntrl4_rd;\n\nendmodule"}
{"task_id": 1814, "completion": "wire clkfbout;\n  wire clkfbin;\n  wire clkout0;\n  wire clkout1;\n  wire clkout2;\n  wire txsync_clkout;\n  wire clk0;\n  wire clkfb;\n  wire clkdv;\n  wire [15:0] not_connected;\n  reg  [7:0]  lock_wait_cntr_7_0;\n  reg  [7:0]  lock_wait_cntr_15_8;\n  reg         pll_locked_out_r;\n  reg         pll_locked_out_r_d;\n  reg         pll_locked_out_r_2d;\n  reg         time_elapsed;\n  parameter G_DVIDED_VAL_PLL = G_DIVIDE_VAL*2;\n  generate\n      begin : use_pll\n        PLL_ADV #\n        (\n          .CLKFBOUT_MULT (5-(REF_CLK_FREQ*3)),\n          .CLKFBOUT_PHASE(0),\n          .CLKIN1_PERIOD (10-(REF_CLK_FREQ*6)),\n          .CLKIN2_PERIOD (10-(REF_CLK_FREQ*6)),\n          .CLKOUT0_DIVIDE(2),\n          .CLKOUT0_PHASE (0),\n          .CLKOUT1_DIVIDE(G_DVIDED_VAL_PLL),\n          .CLKOUT1_PHASE (0),\n          .CLKOUT2_DIVIDE (4),\n          .CLKOUT2_PHASE (0),\n          .CLKOUT3_DIVIDE (4),\n          .CLKOUT3_PHASE (0)\n        )\n        pll_adv_i\n        (\n          .CLKIN1(clkin_pll),\n          .CLKINSEL(1'b1),\n          .CLKFBIN(clkfbin),\n          .RST(rst),\n          .CLKOUT0(clkout0),\n          .CLKOUT1(clkout1),\n          .CLKOUT2(clkout2),\n          .CLKOUT3(txsync_clkout),\n          .CLKFBOUT(clkfbout),\n          .LOCKED(pll_lk_out)\n        );\n        assign clkfbin = clkfbout;\n        BUFG coreclk_pll_bufg  (.O(coreclk),    .I(clkout0));\n        BUFG gtxclk_pll_bufg   (.O(gtx_usrclk), .I(clkout2));\n        BUFG txsync_clk_pll_bufg   (.O(txsync_clk), .I(txsync_clkout));\n\n      if (REF_CLK_FREQ == 1) \n      begin\n          always @(posedge clkin_pll or posedge rst)\n          begin\n             if(rst) \n             begin\n                lock_wait_cntr_7_0  <= 8'h0;\n                lock_wait_cntr_15_8 <= 8'h0;\n                pll_locked_out_r  <= 1'b0;\n                time_elapsed      <= 1'b0;\n             end else begin\n                if ((lock_wait_cntr_15_8 == 8'h80) | time_elapsed)\n                begin\n                   pll_locked_out_r <= pll_lk_out;\n                   time_elapsed     <= 1'b1;\n                end else begin\n                   lock_wait_cntr_7_0  <= lock_wait_cntr_7_0 + 1'b1;\n                   lock_wait_cntr_15_8 <= (lock_wait_cntr_7_0 == 8'hff) ?\n                       (lock_wait_cntr_15_8 + 1'b1) : lock_wait_cntr_15_8;\n                end\n             end\n          end\n      end\n      else  \n      begin\n          always @(posedge clkin_pll or posedge rst)\n          begin\n             if(rst) \n             begin\n                lock_wait_cntr_7_0  <= 8'h0;\n                lock_wait_cntr_15_8 <= 8'h0;\n                pll_locked_out_r  <= 1'b0;\n                time_elapsed      <= 1'b0;\n             end else begin\n                if ((lock_wait_cntr_15_8 == 8'h33) | time_elapsed)\n                begin\n                   pll_locked_out_r <= pll_lk_out;\n                   time_elapsed     <= 1'b1;\n                end else begin\n                   lock_wait_cntr_7_0  <= lock_wait_cntr_7_0 + 1'b1;\n                   lock_wait_cntr_15_8 <= (lock_wait_cntr_7_0 == 8'hff) ?\n                       (lock_wait_cntr_15_8 + 1'b1) : lock_wait_cntr_15_8;\n                end\n             end\n          end\n      end\n          always @(posedge coreclk or posedge rst)\n          begin\n             if (rst)\n             begin\n                pll_locked_out_r_d  <= 0;\n                pll_locked_out_r_2d <= 0;\n             end\n             else\n             begin\n                pll_locked_out_r_d  <= pll_locked_out_r;\n                pll_locked_out_r_2d <= pll_locked_out_r_d;\n             end\n          end\n            assign locked = fast_train_simulation_only ?\n                                     pll_lk_out : pll_locked_out_r_2d;\n       end   \n   endgenerate       \n   generate\n     if (G_DIVIDE_VAL == 1)\n      begin : sameclk\n        assign userclk = coreclk;\n      end\n     else\n      begin : notsame\n        BUFG usrclk_pll_bufg (.O(userclk), .I(clkout1));\n      end\n   endgenerate\nendmodule"}
{"task_id": 1864, "completion": "wire [1 : 0]     sel;\n    wire [31 : 0]         mux_1_0;\n    wire [31 : 0]         mux_1_1;\n    wire [31 : 0]         mux_2_0;\n\n    assign sel = din5;\n\n    assign mux_1_0 = (sel[0] == 0)? din1 : din2;\n    assign mux_1_1 = (sel[0] == 0)? din3 : din4;\n\n    assign mux_2_0 = (sel[1] == 0)? mux_1_0 : mux_1_1;\n\n    assign dout = mux_2_0;\n\nendmodule"}
{"task_id": 1821, "completion": "reg [ 1:0] plane;\n  reg        latch_sel;\n  reg [15:0] latch [0:3];\n\n  wire [15:1] offset;\n  wire [15:0] dat_o0, dat_o1;\n  wire [15:0] out_l0, out_l1, out_l2, out_l3;\n  wire        cont;\n\n  assign latch0 = latch_sel ? latch[0][15:8] : latch[0][7:0];\n  assign latch1 = latch_sel ? latch[1][15:8] : latch[1][7:0];\n  assign latch2 = latch_sel ? latch[2][15:8] : latch[2][7:0];\n  assign latch3 = latch_sel ? latch[3][15:8] : latch[3][7:0];\n\n  assign wbm_adr_o = { offset, plane };\n  assign wbs_ack_o = (plane==2'b11 && wbm_ack_i);\n  assign offset    = memory_mapping1 ? { 1'b0, wbs_adr_i[14:1] }\n                                     : wbs_adr_i[15:1];\n  assign wbs_dat_o = read_mode ? dat_o1 : dat_o0;\n  assign dat_o0    = (read_map_select==2'b11) ? wbm_dat_i\n                                              : latch[read_map_select];\n  assign dat_o1    = ~(out_l0 | out_l1 | out_l2 | out_l3);\n\n  assign out_l0 = (latch[0] ^ { 16{color_compare[0]} })\n                            & { 16{color_dont_care[0]} }; \n  assign out_l1 = (latch[1] ^ { 16{color_compare[1]} })\n                            & { 16{color_dont_care[1]} }; \n  assign out_l2 = (latch[2] ^ { 16{color_compare[2]} })\n                            & { 16{color_dont_care[2]} }; \n  assign out_l3 = (wbm_dat_i ^ { 16{color_compare[3]} })\n                            & { 16{color_dont_care[3]} }; \n\n  assign cont = wbm_ack_i && wbs_stb_i;\n\n  always @(posedge wb_clk_i)\n    latch_sel <= wb_rst_i ? 1'b0\n      : (wbs_stb_i ? wbs_sel_i[1] : latch_sel);\n\n  always @(posedge wb_clk_i)\n    wbm_stb_o <= wb_rst_i ? 1'b0 : (wbm_stb_o ? ~wbs_ack_o : wbs_stb_i);\n\n  always @(posedge wb_clk_i)\n    plane <= wb_rst_i ? 2'b00 : (cont ? (plane + 2'b01) : plane);\n\n  always @(posedge wb_clk_i)\n    if (wb_rst_i)\n      begin\n        latch[0] <= 8'h0;\n        latch[1] <= 8'h0;\n        latch[2] <= 8'h0;\n        latch[3] <= 8'h0;\n      end\n    else if (wbm_ack_i && wbm_stb_o) latch[plane] <= wbm_dat_i;\n\nendmodule"}
{"task_id": 1631, "completion": "wire [31:0]        mvendorid;\n   wire [31:0]        marchid;\n   wire [31:0]        mimpid;\n   wire [31:0]        mhartid;\n   wire [31:0]        mstatus;\n   wire [31:0]        misa;\n   reg [31:0]         medeleg;\n   reg [31:0]         mideleg;\n   wire [31:0]         mie;\n   reg [31:0]         mtvec;\n   reg [31:0]         mscratch;\n   reg [31:0]         mepc;\n   reg [31:0]         mcause;\n   reg [31:0]         mbadaddr;\n   wire [31:0]         mip;\n   wire [31:0]         mbase;\n   wire [31:0]         mbound;\n   wire [31:0]         mibase;\n   wire [31:0]         mibound;\n   wire [31:0]         mdbase;\n   wire [31:0]         mdbound;\n   reg [63:0]         mcycle;\n   reg [63:0]         minstret;\n   wire [63:0]         mhpmcounter3;\n   wire [63:0]         mhpmcounter4;\n   wire [63:0]         mhpmcounter5;\n   wire [63:0]         mhpmcounter6;\n   wire [63:0]         mhpmcounter7;\n   wire [63:0]         mhpmcounter8;\n   wire [63:0]         mhpmcounter9;\n   wire [63:0]         mhpmcounter10;\n   wire [63:0]         mhpmcounter11;\n   wire [63:0]         mhpmcounter12;\n   wire [63:0]         mhpmcounter13;\n   wire [63:0]         mhpmcounter14;\n   wire [63:0]         mhpmcounter15;\n   wire [63:0]         mhpmcounter16;\n   wire [63:0]         mhpmcounter17;\n   wire [63:0]         mhpmcounter18;\n   wire [63:0]         mhpmcounter19;\n   wire [63:0]         mhpmcounter20;\n   wire [63:0]         mhpmcounter21;\n   wire [63:0]         mhpmcounter22;\n   wire [63:0]         mhpmcounter23;\n   wire [63:0]         mhpmcounter24;\n   wire [63:0]         mhpmcounter25;\n   wire [63:0]         mhpmcounter26;\n   wire [63:0]         mhpmcounter27;\n   wire [63:0]         mhpmcounter28;\n   wire [63:0]         mhpmcounter29;\n   wire [63:0]         mhpmcounter30;\n   wire [63:0]         mhpmcounter31;\n   wire [31:0]         mucounteren;\n   wire [31:0]         mscounteren;\n   wire [31:0]         mhcounteren;\n   wire [31:0]         mhpmevent3;\n   wire [31:0]         mhpmevent4;\n   wire [31:0]         mhpmevent5;\n   wire [31:0]         mhpmevent6;\n   wire [31:0]         mhpmevent7;\n   wire [31:0]         mhpmevent8;\n   wire [31:0]         mhpmevent9;\n   wire [31:0]         mhpmevent10;\n   wire [31:0]         mhpmevent11;\n   wire [31:0]         mhpmevent12;\n   wire [31:0]         mhpmevent13;\n   wire [31:0]         mhpmevent14;\n   wire [31:0]         mhpmevent15;\n   wire [31:0]         mhpmevent16;\n   wire [31:0]         mhpmevent17;\n   wire [31:0]         mhpmevent18;\n   wire [31:0]         mhpmevent19;\n   wire [31:0]         mhpmevent20;\n   wire [31:0]         mhpmevent21;\n   wire [31:0]         mhpmevent22;\n   wire [31:0]         mhpmevent23;\n   wire [31:0]         mhpmevent24;\n   wire [31:0]         mhpmevent25;\n   wire [31:0]         mhpmevent26;\n   wire [31:0]         mhpmevent27;\n   wire [31:0]         mhpmevent28;\n   wire [31:0]         mhpmevent29;\n   wire [31:0]         mhpmevent30;\n   wire [31:0]         mhpmevent31;\n   wire [31:0]         tselect;\n   wire [31:0]         tdata1;\n   wire [31:0]         tdata2;\n   wire [31:0]         tdata3;\n   wire [31:0]         dcsr;\n   wire [31:0]         dpc;\n   wire [31:0]         dscratch;\n   assign mvendorid = 32'd0;\n   assign marchid   = 32'd0;\n   assign mimpid    = 32'd0;\n   assign mhartid   = 32'd0;\n   reg [1:0]           ms_mpp;\n   reg                 ms_mpie;\n   reg                 ms_mie;\n   always @(posedge CLK) begin\n      if(!RST_N) begin\n         ms_mpp  <= 0;\n         ms_mpie <= 0;\n         ms_mie  <= 0;\n      end else begin\n         if(CSR_WE & (CSR_ADDR == 12'h300)) begin\n            ms_mpp[1:0] <= CSR_WDATA[12:11];\n            ms_mpie     <= CSR_WDATA[7];\n            ms_mie      <= CSR_WDATA[3];\n         end\n      end\n   end\n   assign mstatus = {19'd0, ms_mpp[1:0], 3'd0, ms_mpie, 3'd0, ms_mie, 3'd0};\n   assign misa = {2'b01,   4'b0000, 26'b00_0000_0000_0001_0000_0001_0000};\n   always @(posedge CLK) begin\n      if(!RST_N) begin\n         mideleg <= 0;\n         medeleg <= 0;\n      end else begin\n         if(CSR_WE & (CSR_ADDR == 12'h302)) begin\n            medeleg <= CSR_WDATA;\n         end\n         if(CSR_WE & (CSR_ADDR == 12'h303)) begin\n            mideleg <= CSR_WDATA;\n         end\n      end\n   end\n   reg meie, mtie, msie;\n   always @(posedge CLK) begin\n      if(!RST_N) begin\n         meie <= 0;\n         mtie <= 0;\n         msie <= 0;\n      end else begin\n         if(CSR_WE & (CSR_ADDR == 12'h304)) begin\n            meie <= CSR_WDATA[11];\n            mtie <= CSR_WDATA[7];\n            msie <= CSR_WDATA[3];\n         end\n      end\n   end\n   assign mie = {20'd0, meie, 3'd0, mtie, 3'd0, msie, 3'd0};\n   always @(posedge CLK) begin\n      if(!RST_N) begin\n         mtvec <= 0;\n      end else begin\n         if(CSR_WE & (CSR_ADDR == 12'h305)) begin\n            mtvec <= CSR_WDATA;\n         end\n      end\n   end\n   assign HANDLER_PC = mtvec;\n   always @(posedge CLK) begin\n      if(!RST_N) begin\n         mscratch <= 0;\n      end else begin\n         if(CSR_WE & (CSR_ADDR == 12'h340)) begin\n            mscratch <= CSR_WDATA;\n         end\n      end\n   end\n   always @(posedge CLK) begin\n      if(!RST_N) begin\n         mepc <= 0;\n      end else begin\n         if(INTERRUPT) begin\n            mepc <= (EXCEPTION_PC & {{30{1'b1}},2'b0}) + 32'd4;\n         end else if(SW_INTERRUPT) begin\n            mepc <= (SW_INTERRUPT_PC & {{30{1'b1}},2'b0}) + 32'd4;\n         end else if(EXCEPTION) begin\n            mepc <= (EXCEPTION_PC & {{30{1'b1}},2'b0});\n         end else if(CSR_WE & (CSR_ADDR == 12'h341)) begin\n            mepc <= (CSR_WDATA & {{30{1'b1}},2'b0});\n         end\n      end\n   end\n   assign EPC = mepc;\n   always @(posedge CLK) begin\n      if(!RST_N) begin\n         mcause <= 0;\n      end else begin\n         if(INTERRUPT) begin\n            mcause[31]   <= 1'b1;\n            mcause[11]   <= EXT_INTERRUPT;\n            mcause[10:8] <= 3'd0;\n            mcause[7]    <= TIMER_EXPIRED;\n            mcause[6:4]  <= 3'd0;\n            mcause[3]    <= 1'b0;\n            mcause[2:0]  <= 3'd0;\n         end else if(EXCEPTION) begin\n            mcause[31]   <= 1'b0;\n            mcause[11:0] <= EXCEPTION_CODE;\n         end else if(CSR_WE & (CSR_ADDR == 12'h342)) begin\n            mcause[31]   <= CSR_WDATA[31];\n            mcause[11:0] <= CSR_WDATA[11:0];\n         end\n      end\n   end\n   always @(posedge CLK) begin\n      if(!RST_N) begin\n         mbadaddr <= 0;\n      end else begin\n         if(EXCEPTION) begin\n            mbadaddr <= (|EXCEPTION_CODE[3:0])?EXCEPTION_PC:EXCEPTION_ADDR;\n         end else if(CSR_WE & (CSR_ADDR == 12'h343)) begin\n            mbadaddr <= CSR_WDATA;\n         end\n      end\n   end\n   reg meip, mtip, msip;\n   always @(posedge CLK) begin\n      if(!RST_N) begin\n         meip <= 0;\n         mtip <= 0;\n         msip <= 0;\n      end else begin\n         if(EXT_INTERRUPT) begin\n            meip <= 1'b1;\n         end else if(CSR_WE & (CSR_ADDR == 12'h344)) begin\n            meip <= CSR_WDATA[11];\n         end\n         if(TIMER_EXPIRED) begin\n            mtip <= 1'b1;\n         end else if(CSR_WE & (CSR_ADDR == 12'h344)) begin\n            mtip <= CSR_WDATA[7];\n         end\n         if(SW_INTERRUPT) begin\n            msip <= 1'b1;\n         end else if(CSR_WE & (CSR_ADDR == 12'h344)) begin\n            msip <= CSR_WDATA[3];\n         end\n      end\n   end\n   assign mip = {20'd0, meip, 3'd0, mtip, 3'd0, msip, 3'd0};\n   assign INTERRUPT = mstatus[3] & (|(mie & mip));\n   assign INTERRUPT_PENDING = |mip;\n   assign mbase   = 32'd0;\n   assign mbound  = 32'd0;\n   assign mibase  = 32'd0;\n   assign mibound = 32'd0;\n   assign mdbase  = 32'd0;\n   assign mdbound = 32'd0;\n   always @(posedge CLK) begin\n      if(!RST_N) begin\n         mcycle <= 0;\n      end else begin\n         if(CSR_WE & (CSR_ADDR == 12'hB00)) begin\n            mcycle[31:0]  <= CSR_WDATA;\n         end else if(CSR_WE & (CSR_ADDR == 12'hB20)) begin\n            mcycle[63:32] <= CSR_WDATA;\n         end else begin\n            mcycle <= mcycle + 64'd1;\n         end\n      end\n   end\n   always @(posedge CLK) begin\n      if(!RST_N) begin\n         minstret <= 0;\n      end else begin\n         if(CSR_WE & (CSR_ADDR == 12'hB02)) begin\n            minstret[31:0]  <= CSR_WDATA;\n         end else if(CSR_WE & (CSR_ADDR == 12'hB20)) begin\n            minstret[63:32] <= CSR_WDATA;\n         end else begin\n            if(RETIRE) begin\n               minstret <= minstret + 64'd1;\n            end\n         end\n      end\n   end\n   assign mucounteren = 32'd0;\n   assign mscounteren = 32'd0;\n   assign mhcounteren = 32'd0;\n   assign mhpmcounter3 = 64'd0;\n   assign mhpmcounter4 = 64'd0;\n   assign mhpmcounter5 = 64'd0;\n   assign mhpmcounter6 = 64'd0;\n   assign mhpmcounter7 = 64'd0;\n   assign mhpmcounter8 = 64'd0;\n   assign mhpmcounter9 = 64'd0;\n   assign mhpmcounter10 = 64'd0;\n   assign mhpmcounter11 = 64'd0;\n   assign mhpmcounter12 = 64'd0;\n   assign mhpmcounter13 = 64'd0;\n   assign mhpmcounter14 = 64'd0;\n   assign mhpmcounter15 = 64'd0;\n   assign mhpmcounter16 = 64'd0;\n   assign mhpmcounter17 = 64'd0;\n   assign mhpmcounter18 = 64'd0;\n   assign mhpmcounter19 = 64'd0;\n   assign mhpmcounter20 = 64'd0;\n   assign mhpmcounter21 = 64'd0;\n   assign mhpmcounter22 = 64'd0;\n   assign mhpmcounter23 = 64'd0;\n   assign mhpmcounter24 = 64'd0;\n   assign mhpmcounter25 = 64'd0;\n   assign mhpmcounter26 = 64'd0;\n   assign mhpmcounter27 = 64'd0;\n   assign mhpmcounter28 = 64'd0;\n   assign mhpmcounter29 = 64'd0;\n   assign mhpmcounter30 = 64'd0;\n   assign mhpmcounter31 = 64'd0;\n   assign mhpmevent3 = 32'd0;\n   assign mhpmevent4 = 32'd0;\n   assign mhpmevent5 = 32'd0;\n   assign mhpmevent6 = 32'd0;\n   assign mhpmevent7 = 32'd0;\n   assign mhpmevent8 = 32'd0;\n   assign mhpmevent9 = 32'd0;\n   assign mhpmevent10 = 32'd0;\n   assign mhpmevent11 = 32'd0;\n   assign mhpmevent12 = 32'd0;\n   assign mhpmevent13 = 32'd0;\n   assign mhpmevent14 = 32'd0;\n   assign mhpmevent15 = 32'd0;\n   assign mhpmevent16 = 32'd0;\n   assign mhpmevent17 = 32'd0;\n   assign mhpmevent18 = 32'd0;\n   assign mhpmevent19 = 32'd0;\n   assign mhpmevent20 = 32'd0;\n   assign mhpmevent21 = 32'd0;\n   assign mhpmevent22 = 32'd0;\n   assign mhpmevent23 = 32'd0;\n   assign mhpmevent24 = 32'd0;\n   assign mhpmevent25 = 32'd0;\n   assign mhpmevent26 = 32'd0;\n   assign mhpmevent27 = 32'd0;\n   assign mhpmevent28 = 32'd0;\n   assign mhpmevent29 = 32'd0;\n   assign mhpmevent30 = 32'd0;\n   assign mhpmevent31 = 32'd0;\n   assign tselect  = 32'd0;\n   assign tdata1   = 32'd0;\n   assign tdata2   = 32'd0;\n   assign tdata3   = 32'd0;\n   assign dcsr     = 32'd0;\n   assign dpc      = 32'd0;\n   assign dscratch = 32'd0;\n   always @(*) begin\n      case(CSR_ADDR)\n        12'hF11: CSR_RDATA <= mvendorid;\n        12'hF12: CSR_RDATA <= marchid;\n        12'hF13: CSR_RDATA <= mimpid;\n        12'hF14: CSR_RDATA <= mhartid;\n        12'h300: CSR_RDATA <= mstatus;\n        12'h301: CSR_RDATA <= misa;\n        12'h302: CSR_RDATA <= medeleg;\n        12'h303: CSR_RDATA <= mideleg;\n        12'h304: CSR_RDATA <= mie;\n        12'h305: CSR_RDATA <= mtvec;\n        12'h340: CSR_RDATA <= mscratch;\n        12'h341: CSR_RDATA <= mepc;\n        12'h342: CSR_RDATA <= mcause;\n        12'h343: CSR_RDATA <= mbadaddr;\n        12'h344: CSR_RDATA <= mip;\n        12'h380: CSR_RDATA <= mbase;\n        12'h381: CSR_RDATA <= mbound;\n        12'h382: CSR_RDATA <= mibase;\n        12'h383: CSR_RDATA <= mibound;\n        12'h384: CSR_RDATA <= mdbase;\n        12'h385: CSR_RDATA <= mdbound;\n        12'hB00: CSR_RDATA <= mcycle[31:0];\n        12'hB02: CSR_RDATA <= minstret[31:0];\n        12'hB03: CSR_RDATA <= mhpmcounter3[31:0];\n        12'hB04: CSR_RDATA <= mhpmcounter4[31:0];\n        12'hB05: CSR_RDATA <= mhpmcounter5[31:0];\n        12'hB06: CSR_RDATA <= mhpmcounter6[31:0];\n        12'hB07: CSR_RDATA <= mhpmcounter7[31:0];\n        12'hB08: CSR_RDATA <= mhpmcounter8[31:0];\n        12'hB09: CSR_RDATA <= mhpmcounter9[31:0];\n        12'hB0A: CSR_RDATA <= mhpmcounter10[31:0];\n        12'hB0B: CSR_RDATA <= mhpmcounter11[31:0];\n        12'hB0C: CSR_RDATA <= mhpmcounter12[31:0];\n        12'hB0D: CSR_RDATA <= mhpmcounter13[31:0];\n        12'hB0E: CSR_RDATA <= mhpmcounter14[31:0];\n        12'hB0F: CSR_RDATA <= mhpmcounter15[31:0];\n        12'hB10: CSR_RDATA <= mhpmcounter16[31:0];\n        12'hB11: CSR_RDATA <= mhpmcounter17[31:0];\n        12'hB12: CSR_RDATA <= mhpmcounter18[31:0];\n        12'hB13: CSR_RDATA <= mhpmcounter19[31:0];\n        12'hB14: CSR_RDATA <= mhpmcounter20[31:0];\n        12'hB15: CSR_RDATA <= mhpmcounter21[31:0];\n        12'hB16: CSR_RDATA <= mhpmcounter22[31:0];\n        12'hB17: CSR_RDATA <= mhpmcounter23[31:0];\n        12'hB18: CSR_RDATA <= mhpmcounter24[31:0];\n        12'hB19: CSR_RDATA <= mhpmcounter25[31:0];\n        12'hB1A: CSR_RDATA <= mhpmcounter26[31:0];\n        12'hB1B: CSR_RDATA <= mhpmcounter27[31:0];\n        12'hB1C: CSR_RDATA <= mhpmcounter28[31:0];\n        12'hB1D: CSR_RDATA <= mhpmcounter29[31:0];\n        12'hB1E: CSR_RDATA <= mhpmcounter30[31:0];\n        12'hB1F: CSR_RDATA <= mhpmcounter31[31:0];\n        12'hB20: CSR_RDATA <= mcycle[63:32];\n        12'hB22: CSR_RDATA <= minstret[63:32];\n        12'hB23: CSR_RDATA <= mhpmcounter3[63:32];\n        12'hB24: CSR_RDATA <= mhpmcounter4[63:32];\n        12'hB25: CSR_RDATA <= mhpmcounter5[63:32];\n        12'hB26: CSR_RDATA <= mhpmcounter6[63:32];\n        12'hB27: CSR_RDATA <= mhpmcounter7[63:32];\n        12'hB28: CSR_RDATA <= mhpmcounter8[63:32];\n        12'hB29: CSR_RDATA <= mhpmcounter9[63:32];\n        12'hB2A: CSR_RDATA <= mhpmcounter10[63:32];\n        12'hB2B: CSR_RDATA <= mhpmcounter11[63:32];\n        12'hB2C: CSR_RDATA <= mhpmcounter12[63:32];\n        12'hB2D: CSR_RDATA <= mhpmcounter13[63:32];\n        12'hB2E: CSR_RDATA <= mhpmcounter14[63:32];\n        12'hB2F: CSR_RDATA <= mhpmcounter15[63:32];\n        12'hB30: CSR_RDATA <= mhpmcounter16[63:32];\n        12'hB31: CSR_RDATA <= mhpmcounter17[63:32];\n        12'hB32: CSR_RDATA <= mhpmcounter18[63:32];\n        12'hB33: CSR_RDATA <= mhpmcounter19[63:32];\n        12'hB34: CSR_RDATA <= mhpmcounter20[63:32];\n        12'hB35: CSR_RDATA <= mhpmcounter21[63:32];\n        12'hB36: CSR_RDATA <= mhpmcounter22[63:32];\n        12'hB37: CSR_RDATA <= mhpmcounter23[63:32];\n        12'hB38: CSR_RDATA <= mhpmcounter24[63:32];\n        12'hB39: CSR_RDATA <= mhpmcounter25[63:32];\n        12'hB3A: CSR_RDATA <= mhpmcounter26[63:32];\n        12'hB3B: CSR_RDATA <= mhpmcounter27[63:32];\n        12'hB3C: CSR_RDATA <= mhpmcounter28[63:32];\n        12'hB3D: CSR_RDATA <= mhpmcounter29[63:32];\n        12'hB3E: CSR_RDATA <= mhpmcounter30[63:32];\n        12'hB3F: CSR_RDATA <= mhpmcounter31[63:32];\n        12'h320: CSR_RDATA <= mucounteren;\n        12'h321: CSR_RDATA <= mscounteren;\n        12'h322: CSR_RDATA <= mhcounteren;\n        12'h323: CSR_RDATA <= mhpmevent3;\n        12'h324: CSR_RDATA <= mhpmevent4;\n        12'h325: CSR_RDATA <= mhpmevent5;\n        12'h326: CSR_RDATA <= mhpmevent6;\n        12'h327: CSR_RDATA <= mhpmevent7;\n        12'h328: CSR_RDATA <= mhpmevent8;\n        12'h329: CSR_RDATA <= mhpmevent9;\n        12'h32A: CSR_RDATA <= mhpmevent10;\n        12'h32B: CSR_RDATA <= mhpmevent11;\n        12'h32C: CSR_RDATA <= mhpmevent12;\n        12'h32D: CSR_RDATA <= mhpmevent13;\n        12'h32E: CSR_RDATA <= mhpmevent14;\n        12'h32F: CSR_RDATA <= mhpmevent15;\n        12'h330: CSR_RDATA <= mhpmevent16;\n        12'h331: CSR_RDATA <= mhpmevent17;\n        12'h332: CSR_RDATA <= mhpmevent18;\n        12'h333: CSR_RDATA <= mhpmevent19;\n        12'h334: CSR_RDATA <= mhpmevent20;\n        12'h335: CSR_RDATA <= mhpmevent21;\n        12'h336: CSR_RDATA <= mhpmevent22;\n        12'h337: CSR_RDATA <= mhpmevent23;\n        12'h338: CSR_RDATA <= mhpmevent24;\n        12'h339: CSR_RDATA <= mhpmevent25;\n        12'h33A: CSR_RDATA <= mhpmevent26;\n        12'h33B: CSR_RDATA <= mhpmevent27;\n        12'h33C: CSR_RDATA <= mhpmevent28;\n        12'h33D: CSR_RDATA <= mhpmevent29;\n        12'h33E: CSR_RDATA <= mhpmevent30;\n        12'h33F: CSR_RDATA <= mhpmevent31;\n        12'h7A0: CSR_RDATA <= tselect;\n        12'h7A1: CSR_RDATA <= tdata1;\n        12'h7A2: CSR_RDATA <= tdata2;\n        12'h7A3: CSR_RDATA <= tdata3;\n        12'h7B0: CSR_RDATA <= dcsr;\n        12'h7B1: CSR_RDATA <= dpc;\n        12'h7B2: CSR_RDATA <= dscratch;\n        default: CSR_RDATA <= 32'd0;\n      endcase\n   end\nendmodule"}
{"task_id": 1747, "completion": "reg [3:0] count4 = 0;\n   reg [1:0] count2 = 0;\n\n   reg [`DATA_WIDTH-1:0] a = {`REP_COUNT4{4'b0000}};\n   reg [`DATA_WIDTH-1:0] b = {`REP_COUNT4{4'b1111}};\n   reg [`DATA_WIDTH-1:0] c = {`REP_COUNT4{4'b1111}};\n   reg [`DATA_WIDTH-1:0] d = {`REP_COUNT4{4'b1111}};\n   reg [`DATA_WIDTH-1:0] res1;\n   reg [`DATA_WIDTH-1:0] res2;\n   reg [`DATA_WIDTH-1:0] res3;\n   reg [`DATA_WIDTH-1:0] res4;\n\n   drv1 t_drv1 [`DATA_WIDTH-1:0] (.colSelA(a), .datao(res1));\n   drv2 t_drv2 [`DATA_WIDTH-1:0] (.colSelA(a), .colSelB(b), .datao(res2));\n   drv3 t_drv3 [`DATA_WIDTH-1:0] (.colSelA(a), .colSelB(b), .colSelC(c), .datao(res3));\n   drv4 t_drv4 [`DATA_WIDTH-1:0] (.colSelA(a), .colSelB(b), .colSelC(c), .colSelD(d), .datao(res4));\n\n   always@(posedge clk)\n   begin\n       count2 <= count2 + 1;\n       count4 <= count4 + 1;\n       a <= {`REP_COUNT4{count4}};\n       b <= {`REP_COUNT4{count4}};\n       c <= {`REP_COUNT2{count2}};\n       d <= {`REP_COUNT2{count2}};\n\n       if (res1 != (a)) begin\n       $stop;\n       end\n       if (res2 != (a&b)) begin\n       $stop;\n       end\n       if (res3 != (a&b&c)) begin\n       $stop;\n       end\n       if (res4 != (a&b&c&d)) begin\n       $stop;\n       end\n\n       if (count4 > 10) begin\n           $write(\"*-* All Finished *-*\n\");\n           $finish;\n       end\n   end\nendmodule\n\nmodule drv1\n  (input colSelA,\n   output datao\n   );\n   assign datao = colSelA;\nendmodule\n\nmodule drv2\n  (input colSelA,\n   input colSelB,\n   output datao\n   );\n   assign datao = colSelB & colSelA;\nendmodule\n\nmodule drv3\n  (input colSelA,\n   input colSelB,\n   input colSelC,\n   output datao\n   );\n   assign datao = colSelB & colSelA & colSelC;\n\nendmodule\n\nmodule drv4\n  (input colSelA,\n   input colSelB,\n   input colSelC,\n   input colSelD,\n   output datao\n   );\n   assign datao = colSelB & colSelA & colSelC & colSelD;\n\nendmodule"}
{"task_id": 1686, "completion": "localparam ADDR_AP_CTRL = 6'h00;\nlocalparam ADDR_GIE = 6'h04;\nlocalparam ADDR_IER = 6'h08;\nlocalparam ADDR_ISR = 6'h0c;\nlocalparam ADDR_DATA_COMPARE_V_DATA_0 = 6'h10;\nlocalparam ADDR_DATA_COMPARE_V_DATA_1 = 6'h14;\nlocalparam ADDR_DATA_COMPARE_V_CTRL = 6'h18;\nlocalparam ADDR_LENGTH_R_DATA_0 = 6'h1c;\nlocalparam ADDR_LENGTH_R_CTRL = 6'h20;\nlocalparam ADDR_SAMPLE_RATE_DATA_0 = 6'h24;\nlocalparam ADDR_SAMPLE_RATE_CTRL = 6'h28;\nWRIDLE = 2'd0;\nWRDATA = 2'd1;\nWRRESP = 2'd2;\nRDIDLE = 2'd0;\nRDDATA = 2'd1;\nADDR_BITS = 6;\nreg [1:0] wstate;\nreg [1:0] wnext;\nreg [ADDR_BITS-1:0] waddr;\nwire [31:0] wmask;\nwire aw_hs;\nwire w_hs;\nreg [1:0] rstate;\nreg [1:0] rnext;\nreg [31:0] rdata;\nwire ar_hs;\nwire [ADDR_BITS-1:0] raddr;\nwire int_ap_idle;\nwire int_ap_ready;\nreg int_ap_done;\nreg int_ap_start;\nreg int_auto_restart;\nreg int_gie;\nreg [1:0] int_ier;\nreg [1:0] int_isr;\nreg [63:0] int_data_compare_V;\nreg [31:0] int_length_r;\nreg [31:0] int_sample_rate;\nassign AWREADY = (wstate == WRIDLE);\nassign WREADY  = (wstate == WRDATA);\nassign BRESP   = 2'b00;\nassign BVALID  = (wstate == WRRESP);\nassign wmask   = { {8{WSTRB[3]}}, {8{WSTRB[2]}}, {8{WSTRB[1]}}, {8{WSTRB[0]}} };\nassign aw_hs   = AWVALID & AWREADY;\nassign w_hs    = WVALID & WREADY;\nalways @(posedge ACLK) begin\n    if (ARESET)\n        wstate <= WRIDLE;\n    else if (ACLK_EN)\n        wstate <= wnext;\nend\nalways @(*) begin\n    case (wstate)\n        WRIDLE:\n            if (AWVALID)\n                wnext = WRDATA;\n            else\n                wnext = WRIDLE;\n        WRDATA:\n            if (WVALID)\n                wnext = WRRESP;\n            else\n                wnext = WRDATA;\n        WRRESP:\n            if (BREADY)\n                wnext = WRIDLE;\n            else\n                wnext = WRRESP;\n        default:\n            wnext = WRIDLE;\n    endcase\nend\nalways @(posedge ACLK) begin\n    if (ACLK_EN) begin\n        if (aw_hs)\n            waddr <= AWADDR[ADDR_BITS-1:0];\n    end\nend\nassign ARREADY = (rstate == RDIDLE);\nassign RDATA   = rdata;\nassign RRESP   = 2'b00;\nassign RVALID  = (rstate == RDDATA);\nassign ar_hs   = ARVALID & ARREADY;\nassign raddr   = ARADDR[ADDR_BITS-1:0];\nalways @(posedge ACLK) begin\n    if (ARESET)\n        rstate <= RDIDLE;\n    else if (ACLK_EN)\n        rstate <= rnext;\nend\nalways @(*) begin\n    case (rstate)\n        RDIDLE:\n            if (ARVALID)\n                rnext = RDDATA;\n            else\n                rnext = RDIDLE;\n        RDDATA:\n            if (RREADY & RVALID)\n                rnext = RDIDLE;\n            else\n                rnext = RDDATA;\n        default:\n            rnext = RDIDLE;\n    endcase\nend\nalways @(posedge ACLK) begin\n    if (ACLK_EN) begin\n        if (ar_hs) begin\n            rdata <= 1'b0;\n            case (raddr)\n                ADDR_AP_CTRL: begin\n                    rdata[0] <= int_ap_start;\n                    rdata[1] <= int_ap_done;\n                    rdata[2] <= int_ap_idle;\n                    rdata[3] <= int_ap_ready;\n                    rdata[7] <= int_auto_restart;\n                end\n                ADDR_GIE: begin\n                    rdata <= int_gie;\n                end\n                ADDR_IER: begin\n                    rdata <= int_ier;\n                end\n                ADDR_ISR: begin\n                    rdata <= int_isr;\n                end\n                ADDR_DATA_COMPARE_V_DATA_0: begin\n                    rdata <= int_data_compare_V[31:0];\n                end\n                ADDR_DATA_COMPARE_V_DATA_1: begin\n                    rdata <= int_data_compare_V[63:32];\n                end\n                ADDR_LENGTH_R_DATA_0: begin\n                    rdata <= int_length_r[31:0];\n                end\n                ADDR_SAMPLE_RATE_DATA_0: begin\n                    rdata <= int_sample_rate[31:0];\n                end\n            endcase\n        end\n    end\nend\nassign interrupt = int_gie & (|int_isr);\nassign ap_start = int_ap_start;\nassign int_ap_idle = ap_idle;\nassign int_ap_ready = ap_ready;\nassign data_compare_V = int_data_compare_V;\nassign length_r = int_length_r;\nassign sample_rate = int_sample_rate;\nalways @(posedge ACLK) begin\n    if (ARESET)\n        int_ap_start <= 1'b0;\n    else if (ACLK_EN) begin\n        if (w_hs && waddr == ADDR_AP_CTRL && WSTRB[0] && WDATA[0])\n            int_ap_start <= 1'b1;\n        else if (int_ap_ready)\n            int_ap_start <= int_auto_restart;\n    end\nend\nalways @(posedge ACLK) begin\n    if (ARESET)\n        int_ap_done <= 1'b0;\n    else if (ACLK_EN) begin\n        if (ap_done)\n            int_ap_done <= 1'b1;\n        else if (ar_hs && raddr == ADDR_AP_CTRL)\n            int_ap_done <= 1'b0;\n    end\nend\nalways @(posedge ACLK) begin\n    if (ARESET)\n        int_auto_restart <= 1'b0;\n    else if (ACLK_EN) begin\n        if (w_hs && waddr == ADDR_AP_CTRL && WSTRB[0])\n            int_auto_restart <=  WDATA[7];\n    end\nend\nalways @(posedge ACLK) begin\n    if (ARESET)\n        int_gie <= 1'b0;\n    else if (ACLK_EN) begin\n        if (w_hs && waddr == ADDR_GIE && WSTRB[0])\n            int_gie <= WDATA[0];\n    end\nend\nalways @(posedge ACLK) begin\n    if (ARESET)\n        int_ier <= 1'b0;\n    else if (ACLK_EN) begin\n        if (w_hs && waddr == ADDR_IER && WSTRB[0])\n            int_ier <= WDATA[1:0];\n    end\nend\nalways @(posedge ACLK) begin\n    if (ARESET)\n        int_isr[0] <= 1'b0;\n    else if (ACLK_EN) begin\n        if (int_ier[0] & ap_done)\n            int_isr[0] <= 1'b1;\n        else if (w_hs && waddr == ADDR_ISR && WSTRB[0])\n            int_isr[0] <= int_isr[0] ^ WDATA[0];\n    end\nend\nalways @(posedge ACLK) begin\n    if (ARESET)\n        int_isr[1] <= 1'b0;\n    else if (ACLK_EN) begin\n        if (int_ier[1] & ap_ready)\n            int_isr[1] <= 1'b1;\n        else if (w_hs && waddr == ADDR_ISR && WSTRB[0])\n            int_isr[1] <= int_isr[1] ^ WDATA[1];\n    end\nend\nalways @(posedge ACLK) begin\n    if (ARESET)\n        int_data_compare_V[31:0] <= 0;\n    else if (ACLK_EN) begin\n        if (w_hs && waddr == ADDR_DATA_COMPARE_V_DATA_0)\n            int_data_compare_V[31:0] <= (WDATA[31:0] & wmask) | (int_data_compare_V[31:0] & ~wmask);\n    end\nend\nalways @(posedge ACLK) begin\n    if (ARESET)\n        int_data_compare_V[63:32] <= 0;\n    else if (ACLK_EN) begin\n        if (w_hs && waddr == ADDR_DATA_COMPARE_V_DATA_1)\n            int_data_compare_V[63:32] <= (WDATA[31:0] & wmask) | (int_data_compare_V[63:32] & ~wmask);\n    end\nend\nalways @(posedge ACLK) begin\n    if (ARESET)\n        int_length_r[31:0] <= 0;\n    else if (ACLK_EN) begin\n        if (w_hs && waddr == ADDR_LENGTH_R_DATA_0)\n            int_length_r[31:0] <= (WDATA[31:0] & wmask) | (int_length_r[31:0] & ~wmask);\n    end\nend\nalways @(posedge ACLK) begin\n    if (ARESET)\n        int_sample_rate[31:0] <= 0;\n    else if (ACLK_EN) begin\n        if (w_hs && waddr == ADDR_SAMPLE_RATE_DATA_0)\n            int_sample_rate[31:0] <= (WDATA[31:0] & wmask) | (int_sample_rate[31:0] & ~wmask);\n    end\nend\nendmodule"}
{"task_id": 1770, "completion": "word32[0] = 'h00;      word32[1] = 'h11;      word32[2] = 'h22;      word32[3] = 'h33;      if (word32 !== 'h33_22_11_00) begin         $display(\"FAILED -- word32 = %h (1)\", word32);         $finish;      end      #1 if (word1 !== 8'h11) begin         $display(\"FAILED -- word1 = %h\", word1);         $finish;      end      for (idx = 0 ; idx < 4 ; idx = idx+1)         word32[idx] = ~word32[idx];      if (word32 !== ~ 'h33_22_11_00) begin         $display(\"FAILED -- word32 = %h (2)\", word32);         $finish;      end      word32[0][3:0] = 'h0;      word32[1][3:0] = 'h1;      word32[2][3:0] = 'h2;      word32[3][3:0] = 'h3;      word32[0][7:4] = 'h3;      word32[1][7:4] = 'h2;      word32[2][4 +: 4] = 'h1;      word32[3][4 +: 4] = 'h0;      if (word32 !== 'h03_12_21_30) begin         $display(\"FAILED -- word32 = %h (3)\", word32);         $finish;      end      if (word32[1][7:4] !== word32[1][4 +: 4]) begin         $display(\"FAILED -- word32[1][7:4]=%h, word32[1][4 +: 4]=%h\",             word32[1][7:4],word32[1][4 +: 4]);         $finish;      end      x = 4;      word32[1][x +: 4] = 'h2;      if (word32[1][7:4] !== word32[1][x +: 4]) begin         $display(\"FAILED -- word32[1][7:4]=%h, word32[1][x +: 4]=%h\",             word32[1][7:4], word32[1][x +: 4]);         $finish;      end      for (idx = 0 ; idx < 8 ; idx = idx+1) begin         word32[0][idx] = idx[0];         word32[2][idx] = idx[0];         word32[1][idx] = ~idx[0];         word32[3][idx] = ~idx[0];      end      if (word32 !== 'h55_aa_55_aa) begin         $display(\"FAILED -- word32 = %h (4)\", word32);         $finish;      end      for (idx = 0 ; idx < 8 ; idx = idx+1) begin         if (word32[0][idx] !== word32[2][idx]) begin            $display(\"FAILED -- word32[0][%0d]=%b, word32[2][%0d]=%b\",                 idx, word32[0][idx], idx, word32[2][idx]);            $finish;         end         if (word32[1][idx] !== word32[3][idx]) begin            $display(\"FAILED -- word32[1][%0d]=%b, word32[3][%0d]=%b\",                 idx, word32[1][idx], idx, word32[3][idx]);            $display(\"FAILED\");            $finish;         end      end      $display(\"PASSED\");   endendmodule"}
{"task_id": 1873, "completion": "foo #(.WIDTH (1)) foo1 (.*);\n   foo #(.WIDTH (7)) foo7 (.*);\n   foo #(.WIDTH (8)) foo8 (.*);\n   foo #(.WIDTH (32)) foo32 (.*);\n   foo #(.WIDTH (33)) foo33 (.*);\n   foo #(.WIDTH (40)) foo40 (.*);\n   foo #(.WIDTH (41)) foo41 (.*);\n   foo #(.WIDTH (64)) foo64 (.*);\n   foo #(.WIDTH (65)) foo65 (.*);\n   foo #(.WIDTH (96)) foo96 (.*);\n   foo #(.WIDTH (97)) foo97 (.*);\n   foo #(.WIDTH (128)) foo128 (.*);\n   foo #(.WIDTH (256)) foo256 (.*);\n   foo #(.WIDTH (1024)) foo1024 (.*);\n   bar #(.WIDTH (1024)) bar1024 (.*);\n\nendmodule"}
{"task_id": 1820, "completion": "function integer log2; input integer number; begin log2=0; while(2**log2<number) begin log2=log2+1; end end endfunction // log2 parameter NUM_REGS_USED = 6; parameter OP_LUT_REG_ADDR_WIDTH_USED = log2(NUM_REGS_USED); parameter WAIT_FOR_REQ = 1; parameter WRITE_TO_MAC_LUT = 2; parameter READ_FROM_MAC_LUT = 4; parameter DONE = 8; wire [`CPCI_NF2_DATA_WIDTH-1:0] reg_file [0:NUM_REGS_USED-1]; reg [`CPCI_NF2_DATA_WIDTH-1:0] reg_file_next [0:NUM_REGS_USED-1]; wire [`CPCI_NF2_DATA_WIDTH-1:0] reg_file_selected; wire [OP_LUT_REG_ADDR_WIDTH_USED-1:0]addr; wire [`IN_ARB_REG_ADDR_WIDTH - 1:0] reg_addr; wire [`UDP_REG_ADDR_WIDTH-`SWITCH_OP_LUT_BLOCK_ADDR_WIDTH-`SWITCH_OP_LUT_REG_ADDR_WIDTH - 1:0] tag_addr; wire addr_good; wire tag_hit; wire [`CPCI_NF2_DATA_WIDTH-1:0] mac_addr_lo; wire [`CPCI_NF2_DATA_WIDTH-1:0] ports_mac_addr_hi; reg [3:0] state, state_next; reg [`CPCI_NF2_DATA_WIDTH-1:0] op_lut_reg_rd_data_next; wire [`CPCI_NF2_DATA_WIDTH-1:0] num_hits; wire [`CPCI_NF2_DATA_WIDTH-1:0] num_misses; reg [NUM_REGS_USED*`CPCI_NF2_DATA_WIDTH-1:0] reg_file_linear; wire [NUM_REGS_USED*`CPCI_NF2_DATA_WIDTH-1:0] reg_file_linear_next; reg reg_rd_wr_L_held; reg [`UDP_REG_ADDR_WIDTH-1:0] reg_addr_held; reg [`CPCI_NF2_DATA_WIDTH-1:0] reg_data_held; reg [UDP_REG_SRC_WIDTH-1:0] reg_src_held; reg reg_rd_wr_L_held_nxt; reg [`UDP_REG_ADDR_WIDTH-1:0] reg_addr_held_nxt; reg [`CPCI_NF2_DATA_WIDTH-1:0] reg_data_held_nxt; reg [UDP_REG_SRC_WIDTH-1:0] reg_src_held_nxt; reg reg_req_out_nxt; reg reg_ack_out_nxt; reg reg_rd_wr_L_out_nxt; reg [`UDP_REG_ADDR_WIDTH-1:0] reg_addr_out_nxt; reg [`CPCI_NF2_DATA_WIDTH-1:0] reg_data_out_nxt; reg [UDP_REG_SRC_WIDTH-1:0] reg_src_out_nxt; assign addr = reg_addr_in[OP_LUT_REG_ADDR_WIDTH_USED-1:0]; assign reg_addr = reg_addr_in[`SWITCH_OP_LUT_REG_ADDR_WIDTH-1:0]; assign tag_addr = reg_addr_in[`UDP_REG_ADDR_WIDTH - 1:`SWITCH_OP_LUT_REG_ADDR_WIDTH]; assign addr_good = (reg_addr<NUM_REGS_USED); assign tag_hit = tag_addr == `SWITCH_OP_LUT_BLOCK_ADDR; assign mac_addr_lo = reg_file[`SWITCH_OP_LUT_MAC_LO]; assign ports_mac_addr_hi = reg_file[`SWITCH_OP_LUT_PORTS_MAC_HI]; assign wr_oq = ports_mac_addr_hi[NUM_OUTPUT_QUEUES+15:16]; assign wr_protect = ports_mac_addr_hi[31]; assign wr_mac = {ports_mac_addr_hi, reg_file[`SWITCH_OP_LUT_MAC_LO]}; assign wr_addr = reg_file[`SWITCH_OP_LUT_MAC_LUT_WR_ADDR]; assign rd_addr = reg_file[`SWITCH_OP_LUT_MAC_LUT_RD_ADDR]; assign num_hits = reg_file[`SWITCH_OP_LUT_NUM_HITS]; assign num_misses = reg_file[`SWITCH_OP_LUT_NUM_MISSES]; assign reg_file_selected = reg_file[addr]; generate genvar j; for(j=0; j<NUM_REGS_USED; j=j+1) begin:linear_reg assign reg_file_linear_next[`REG_END(j):`REG_START(j)] = reg_file_next[j]; assign reg_file[j] = reg_file_linear[`REG_END(j):`REG_START(j)]; end endgenerate always @(*) begin reg_file_next[`SWITCH_OP_LUT_PORTS_MAC_HI] = ports_mac_addr_hi; reg_file_next[`SWITCH_OP_LUT_MAC_LO] = mac_addr_lo; reg_file_next[`SWITCH_OP_LUT_MAC_LUT_WR_ADDR] = wr_addr; reg_file_next[`SWITCH_OP_LUT_MAC_LUT_RD_ADDR] = rd_addr; reg_file_next[`SWITCH_OP_LUT_NUM_HITS] = num_hits + lut_hit; reg_file_next[`SWITCH_OP_LUT_NUM_MISSES] = num_misses + lut_miss; state_next = state; reg_req_out_nxt = 0; reg_ack_out_nxt = 0; reg_rd_wr_L_out_nxt = 0; reg_addr_out_nxt = 0; reg_data_out_nxt = 0; reg_src_out_nxt = 0; reg_rd_wr_L_held_nxt = reg_rd_wr_L_held; reg_addr_held_nxt = reg_addr_held; reg_data_held_nxt = reg_data_held; reg_src_held_nxt = reg_src_held; wr_req = 0; rd_req = 0; case(state) WAIT_FOR_REQ: begin if (reg_req_in && tag_hit) begin if (!reg_rd_wr_L_in && addr_good) begin reg_file_next[addr] = reg_data_in; case (addr) `SWITCH_OP_LUT_MAC_LUT_WR_ADDR : state_next = WRITE_TO_MAC_LUT; `SWITCH_OP_LUT_MAC_LUT_RD_ADDR : state_next = READ_FROM_MAC_LUT; default : state_next = DONE; endcase reg_rd_wr_L_held_nxt = reg_rd_wr_L_in; reg_addr_held_nxt = reg_addr_in; reg_data_held_nxt = reg_data_in; reg_src_held_nxt = reg_src_in; end else begin reg_req_out_nxt = 1'b 1; reg_ack_out_nxt = 1'b 1; reg_rd_wr_L_out_nxt = reg_rd_wr_L_in; reg_addr_out_nxt = reg_addr_in; reg_data_out_nxt = addr_good ? reg_file_selected : 32'h DEAD_BEEF; reg_src_out_nxt = reg_src_in; end end else begin reg_req_out_nxt = reg_req_in; reg_ack_out_nxt = reg_ack_in; reg_rd_wr_L_out_nxt = reg_rd_wr_L_in; reg_addr_out_nxt = reg_addr_in; reg_data_out_nxt = reg_data_in; reg_src_out_nxt = reg_src_in; end end // case: WAIT_FOR_REQ WRITE_TO_MAC_LUT: begin if(wr_ack) begin state_next = DONE; end else begin wr_req = 1; end end READ_FROM_MAC_LUT: begin if(rd_ack) begin reg_file_next[`SWITCH_OP_LUT_PORTS_MAC_HI] = {rd_wr_protect, {(15-NUM_OUTPUT_QUEUES){1'b0}}, rd_oq, rd_mac[47:32]}; reg_file_next[`SWITCH_OP_LUT_MAC_LO] = rd_mac[31:0]; state_next = DONE; end else begin rd_req = 1; end end // case: READ_FROM_MAC_LUT DONE: begin state_next = WAIT_FOR_REQ; reg_req_out_nxt = 1'b 1; reg_ack_out_nxt = 1'b 1; reg_rd_wr_L_out_nxt = reg_rd_wr_L_held; reg_addr_out_nxt = reg_addr_held; reg_data_out_nxt = reg_data_held; reg_src_out_nxt = reg_src_held; end endcase // case(state) end // always @ (*) always @(posedge clk) begin if( reset ) begin reg_req_out <= 0; reg_ack_out <= 0; reg_rd_wr_L_out <= 0; reg_addr_out <= 0; reg_data_out <= 0; reg_src_out <= 0; reg_rd_wr_L_held <= 0; reg_addr_held <= 0; reg_data_held <= 0; reg_src_held <= 0; reg_file_linear <= {(`CPCI_NF2_DATA_WIDTH*NUM_REGS_USED){1'b0}}; state <= WAIT_FOR_REQ; end else begin reg_req_out <= reg_req_out_nxt; reg_ack_out <= reg_ack_out_nxt; reg_rd_wr_L_out <= reg_rd_wr_L_out_nxt; reg_addr_out <= reg_addr_out_nxt; reg_data_out <= reg_data_out_nxt; reg_src_out <= reg_src_out_nxt; reg_rd_wr_L_held <= reg_rd_wr_L_held_nxt; reg_addr_held <= reg_addr_held_nxt; reg_data_held <= reg_data_held_nxt; reg_src_held <= reg_src_held_nxt; reg_file_linear <= reg_file_linear_next; state <= state_next; end // else: !if( reset ) end // always @ (posedge clk) endmodule"}
{"task_id": 1840, "completion": "(*preserve*) reg [DEPTH-1:0] altera_reset_synchronizer_int_chain;\n    reg altera_reset_synchronizer_int_chain_out;\n\n    generate if (ASYNC_RESET) begin\n\n        always @(posedge clk or posedge reset_in) begin\n            if (reset_in) begin\n                altera_reset_synchronizer_int_chain <= {DEPTH{1'b1}};\n                altera_reset_synchronizer_int_chain_out <= 1'b1;\n            end\n            else begin\n                altera_reset_synchronizer_int_chain[DEPTH-2:0] <= altera_reset_synchronizer_int_chain[DEPTH-1:1];\n                altera_reset_synchronizer_int_chain[DEPTH-1] <= 0;\n                altera_reset_synchronizer_int_chain_out <= altera_reset_synchronizer_int_chain[0];\n            end\n        end\n\n        assign reset_out = altera_reset_synchronizer_int_chain_out;\n     \n    end else begin\n\n        always @(posedge clk) begin\n            altera_reset_synchronizer_int_chain[DEPTH-2:0] <= altera_reset_synchronizer_int_chain[DEPTH-1:1];\n            altera_reset_synchronizer_int_chain[DEPTH-1] <= reset_in;\n            altera_reset_synchronizer_int_chain_out <= altera_reset_synchronizer_int_chain[0];\n        end\n\n        assign reset_out = altera_reset_synchronizer_int_chain_out;\n \n    end\n    endgenerate\n\nendmodule"}
{"task_id": 1872, "completion": "reg                     full0;\n   reg                     full1;\n   reg [DATA_WIDTH-1:0]    data0;\n   reg [DATA_WIDTH-1:0]    data1;\n\n   assign out_valid = full1;\n   assign out_data  = data1;    \n   generate if (PIPELINE_READY == 1) \n     begin : REGISTERED_READY_PLINE\n        assign in_ready  = !full0;\n\n        always @(posedge clk, posedge reset) begin\n           if (reset) begin\n              data0 <= {DATA_WIDTH{1'b0}};\n              data1 <= {DATA_WIDTH{1'b0}};\n           end else begin\n              if (~full0)\n                data0 <= in_data;\n              if (~full1 || (out_ready && out_valid)) begin\n                 if (full0)\n                   data1 <= data0;\n                 else\n                   data1 <= in_data;\n              end\n           end\n        end\n        always @(posedge clk or posedge reset) begin\n           if (reset) begin\n              full0    <= 1'b0;\n              full1    <= 1'b0;\n           end else begin\n              if (~full0 & ~full1) begin\n                 if (in_valid) begin\n                    full1 <= 1'b1;\n                 end\n              end \n              if (full1 & ~full0) begin\n                 if (in_valid & ~out_ready) begin\n                    full0 <= 1'b1;\n                 end\n                 if (~in_valid & out_ready) begin\n                    full1 <= 1'b0;\n                 end\n              end \n              if (full1 & full0) begin\n                 if (out_ready) begin\n                    full0 <= 1'b0;\n                 end\n              end\n           end\n        end\n     end \n   else \n     begin : UNREGISTERED_READY_PLINE\n\tassign in_ready = (~full1) | out_ready;\n\talways @(posedge clk or posedge reset) begin\n\t   if (reset) begin\n\t      data1 <= 'b0;\n\t      full1 <= 1'b0;\n\t   end\n\t   else begin\n\t      if (in_ready) begin\n\t\t data1 <= in_data;\n\t\t full1 <= in_valid;\n\t      end\n\t   end\n\tend\t\n     end\n   endgenerate\nendmodule"}
{"task_id": 1764, "completion": "input start;\n    input[`NWIDTH-1:0] N;\n    input[`DDRSIZEWIDTH-1:0] offset;\n    output done;\n    input clk;\n\n    output burst_begin;\n    output [`MEMCONNUMBYTES-1:0] mem_local_be;\n    output mem_local_read_req;\n    output [`BURSTLEN-1:0] mem_local_size;\n    output [`MEMCONWIDTH-1:0] mem_local_wdata;\n    output mem_local_write_req;\n    output [`DDRSIZEWIDTH-1:0] mem_local_addr;\n    input [`MEMCONWIDTH-1:0] mem_local_rdata;\n    input mem_local_rdata_valid;\n    input mem_local_ready;\n    input reset_n;\n    input mem_local_wdata_req;\n    wire[`BLOCKWIDTH-1:0] m, n, loop;\n    wire[1:0] mode;\n    wire comp_start, comp_done;\n    wire dtu_write_req, dtu_read_req, dtu_ack, dtu_done;\n    wire [`DDRSIZEWIDTH-1:0] dtu_mem_addr;\n    wire [`RAMSIZEWIDTH-1:0] dtu_ram_addr;\n    wire [`BLOCKWIDTH-1:0] dtu_size;\n    wire left_sel;\n\n    wire[`RAMWIDTH-1:0] curWriteDataMem, curReadDataMem;\n    wire[`RAMSIZEWIDTH-1:0] curWriteAddrMem, curReadAddrMem;\n    wire[`RAMNUMBYTES-1:0] curWriteByteEnMem;\n    wire curWriteEnMem;\n    wire[`RAMWIDTH-1:0] leftWriteDataMem;\n    wire[`RAMSIZEWIDTH-1:0] leftWriteAddrMem;\n    wire[`RAMNUMBYTES-1:0] leftWriteByteEnMem;\n    wire leftWriteEnMem;\n    wire curMemSel, leftMemSel;\n\n    wire burst_begin;\n    wire [`MEMCONNUMBYTES-1:0] mem_local_be;\n    wire mem_local_read_req;\n    wire [`BURSTLEN-1:0] mem_local_size;\n    wire [`MEMCONWIDTH-1:0] mem_local_wdata;\n    wire mem_local_write_req;\n    wire [`MEMCONWIDTH-1:0] mem_local_rdata;\n    wire mem_local_rdata_valid;\n    wire mem_local_ready;\n    wire mem_local_wdata_req;\n    wire reset_n;\n    wire [`DDRSIZEWIDTH-1:0] mem_local_addr;\n\n    wire[`RAMWIDTH-1:0] ram_write_data, ram_read_data;\n    wire[`RAMSIZEWIDTH-1:0] ram_write_addr, ram_read_addr;\n    wire[`RAMNUMBYTES-1:0] ram_write_byte_en;\n    wire ram_write_en;\n\n    MarshallerController MC (clk, start, done, N, offset, comp_start, m, n, loop, mode, comp_done, curMemSel, leftMemSel, dtu_write_req, dtu_read_req, dtu_mem_addr, dtu_ram_addr, dtu_size, dtu_ack, dtu_done, left_sel);\n\n    LU compBlock (clk, comp_start, m, n, loop, mode, comp_done, curReadAddrMem, curReadDataMem, curWriteByteEnMem, curWriteDataMem, curWriteAddrMem, curWriteEnMem, curMemSel, leftWriteByteEnMem, leftWriteDataMem, leftWriteAddrMem, leftWriteEnMem, leftMemSel);\n\n    DataTransferUnit DTU (.clk(clk), .dtu_write_req(dtu_write_req), .dtu_read_req(dtu_read_req), .dtu_mem_addr(dtu_mem_addr), .dtu_ram_addr(dtu_ram_addr), .dtu_size(dtu_size), .dtu_ack(dtu_ack), .dtu_done(dtu_done), .ram_read_addr(ram_read_addr), .ram_read_data(ram_read_data), .ram_write_byte_en(ram_write_byte_en), .ram_write_data(ram_write_data), .ram_write_addr(ram_write_addr), .ram_write_en(ram_write_en), .mem_rdata(mem_local_rdata), .mem_rdata_valid(mem_local_rdata_valid), .mem_ready(mem_local_ready), .mem_wdata_req(mem_local_wdata_req), .reset_n(reset_n), .burst_begin(burst_begin), .mem_local_addr(mem_local_addr), .mem_be(mem_local_be), .mem_read_req(mem_local_read_req), .mem_size(mem_local_size), .mem_wdata(mem_local_wdata), .mem_write_req(mem_local_write_req));\n\n    assign curReadAddrMem = ram_read_addr;\n    assign curWriteByteEnMem = ram_write_byte_en;\n    assign curWriteDataMem = ram_write_data;\n    assign curWriteAddrMem = ram_write_addr;\n    assign curWriteEnMem = ram_write_en && (left_sel == 0);\n    assign leftWriteByteEnMem = ram_write_byte_en;\n    assign leftWriteDataMem = ram_write_data;\n    assign leftWriteAddrMem = ram_write_addr;\n    assign leftWriteEnMem = ram_write_en && (left_sel == 1);\n    assign ram_read_data = curReadDataMem;\nendmodule"}
{"task_id": 1859, "completion": "reg [WIDTH-1:0] data_out;\n  reg empty, full;\n  reg [DEPTH-1:0] wraddr, rdaddr;\n  reg [DEPTH-1:0] reg_file [WIDTH-1:0];\n  reg [DEPTH-1:0] num_elems;\n\n  always @(reset)\n  begin\n    data_out=8'd0;\n    empty=1'd0;\n    full=1'd0;\n    wraddr=8'd0;\n    rdaddr=8'd0;\n    num_elems=8'd0;\n  end\n\n  always @(posedge clk)\n  begin\n    if(push && (~full) && (~pop))\n    begin\n      reg_file[wraddr] = data_in;\n      wraddr=(wraddr+1)%DEPTH;\n      num_elems=num_elems+1;\n      if(empty)\n      begin\n        empty=1'd0;\n      end\n      if((wraddr==rdaddr) &&(~empty) && (num_elems==DEPTH))\n      begin\n        full=1'd1;\n      end\n      else\n      begin\n        full=1'd0;\n      end\n    end\n    else if(pop && (~empty) && (~push))\n    begin\n      data_out=reg_file[rdaddr];\n      rdaddr=(rdaddr+1)%DEPTH;\n      num_elems=num_elems-1;\n      if(full)\n      begin\n        full=1'd0;\n      end\n      if(wraddr==rdaddr)\n      begin\n        empty=1'd1;\n      end\n      else\n      begin\n        empty=1'd0;\n      end\n    end\n  end\n\nendmodule"}
{"task_id": 1887, "completion": "generate\n    if ( C_FAMILY == \"rtl\" ) begin : USE_RTL\n      assign O = CIN & ~I;\n    end else begin : USE_FPGA\n      wire I_n;\n      assign I_n = ~I;\n      AND2B1L and2b1l_inst \n        (\n         .O(O),\n         .DI(CIN),\n         .SRI(I_n)\n        );\n    end\n  endgenerate\n\nendmodule"}
{"task_id": 1107, "completion": "parameter C_CF_BUFTYPE = 0;\n  parameter C_CF_7SERIES = 0;\n  parameter C_CF_VIRTEX6 = 1;\n  reg             adc_dmode_m1 = 'd0;\n  reg             adc_dmode = 'd0;\n  reg     [ 7:0]  adc_data_p = 'd0;\n  reg     [ 7:0]  adc_data_n = 'd0;\n  reg     [ 7:0]  adc_data_n_d = 'd0;\n  reg     [ 7:0]  adc_dmux_a = 'd0;\n  reg     [ 7:0]  adc_dmux_b = 'd0;\n  reg     [15:0]  adc_data = 'd0;\n  reg             adc_or_p = 'd0;\n  reg             adc_or_n = 'd0;\n  reg     [ 4:0]  adc_or_count = 'd0;\n  reg             adc_or = 'd0;\n  reg     [ 7:0]  delay_rst_cnt = 'd0;\n  reg             delay_sel_m1 = 'd0;\n  reg             delay_sel_m2 = 'd0;\n  reg             delay_sel_m3 = 'd0;\n  reg             delay_sel = 'd0;\n  reg             delay_rwn = 'd0;\n  reg     [ 3:0]  delay_addr = 'd0;\n  reg     [ 4:0]  delay_wdata = 'd0;\n  reg     [ 8:0]  delay_ld = 'd0;\n  reg             delay_sel_d = 'd0;\n  reg             delay_sel_2d = 'd0;\n  reg             delay_sel_3d = 'd0;\n  reg             delay_ack = 'd0;\n  reg     [ 4:0]  delay_rdata = 'd0;\n  reg             delay_locked = 'd0;\n\n  wire            delay_preset_s;\n  wire            delay_rst_s;\n  wire    [ 4:0]  delay_rdata_s[8:0];\n  wire            delay_locked_s;\n  wire    [ 7:0]  adc_data_ibuf_s;\n  wire    [ 7:0]  adc_data_idelay_s;\n  wire    [ 7:0]  adc_data_p_s;\n  wire    [ 7:0]  adc_data_n_s;\n  wire            adc_or_ibuf_s;\n  wire            adc_or_idelay_s;\n  wire            adc_or_p_s;\n  wire            adc_or_n_s;\n  wire            adc_clk_ibuf_s;\n\n  genvar          l_inst;\n\n  always @(posedge adc_clk) begin\n    adc_dmode_m1 <= up_dmode;\n    adc_dmode <= adc_dmode_m1;\n    adc_data_p <= adc_data_p_s;\n    adc_data_n <= adc_data_n_s;\n    adc_data_n_d <= adc_data_n;\n    adc_dmux_a <= (adc_dmode == 1'b1) ? adc_data_n : adc_data_p;\n    adc_dmux_b <= (adc_dmode == 1'b1) ? adc_data_p : adc_data_n_d;\n    adc_data[15] <= adc_dmux_b[7];\n    adc_data[14] <= adc_dmux_a[7];\n    adc_data[13] <= adc_dmux_b[6];\n    adc_data[12] <= adc_dmux_a[6];\n    adc_data[11] <= adc_dmux_b[5];\n    adc_data[10] <= adc_dmux_a[5];\n    adc_data[ 9] <= adc_dmux_b[4];\n    adc_data[ 8] <= adc_dmux_a[4];\n    adc_data[ 7] <= adc_dmux_b[3];\n    adc_data[ 6] <= adc_dmux_a[3];\n    adc_data[ 5] <= adc_dmux_b[2];\n    adc_data[ 4] <= adc_dmux_a[2];\n    adc_data[ 3] <= adc_dmux_b[1];\n    adc_data[ 2] <= adc_dmux_a[1];\n    adc_data[ 1] <= adc_dmux_b[0];\n    adc_data[ 0] <= adc_dmux_a[0];\n    adc_or_p <= adc_or_p_s;\n    adc_or_n <= adc_or_n_s;\n    if ((adc_or_p == 1'b1) || (adc_or_n == 1'b1)) begin\n      adc_or_count <= 5'h10;\n    end else if (adc_or_count[4] == 1'b1) begin\n      adc_or_count <= adc_or_count + 1'b1;\n    end\n    adc_or <= adc_or_count[4];\n  end\n\n  always @(posedge delay_clk) begin\n    if ((delay_sel == 1'b1) && (delay_rwn == 1'b0) && (delay_addr == 4'hf)) begin\n      delay_rst_cnt <= 'd0;\n    end else if (delay_rst_cnt[7] == 1'b0) begin\n      delay_rst_cnt <= delay_rst_cnt + 1'b1;\n    end\n    delay_sel_m1 <= up_delay_sel;\n    delay_sel_m2 <= delay_sel_m1;\n    delay_sel_m3 <= delay_sel_m2;\n    delay_sel <= delay_sel_m2 & ~delay_sel_m3;\n    if ((delay_sel_m2 == 1'b1) && (delay_sel_m3 == 1'b0)) begin\n      delay_rwn <= up_delay_rwn;\n      delay_addr <= up_delay_addr;\n      delay_wdata <= up_delay_wdata[4:0];\n    end\n    if ((delay_sel == 1'b1) && (delay_rwn == 1'b0)) begin\n      case (delay_addr)\n        4'b1000: delay_ld <= 9'h100;\n        4'b0111: delay_ld <= 9'h080;\n        4'b0110: delay_ld <= 9'h040;\n        4'b0101: delay_ld <= 9'h020;\n        4'b0100: delay_ld <= 9'h010;\n        4'b0011: delay_ld <= 9'h008;\n        4'b0010: delay_ld <= 9'h004;\n        4'b0001: delay_ld <= 9'h002;\n        4'b0000: delay_ld <= 9'h001;\n        default: delay_ld <= 9'h000;\n      endcase\n    end else begin\n      delay_ld <= 9'h000;\n    end\n    delay_sel_d <= delay_sel;\n    delay_sel_2d <= delay_sel_d;\n    delay_sel_3d <= delay_sel_2d;\n    if (delay_sel_3d == 1'b1) begin\n      delay_ack <= ~delay_ack;\n    end\n    case (delay_addr)\n      4'b1000: delay_rdata <= delay_rdata_s[ 8];\n      4'b0111: delay_rdata <= delay_rdata_s[ 7];\n      4'b0110: delay_rdata <= delay_rdata_s[ 6];\n      4'b0101: delay_rdata <= delay_rdata_s[ 5];\n      4'b0100: delay_rdata <= delay_rdata_s[ 4];\n      4'b0011: delay_rdata <= delay_rdata_s[ 3];\n      4'b0010: delay_rdata <= delay_rdata_s[ 2];\n      4'b0001: delay_rdata <= delay_rdata_s[ 1];\n      4'b0000: delay_rdata <= delay_rdata_s[ 0];\n      default: delay_rdata <= 5'd0;\n    endcase\n    delay_locked <= delay_locked_s;\n  end\n\n  assign delay_preset_s = ~delay_rst_cnt[7];\n\n  FDPE #(.INIT(1'b1)) i_delayctrl_rst_reg (\n    .CE (1'b1),\n    .D (1'b0),\n    .PRE (delay_preset_s),\n    .C (delay_clk),\n    .Q (delay_rst_s));\n\n  generate\n  for (l_inst = 0; l_inst <= 7; l_inst = l_inst + 1) begin : g_adc_if\n\n  IBUFDS i_data_ibuf (\n    .I (adc_data_in_p[l_inst]),\n    .IB (adc_data_in_n[l_inst]),\n    .O (adc_data_ibuf_s[l_inst]));\n\n  if (C_CF_BUFTYPE == C_CF_VIRTEX6) begin\n  (* IODELAY_GROUP = \"adc_if_delay_group\" *)\n  IODELAYE1 #(\n    .CINVCTRL_SEL (\"FALSE\"),\n    .DELAY_SRC (\"I\"),\n    .HIGH_PERFORMANCE_MODE (\"TRUE\"),\n    .IDELAY_TYPE (\"VAR_LOADABLE\"),\n    .IDELAY_VALUE (0),\n    .ODELAY_TYPE (\"FIXED\"),\n    .ODELAY_VALUE (0),\n    .REFCLK_FREQUENCY (200.0),\n    .SIGNAL_PATTERN (\"DATA\"))\n  i_data_idelay (\n    .T (1'b1),\n    .CE (1'b0),\n    .INC (1'b0),\n    .CLKIN (1'b0),\n    .DATAIN (1'b0),\n    .ODATAIN (1'b0),\n    .CINVCTRL (1'b0),\n    .C (delay_clk),\n    .IDATAIN (adc_data_ibuf_s[l_inst]),\n    .DATAOUT (adc_data_idelay_s[l_inst]),\n    .RST (delay_ld[l_inst]),\n    .CNTVALUEIN (delay_wdata),\n    .CNTVALUEOUT (delay_rdata_s[l_inst]));\n  end else begin\n  (* IODELAY_GROUP = \"adc_if_delay_group\" *)\n  IDELAYE2 #(\n    .CINVCTRL_SEL (\"FALSE\"),\n    .DELAY_SRC (\"IDATAIN\"),\n    .HIGH_PERFORMANCE_MODE (\"FALSE\"),\n    .IDELAY_TYPE (\"VAR_LOAD\"),\n    .IDELAY_VALUE (0),\n    .REFCLK_FREQUENCY (200.0),\n    .PIPE_SEL (\"FALSE\"),\n    .SIGNAL_PATTERN (\"DATA\"))\n  i_data_idelay (\n    .CE (1'b0),\n    .INC (1'b0),\n    .DATAIN (1'b0),\n    .LDPIPEEN (1'b0),\n    .CINVCTRL (1'b0),\n    .REGRST (1'b0),\n    .C (delay_clk),\n    .IDATAIN (adc_data_ibuf_s[l_inst]),\n    .DATAOUT (adc_data_idelay_s[l_inst]),\n    .LD (delay_ld[l_inst]),\n    .CNTVALUEIN (delay_wdata),\n    .CNTVALUEOUT (delay_rdata_s[l_inst]));\n  end\n\n  IDDR #(\n    .INIT_Q1 (1'b0),\n    .INIT_Q2 (1'b0),\n    .DDR_CLK_EDGE (\"SAME_EDGE_PIPELINED\"),\n    .SRTYPE (\"ASYNC\"))\n  i_data_ddr (\n    .CE (1'b1),\n    .R (1'b0),\n    .S (1'b0),\n    .C (adc_clk),\n    .D (adc_data_idelay_s[l_inst]),\n    .Q1 (adc_data_p_s[l_inst]),\n    .Q2 (adc_data_n_s[l_inst]));\n\n  end\n  endgenerate\n\n  IBUFDS i_or_ibuf (\n    .I (adc_data_or_p),\n    .IB (adc_data_or_n),\n    .O (adc_or_ibuf_s));\n\n  generate\n  if (C_CF_BUFTYPE == C_CF_VIRTEX6) begin\n  (* IODELAY_GROUP = \"adc_if_delay_group\" *)\n  IODELAYE1 #(\n    .CINVCTRL_SEL (\"FALSE\"),\n    .DELAY_SRC (\"I\"),\n    .HIGH_PERFORMANCE_MODE (\"TRUE\"),\n    .IDELAY_TYPE (\"VAR_LOADABLE\"),\n    .IDELAY_VALUE (0),\n    .ODELAY_TYPE (\"FIXED\"),\n    .ODELAY_VALUE (0),\n    .REFCLK_FREQUENCY (200.0),\n    .SIGNAL_PATTERN (\"DATA\"))\n  i_or_idelay (\n    .T (1'b1),\n    .CE (1'b0),\n    .INC (1'b0),\n    .CLKIN (1'b0),\n    .DATAIN (1'b0),\n    .ODATAIN (1'b0),\n    .CINVCTRL (1'b0),\n    .C (delay_clk),\n    .IDATAIN (adc_or_ibuf_s),\n    .DATAOUT (adc_or_idelay_s),\n    .RST (delay_ld[8]),\n    .CNTVALUEIN (delay_wdata),\n    .CNTVALUEOUT (delay_rdata_s[8]));\n  end else begin\n  (* IODELAY_GROUP = \"adc_if_delay_group\" *)\n  IDELAYE2 #(\n    .CINVCTRL_SEL (\"FALSE\"),\n    .DELAY_SRC (\"IDATAIN\"),\n    .HIGH_PERFORMANCE_MODE (\"FALSE\"),\n    .IDELAY_TYPE (\"VAR_LOAD\"),\n    .IDELAY_VALUE (0),\n    .REFCLK_FREQUENCY (200.0),\n    .PIPE_SEL (\"FALSE\"),\n    .SIGNAL_PATTERN (\"DATA\"))\n  i_or_idelay (\n    .CE (1'b0),\n    .INC (1'b0),\n    .DATAIN (1'b0),\n    .LDPIPEEN (1'b0),\n    .CINVCTRL (1'b0),\n    .REGRST (1'b0),\n    .C (delay_clk),\n    .IDATAIN (adc_or_ibuf_s),\n    .DATAOUT (adc_or_idelay_s),\n    .LD (delay_ld[8]),\n    .CNTVALUEIN (delay_wdata),\n    .CNTVALUEOUT (delay_rdata_s[8]));\n  end\n  endgenerate\n\n  IDDR #(\n    .INIT_Q1 (1'b0),\n    .INIT_Q2 (1'b0),\n    .DDR_CLK_EDGE (\"SAME_EDGE_PIPELINED\"),\n    .SRTYPE (\"ASYNC\"))\n  i_or_ddr (\n    .CE (1'b1),\n    .R (1'b0),\n    .S (1'b0),\n    .C (adc_clk),\n    .D (adc_or_idelay_s),\n    .Q1 (adc_or_p_s),\n    .Q2 (adc_or_n_s));\n\n  IBUFGDS i_clk_ibuf (\n    .I (adc_clk_in_p),\n    .IB (adc_clk_in_n),\n    .O (adc_clk_ibuf_s));\n\n  generate\n  if (C_CF_BUFTYPE == C_CF_VIRTEX6) begin\n  BUFR #(.BUFR_DIVIDE (\"BYPASS\")) i_clk_gbuf (\n    .CLR (1'b0),\n    .CE (1'b1),\n    .I (adc_clk_ibuf_s),\n    .O (adc_clk));\n  end else begin\n  BUFG i_clk_gbuf (\n    .I (adc_clk_ibuf_s),\n    .O (adc_clk));\n  end\n  endgenerate\n\n  (* IODELAY_GROUP = \"adc_if_delay_group\" *)\n  IDELAYCTRL i_delay_ctrl (\n    .RST (delay_rst_s),\n    .REFCLK (delay_clk),\n    .RDY (delay_locked_s));\nendmodule"}
{"task_id": 1902, "completion": "if (SUMS1 != 30) $stop;      if (SUMS2 != 20) $stop;      if (SUMS3 != 10) $stop;      if (LE_SUMS1 != 10) $stop;      if (LE_SUMS2 != 20) $stop;      if (LE_SUMS3 != 30) $stop;      if (from_array(1) != 30) $stop;      if (from_array(2) != 20) $stop;      if (from_array(3) != 10) $stop;      if (from_array_le(1) != 10) $stop;      if (from_array_le(2) != 20) $stop;      if (from_array_le(3) != 30) $stop;      $write(\"*-* All Finished *-*\n\");      $finish;   endendmodule"}
{"task_id": 1888, "completion": "localparam PADDING_WIDTH = AXIS_TDATA_WIDTH/2 - ADC_DATA_WIDTH;\n\n  reg  [ADC_DATA_WIDTH-1:0] int_dat_a_reg;\n  reg  [ADC_DATA_WIDTH-1:0] int_dat_b_reg;\n  wire                      int_clk;\n\n  IBUFGDS adc_clk_inst (.I(adc_clk_p), .IB(adc_clk_n), .O(int_clk));\n\n  always @(posedge int_clk)\n  begin\n    int_dat_a_reg <= adc_dat_a;\n    int_dat_b_reg <= adc_dat_b;\n  end\n\n  assign adc_clk = int_clk;\n\n  assign adc_csn = 1'b1;\n\n  assign m_axis_tvalid = 1'b1;\n\n  assign m_axis_tdata = {\n    {(PADDING_WIDTH+1){int_dat_b_reg[ADC_DATA_WIDTH-1]}}, ~int_dat_b_reg[ADC_DATA_WIDTH-2:0],\n    {(PADDING_WIDTH+1){int_dat_a_reg[ADC_DATA_WIDTH-1]}}, ~int_dat_a_reg[ADC_DATA_WIDTH-2:0]};\n\nendmodule"}
{"task_id": 1858, "completion": "`define IDLE                     3'd0\n    `define HEADER1                  3'd1\n    `define HEADER2                  3'd2\n    `define TIMESTAMP                3'd3\n    `define FORWARD                  3'd4\n    \n    `define MAXPAYLOAD 504\n    \n    `define PAYLOAD_LEN 8:0\n    `define TAG 12:9\n    `define MBZ 15:13\n    \n    `define CHAN 4:0\n    `define RSSI 10:5\n    `define BURST 12:11\n    `define DROPPED 13\n    `define UNDERRUN 14\n    `define OVERRUN 15\n    \n    reg [NUM_CHAN:0] overrun;\n    reg [2:0] state;\n    reg [8:0] read_length;\n    reg [8:0] payload_len;\n    reg timestamp_complete;\n    reg [3:0] check_next;\n    \n    wire [31:0] true_rssi;\n    wire [4:0] true_channel;\n    wire ready_to_send;\n    \n    assign debugbus = {chan_empty[0], rd_select[0], have_space, \n                       (chan_usedw >= 10'd504), (chan_usedw ==0),  \n                       ready_to_send, state[1:0]};\n    \n    assign true_rssi = (rd_select[1]) ? ((rd_select[0]) ? rssi_3:rssi_2) :\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t((rd_select[0]) ? rssi_1:rssi_0);\n    assign true_channel = (check_next == 4'd0 ? 5'h1f : {1'd0, check_next - 4'd1});\n    assign ready_to_send = (chan_usedw >= 10'd504) || (chan_usedw == 0) || \n                           ((rd_select == NUM_CHAN)&&(chan_usedw > 0));\n    \n    always @(posedge rxclk)\n    begin\n        if (reset)\n          begin\n            overrun <= 0;\n            WR <= 0;\n            rd_select <= 0;\n            chan_rdreq <= 0;\n            timestamp_complete <= 0;\n            check_next <= 0;\n            state <= `IDLE;\n          end\n        else case (state)\n            `IDLE: begin\n\t\t\tchan_rdreq <= #1 0;\n\t\t\t//check if the channel is full\n\t\t\tif(~chan_empty[check_next])\n\t\t\t  begin\n                    if (have_space)\n                      begin\n                        //transmit if the usb buffer have space\n                       //check if we should send\n                       if (ready_to_send)\n                           state <= #1 `HEADER1;\n\t\t\t\t\t\t\t\n                       overrun[check_next] <= 0;\n                      end\n                  else\n                    begin\n                      state <= #1 `IDLE;\n                      overrun[check_next] <= 1;\n                    end\n                  rd_select <= #1 check_next;\n                end\n                check_next <= #1 (check_next == channels ? 4'd0 : check_next + 4'd1);\n            end\n            \n            `HEADER1: begin\n                fifodata[`PAYLOAD_LEN] <= #1 9'd504;\n                payload_len <= #1 9'd504;\n                fifodata[`TAG] <= #1 0;\n                fifodata[`MBZ] <= #1 0;\n                WR <= #1 1;\n                \n                state <= #1 `HEADER2;\n                read_length <= #1 0;\n            end\n            \n            `HEADER2: begin\n                fifodata[`CHAN] <= #1 true_channel;\n                fifodata[`RSSI] <= #1 true_rssi[5:0];\n                fifodata[`BURST] <= #1 0;\n                fifodata[`DROPPED] <= #1 0;\n                fifodata[`UNDERRUN] <= #1 (check_next == 0) ? 1'b0 : underrun[true_channel];\n                fifodata[`OVERRUN] <= #1 (check_next == 0) ? 1'b0 : overrun[true_channel];\n                state <= #1 `TIMESTAMP;\n            end\n            \n            `TIMESTAMP: begin\n                fifodata <= #1 (timestamp_complete ? timestamp_clock[31:16] : timestamp_clock[15:0]);\n                timestamp_complete <= #1 ~timestamp_complete;\n                \n                if (~timestamp_complete)\n                    chan_rdreq <= #1 1;\n                \n                state <= #1 (timestamp_complete ? `FORWARD : `TIMESTAMP);\n            end\n            \n            `FORWARD: begin\n                read_length <= #1 read_length + 9'd2;\n                fifodata <= #1 (read_length >= payload_len ? 16'hDEAD : chan_fifodata);\n                \n                if (read_length >= `MAXPAYLOAD)\n                  begin\n                    WR <= #1 0;\n                    state <= #1 `IDLE;\n\t\t\t\t\t\t\t\t\t\t\t\tchan_rdreq <= #1 0;\n                  end\n                else if (read_length == payload_len - 4)\n                    chan_rdreq <= #1 0;\n            end\n            \n            default: begin\n\t\t\t\t//handling error state\n                state <= `IDLE;\n            end\n            endcase\n    end\nendmodule"}
{"task_id": 1894, "completion": "wire next;\n    wire next_pending;\n    wire a_push;\n    wire incr_burst;\n    reg [C_ID_WIDTH-1:0] s_arid_r;\n\n    axi_protocol_converter_v2_1_7_b2s_cmd_translator #(\n        .C_AXI_ADDR_WIDTH ( C_AXI_ADDR_WIDTH )\n    ) cmd_translator_0 (\n        .clk ( clk ),\n        .reset ( reset ),\n        .s_axaddr ( s_araddr ),\n        .s_axlen ( s_arlen ),\n        .s_axsize ( s_arsize ),\n        .s_axburst ( s_arburst ),\n        .s_axhandshake ( s_arvalid & a_push ),\n        .incr_burst ( incr_burst ),\n        .m_axaddr ( m_araddr ),\n        .next ( next ),\n        .next_pending ( next_pending )\n    );\n\n    axi_protocol_converter_v2_1_7_b2s_rd_cmd_fsm ar_cmd_fsm_0 (\n        .clk ( clk ),\n        .reset ( reset ),\n        .s_arready ( s_arready ),\n        .s_arvalid ( s_arvalid ),\n        .s_arlen ( s_arlen ),\n        .m_arvalid ( m_arvalid ),\n        .m_arready ( m_arready ),\n        .next ( next ),\n        .next_pending ( next_pending ),\n        .data_ready ( ~r_full ),\n        .a_push ( a_push ),\n        .r_push ( r_push )\n    );\n\n    assign r_arid = s_arid_r;\n    assign r_rlast = ~next_pending;\n\n    always @(posedge clk) begin\n        s_arid_r <= s_arid;\n    end\nendmodule"}
{"task_id": 1906, "completion": "wire signed [45:0] int_AB;\n\n  assign int_AB = a * b;\n\nalways @(a, b, int_AB, c) begin\n  #1;\n  if (int_AB !== c) begin\n     $display(\"ERROR: mismatch for inputs %d * %d\", a, b);\n\t $display(\"VHDL = %d; Verilog = %d\", c, int_AB);\n     $finish;\n  end\nend\n\nendmodule"}
{"task_id": 1890, "completion": "wire inv;\n    assign inv = BITVAL ^ CRC[15];\n    always @(posedge CLK or posedge RST) begin\n        if (RST) begin\n            CRC = 0;\n        end\n        else begin\n            if (Enable == 1) begin\n                CRC[15] = CRC[14];\n                CRC[14] = CRC[13];\n                CRC[13] = CRC[12];\n                CRC[12] = CRC[11] ^ inv;\n                CRC[11] = CRC[10];\n                CRC[10] = CRC[9];\n                CRC[9] = CRC[8];\n                CRC[8] = CRC[7];\n                CRC[7] = CRC[6];\n                CRC[6] = CRC[5];\n                CRC[5] = CRC[4] ^ inv;\n                CRC[4] = CRC[3];\n                CRC[3] = CRC[2];\n                CRC[2] = CRC[1];\n                CRC[1] = CRC[0];\n                CRC[0] = inv;\n            end\n        end\n    end\nendmodule"}
{"task_id": 1889, "completion": "reg                     full0;   reg                     full1;   reg [DATA_WIDTH-1:0]    data0;   reg [DATA_WIDTH-1:0]    data1;   assign out_valid = full1;   assign out_data  = data1;   generate if (PIPELINE_READY == 1)    begin : REGISTERED_READY_PLINE         assign in_ready  = !full0;         always @(posedge clk, posedge reset) begin            if (reset) begin               data0 <= {DATA_WIDTH{1'b0}};               data1 <= {DATA_WIDTH{1'b0}};            end else begin               if (~full0)                 data0 <= in_data;               if (~full1 || (out_ready && out_valid)) begin                  if (full0)                    data1 <= data0;                  else                    data1 <= in_data;               end            end         end          always @(posedge clk or posedge reset) begin            if (reset) begin               full0    <= 1'b0;               full1    <= 1'b0;            end else begin               if (~full0 & ~full1) begin                  if (in_valid) begin                     full1 <= 1'b1;                  end               end               if (full1 & ~full0) begin                  if (in_valid & ~out_ready) begin                     full0 <= 1'b1;                  end                 if (~in_valid & out_ready) begin                    full1 <= 1'b0;                 end               end               if (full1 & full0) begin                  if (out_ready) begin                     full0 <= 1'b0;                  end               end            end         end      end    else     begin : UNREGISTERED_READY_PLINE         assign in_ready = (~full1) | out_ready;         always @(posedge clk or posedge reset) begin            if (reset) begin               data1 <= 'b0;               full1 <= 1'b0;            end            else begin               if (in_ready) begin                  data1 <= in_data;                  full1 <= in_valid;               end            end         end      end   endgenerate endmodule"}
{"task_id": 1825, "completion": "reg reserve_i, reserve_d;\n\n    wire en_i = (~reset_i & icyc_i & ~dcyc_i) |\n                (~reset_i & icyc_i & dcyc_i & reserve_i & ~reserve_d);\n\n    wire en_d = (~reset_i & ~icyc_i & dcyc_i) |\n                (~reset_i & icyc_i & dcyc_i & ~reserve_i) |\n                (~reset_i & icyc_i & dcyc_i & reserve_i & reserve_d);\n\n    assign xdat_o = (en_i ? idat_i : 64'd0) | (en_d ? ddat_i : 64'd0);\n    assign xadr_o = (en_i ? iadr_i : 64'd0) | (en_d ? dadr_i : 64'd0);\n    assign xwe_o = (en_i & iwe_i) | (en_d & dwe_i);\n    assign xcyc_o = (en_i & icyc_i) | (en_d & dcyc_i);\n    assign xstb_o = (en_i & istb_i) | (en_d & dstb_i);\n    assign xsiz_o = (en_i ? isiz_i : 2'd0) | (en_d ? dsiz_i : 2'd0);\n    assign xsigned_o = (en_i & isigned_i) | (en_d & dsigned_i);\n\n    assign iack_o = (en_i & xack_i);\n    assign dack_o = (en_d & xack_i);\n\n    assign idat_o = (en_i ? xdat_i : 64'd0);\n    assign ddat_o = (en_d ? xdat_i : 64'd0);\n\n    always @(posedge clk_i) begin\n        reserve_i <= en_i;\n        reserve_d <= en_d;\n    end\nendmodule"}
{"task_id": 1893, "completion": "reg\t\t[23: 0] \tdata;\n\nassign rom_data = {data[13: 8], 2'h0, \n\t\t\t\tdata[ 7: 0]};\n\nalways @(*)\nbegin\n\tcase (rom_address)\n\t0\t\t: \tdata\t<= \t{6'h02, 8'h07};\n\t1\t\t: \tdata\t<= \t{6'h03, 8'hDF};\n\t2\t\t: \tdata\t<= \t{6'h04, 8'h17};\n\t3\t\t: \tdata\t<= \t{6'h11, 8'h00};\n\t4\t\t: \tdata\t<= \t{6'h12, 8'h5B};\n\t5\t\t: \tdata\t<= \t{6'h13, 8'hFF};\n\t6\t\t: \tdata\t<= \t{6'h14, 8'h00};\n\t7\t\t: \tdata\t<= \t{6'h15, 8'h20};\n\t8\t\t: \tdata\t<= \t{6'h16, 8'h40};\n\t9\t\t: \tdata\t<= \t{6'h17, 8'h80};\n\t10\t: \tdata\t<= \t{6'h18, 8'h00};\n\t11\t: \tdata\t<= \t{6'h19, 8'h80};\n\t12\t: \tdata\t<= \t{6'h1A, 8'h00};\n\t13\t: \tdata\t<= \t{6'h1B, 8'h00};\n\t14\t: \tdata\t<= \t{6'h1C, 8'h80};\n\t15\t: \tdata\t<= \t{6'h1D, 8'hC0};\n\t16\t: \tdata\t<= \t{6'h1E, 8'hE0};\n\t17\t: \tdata\t<= \t{6'h1F, 8'hFF};\n\t18\t: \tdata\t<= \t{6'h20, 8'hD2};\n\t19\t: \tdata\t<= \t{6'h21, 8'hD2};\n\tdefault\t: \tdata\t<= \t14'h0000;\n\tendcase\nend\n\nendmodule"}
{"task_id": 1874, "completion": "reg en_int=0;\nreg done_int=0;\nreg clk_int=0;\nreg pdm_clk_rising;\nreg [15:0] pdm_s_tmp, dout;\ninteger cnt_bits=0;\ninteger cnt_clk=0;\n\nassign done = done_int;\nassign pwm_audio_o = pdm_s_tmp[15]; \n\n// register en input    \nalways @(posedge clk)\n    en_int <= en;\n\n// Count the number of sampled bits\nalways @(posedge clk)\nbegin\n  if (en_int==0)\n    cnt_bits <=0;\n  else\n    if (pdm_clk_rising)\n    begin\n        if (cnt_bits == 15)\n            cnt_bits <=0;\n        else\n            cnt_bits <= cnt_bits + 1;\n     end           \nend\n\n// Generate the done signal\nalways @(posedge clk)\nbegin\n  if (pdm_clk_rising)\n  begin\n    if (cnt_bits==15)\n        done_int<=1;\n  end\n  else\n    done_int <= 0;\nend\n\n// Serializer\nalways @(posedge clk)\nbegin\n  if (pdm_clk_rising)\n  begin\n    if (cnt_bits==0)\n        pdm_s_tmp <= din;\n    else\n        pdm_s_tmp <= {pdm_s_tmp[14:0], 1'b0};\n  end\nend\n\n// Generate the internal PDM Clock\nalways @(posedge clk)\nbegin\n  if (en_int == 0)\n  begin\n    cnt_clk <= 0;\n    pdm_clk_rising <= 0;\n  end\n  else\n  begin\n      if (cnt_clk == 24) // (C_SYS_CLK_FREQ_MHZ*1000000)/(C_PDM_FREQ_HZ*2))-1  where C_SYS_CLK_FREQ_MHZ=100, C_PDM_FREQ_HZ=2MHz\n      begin\n        cnt_clk <= 0;\n        pdm_clk_rising <= 1;\n      end\n      else\n      begin\n        cnt_clk <= cnt_clk + 1;\n        pdm_clk_rising <= 0;\n      end\n  end\nend\n   \nendmodule"}
{"task_id": 1625, "completion": "parameter Tp = 1;\n\ninput         MTxClk;\ninput         TxReset;\ninput         TxUsedDataIn;\ninput         TxUsedDataOut;\ninput         TxDoneIn;\ninput         TxAbortIn;\ninput         TxStartFrmIn;\ninput         TPauseRq;\ninput         TxUsedDataOutDetected;\ninput         TxFlow;\ninput         DlyCrcEn;\ninput  [15:0] TxPauseTV;\ninput  [47:0] MAC;\n\noutput        TxCtrlStartFrm;\noutput        TxCtrlEndFrm;\noutput        SendingCtrlFrm;\noutput        CtrlMux;\noutput [7:0]  ControlData;\noutput        WillSendControlFrame;\noutput        BlockTxDone;\n\nreg           SendingCtrlFrm;\nreg           CtrlMux;\nreg           WillSendControlFrame;\nreg    [3:0]  DlyCrcCnt;\nreg    [5:0]  ByteCnt;\nreg           ControlEnd_q;\nreg    [7:0]  MuxedCtrlData;\nreg           TxCtrlStartFrm;\nreg           TxCtrlStartFrm_q;\nreg           TxCtrlEndFrm;\nreg    [7:0]  ControlData;\nreg           TxUsedDataIn_q;\nreg           BlockTxDone;\n\nwire          IncrementDlyCrcCnt;\nwire          ResetByteCnt;\nwire          IncrementByteCnt;\nwire          ControlEnd;\nwire          IncrementByteCntBy2;\nwire          EnableCnt;\n\nalways @ (posedge MTxClk or posedge TxReset)\nbegin\n  if(TxReset)\n    WillSendControlFrame <= #Tp 1'b0;\n  else\n  if(TxCtrlEndFrm & CtrlMux)\n    WillSendControlFrame <= #Tp 1'b0;\n  else\n  if(TPauseRq & TxFlow)\n    WillSendControlFrame <= #Tp 1'b1;\nend\n\nalways @ (posedge MTxClk or posedge TxReset)\nbegin\n  if(TxReset)\n    TxCtrlStartFrm <= #Tp 1'b0;\n  else\n  if(TxUsedDataIn_q & CtrlMux)\n    TxCtrlStartFrm <= #Tp 1'b0;\n  else\n  if(WillSendControlFrame & ~TxUsedDataOut & (TxDoneIn | TxAbortIn | TxStartFrmIn | (~TxUsedDataOutDetected)))\n    TxCtrlStartFrm <= #Tp 1'b1;\nend\n\nalways @ (posedge MTxClk or posedge TxReset)\nbegin\n  if(TxReset)\n    TxCtrlEndFrm <= #Tp 1'b0;\n  else\n  if(ControlEnd | ControlEnd_q)\n    TxCtrlEndFrm <= #Tp 1'b1;\n  else\n    TxCtrlEndFrm <= #Tp 1'b0;\nend\n\nalways @ (posedge MTxClk or posedge TxReset)\nbegin\n  if(TxReset)\n    CtrlMux <= #Tp 1'b0;\n  else\n  if(WillSendControlFrame & ~TxUsedDataOut)\n    CtrlMux <= #Tp 1'b1;\n  else\n  if(TxDoneIn)\n    CtrlMux <= #Tp 1'b0;\nend\n\nalways @ (posedge MTxClk or posedge TxReset)\nbegin\n  if(TxReset)\n    SendingCtrlFrm <= #Tp 1'b0;\n  else\n  if(WillSendControlFrame & TxCtrlStartFrm)\n    SendingCtrlFrm <= #Tp 1'b1;\n  else\n  if(TxDoneIn)\n    SendingCtrlFrm <= #Tp 1'b0;\nend\n\nalways @ (posedge MTxClk or posedge TxReset)\nbegin\n  if(TxReset)\n    TxUsedDataIn_q <= #Tp 1'b0;\n  else\n    TxUsedDataIn_q <= #Tp TxUsedDataIn;\nend\n\nalways @ (posedge MTxClk or posedge TxReset)\nbegin\n  if(TxReset)\n    BlockTxDone <= #Tp 1'b0;\n  else\n  if(TxCtrlStartFrm)\n    BlockTxDone <= #Tp 1'b1;\n  else\n  if(TxStartFrmIn)\n    BlockTxDone <= #Tp 1'b0;\nend\n\nalways @ (posedge MTxClk)\nbegin\n  ControlEnd_q     <= #Tp ControlEnd;\n  TxCtrlStartFrm_q <= #Tp TxCtrlStartFrm;\nend\n\nassign IncrementDlyCrcCnt = CtrlMux & TxUsedDataIn &  ~DlyCrcCnt[2];\n\nalways @ (posedge MTxClk or posedge TxReset)\nbegin\n  if(TxReset)\n    DlyCrcCnt <= #Tp 4'h0;\n  else\n  if(ResetByteCnt)\n    DlyCrcCnt <= #Tp 4'h0;\n  else\n  if(IncrementDlyCrcCnt)\n    DlyCrcCnt <= #Tp DlyCrcCnt + 1'b1;\nend\n\nassign ResetByteCnt = TxReset | (~TxCtrlStartFrm & (TxDoneIn | TxAbortIn));\nassign IncrementByteCnt = CtrlMux & (TxCtrlStartFrm & ~TxCtrlStartFrm_q & ~TxUsedDataIn | TxUsedDataIn & ~ControlEnd);\nassign IncrementByteCntBy2 = CtrlMux & TxCtrlStartFrm & (~TxCtrlStartFrm_q) & TxUsedDataIn;\nassign EnableCnt = (~DlyCrcEn | DlyCrcEn & (&DlyCrcCnt[1:0]));\n\nalways @ (posedge MTxClk or posedge TxReset)\nbegin\n  if(TxReset)\n    ByteCnt <= #Tp 6'h0;\n  else\n  if(ResetByteCnt)\n    ByteCnt <= #Tp 6'h0;\n  else\n  if(IncrementByteCntBy2 & EnableCnt)\n    ByteCnt <= #Tp (ByteCnt[5:0] ) + 2'h2;\n  else\n  if(IncrementByteCnt & EnableCnt)\n    ByteCnt <= #Tp (ByteCnt[5:0] ) + 1'b1;\nend\n\nassign ControlEnd = ByteCnt[5:0] == 6'h22;\n\nalways @ (ByteCnt or DlyCrcEn or MAC or TxPauseTV or DlyCrcCnt)\nbegin\n  case(ByteCnt)\n    6'h0:    if(~DlyCrcEn | DlyCrcEn & (&DlyCrcCnt[1:0]))\n               MuxedCtrlData[7:0] = 8'h01;\n             else\n               MuxedCtrlData[7:0] = 8'h0;\n    6'h2:      MuxedCtrlData[7:0] = 8'h80;\n    6'h4:      MuxedCtrlData[7:0] = 8'hC2;\n    6'h6:      MuxedCtrlData[7:0] = 8'h00;\n    6'h8:      MuxedCtrlData[7:0] = 8'h00;\n    6'hA:      MuxedCtrlData[7:0] = 8'h01;\n    6'hC:      MuxedCtrlData[7:0] = MAC[47:40];\n    6'hE:      MuxedCtrlData[7:0] = MAC[39:32];\n    6'h10:     MuxedCtrlData[7:0] = MAC[31:24];\n    6'h12:     MuxedCtrlData[7:0] = MAC[23:16];\n    6'h14:     MuxedCtrlData[7:0] = MAC[15:8];\n    6'h16:     MuxedCtrlData[7:0] = MAC[7:0];\n    6'h18:     MuxedCtrlData[7:0] = 8'h88;\n    6'h1A:     MuxedCtrlData[7:0] = 8'h08;\n    6'h1C:     MuxedCtrlData[7:0] = 8'h00;\n    6'h1E:     MuxedCtrlData[7:0] = 8'h01;\n    6'h20:     MuxedCtrlData[7:0] = TxPauseTV[15:8];\n    6'h22:     MuxedCtrlData[7:0] = TxPauseTV[7:0];\n    default:   MuxedCtrlData[7:0] = 8'h0;\n  endcase\nend\n\nalways @ (posedge MTxClk or posedge TxReset)\nbegin\n  if(TxReset)\n    ControlData[7:0] <= #Tp 8'h0;\n  else\n  if(~ByteCnt[0])\n    ControlData[7:0] <= #Tp MuxedCtrlData[7:0];\nend\n\nendmodule"}
{"task_id": 1912, "completion": "wire [15:0] op2;    wire [15:0] outadd;    wire [15:0] outlog;    wire ci;    wire cfoadd;    wire log;    wire xs;    wire ys;    wire os;    zet_fulladd16 fulladd16 ( // We instantiate only one adder    .x  (x),                //  to have less hardware    .y  (op2),    .ci (ci),    .co (cfoadd),    .z  (outadd),    .s  (f[0])  );    assign op2 = f[0] ? ~y  /* sbb,sub,cmp */                    : y;  /* add, adc */    assign ci  = f[2] | ~f[2] & f[1] & (!f[0] & cfi             | f[0] & ~cfi);    assign log = f[2:0]==3'd1 || f[2:0]==3'd4 || f[2:0]==3'd6;    assign afo   = !log & (x[4] ^ y[4] ^ outadd[4]);    assign cfo   = !log & (word_op ? cfoadd : (x[8]^y[8]^outadd[8]));    assign xs  = word_op ? x[15] : x[7];    assign ys  = word_op ? y[15] : y[7];    assign os  = word_op ? outadd[15] : outadd[7];    assign ofo = !log &    (f[0] ? (~xs & ys & os | xs & ~ys & ~os)          : (~xs & ~ys & os | xs & ys & ~os));    assign outlog = f[2] ? (f[1] ? x^y : x&y) : x|y;    assign o      = log ? outlog : outadd;endmodule"}
{"task_id": 1899, "completion": "wire  sub_wire0;\n    wire [4:0] sub_wire1;\n    wire  cout = sub_wire0;\n    wire [4:0] q = sub_wire1[4:0];\n\n    lpm_counter LPM_COUNTER_component (\n                .aclr (aclr),\n                .clk_en (clk_en),\n                .clock (clock),\n                .cnt_en (cnt_en),\n                .sset (sset),\n                .cout (sub_wire0),\n                .q (sub_wire1),\n                .aload (1'b0),\n                .aset (1'b0),\n                .cin (1'b1),\n                .data ({5{1'b0}}),\n                .eq (),\n                .sclr (1'b0),\n                .sload (1'b0),\n                .updown (1'b1));\n    defparam\n        LPM_COUNTER_component.lpm_direction = \"DOWN\",\n        LPM_COUNTER_component.lpm_port_updown = \"PORT_UNUSED\",\n        LPM_COUNTER_component.lpm_svalue = \"29\",\n        LPM_COUNTER_component.lpm_type = \"LPM_COUNTER\",\n        LPM_COUNTER_component.lpm_width = 5;\n\nendmodule"}
{"task_id": 1688, "completion": "localparam READY = 5'b00001,          READ = 5'b00010,          WRITE = 5'b00100,          CMD_WAIT = 5'b01000,          REFRESH_ST = 5'b10000;   localparam RD = 3'b001;   localparam RDP = 3'b011;   localparam WR = 3'b000;   localparam WRP = 3'b010;   localparam REFRESH = 3'b100;   localparam NOP = 3'b101;   reg cmd_fifo_rdy;   wire cmd_rd;   wire cmd_wr;   wire cmd_others;   reg push_cmd;   reg xfer_cmd;   reg rd_vld;   reg wr_vld;   reg cmd_rdy;   reg [2:0] cmd_reg;   reg [31:0] addr_reg;   reg [5:0] bl_reg;   reg rdp_valid;   (*EQUIVALENT_REGISTER_REMOVAL=\"NO\"*) reg wdp_valid, wdp_validB, wdp_validC;   reg [4:0] current_state;   reg [4:0] next_state;   reg [3:0] tstpointA;   reg push_cmd_r;   reg wait_done;   reg cmd_en_r1;   reg wr_in_progress;   reg tst_cmd_rdy_o;   assign cmd_en_o = cmd_en_r1;   always @ (posedge clk_i) begin       cmd_rdy_o <= #TCQ cmd_rdy;       tst_cmd_rdy_o <= #TCQ cmd_rdy;   end   always @ (posedge clk_i)   begin       if (rst_i[8])           cmd_en_r1 <= #TCQ 1'b0;       else if (xfer_cmd)           cmd_en_r1 <= #TCQ 1'b1;       else if (!mcb_cmd_full)           cmd_en_r1 <= #TCQ 1'b0;    end   always @ (posedge clk_i)   begin       if (rst_i[9])           cmd_fifo_rdy <= #TCQ 1'b1;       else if (xfer_cmd)           cmd_fifo_rdy <= #TCQ 1'b0;       else if (!mcb_cmd_full)       cmd_fifo_rdy <= #TCQ 1'b1;   end   always @ (posedge clk_i)   begin       if (rst_i[9]) begin           addr_o <= #TCQ 'b0;           cmd_o <= #TCQ 'b0;           bl_o <= #TCQ 'b0;       end       else if (xfer_cmd) begin           addr_o <= #TCQ addr_reg;           if (FAMILY == \"SPARTAN6\")               cmd_o <= #TCQ cmd_reg;           else               cmd_o <= #TCQ {2'b00, cmd_reg[0]};           bl_o <= #TCQ bl_reg;       end   end   assign wr_addr_o = addr_i;   assign rd_addr_o = addr_i;   assign rd_bl_o = bl_i;   assign wr_bl_o = bl_i;   assign wdp_valid_o = wdp_valid;   assign wdp_validB_o = wdp_validB;   assign wdp_validC_o = wdp_validC;   assign rdp_valid_o = rdp_valid;   always @ (posedge clk_i)   begin       if (rst_i[8])           wait_done <= #TCQ 1'b1;       else if (push_cmd_r)           wait_done <= #TCQ 1'b1;       else if (cmd_rdy_o && cmd_valid_i && FAMILY == \"SPARTAN6\")           wait_done <= #TCQ 1'b0;   end   always @ (posedge clk_i)       begin           push_cmd_r <= #TCQ push_cmd;       end   always @ (posedge clk_i)       if (push_cmd)       begin           cmd_reg <= #TCQ cmd_i;           addr_reg <= #TCQ addr_i;           bl_reg <= #TCQ bl_i - 1;       end   assign cmd_wr = ((cmd_i == WR | cmd_i == WRP) & cmd_valid_i) ? 1'b1 : 1'b0;   assign cmd_rd = ((cmd_i == RD | cmd_i == RDP) & cmd_valid_i) ? 1'b1 : 1'b0;   assign cmd_others = ((cmd_i[2] == 1'b1) & cmd_valid_i && (FAMILY == \"SPARTAN6\")) ? 1'b1 : 1'b0;   reg cmd_wr_pending_r1;   reg cmd_rd_pending_r1;   always @ (posedge clk_i)   begin       if (rst_i[0])           cmd_wr_pending_r1 <= #TCQ 1'b0;       else if (last_word_wr_i)           cmd_wr_pending_r1 <= #TCQ 1'b1;       else if (push_cmd)           cmd_wr_pending_r1 <= #TCQ 1'b0;   end   always @ (posedge clk_i)   begin       if (cmd_rd & push_cmd)           cmd_rd_pending_r1 <= #TCQ 1'b1;       else if (xfer_cmd)           cmd_rd_pending_r1 <= #TCQ 1'b0;   end   always @ (posedge clk_i)   begin       if (rst_i[0])           wr_in_progress <= #TCQ 1'b0;       else if (last_word_wr_i)           wr_in_progress <= #TCQ 1'b0;       else if (current_state == WRITE)           wr_in_progress <= #TCQ 1'b1;   end   always @ (posedge clk_i)   begin       if (rst_i[0])           current_state <= #TCQ 4'b0001;       else           current_state <= #TCQ next_state;   end   always @ (*)   begin       push_cmd = 1'b0;       xfer_cmd = 1'b0;       wdp_valid = 1'b0;       wdp_validB = 1'b0;       wdp_validC = 1'b0;       rdp_valid = 1'b0;       cmd_rdy = 1'b0;       next_state = current_state;       case(current_state)           READY:           begin               if (rdp_rdy_i & cmd_rd & cmd_fifo_rdy)               begin                   next_state = READ;                   push_cmd = 1'b1;                   xfer_cmd = 1'b0;                   rdp_valid = 1'b1;               end               else if (wdp_rdy_i & cmd_wr & cmd_fifo_rdy)               begin                   next_state = WRITE;                   push_cmd = 1'b1;                   wdp_valid = 1'b1;                   wdp_validB = 1'b1;                   wdp_validC = 1'b1;               end               else if (cmd_others & cmd_fifo_rdy)               begin                   next_state = REFRESH_ST;                   push_cmd = 1'b1;                   xfer_cmd = 1'b0;               end               else               begin                   next_state = READY;                   push_cmd = 1'b0;               end               if (cmd_fifo_rdy)                   cmd_rdy = 1'b1;               else                   cmd_rdy = 1'b0;           end           REFRESH_ST:           begin               if (rdp_rdy_i && cmd_rd && cmd_fifo_rdy)               begin                   next_state = READ;                   push_cmd = 1'b1;                   rdp_valid = 1'b1;                   wdp_valid = 1'b0;                   xfer_cmd = 1'b1;               end               else if (cmd_fifo_rdy && cmd_wr && wdp_rdy_i)               begin                   next_state = WRITE;                   push_cmd = 1'b1;                   xfer_cmd = 1'b1;                   wdp_valid = 1'b1;                   wdp_validB = 1'b1;                   wdp_validC = 1'b1;               end               else if (cmd_fifo_rdy && cmd_others)               begin                   push_cmd = 1'b1;                   xfer_cmd = 1'b1;               end               else if (!cmd_fifo_rdy)               begin                   next_state = CMD_WAIT;               end               else                   next_state = READ;               if (cmd_fifo_rdy && ((rdp_rdy_i && cmd_rd) || (wdp_rdy_i && cmd_wr) || (cmd_others)))                   cmd_rdy = 1'b1;               else                   cmd_rdy = 1'b0;           end           READ:           begin               if (rdp_rdy_i && cmd_rd && cmd_fifo_rdy)               begin                   next_state = READ;                   push_cmd = 1'b1;                   rdp_valid = 1'b1;                   wdp_valid = 1'b0;                   xfer_cmd = 1'b1;               end               else if (cmd_fifo_rdy && cmd_wr && wdp_rdy_i)               begin                   next_state = WRITE;                   push_cmd = 1'b1;                   xfer_cmd = 1'b1;                   wdp_valid = 1'b1;                   wdp_validB = 1'b1;                   wdp_validC = 1'b1;               end               else if (!rdp_rdy_i)               begin                   next_state = READ;                   push_cmd = 1'b0;                   xfer_cmd = 1'b0;                   wdp_valid = 1'b0;                   wdp_validB = 1'b0;                   wdp_validC = 1'b0;                   rdp_valid = 1'b0;               end               else if (last_word_rd_i && cmd_others && cmd_fifo_rdy)               begin                   next_state = REFRESH_ST;                   push_cmd = 1'b1;                   xfer_cmd = 1'b1;                   wdp_valid = 1'b0;                   wdp_validB = 1'b0;                   wdp_validC = 1'b0;                   rdp_valid = 1'b0;               end               else if (!cmd_fifo_rdy || !wdp_rdy_i)               begin                   next_state = CMD_WAIT;               end               else                   next_state = READ;               if ((rdp_rdy_i && cmd_rd || cmd_wr && wdp_rdy_i || cmd_others) && cmd_fifo_rdy)                   cmd_rdy = wait_done;               else                   cmd_rdy = 1'b0;           end           WRITE:           begin               if (cmd_fifo_rdy &&  cmd_rd && rdp_rdy_i && last_word_wr_i)               begin                   next_state = READ;                   push_cmd = 1'b1;                   xfer_cmd = 1'b1;                   rdp_valid = 1'b1;               end               else if (!wdp_rdy_i || (wdp_rdy_i && cmd_wr && cmd_fifo_rdy && last_word_wr_i))               begin                   next_state = WRITE;                   if (cmd_wr && last_word_wr_i) begin                       wdp_valid = 1'b1;                       wdp_validB = 1'b1;                       wdp_validC = 1'b1;                   end               end               else if (last_word_wr_i && cmd_others && cmd_fifo_rdy)               begin                   next_state = REFRESH_ST;                   push_cmd = 1'b1;                   xfer_cmd = 1'b1;                   wdp_valid = 1'b0;                   wdp_validB = 1'b0;                   wdp_validC = 1'b0;                   rdp_valid = 1'b0;               end               else if (!cmd_fifo_rdy && last_word_wr_i || !rdp_rdy_i || (!cmd_valid_i && wait_done))               begin                   next_state = CMD_WAIT;                   push_cmd = 1'b0;                   xfer_cmd = 1'b0;               end               else begin                   next_state = WRITE;               end               if (last_word_wr_i && (cmd_others || rdp_rdy_i && cmd_rd || cmd_wr && wdp_rdy_i) && cmd_fifo_rdy)                   cmd_rdy = wait_done;               else                   cmd_rdy = 1'b0;           end           CMD_WAIT:           if (!cmd_fifo_rdy || wr_in_progress)               begin                   next_state = CMD_WAIT;                   cmd_rdy = 1'b0;               end             else if (cmd_fifo_rdy && rdp_rdy_i && cmd_rd)               begin                   next_state = READ;                   push_cmd = 1'b1;                   xfer_cmd = 1'b1;                   cmd_rdy = 1'b1;                   rdp_valid = 1'b1;               end             else if (cmd_fifo_rdy  && cmd_wr && (wait_done || cmd_wr_pending_r1))               begin                   next_state = WRITE;                   push_cmd = 1'b1;                   xfer_cmd = 1'b1;                   wdp_valid = 1'b1;                   wdp_validB = 1'b1;                   wdp_validC = 1'b1;                   cmd_rdy = 1'b1;               end             else if (cmd_fifo_rdy &&  cmd_others)               begin                   next_state = REFRESH_ST;                   push_cmd = 1'b1;                   xfer_cmd = 1'b1;                   cmd_rdy = 1'b1;               end             else               begin                   next_state = CMD_WAIT;                   if ((wdp_rdy_i && rdp_rdy_i))                       cmd_rdy = 1'b1;               else                   cmd_rdy = 1'b0;               end           default:           begin               push_cmd = 1'b0;               xfer_cmd = 1'b0;               wdp_valid = 1'b0;               wdp_validB = 1'b0;               wdp_validC = 1'b0;               next_state = READY;               end       endcase   endendmodule"}
{"task_id": 1925, "completion": "assign sc = a + b;\n   always @(a, b) ss = a + b;\nendmodule"}
{"task_id": 1935, "completion": "rxuart _rx (\n     .clk(clk),\n     .resetq(resetq),\n     .uart_rx(rx),\n     .rd(rd),\n     .valid(valid),\n     .data(rx_data));\n  uart _tx (\n     .clk(clk),\n     .resetq(resetq),\n     .uart_busy(busy),\n     .uart_tx(tx),\n     .uart_wr_i(wr),\n     .uart_dat_i(tx_data));\nendmodule"}
{"task_id": 1917, "completion": "always @ (wptr[N:N-1] or rptr[N:N-1])\n     case ({wptr[N:N-1],rptr[N:N-1]})\n       {Q1,Q2} : direction_set <= 1'b1;\n       {Q2,Q3} : direction_set <= 1'b1;\n       {Q3,Q4} : direction_set <= 1'b1;\n       {Q4,Q1} : direction_set <= 1'b1;\n       default : direction_set <= 1'b0;\n     endcase\n\n   always @ (wptr[N:N-1] or rptr[N:N-1] or rst)\n     if (rst)\n       direction_clr <= 1'b1;\n     else\n       case ({wptr[N:N-1],rptr[N:N-1]})\n         {Q2,Q1} : direction_clr <= 1'b1;\n         {Q3,Q2} : direction_clr <= 1'b1;\n         {Q4,Q3} : direction_clr <= 1'b1;\n         {Q1,Q4} : direction_clr <= 1'b1;\n         default : direction_clr <= 1'b0;\n       endcase\n\n   always @ (posedge direction_set or posedge direction_clr)\n     if (direction_clr)\n       direction <= going_empty;\n     else\n       direction <= going_full;\n\n   assign async_empty = (wptr == rptr) && (direction==going_empty);\n   assign async_full  = (wptr == rptr) && (direction==going_full);\n\n   always @ (posedge wclk or posedge rst or posedge async_full)\n     if (rst)\n       {fifo_full, fifo_full2} <= 2'b00;\n     else if (async_full)\n       {fifo_full, fifo_full2} <= 2'b11;\n     else\n       {fifo_full, fifo_full2} <= {fifo_full2, async_full};\n\n   always @ (posedge rclk or posedge async_empty)\n     if (async_empty)\n       {fifo_empty, fifo_empty2} <= 2'b11;\n     else\n       {fifo_empty,fifo_empty2} <= {fifo_empty2,async_empty};   \nendmodule"}
{"task_id": 1815, "completion": "`include \"VGA_Param.h\"\n\n    `ifdef VGA_640x480p60\n    parameter H_SYNC_CYC = 96;\n    parameter H_SYNC_BACK = 48;\n    parameter H_SYNC_ACT = 640;\n    parameter H_SYNC_FRONT = 16;\n    parameter H_SYNC_TOTAL = 800;\n\n    parameter V_SYNC_CYC = 2;\n    parameter V_SYNC_BACK = 33;\n    parameter V_SYNC_ACT = 480;\n    parameter V_SYNC_FRONT = 10;\n    parameter V_SYNC_TOTAL = 525;\n\n    `else\n    parameter H_SYNC_CYC = 128;\n    parameter H_SYNC_BACK = 88;\n    parameter H_SYNC_ACT = 800;\n    parameter H_SYNC_FRONT = 40;\n    parameter H_SYNC_TOTAL = 1056;\n    parameter V_SYNC_CYC = 4;\n    parameter V_SYNC_BACK = 23;\n    parameter V_SYNC_ACT = 600;\n    parameter V_SYNC_FRONT = 1;\n    parameter V_SYNC_TOTAL = 628;\n\n    `endif\n    parameter X_START = H_SYNC_CYC + H_SYNC_BACK;\n    parameter Y_START = V_SYNC_CYC + V_SYNC_BACK;\n    wire [9:0] mVGA_R;\n    wire [9:0] mVGA_G;\n    wire [9:0] mVGA_B;\n    reg mVGA_H_SYNC;\n    reg mVGA_V_SYNC;\n    wire mVGA_SYNC;\n    wire mVGA_BLANK;\n    input [12:0] H_Cont;\n    input [12:0] V_Cont;\n    wire [12:0] v_mask;\n\n    assign v_mask = 13'd0;\n\n    assign mVGA_BLANK = mVGA_H_SYNC & mVGA_V_SYNC;\n    assign mVGA_SYNC = 1'b0;\n    assign mVGA_R = (H_Cont >= X_START && H_Cont < X_START + H_SYNC_ACT && V_Cont >= Y_START + v_mask && V_Cont < Y_START + V_SYNC_ACT) ? iRed : 0;\n    assign mVGA_G = (H_Cont >= X_START && H_Cont < X_START + H_SYNC_ACT && V_Cont >= Y_START + v_mask && V_Cont < Y_START + V_SYNC_ACT) ? iGreen : 0;\n    assign mVGA_B = (H_Cont >= X_START && H_Cont < X_START + H_SYNC_ACT && V_Cont >= Y_START + v_mask && V_Cont < Y_START + V_SYNC_ACT) ? iBlue : 0;\n\n    always @(posedge iCLK or negedge iRST_N) begin\n        if (!iRST_N) begin\n            oVGA_R <= 0;\n            oVGA_G <= 0;\n            oVGA_B <= 0;\n            oVGA_BLANK <= 0;\n            oVGA_SYNC <= 0;\n            oVGA_H_SYNC <= 0;\n            oVGA_V_SYNC <= 0;\n        end else begin\n            oVGA_R <= mVGA_R;\n            oVGA_G <= mVGA_G;\n            oVGA_B <= mVGA_B;\n            oVGA_BLANK <= mVGA_BLANK;\n            oVGA_SYNC <= mVGA_SYNC;\n            oVGA_H_SYNC <= mVGA_H_SYNC;\n            oVGA_V_SYNC <= mVGA_V_SYNC;\n        end\n    end\n\n    always @(posedge iCLK or negedge iRST_N) begin\n        if (!iRST_N) oRequest <= 0;\n        else begin\n            if (H_Cont >= X_START - 2 && H_Cont < X_START + H_SYNC_ACT - 2 && V_Cont >= Y_START && V_Cont < Y_START + V_SYNC_ACT)\n                oRequest <= 1;\n            else\n                oRequest <= 0;\n        end\n    end\n\n    always @(posedge iCLK or negedge iRST_N) begin\n        if (!iRST_N) begin\n            H_Cont <= 0;\n            mVGA_H_SYNC <= 0;\n        end else begin\n            if (H_Cont < H_SYNC_TOTAL) H_Cont <= H_Cont + 1;\n            else H_Cont <= 0;\n            if (H_Cont < H_SYNC_CYC) mVGA_H_SYNC <= 0;\n            else mVGA_H_SYNC <= 1;\n        end\n    end\n\n    always @(posedge iCLK or negedge iRST_N) begin\n        if (!iRST_N) begin\n            V_Cont <= 0;\n            mVGA_V_SYNC <= 0;\n        end else begin\n            if (H_Cont == 0) begin\n                if (V_Cont < V_SYNC_TOTAL) V_Cont <= V_Cont + 1;\n                else V_Cont <= 0;\n                if (V_Cont < V_SYNC_CYC) mVGA_V_SYNC <= 0;\n                else mVGA_V_SYNC <= 1;\n            end\n        end\n    end\n\nendmodule"}
{"task_id": 1944, "completion": "reg [DATA-1:0] mem [(2**ADDR)-1:0];\n \nalways @(posedge a_clk) begin\n   if(a_wr) begin\n      a_dout <= a_din;\n      mem[a_addr] <= a_din;\n   end else\n      a_dout <= mem[a_addr];\nend\n \nalways @(posedge b_clk) begin\n   if(b_wr) begin\n      b_dout <= b_din;\n      mem[b_addr] <= b_din;\n   end else\n      b_dout <= mem[b_addr];\nend\n\nendmodule"}
{"task_id": 1910, "completion": "wire [7:0] sd_datain;\n    wire [7:0] sd_dataout;\n    wire       sd_start;\n\n    assign zx_sd_dataout  = sd_dataout;\n    assign avr_sd_dataout = sd_dataout;\n\n    spi2 spi2(\n        .clock(fclk),\n        .sck(sdclk),\n        .sdo(sddo ),\n        .sdi(sddi ),\n        .start(sd_start  ),\n        .din  (sd_datain ),\n        .dout (sd_dataout),\n        .speed(2'b00)\n    );\n\n    always @(posedge fclk, negedge rst_n)\n    if( !rst_n )\n        avr_lock_out <= 1'b0;\n    else\n    begin\n        if( sdcs_n )\n            avr_lock_out <= avr_lock_in;\n    end\n\n    always @(posedge fclk, negedge rst_n)\n    if( !rst_n )\n        sdcs_n <= 1'b1;\n    else\n    begin\n        if( avr_lock_out )\n            sdcs_n <= avr_sdcs_n;\n        else\n            if( zx_sdcs_n_stb )\n                sdcs_n <= zx_sdcs_n_val;\n    end\n\n    assign sd_start = avr_lock_out ? avr_sd_start : zx_sd_start;\n    assign sd_datain = avr_lock_out ? avr_sd_datain : zx_sd_datain;\nendmodule"}
{"task_id": 1923, "completion": "module autoinst_ams_vorwerk;\n   latch latch (/*AUTOINST*/\n                // Outputs\n                .q                      (q),\n                // Inputs\n                .en                     (en),\n                .d                      (d));\nendmodule"}
{"task_id": 1822, "completion": "fifo_generator_v13_1_3 #(\n    .C_COMMON_CLOCK(1),\n    .C_SELECT_XPM(0),\n    .C_COUNT_TYPE(0),\n    .C_DATA_COUNT_WIDTH(11),\n    .C_DEFAULT_VALUE(\"BlankString\"),\n    .C_DIN_WIDTH(8),\n    .C_DOUT_RST_VAL(\"0\"),\n    .C_DOUT_WIDTH(8),\n    .C_ENABLE_RLOCS(0),\n    .C_FAMILY(\"zynq\"),\n    .C_FULL_FLAGS_RST_VAL(0),\n    .C_HAS_ALMOST_EMPTY(0),\n    .C_HAS_ALMOST_FULL(0),\n    .C_HAS_BACKUP(0),\n    .C_HAS_DATA_COUNT(0),\n    .C_HAS_INT_CLK(0),\n    .C_HAS_MEMINIT_FILE(0),\n    .C_HAS_OVERFLOW(0),\n    .C_HAS_RD_DATA_COUNT(0),\n    .C_HAS_RD_RST(0),\n    .C_HAS_RST(0),\n    .C_HAS_SRST(1),\n    .C_HAS_UNDERFLOW(0),\n    .C_HAS_VALID(0),\n    .C_HAS_WR_ACK(1),\n    .C_HAS_WR_DATA_COUNT(0),\n    .C_HAS_WR_RST(0),\n    .C_IMPLEMENTATION_TYPE(0),\n    .C_INIT_WR_PNTR_VAL(0),\n    .C_MEMORY_TYPE(1),\n    .C_MIF_FILE_NAME(\"BlankString\"),\n    .C_OPTIMIZATION_MODE(0),\n    .C_OVERFLOW_LOW(0),\n    .C_PRELOAD_LATENCY(0),\n    .C_PRELOAD_REGS(1),\n    .C_PRIM_FIFO_TYPE(\"1kx18\"),\n    .C_PROG_EMPTY_THRESH_ASSERT_VAL(4),\n    .C_PROG_EMPTY_THRESH_NEGATE_VAL(5),\n    .C_PROG_EMPTY_TYPE(0),\n    .C_PROG_FULL_THRESH_ASSERT_VAL(1023),\n    .C_PROG_FULL_THRESH_NEGATE_VAL(1022),\n    .C_PROG_FULL_TYPE(0),\n    .C_RD_DATA_COUNT_WIDTH(11),\n    .C_RD_DEPTH(1024),\n    .C_RD_FREQ(1),\n    .C_RD_PNTR_WIDTH(10),\n    .C_UNDERFLOW_LOW(0),\n    .C_USE_DOUT_RST(1),\n    .C_USE_ECC(0),\n    .C_USE_EMBEDDED_REG(0),\n    .C_USE_PIPELINE_REG(0),\n    .C_POWER_SAVING_MODE(0),\n    .C_USE_FIFO16_FLAGS(0),\n    .C_USE_FWFT_DATA_COUNT(1),\n    .C_VALID_LOW(0),\n    .C_WR_ACK_LOW(0),\n    .C_WR_DATA_COUNT_WIDTH(11),\n    .C_WR_DEPTH(1024),\n    .C_WR_FREQ(1),\n    .C_WR_PNTR_WIDTH(10),\n    .C_WR_RESPONSE_LATENCY(1),\n    .C_MSGON_VAL(1),\n    .C_ENABLE_RST_SYNC(1),\n    .C_EN_SAFETY_CKT(0),\n    .C_ERROR_INJECTION_TYPE(0),\n    .C_SYNCHRONIZER_STAGE(2),\n    .C_INTERFACE_TYPE(0),\n    .C_AXI_TYPE(1),\n    .C_HAS_AXI_WR_CHANNEL(1),\n    .C_HAS_AXI_RD_CHANNEL(1),\n    .C_HAS_SLAVE_CE(0),\n    .C_HAS_MASTER_CE(0),\n    .C_ADD_NGC_CONSTRAINT(0),\n    .C_USE_COMMON_OVERFLOW(0),\n    .C_USE_COMMON_UNDERFLOW(0),\n    .C_USE_DEFAULT_SETTINGS(0),\n    .C_AXI_ID_WIDTH(1),\n    .C_AXI_ADDR_WIDTH(32),\n    .C_AXI_DATA_WIDTH(64),\n    .C_AXI_LEN_WIDTH(8),\n    .C_AXI_LOCK_WIDTH(1),\n    .C_HAS_AXI_ID(0),\n    .C_HAS_AXI_AWUSER(0),\n    .C_HAS_AXI_WUSER(0),\n    .C_HAS_AXI_BUSER(0),\n    .C_HAS_AXI_ARUSER(0),\n    .C_HAS_AXI_RUSER(0),\n    .C_AXI_ARUSER_WIDTH(1),\n    .C_AXI_AWUSER_WIDTH(1),\n    .C_AXI_WUSER_WIDTH(1),\n    .C_AXI_BUSER_WIDTH(1),\n    .C_AXI_RUSER_WIDTH(1),\n    .C_HAS_AXIS_TDATA(1),\n    .C_HAS_AXIS_TID(0),\n    .C_HAS_AXIS_TDEST(0),\n    .C_HAS_AXIS_TUSER(1),\n    .C_HAS_AXIS_TREADY(1),\n    .C_HAS_AXIS_TLAST(0),\n    .C_HAS_AXIS_TSTRB(0),\n    .C_HAS_AXIS_TKEEP(0),\n    .C_AXIS_TDATA_WIDTH(8),\n    .C_AXIS_TID_WIDTH(1),\n    .C_AXIS_TDEST_WIDTH(1),\n    .C_AXIS_TUSER_WIDTH(4),\n    .C_AXIS_TSTRB_WIDTH(1),\n    .C_AXIS_TKEEP_WIDTH(1),\n    .C_WACH_TYPE(0),\n    .C_WDCH_TYPE(0),\n    .C_WRCH_TYPE(0),\n    .C_RACH_TYPE(0),\n    .C_RDCH_TYPE(0),\n    .C_AXIS_TYPE(0),\n    .C_IMPLEMENTATION_TYPE_WACH(1),\n    .C_IMPLEMENTATION_TYPE_WDCH(1),\n    .C_IMPLEMENTATION_TYPE_WRCH(1),\n    .C_IMPLEMENTATION_TYPE_RACH(1),\n    .C_IMPLEMENTATION_TYPE_RDCH(1),\n    .C_IMPLEMENTATION_TYPE_AXIS(1),\n    .C_APPLICATION_TYPE_WACH(0),\n    .C_APPLICATION_TYPE_WDCH(0),\n    .C_APPLICATION_TYPE_WRCH(0),\n    .C_APPLICATION_TYPE_RACH(0),\n    .C_APPLICATION_TYPE_RDCH(0),\n    .C_PRIM_FIFO_TYPE_WACH(\"512x36\"),\n    .C_PRIM_FIFO_TYPE_WDCH(\"1kx36\"),\n    .C_PRIM_FIFO_TYPE_WRCH(\"512x36\"),\n    .C_PRIM_FIFO_TYPE_RACH(\"512x36\"),\n    .C_PRIM_FIFO_TYPE_RDCH(\"1kx36\"),\n    .C_PRIM_FIFO_TYPE_AXIS(\"1kx18\"),\n    .C_USE_ECC_WACH(0),\n    .C_USE_ECC_WDCH(0),\n    .C_USE_ECC_WRCH(0),\n    .C_USE_ECC_RACH(0),\n    .C_USE_ECC_RDCH(0),\n    .C_USE_ECC_AXIS(0),\n    .C_ERROR_INJECTION_TYPE_WACH(0),\n    .C_ERROR_INJECTION_TYPE_WDCH(0),\n    .C_ERROR_INJECTION_TYPE_WRCH(0),\n    .C_ERROR_INJECTION_TYPE_RACH(0),\n    .C_ERROR_INJECTION_TYPE_RDCH(0),\n    .C_ERROR_INJECTION_TYPE_AXIS(0),\n    .C_DIN_WIDTH_WACH(1),\n    .C_DIN_WIDTH_WDCH(64),\n    .C_DIN_WIDTH_WRCH(2),\n    .C_DIN_WIDTH_RACH(32),\n    .C_DIN_WIDTH_RDCH(64),\n    .C_DIN_WIDTH_AXIS(1),\n    .C_WR_DEPTH_WACH(16),\n    .C_WR_DEPTH_WDCH(1024),\n    .C_WR_DEPTH_WRCH(16),\n    .C_WR_DEPTH_RACH(16),\n    .C_WR_DEPTH_RDCH(1024),\n    .C_WR_DEPTH_AXIS(1024),\n    .C_WR_PNTR_WIDTH_WACH(4),\n    .C_WR_PNTR_WIDTH_WDCH(10),\n    .C_WR_PNTR_WIDTH_WRCH(4),\n    .C_WR_PNTR_WIDTH_RACH(4),\n    .C_WR_PNTR_WIDTH_RDCH(10),\n    .C_WR_PNTR_WIDTH_AXIS(10),\n    .C_HAS_DATA_COUNTS_WACH(0),\n    .C_HAS_DATA_COUNTS_WDCH(0),\n    .C_HAS_DATA_COUNTS_WRCH(0),\n    .C_HAS_DATA_COUNTS_RACH(0),\n    .C_HAS_DATA_COUNTS_RDCH(0),\n    .C_HAS_PROG_FLAGS_WACH(0),\n    .C_HAS_PROG_FLAGS_WDCH(0),\n    .C_HAS_PROG_FLAGS_WRCH(0),\n    .C_HAS_PROG_FLAGS_RACH(0),\n    .C_HAS_PROG_FLAGS_RDCH(0),\n    .C_HAS_PROG_FLAGS_AXIS(0),\n    .C_PROG_FULL_TYPE_WACH(0),\n    .C_PROG_FULL_TYPE_WDCH(0),\n    .C_PROG_FULL_TYPE_WRCH(0),\n    .C_PROG_FULL_TYPE_RACH(0),\n    .C_PROG_FULL_TYPE_RDCH(0),\n    .C_PROG_FULL_TYPE_AXIS(0),\n    .C_PROG_FULL_THRESH_ASSERT_VAL_WACH(1023),\n    .C_PROG_FULL_THRESH_ASSERT_VAL_WDCH(1023),\n    .C_PROG_FULL_THRESH_ASSERT_VAL_WRCH(1023),\n    .C_PROG_FULL_THRESH_ASSERT_VAL_RACH(1023),\n    .C_PROG_FULL_THRESH_ASSERT_VAL_RDCH(1023),\n    .C_PROG_FULL_THRESH_ASSERT_VAL_AXIS(1023),\n    .C_PROG_EMPTY_TYPE_WACH(0),\n    .C_PROG_EMPTY_TYPE_WDCH(0),\n    .C_PROG_EMPTY_TYPE_WRCH(0),\n    .C_PROG_EMPTY_TYPE_RACH(0),\n    .C_PROG_EMPTY_TYPE_RDCH(0),\n    .C_PROG_EMPTY_TYPE_AXIS(0),\n    .C_PROG_EMPTY_THRESH_ASSERT_VAL_WACH(1022),\n    .C_PROG_EMPTY_THRESH_ASSERT_VAL_WDCH(1022),\n    .C_PROG_EMPTY_THRESH_ASSERT_VAL_WRCH(1022),\n    .C_PROG_EMPTY_THRESH_ASSERT_VAL_RACH(1022),\n    .C_PROG_EMPTY_THRESH_ASSERT_VAL_RDCH(1022),\n    .C_PROG_EMPTY_THRESH_ASSERT_VAL_AXIS(1022),\n    .C_REG_SLICE_MODE_WACH(0),\n    .C_REG_SLICE_MODE_WDCH(0),\n    .C_REG_SLICE_MODE_WRCH(0),\n    .C_REG_SLICE_MODE_RACH(0),\n    .C_REG_SLICE_MODE_RDCH(0),\n    .C_REG_SLICE_MODE_AXIS(0)\n  ) inst (\n    .backup(1'D0),\n    .backup_marker(1'D0),\n    .clk(clk),\n    .rst(1'D0),\n    .srst(srst),\n    .wr_clk(1'D0),\n    .wr_rst(1'D0),\n    .rd_clk(1'D0),\n    .rd_rst(1'D0),\n    .din(din),\n    .wr_en(wr_en),\n    .rd_en(rd_en),\n    .prog_empty_thresh(10'B0),\n    .prog_empty_thresh_assert(10'B0),\n    .prog_empty_thresh_negate(10'B0),\n    .prog_full_thresh(10'B0),\n    .prog_full_thresh_assert(10'B0),\n    .prog_full_thresh_negate(10'B0),\n    .int_clk(1'D0),\n    .injectdbiterr(1'D0),\n    .injectsbiterr(1'D0),\n    .sleep(1'D0),\n    .dout(dout),\n    .full(full),\n    .almost_full(),\n    .wr_ack(wr_ack),\n    .overflow(),\n    .empty(empty),\n    .almost_empty(),\n    .valid(),\n    .underflow(),\n    .data_count(),\n    .rd_data_count(),\n    .wr_data_count(),\n    .prog_full(),\n    .prog_empty(),\n    .sbiterr(),\n    .dbiterr(),\n    .wr_rst_busy(),\n    .rd_rst_busy(),\n    .m_aclk(1'D0),\n    .s_aclk(1'D0),\n    .s_aresetn(1'D0),\n    .m_aclk_en(1'D0),\n    .s_aclk_en(1'D0),\n    .s_axi_awid(1'B0),\n    .s_axi_awaddr(32'B0),\n    .s_axi_awlen(8'B0),\n    .s_axi_awsize(3'B0),\n    .s_axi_awburst(2'B0),\n    .s_axi_awlock(1'B0),\n    .s_axi_awcache(4'B0),\n    .s_axi_awprot(3'B0),\n    .s_axi_awqos(4'B0),\n    .s_axi_awregion(4'B0),\n    .s_axi_awuser(1'B0),\n    .s_axi_awvalid(1'D0),\n    .s_axi_awready(),\n    .s_axi_wid(1'B0),\n    .s_axi_wdata(64'B0),\n    .s_axi_wstrb(8'B0),\n    .s_axi_wlast(1'D0),\n    .s_axi_wuser(1'B0),\n    .s_axi_wvalid(1'D0),\n    .s_axi_wready(),\n    .s_axi_bid(),\n    .s_axi_bresp(),\n    .s_axi_buser(),\n    .s_axi_bvalid(),\n    .s_axi_bready(1'D0),\n    .m_axi_awid(),\n    .m_axi_awaddr(),\n    .m_axi_awlen(),\n    .m_axi_awsize(),\n    .m_axi_awburst(),\n    .m_axi_awlock(),\n    .m_axi_awcache(),\n    .m_axi_awprot(),\n    .m_axi_awqos(),\n    .m_axi_awregion(),\n    .m_axi_awuser(),\n    .m_axi_awvalid(),\n    .m_axi_awready(1'D0),\n    .m_axi_wid(),\n    .m_axi_wdata(),\n    .m_axi_wstrb(),\n    .m_axi_wlast(),\n    .m_axi_wuser(),\n    .m_axi_wvalid(),\n    .m_axi_wready(1'D0),\n    .m_axi_bid(1'B0),\n    .m_axi_bresp(2'B0),\n    .m_axi_buser(1'B0),\n    .m_axi_bvalid(1'D0),\n    .m_axi_bready(),\n    .s_axi_arid(1'B0),\n    .s_axi_araddr(32'B0),\n    .s_axi_arlen(8'B0),\n    .s_axi_arsize(3'B0),\n    .s_axi_arburst(2'B0),\n    .s_axi_arlock(1'B0),\n    .s_axi_arcache(4'B0),\n    .s_axi_arprot(3'B0),\n    .s_axi_arqos(4'B0),\n    .s_axi_arregion(4'B0),\n    .s_axi_aruser(1'B0),\n    .s_axi_arvalid(1'D0),\n    .s_axi_arready(),\n    .s_axi_rid(),\n    .s_axi_rdata(),\n    .s_axi_rresp(),\n    .s_axi_rlast(),\n    .s_axi_ruser(),\n    .s_axi_rvalid(),\n    .s_axi_rready(1'D0),\n    .m_axi_arid(),\n    .m_axi_araddr(),\n    .m_axi_arlen(),\n    .m_axi_arsize(),\n    .m_axi_arburst(),\n    .m_axi_arlock(),\n    .m_axi_arcache(),\n    .m_axi_arprot(),\n    .m_axi_arqos(),\n    .m_axi_arregion(),\n    .m_axi_aruser(),\n    .m_axi_arvalid(),\n    .m_axi_arready(1'D0),\n    .m_axi_rid(1'B0),\n    .m_axi_rdata(64'B0),\n    .m_axi_rresp(2'B0),\n    .m_axi_rlast(1'D0),\n    .m_axi_ruser(1'B0),\n    .m_axi_rvalid(1'D0),\n    .m_axi_rready(),\n    .s_axis_tvalid(1'D0),\n    .s_axis_tready(),\n    .s_axis_tdata(8'B0),\n    .s_axis_tstrb(1'B0),\n    .s_axis_tkeep(1'B0),\n    .s_axis_tlast(1'D0),\n    .s_axis_tid(1'B0),\n    .s_axis_tdest(1'B0),\n    .s_axis_tuser(4'B0),\n    .m_axis_tvalid(),\n    .m_axis_tready(1'D0),\n    .m_axis_tdata(),\n    .m_axis_tstrb(),\n    .m_axis_tkeep(),\n    .m_axis_tlast(),\n    .m_axis_tid(),\n    .m_axis_tdest(),\n    .m_axis_tuser(),\n    .axi_aw_injectsbiterr(1'D0),\n    .axi_aw_injectdbiterr(1'D0),\n    .axi_aw_prog_full_thresh(4'B0),\n    .axi_aw_prog_empty_thresh(4'B0),\n    .axi_aw_data_count(),\n    .axi_aw_wr_data_count(),\n    .axi_aw_rd_data_count(),\n    .axi_aw_sbiterr(),\n    .axi_aw_dbiterr(),\n    .axi_aw_overflow(),\n    .axi_aw_underflow(),\n    .axi_aw_prog_full(),\n    .axi_aw_prog_empty(),\n    .axi_w_injectsbiterr(1'D0),\n    .axi_w_injectdbiterr(1'D0),\n    .axi_w_prog_full_thresh(10'B0),\n    .axi_w_prog_empty_thresh(10'B0),\n    .axi_w_data_count(),\n    .axi_w_wr_data_count(),\n    .axi_w_rd_data_count(),\n    .axi_w_sbiterr(),\n    .axi_w_dbiterr(),\n    .axi_w_overflow(),\n    .axi_w_underflow(),\n    .axi_w_prog_full(),\n    .axi_w_prog_empty(),\n    .axi_b_injectsbiterr(1'D0),\n    .axi_b_injectdbiterr(1'D0),\n    .axi_b_prog_full_thresh(4'B0),\n    .axi_b_prog_empty_thresh(4'B0),\n    .axi_b_data_count(),\n    .axi_b_wr_data_count(),\n    .axi_b_rd_data_count(),\n    .axi_b_sbiterr(),\n    .axi_b_dbiterr(),\n    .axi_b_overflow(),\n    .axi_b_underflow(),\n    .axi_b_prog_full(),\n    .axi_b_prog_empty(),\n    .axi_ar_injectsbiterr(1'D0),\n    .axi_ar_injectdbiterr(1'D0),\n    .axi_ar_prog_full_thresh(4'B0),\n    .axi_ar_prog_empty_thresh(4'B0),\n    .axi_ar_data_count(),\n    .axi_ar_wr_data_count(),\n    .axi_ar_rd_data_count(),\n    .axi_ar_sbiterr(),\n    .axi_ar_dbiterr(),\n    .axi_ar_overflow(),\n    .axi_ar_underflow(),\n    .axi_ar_prog_full(),\n    .axi_ar_prog_empty(),\n    .axi_r_injectsbiterr(1'D0),\n    .axi_r_injectdbiterr(1'D0),\n    .axi_r_prog_full_thresh(10'B0),\n    .axi_r_prog_empty_thresh(10'B0),\n    .axi_r_data_count(),\n    .axi_r_wr_data_count(),\n    .axi_r_rd_data_count(),\n    .axi_r_sbiterr(),\n    .axi_r_dbiterr(),\n    .axi_r_overflow(),\n    .axi_r_underflow(),\n    .axi_r_prog_full(),\n    .axi_r_prog_empty(),\n    .axis_injectsbiterr(1'D0),\n    .axis_injectdbiterr(1'D0),\n    .axis_prog_full_thresh(10'B0),\n    .axis_prog_empty_thresh(10'B0),\n    .axis_data_count(),\n    .axis_wr_data_count(),\n    .axis_rd_data_count(),\n    .axis_sbiterr(),\n    .axis_dbiterr(),\n    .axis_overflow(),\n    .axis_underflow(),\n    .axis_prog_full(),\n    .axis_prog_empty()\n  );\nendmodule"}
{"task_id": 1915, "completion": "tri0\t areset;\n\n\twire [5:0] sub_wire0;\n\twire  sub_wire4;\n\twire [0:0] sub_wire7 = 1'h0;\n\twire [2:2] sub_wire3 = sub_wire0[2:2];\n\twire [1:1] sub_wire2 = sub_wire0[1:1];\n\twire [0:0] sub_wire1 = sub_wire0[0:0];\n\twire  c0 = sub_wire1;\n\twire  c1 = sub_wire2;\n\twire  c2 = sub_wire3;\n\twire  locked = sub_wire4;\n\twire  sub_wire5 = inclk0;\n\twire [1:0] sub_wire6 = {sub_wire7, sub_wire5};\n\n\taltpll\taltpll_component (\n\t\t\t.inclk (sub_wire6),\n\t\t\t.areset (areset),\n\t\t\t.clk (sub_wire0),\n\t\t\t.locked (sub_wire4),\n\t\t\t.activeclock (),\n\t\t\t.clkbad (),\n\t\t\t.clkena ({6{1'b1}}),\n\t\t\t.clkloss (),\n\t\t\t.clkswitch (1'b0),\n\t\t\t.configupdate (1'b0),\n\t\t\t.enable0 (),\n\t\t\t.enable1 (),\n\t\t\t.extclk (),\n\t\t\t.extclkena ({4{1'b1}}),\n\t\t\t.fbin (1'b1),\n\t\t\t.fbmimicbidir (),\n\t\t\t.fbout (),\n\t\t\t.pfdena (1'b1),\n\t\t\t.phasecounterselect ({4{1'b1}}),\n\t\t\t.phasedone (),\n\t\t\t.phasestep (1'b1),\n\t\t\t.phaseupdown (1'b1),\n\t\t\t.pllena (1'b1),\n\t\t\t.scanaclr (1'b0),\n\t\t\t.scanclk (1'b0),\n\t\t\t.scanclkena (1'b1),\n\t\t\t.scandata (1'b0),\n\t\t\t.scandataout (),\n\t\t\t.scandone (),\n\t\t\t.scanread (1'b0),\n\t\t\t.scanwrite (1'b0),\n\t\t\t.sclkout0 (),\n\t\t\t.sclkout1 (),\n\t\t\t.vcooverrange (),\n\t\t\t.vcounderrange ());\n\tdefparam\n\t\taltpll_component.bandwidth = 500000,\n\t\taltpll_component.bandwidth_type = \"CUSTOM\",\n\t\taltpll_component.clk0_divide_by = 1,\n\t\taltpll_component.clk0_duty_cycle = 50,\n\t\taltpll_component.clk0_multiply_by = 1,\n\t\taltpll_component.clk0_phase_shift = \"0\",\n\t\taltpll_component.clk1_divide_by = 4,\n\t\taltpll_component.clk1_duty_cycle = 50,\n\t\taltpll_component.clk1_multiply_by = 1,\n\t\taltpll_component.clk1_phase_shift = \"0\",\n\t\taltpll_component.clk2_divide_by = 2,\n\t\taltpll_component.clk2_duty_cycle = 50,\n\t\taltpll_component.clk2_multiply_by = 1,\n\t\taltpll_component.clk2_phase_shift = \"0\",\n\t\taltpll_component.compensate_clock = \"CLK0\",\n\t\taltpll_component.gate_lock_signal = \"NO\",\n\t\taltpll_component.inclk0_input_frequency = 8000,\n\t\taltpll_component.intended_device_family = \"Stratix II GX\",\n\t\taltpll_component.invalid_lock_multiplier = 5,\n\t\taltpll_component.lpm_type = \"altpll\",\n\t\taltpll_component.operation_mode = \"NORMAL\",\n\t\taltpll_component.pll_type = \"Fast\",\n\t\taltpll_component.port_activeclock = \"PORT_UNUSED\",\n\t\taltpll_component.port_areset = \"PORT_USED\",\n\t\taltpll_component.port_clkbad0 = \"PORT_UNUSED\",\n\t\taltpll_component.port_clkbad1 = \"PORT_UNUSED\",\n\t\taltpll_component.port_clkloss = \"PORT_UNUSED\",\n\t\taltpll_component.port_clkswitch = \"PORT_UNUSED\",\n\t\taltpll_component.port_configupdate = \"PORT_UNUSED\",\n\t\taltpll_component.port_fbin = \"PORT_UNUSED\",\n\t\taltpll_component.port_inclk0 = \"PORT_USED\",\n\t\taltpll_component.port_inclk1 = \"PORT_UNUSED\",\n\t\taltpll_component.port_locked = \"PORT_USED\",\n\t\taltpll_component.port_pfdena = \"PORT_UNUSED\",\n\t\taltpll_component.port_phasecounterselect = \"PORT_UNUSED\",\n\t\taltpll_component.port_phasedone = \"PORT_UNUSED\",\n\t\taltpll_component.port_phasestep = \"PORT_UNUSED\",\n\t\taltpll_component.port_phaseupdown = \"PORT_UNUSED\",\n\t\taltpll_component.port_pllena = \"PORT_UNUSED\",\n\t\taltpll_component.port_scanaclr = \"PORT_UNUSED\",\n\t\taltpll_component.port_scanclk = \"PORT_UNUSED\",\n\t\taltpll_component.port_scanclkena = \"PORT_UNUSED\",\n\t\taltpll_component.port_scandata = \"PORT_UNUSED\",\n\t\taltpll_component.port_scandataout = \"PORT_UNUSED\",\n\t\taltpll_component.port_scandone = \"PORT_UNUSED\",\n\t\taltpll_component.port_scanread = \"PORT_UNUSED\",\n\t\taltpll_component.port_scanwrite = \"PORT_UNUSED\",\n\t\taltpll_component.port_clk0 = \"PORT_USED\",\n\t\taltpll_component.port_clk1 = \"PORT_USED\",\n\t\taltpll_component.port_clk2 = \"PORT_USED\",\n\t\taltpll_component.port_clk3 = \"PORT_UNUSED\",\n\t\taltpll_component.port_clk4 = \"PORT_UNUSED\",\n\t\taltpll_component.port_clk5 = \"PORT_UNUSED\",\n\t\taltpll_component.port_clkena0 = \"PORT_UNUSED\",\n\t\taltpll_component.port_clkena1 = \"PORT_UNUSED\",\n\t\taltpll_component.port_clkena2 = \"PORT_UNUSED\",\n\t\taltpll_component.port_clkena3 = \"PORT_UNUSED\",\n\t\taltpll_component.port_clkena4 = \"PORT_UNUSED\",\n\t\taltpll_component.port_clkena5 = \"PORT_UNUSED\",\n\t\taltpll_component.port_enable0 = \"PORT_UNUSED\",\n\t\taltpll_component.port_enable1 = \"PORT_UNUSED\",\n\t\taltpll_component.port_extclk0 = \"PORT_UNUSED\",\n\t\taltpll_component.port_extclk1 = \"PORT_UNUSED\",\n\t\taltpll_component.port_extclk2 = \"PORT_UNUSED\",\n\t\taltpll_component.port_extclk3 = \"PORT_UNUSED\",\n\t\taltpll_component.port_sclkout0 = \"PORT_UNUSED\",\n\t\taltpll_component.port_sclkout1 = \"PORT_UNUSED\",\n\t\taltpll_component.valid_lock_multiplier = 1;\n\nendmodule"}
{"task_id": 1922, "completion": "reg [31:0] a;\nreg [15:0] b;\nreg [31:0] yout;\nreg done;\n\nalways @(posedge clk or negedge resetb) begin\n   if (~resetb) begin\n      a <= 0;\n      b <= 0;\n      yout <= 0;\n      done <= 1'b1;\n   end\n   else begin\n      if (start) begin\n         a <= ain;\n         b <= bin;\n         yout <= 0;\n         done <= 0;\n      end\n      else begin\n         if (~done) begin\n            if (b != 0) begin\n               if (b[0]) begin\n                  yout <= yout + a;\n               end\n               b <= b >> 1;\n               a <= a << 1;\n               $display (\"a = %h, b = %h, yout = %h\", a,b,yout);\n            end\n            else begin\n               done <= 1'b1;\n            end\n         end\n      end\n   end\nend\nendmodule"}
{"task_id": 1936, "completion": "wire [15:0] c;  wire [15:0] omemalu;  wire [ 3:0] addr_a;  wire [ 3:0] addr_c;  wire [ 3:0] addr_d;  wire [ 8:0] flags;  wire [15:0] a, b, s, alu_iflags, bus_b;  wire [31:0] aluout;  wire [3:0]  addr_b;  wire [2:0]  t, func;  wire [1:0]  addr_s;  wire        wrfl, high, memalu, r_byte, c_byte;  wire        wr, wr_reg;  wire        wr_cnd;  wire        jmp;  wire        b_imm;  wire  [8:0] iflags, oflags;  wire  [4:0] logic_flags;  wire        alu_word;  wire        a_byte;  wire        b_byte;  wire        wr_high;  wire        dive;  zet_alu alu( {c, a }, bus_b, aluout, t, func, alu_iflags, oflags, alu_word, s, off, clk, dive);  zet_regfile regfile (        a, b, c, cs, ip, {aluout[31:16], omemalu}, s, flags, wr_reg, wrfl,                wr_high, clk, rst, addr_a, addr_b, addr_c, addr_d, addr_s, iflags,                ~byteop, a_byte, b_byte, c_byte, cx_zero, wrip0);  zet_jmp_cond jmp_cond (logic_flags, addr_b, addr_c[0], c, jmp);  assign addr_s = ir[1:0];  assign addr_a = ir[5:2];  assign addr_b = ir[9:6];  assign addr_c = ir[13:10];  assign addr_d = ir[17:14];  assign wrfl   = ir[18];  assign we     = ir[19];  assign wr     = ir[20];  assign wr_cnd = ir[21];  assign high   = ir[22];  assign t      = ir[25:23];  assign func   = ir[28:26];  assign byteop = ir[29];  assign memalu = ir[30];  assign m_io   = ir[32];  assign b_imm  = ir[33];  assign r_byte = ir[34];  assign c_byte = ir[35];  assign omemalu = memalu ? aluout[15:0] : memout;  assign bus_b   = b_imm ? imm : b;  assign addr = aluout[19:0];  assign wr_data = c;  assign wr_reg  = (wr | (jmp & wr_cnd)) && !block && !div_exc;  assign wr_high = high && !block && !div_exc;  assign of  = flags[8];  assign ifl = flags[6];  assign tfl = flags[5];  assign zf  = flags[3];  assign iflags = oflags;  assign alu_iflags = { 4'b1111, flags[8:3], 1'b0, flags[2], 1'b0, flags[1],                        1'b1, flags[0] };  assign logic_flags = { flags[8], flags[4], flags[3], flags[1], flags[0] };  assign alu_word = (t==3'b011) ? ~r_byte : ~byteop;  assign a_byte = (t==3'b011 && func[1]) ? 1'b0 : r_byte;  assign b_byte = r_byte;  assign div_exc = dive && wr;  assign wr_ss = (addr_d == 4'b1010) && wr;  endmodule"}
{"task_id": 1620, "completion": "wire [20:0] wMcuRegWriteSelect;\nwire [31:0] wGpuRegWriteSelect;\nwire [15:0] wOp0, wOp1, wR0, wR1, wR3,wR4, wR5, wR6, wSpriteCoordX,wSpriteCoordY, wOp0_Pre_B, wOp0_Pre_A, wOp1_Pre_B, wOp1_Pre_A;\nwire [7:0] wR2;\nwire [15:0] wCurrentTile,wWinTile;\nwire [7:0] wBh, wBl, wState, wIp, wInitialPc, wSC_Tile_Row;\nwire [15:0] wBGTileOffset, wBGTileMapOffset, wBGRowOffset, wFrameBufferAddress, wCurrentTileRow,wOAMOffset;\nwire [15:0] wTile1_Bg_Offset, wTile0_Bg_Offset,wWinTileMapOffset;\nwire [15:0] wSC_Tile,wWinTileindex;\nwire [7:0] wRegSelect, wSh, wSl;\nwire [1:0] wPixel0,wPixel1,wPixel2,wPixel3,wPixel4,wPixel5,wPixel6,wPixel7;\nwire [1:0] wBgPixel0,wBgPixel1,wBgPixel2,wBgPixel3,wBgPixel4,wBgPixel5,wBgPixel6,wBgPixel7;\nwire [1:0] wSprtPixel0,wSprtPixel1,wSprtPixel2,wSprtPixel3,wSprtPixel4,wSprtPixel5,wSprtPixel6,wSprtPixel7;\nwire [`GPU_UOP_SZ-1:0] wUop;\nwire [5:0] wOp1Sel;\nwire wZ, wRegWe, wGpuActive, wIsSpriteInCurrentTile,wIsSpriteInCurrentRow,wIsWyOnScreen,wIsWxOnScreen,wWinEnabled, wIsWininBG;\nwire [15:0] wSpriteWidth, wSpriteHeight, wTileCoordX, wTileCoordY,wSprite_tile_offset,wSprite_info;\nreg [15:0] rResult;\nreg rRegWe, rBgBufferWe, rJump, rIncFBufferAddr;\nwire[15:0] wSpriteTopLeftX     ;\nwire[15:0] wSpriteTopLeftY     ;\nwire[15:0] wSpriteTopRightX    ;\nwire[15:0] wSpriteTopRightY    ;\nwire[15:0] wSpriteBottomLeftX  ;\nwire[15:0] wSpriteBottomLeftY  ;\nwire[15:0] wSpriteBottomRightX ;\nwire[15:0] wSpriteBottomRightY ;\nwire[15:0] wTileLeft   ;\nwire[15:0] wTileRight  ;\nwire[15:0] wTileTop    ;\nwire[15:0] wTileBottom ;\nassign oFramBufferData = {wPixel7,wPixel6,wPixel5,wPixel4,wPixel3,wPixel2,wPixel1,wPixel0};\nassign wPixel0 = ({wSh[0],wSl[0]} == `SPRITE_COLOR_TRANSPARENT)? wBgPixel0 : wSprtPixel0;\nassign wPixel1 = ({wSh[1],wSl[1]} == `SPRITE_COLOR_TRANSPARENT)? wBgPixel1 : wSprtPixel1;\nassign wPixel2 = ({wSh[2],wSl[2]} == `SPRITE_COLOR_TRANSPARENT)? wBgPixel2 : wSprtPixel2;\nassign wPixel3 = ({wSh[3],wSl[3]} == `SPRITE_COLOR_TRANSPARENT)? wBgPixel3 : wSprtPixel3;\nassign wPixel4 = ({wSh[4],wSl[4]} == `SPRITE_COLOR_TRANSPARENT)? wBgPixel4 : wSprtPixel4;\nassign wPixel5 = ({wSh[5],wSl[5]} == `SPRITE_COLOR_TRANSPARENT)? wBgPixel5 : wSprtPixel5;\nassign wPixel6 = ({wSh[6],wSl[6]} == `SPRITE_COLOR_TRANSPARENT)? wBgPixel6 : wSprtPixel6;\nassign wPixel7 = ({wSh[7],wSl[7]} == `SPRITE_COLOR_TRANSPARENT)? wBgPixel7 : wSprtPixel7;\nassign oFramBufferAddr = {2'b0,wFrameBufferAddress};\nassign oFramBufferWe   = rBgBufferWe;\nassign wSpriteWidth  = 16'h8;\nassign wSpriteHeight = ( oLCDC[2] == 1'b1) ? 16'd16 : 16'd8;\nassign wTileCoordX =  wCurrentTile[4:0] << 3;\nassign wTileCoordY = (wCurrentTile >>5) << 3;\nassign wSpriteTopLeftX     = wSpriteCoordX;\nassign wSpriteTopLeftY     = wSpriteCoordY;\nassign wSpriteTopRightX    = wSpriteCoordX + wSpriteWidth;\nassign wSpriteTopRightY    = wSpriteCoordY;\nassign wSpriteBottomLeftX  = wSpriteCoordX;\nassign wSpriteBottomLeftY  = wSpriteCoordY + wSpriteHeight;\nassign wSpriteBottomRightX = wSpriteTopRightX;\nassign wSpriteBottomRightY = wSpriteBottomLeftY;\nassign wTileLeft   = wTileCoordX;\nassign wTileRight  = wTileCoordX + 8'd8;\nassign wTileTop    = wTileCoordY;\nassign wTileBottom = wTileCoordY + 16'd8;\nassign wIsSpriteInCurrentTile = (((wSpriteTopLeftX >= wTileLeft && wSpriteTopLeftX < wTileRight ) && (wSpriteTopLeftY  >= wTileTop  && wSpriteTopLeftY < wTileBottom)) || ((wSpriteTopRightX >  wTileLeft && wSpriteTopRightX < wTileRight ) && (wSpriteTopRightY  >  wTileTop  && wSpriteTopRightY < wTileBottom)) || ((wSpriteBottomRightX > wTileLeft && wSpriteBottomRightX < wTileRight ) && (wSpriteBottomRightY  > wTileTop  && wSpriteBottomRightY < wTileBottom)) || ((wSpriteBottomLeftX > wTileLeft && wSpriteBottomLeftX < wTileRight ) && (wSpriteBottomLeftY  > wTileTop  && wSpriteBottomLeftY < wTileBottom))) ? 1'b1 : 1'b0;\nassign wIsSpriteInCurrentRow = (wCurrentTileRow + wTileCoordY >= wSpriteCoordY && wCurrentTileRow + wTileCoordY <= wSpriteCoordY + wSpriteHeight) ? 1'b1 : 1'b0;\nassign wIsWyOnScreen = (0 <= oWY <= 8'd143) ? 1'b1:1'b0;\nassign wIsWxOnScreen = (0 <= oWX <= 8'd166) ? 1'b1:1'b0;\nassign oSTAT = { 6'b0, wState };FFD_POSEDGE_SYNCRONOUS_RESET # ( 8 ) FF_LCDC( iClock, iReset, iMcuWe  & wMcuRegWriteSelect[0], iMcuWriteData, oLCDC );FFD_POSEDGE_SYNCRONOUS_RESET # ( 8 ) FFX_STAT(   iClock, iReset, wRegWe  & wGpuRegWriteSelect[1], rResult[7:0], wState );FFD_POSEDGE_SYNCRONOUS_RESET # ( 8 ) FF_SCY(  iClock, iReset, iMcuWe  & wMcuRegWriteSelect[2], iMcuWriteData, oSCY );FFD_POSEDGE_SYNCRONOUS_RESET # ( 8 ) FF_SCX(  iClock, iReset, iMcuWe  & wMcuRegWriteSelect[3], iMcuWriteData, oSCX );FFD_POSEDGE_SYNCRONOUS_RESET # ( 8 ) FF_LY(   iClock, iReset, wRegWe  & wGpuRegWriteSelect[4], rResult[7:0], oLY );FFD_POSEDGE_SYNCRONOUS_RESET # ( 8 ) FF_LYC(  iClock, iReset, iMcuWe  & wMcuRegWriteSelect[5], iMcuWriteData, oLYC );FFD_POSEDGE_SYNCRONOUS_RESET # ( 8 ) FF_DMA(  iClock, iReset, iMcuWe  & wMcuRegWriteSelect[6], iMcuWriteData, oDMA );FFD_POSEDGE_SYNCRONOUS_RESET # ( 8 )FFS_BGP(  iClock, iReset, iMcuWe  & wMcuRegWriteSelect[7], iMcuWriteData, oBGP );FFD_POSEDGE_SYNCRONOUS_RESET # ( 8 )FFS_OBP0( iClock, iReset, iMcuWe  & wMcuRegWriteSelect[8], iMcuWriteData, oOBP0 );FFD_POSEDGE_SYNCRONOUS_RESET # ( 8 )FFS_OBP1( iClock, iReset, iMcuWe  & wMcuRegWriteSelect[9], iMcuWriteData, oOBP1 );FFD_POSEDGE_SYNCRONOUS_RESET # ( 8 )FFS_WY(   iClock, iReset, iMcuWe  & wMcuRegWriteSelect[10],iMcuWriteData, oWY );FFD_POSEDGE_SYNCRONOUS_RESET # ( 8 )FFX_WX(   iClock, iReset, iMcuWe  & wMcuRegWriteSelect[11],iMcuWriteData, oWX );FFD_POSEDGE_SYNCRONOUS_RESET # ( 16 )FFX_12(   iClock, iReset, wRegWe  & wGpuRegWriteSelect[12], rResult,      oMcuAddr );FFD_POSEDGE_SYNCRONOUS_RESET # ( 8 )FFX_13(    iClock, iReset, wRegWe  & wGpuRegWriteSelect[13], rResult[7:0], wBh );FFD_POSEDGE_SYNCRONOUS_RESET # ( 8 )FFX_14(    iClock, iReset, wRegWe  & wGpuRegWriteSelect[14], rResult[7:0], wBl );UPCOUNTER_POSEDGE            # ( 16 )UP_15(    iClock, iReset,  13'b0, wGpuActive  & rIncFBufferAddr,          wFrameBufferAddress );FFD_POSEDGE_SYNCRONOUS_RESET # ( 16 )FFX_16(   iClock, iReset, wRegWe  & wGpuRegWriteSelect[16], rResult,      wCurrentTile );FFD_POSEDGE_SYNCRONOUS_RESET # ( 16 )FFX_17(   iClock, iReset, wRegWe  & wGpuRegWriteSelect[17], rResult,      wSprite_tile_offset );FFD_POSEDGE_SYNCRONOUS_RESET # ( 16 )FFX_18(   iClock, iReset, wRegWe  & wGpuRegWriteSelect[18], rResult,      wSpriteCoordX );FFD_POSEDGE_SYNCRONOUS_RESET # ( 16 )FFX_19(   iClock, iReset, wRegWe  & wGpuRegWriteSelect[19], rResult,      wSpriteCoordY );FFD_POSEDGE_SYNCRONOUS_RESET # ( 16 )FFX_20(   iClock, iReset, wRegWe  & wGpuRegWriteSelect[20], rResult,      wCurrentTileRow );FFD_POSEDGE_SYNCRONOUS_RESET # ( 8 )FFX_21(   iClock, iReset, wRegWe  & wGpuRegWriteSelect[21], rResult[7:0],  wSh );FFD_POSEDGE_SYNCRONOUS_RESET # ( 8 )FFX_22(   iClock, iReset, wRegWe  & wGpuRegWriteSelect[22], rResult[7:0],  wSl );FFD_POSEDGE_SYNCRONOUS_RESET # ( 16 )FFX_23(   iClock, iReset, wRegWe  & wGpuRegWriteSelect[23], rResult,      wR0 );FFD_POSEDGE_SYNCRONOUS_RESET # ( 16 )FFX_24(   iClock, iReset, wRegWe  & wGpuRegWriteSelect[24], rResult,      wR1 );FFD_POSEDGE_SYNCRONOUS_RESET # ( 8 )FFX_25(   iClock, iReset,  wRegWe  & wGpuRegWriteSelect[25], rResult[7:0], wR2 );FFD_POSEDGE_SYNCRONOUS_RESET # ( 16 )FFX_26(   iClock, iReset, wRegWe  & wGpuRegWriteSelect[26], rResult,      wR3 );FFD_POSEDGE_SYNCRONOUS_RESET # ( 16 )FFX_27(   iClock, iReset, wRegWe  & wGpuRegWriteSelect[27], rResult,      wR4 );FFD_POSEDGE_SYNCRONOUS_RESET # ( 16 )FFX_28(   iClock, iReset, wRegWe  & wGpuRegWriteSelect[28], rResult,      wR5 );FFD_POSEDGE_SYNCRONOUS_RESET # ( 16 )FFX_29(   iClock, iReset, wRegWe  & wGpuRegWriteSelect[29], rResult,      wR6 );FFD_POSEDGE_SYNCRONOUS_RESET # ( 16 )FFX_30(   iClock, iReset, wRegWe  & wGpuRegWriteSelect[30], rResult,      wWinTile );FFD_POSEDGE_SYNCRONOUS_RESET # ( 16  )FFX_31(   iClock, iReset, wRegWe  & wGpuRegWriteSelect[31], rResult,      wSprite_info );FFD_POSEDGE_SYNCRONOUS_RESET # ( 1 )FFX_Z(   iClock, iReset, wRegWe, (rResult == 8'b0) ? 1'b1 : 1'b0, wZ );assign wInitialPc = ( rJump ) ? wUop[7:0]: 8'b0;UPCOUNTER_POSEDGE # (8) PC(.Clock(   iClock                ),.Reset(   iReset | rJump        ),.Initial( wInitialPc            ),.Enable(  ~iReset & wGpuActive  ),.Q(       wIp                   ));assign wGpuActive = (oLCDC[7]) ? 1'b1 : 1'b0;assign wRegSelect = ( wGpuActive ) ? wUop[14:10] : iMcuRegSelect ;assign wRegWe     = ( wGpuActive ) ? rRegWe : iMcuWe ;assign wTile1_Bg_Offset = (iMcuReadData[7] == 1'b1) ? 16'h8000 : 16'h8000;\nassign wTile0_Bg_Offset = (iMcuReadData[7] == 1'b1) ? 16'h8000 : 16'h9000;\nassign wBGTileOffset    = ( oLCDC[4] ) ? wTile1_Bg_Offset : wTile0_Bg_Offset;\nassign wBGTileMapOffset = ( oLCDC[3] ) ? 16'h9c00 : 16'h9800;\nassign wWinTileMapOffset = ( oLCDC[5] ) ? 16'h9c00 : 16'h9800;\nassign wBGRowOffset = wCurrentTileRow;\nassign wOAMOffset = 16'hFE00;\nassign wWinTileindex = ((oWY >> 3) << 5) + (oWX -3'd6) ;assign wWinEnabled = (oLCDC[0]  &  oLCDC[5]);\nassign wIsWininBG = ((wWinTile == wCurrentTile) && wWinEnabled == 1)? 1'b1: 1'b0;\n`ifdef LCD_SCXY_DISABLED\n  assign wSC_Tile = 16'b0;\n`else\n  assign wSC_Tile = ((oSCY >> 3) << 5) + oSCX;\n`endif\nassign wSC_Tile_Row = 8'b0;\nassign wMcuRegWriteSelect = (1 << iMcuRegSelect);\nassign wGpuRegWriteSelect = (1 << wUop[`GPU_DST_RNG]);\nassign wOp0 = (wUop[`GPU_S0_RNG_SEL_BIT] == 1'b1) ? wOp0_Pre_A : wOp0_Pre_B;\nMUXFULLPARALELL_4SEL_GENERIC # (16) MUX_REG0_A( .Sel( wUop[ `GPU_S0_RNG_L] ),.I0( wBGTileMapOffset          ),.I1( wBGTileOffset             ),.I2( {8'h0,iMcuReadData}       ),.I3( wBGRowOffset              ),.I4( {8'h0,6'h0,oLY[1:0]}      ),.I5( 16'd8191                  ),.I6( wOAMOffset                ),.I7( {4'b0,iMcuReadData,4'b0}  ),.I8( wSC_Tile                  ),.I9( {8'b0,wSC_Tile_Row}       ),.I10( {15'b0,wIsWininBG}       ),.I11( wWinTileindex            ),.I12(wWinTileMapOffset         ),.I13( 16'b0    ),.I14( 16'h0                    ),.I15( 16'h0                    ),.O( wOp0_Pre_A );MUXFULLPARALELL_5SEL_GENERIC # (16) MUX_REG0_B( .Sel( wUop[ `GPU_S0_RNG_H ] ),.I0( {8'h0,oLCDC} ),.I1( {8'h0,oSTAT} ),.I2( {8'h0,oSCY}  ),.I3( {8'h0,oSCX}  ),.I4( {8'h0,oLY}   ),.I5( {8'h0,oLYC}  ),.I6( {8'h0,oDMA}  ),.I7( {8'h0,oBGP}  ),.I8( {8'h0,oOBP0} ),.I9( {8'h0,oOBP1} ),.I10({8'h0,oWY}   ),.I11({8'h0,oWX}   ),.I12( oMcuAddr            ),.I13( {8'b0,wBh}          ),.I14( {8'b0,wBl}          ),.I15( wFrameBufferAddress ),.I16( wCurrentTile        ),.I17( wSprite_tile_offset ),.I18( wSpriteCoordX       ),.I19( wSpriteCoordY       ),.I20( wCurrentTileRow     ),.I21( {8'b0,wSh}          ),.I22( {8'b0,wSl}          ),.I23( wR0 ),.I24( wR1 ),.I25( {8'b0,wR2} ),.I26( wR3 ),.I27( wR4 ),.I28( wR5 ),.I29( wR6 ),.I30( wWinTile ),.I31( wSprite_info  ),.O( wOp0_Pre_B );assign wOp1 = (wOp1Sel[5] == 1'b1) ? wOp1_Pre_A : wOp1_Pre_B;\nassign wOp1Sel = (wUop[`GPU_OP_RNG] == `gaddl || wUop[`GPU_OP_RNG] == `gsubl ) ? wUop[`GPU_DST_RNG] : wUop[`GPU_S1_RNG];MUXFULLPARALELL_4SEL_GENERIC # (16) MUX_REG1_A( .Sel( wOp1Sel[3:0]     ),.I0( wBGTileMapOffset          ),.I1( wBGTileOffset             ),.I2( {8'h0,iMcuReadData}       ),.I3( wBGRowOffset              ),.I4( {8'h0,6'h0,oLY[1:0]}      ),.I5( 16'd8191                  ),.I6( wOAMOffset                ),.I7( {4'b0,iMcuReadData,4'b0}  ),.I8( wSC_Tile                  ),.I9( {8'b0,wSC_Tile_Row}       ),.I10( {14'b0,wIsWininBG}       ),.I11( wWinTileindex            ),.I12( wWinTileMapOffset        ),.I13( 16'b0      ),.I14( 16'h0                    ),.I15( 16'h0                    ),.O( wOp1_Pre_A );MUXFULLPARALELL_5SEL_GENERIC # (16) MUX_REG1_B( .Sel( wOp1Sel[4:0] ),.I0( {8'h0,oLCDC} ),.I1( {8'h0,oSTAT} ),.I2( {8'h0,oSCY}  ),.I3( {8'h0,oSCX}  ),.I4( {8'h0,oLY}   ),.I5( {8'h0,oLYC}  ),.I6( {8'h0,oDMA}  ),.I7( {8'h0,oBGP}  ),.I8( {8'h0,oOBP0} ),.I9( {8'h0,oOBP1} ),.I10({8'h0,oWY}   ),.I11({8'h0,oWX}   ),.I12( oMcuAddr            ),.I13( {8'b0,wBh}          ),.I14( {8'b0,wBl}          ),.I15( wFrameBufferAddress ),.I16( wCurrentTile        ),.I17( wSprite_tile_offset ),.I18( wSpriteCoordX       ),.I19( wSpriteCoordY       ),.I20( wCurrentTileRow     ),.I21( {8'b0,wSh}          ),.I22( {8'b0,wSl}          ),.I23( wR0 ),.I24( wR1 ),.I25( {8'b0,wR2} ),.I26( wR3 ),.I27( wR4 ),.I28( wR5 ),.I29( wR6 ),.I30( wWinTile ),.I31( wSprite_info  ),.O( wOp1_Pre_B );MUXFULLPARALELL_2SEL_GENERIC # (2) MUX_BGP0 (   .Sel( {wBh[0], wBl[0]} ),  .I0( oBGP[1:0]), .I1( oBGP[3:2]), .I2( oBGP[5:4]), .I3( oBGP[7:6]) , .O( wBgPixel0);MUXFULLPARALELL_2SEL_GENERIC # (2) MUX_BGP1 (   .Sel( {wBh[1], wBl[1]} ),  .I0( oBGP[1:0]), .I1( oBGP[3:2]), .I2( oBGP[5:4]), .I3( oBGP[7:6]) , .O( wBgPixel1);MUXFULLPARALELL_2SEL_GENERIC # (2) MUX_BGP2 (   .Sel( {wBh[2], wBl[2]} ),  .I0( oBGP[1:0]), .I1( oBGP[3:2]), .I2( oBGP[5:4]), .I3( oBGP[7:6]) , .O( wBgPixel2);MUXFULLPARALELL_2SEL_GENERIC # (2) MUX_BGP3 (   .Sel( {wBh[3], wBl[3]} ),  .I0( oBGP[1:0]), .I1( oBGP[3:2]), .I2( oBGP[5:4]), .I3( oBGP[7:6]) , .O( wBgPixel3);MUXFULLPARALELL_2SEL_GENERIC # (2) MUX_BGP4 (   .Sel( {wBh[4], wBl[4]} ),  .I0( oBGP[1:0]), .I1( oBGP[3:2]), .I2( oBGP[5:4]), .I3( oBGP[7:6]) , .O( wBgPixel4);MUXFULLPARALELL_2SEL_GENERIC # (2) MUX_BGP5 (   .Sel( {wBh[5], wBl[5]} ),  .I0( oBGP[1:0]), .I1( oBGP[3:2]), .I2( oBGP[5:4]), .I3( oBGP[7:6]) , .O( wBgPixel5);MUXFULLPARALELL_2SEL_GENERIC # (2) MUX_BGP6 (   .Sel( {wBh[6], wBl[6]} ),  .I0( oBGP[1:0]), .I1( oBGP[3:2]), .I2( oBGP[5:4]), .I3( oBGP[7:6]) , .O( wBgPixel6);MUXFULLPARALELL_2SEL_GENERIC # (2) MUX_BGP7 (   .Sel( {wBh[7], wBl[7]} ),  .I0( oBGP[1:0]), .I1( oBGP[3:2]), .I2( oBGP[5:4]), .I3( oBGP[7:6]) , .O( wBgPixel7);MUXFULLPARALELL_3SEL_GENERIC # (2) MUX_SprtP0 ( .Sel( {wSprite_info[4],wSh[0], wSl[0]} ),  .I3( oOBP0[1:0]), .I2( oOBP0[3:2]), .I1( oOBP0[5:4]), .I0( oOBP0[7:6]) ,  .I4( oOBP1[1:0]), .I5( oOBP1[3:2]), .I6( oOBP1[5:4]), .I7( oOBP1[7:6]),  .O( wSprtPixel0));MUXFULLPARALELL_3SEL_GENERIC # (2) MUX_SprtP1 (.Sel( {wSprite_info[4],wSh[1], wSl[1]} ),  .I3( oOBP0[1:0]), .I2( oOBP0[3:2]), .I1( oOBP0[5:4]), .I0( oOBP0[7:6]) ,  .I4( oOBP1[1:0]), .I5( oOBP1[3:2]), .I6( oOBP1[5:4]), .I7( oOBP1[7:6]),  .O( wSprtPixel1));MUXFULLPARALELL_3SEL_GENERIC # (2) MUX_SprtP2 (.Sel( {wSprite_info[4],wSh[2], wSl[2]} ),  .I3( oOBP0[1:0]), .I2( oOBP0[3:2]), .I1( oOBP0[5:4]), .I0( oOBP0[7:6]) ,  .I4( oOBP1[1:0]), .I5( oOBP1[3:2]), .I6( oOBP1[5:4]), .I7( oOBP1[7:6]),  .O( wSprtPixel2));MUXFULLPARALELL_3SEL_GENERIC # (2) MUX_SprtP3 (.Sel( {wSprite_info[4],wSh[3], wSl[3]} ),  .I3( oOBP0[1:0]), .I2( oOBP0[3:2]), .I1( oOBP0[5:4]),.I0( oOBP0[7:6]) ,  .I4( oOBP1[1:0]), .I5( oOBP1[3:2]), .I6( oOBP1[5:4]), .I7( oOBP1[7:6]),  .O( wSprtPixel3));MUXFULLPARALELL_3SEL_GENERIC # (2) MUX_SprtP4 ( .Sel( {wSprite_info[4],wSh[4], wSl[4]} ),  .I3( oOBP0[1:0]), .I2( oOBP0[3:2]), .I1( oOBP0[5:4]), .I0( oOBP0[7:6]) ,  .I4( oOBP1[1:0]), .I5( oOBP1[3:2]), .I6( oOBP1[5:4]), .I7( oOBP1[7:6]),  .O( wSprtPixel4));MUXFULLPARALELL_3SEL_GENERIC # (2) MUX_SprtP5 (.Sel( {wSprite_info[4],wSh[5], wSl[5]} ),  .I3( oOBP0[1:0]), .I2( oOBP0[3:2]), .I1( oOBP0[5:4]), .I0( oOBP0[7:6]) ,  .I4( oOBP1[1:0]), .I5( oOBP1[3:2]), .I6( oOBP1[5:4]), .I7( oOBP1[7:6]),  .O( wSprtPixel5));MUXFULLPARALELL_3SEL_GENERIC # (2) MUX_SprtP6 (.Sel( {wSprite_info[4],wSh[6], wSl[6]} ),  .I3( oOBP0[1:0]), .I2( oOBP0[3:2]), .I1( oOBP0[5:4]), .I0( oOBP0[7:6]) ,  .I4( oOBP1[1:0]), .I5( oOBP1[3:2]), .I6( oOBP1[5:4]), .I7( oOBP1[7:6]),  .O( wSprtPixel6));MUXFULLPARALELL_3SEL_GENERIC # (2) MUX_SprtP7 (.Sel( {wSprite_info[4],wSh[7], wSl[7]} ),  .I3( oOBP0[1:0]), .I2( oOBP0[3:2]), .I1( oOBP0[5:4]), .I0( oOBP0[7:6]) ,  .I4( oOBP1[1:0]), .I5( oOBP1[3:2]), .I6( oOBP1[5:4]), .I7( oOBP1[7:6]),  .O( wSprtPixel7));always @ ( * )begin  case (wUop[`GPU_OP_RNG])   `gnop:    begin      rResult     = wUop[7:0];      rRegWe      = 1'b0;      rBgBufferWe = 1'b0;      rJump       = 1'b0;      oMcuReadRequest = 1'b0;      rIncFBufferAddr = 1'b0;    end    `gwfbuffer:    begin      rResult     = wUop[7:0];      rRegWe      = 1'b0;      rBgBufferWe = 1'b1;      rJump       = 1'b0;      oMcuReadRequest = 1'b0;      rIncFBufferAddr = 1'b0;    end   `ginfbaddr:    begin      rResult     = wUop[7:0];      rRegWe      = 1'b0;      rBgBufferWe = 1'b0;      rJump       = 1'b0;      oMcuReadRequest = 1'b0;      rIncFBufferAddr = 1'b1;    end    `gwrr:    begin      rResult     = wOp1;      rRegWe      = 1'b1;      rBgBufferWe = 1'b0;      rJump       = 1'b0;      oMcuReadRequest = 1'b0;      rIncFBufferAddr = 1'b0;    end    `gwrl:    begin      rResult     = wUop[`GPU_LIT_RNG];      rRegWe      = 1'b1;      rBgBufferWe = 1'b0;      rJump       = 1'b0;      oMcuReadRequest = 1'b0;      rIncFBufferAddr = 1'b0;    end    `grvmem:    begin      rResult     = wUop[7:0];      rRegWe      = 1'b0;      rBgBufferWe = 1'b0;      rJump       = 1'b0;      oMcuReadRequest = 1'b1;      rIncFBufferAddr = 1'b0;    end    `gadd:    begin      rResult     = wOp1 + wOp0 ;      rRegWe      = 1'b1;      rBgBufferWe = 1'b0;      rJump       = 1'b0;      oMcuReadRequest = 1'b0;      rIncFBufferAddr = 1'b0;    end    `gshl:    begin      rResult     = wOp1 << wUop[5:0]  ;      rRegWe      = 1'b1;      rBgBufferWe = 1'b0;      rJump       = 1'b0;      oMcuReadRequest = 1'b0;      rIncFBufferAddr = 1'b0;    end    `gaddl:    begin      rResult     = wOp1 + {6'b0,wUop[`GPU_LIT_RNG]} ;      rRegWe      = 1'b1;      rBgBufferWe = 1'b0;      rJump       = 1'b0;      oMcuReadRequest = 1'b0;      rIncFBufferAddr = 1'b0;    end    `gsubl:    begin      rResult     = wOp1 - {6'b0,wUop[`GPU_LIT_RNG]} ;      rRegWe      = 1'b1;      rBgBufferWe = 1'b0;      rJump       = 1'b0;      oMcuReadRequest = 1'b0;      rIncFBufferAddr = 1'b0;    end    `gsub:    begin      rResult     = wOp1 - wOp0;      rRegWe      = 1'b1;      rBgBufferWe = 1'b0;      rJump       = 1'b0;      oMcuReadRequest = 1'b0;      rIncFBufferAddr = 1'b0;    end    `gjnz:    begin      rResult     = wOp1 ;      rRegWe      = 1'b0;      rBgBufferWe = 1'b0;      rJump       = ~wZ;      oMcuReadRequest = 1'b0;      rIncFBufferAddr = 1'b0;    end    `gjz:    begin      rResult     = wOp1 ;      rRegWe      = 1'b0;      rBgBufferWe = 1'b0;      rJump       = wZ;      oMcuReadRequest = 1'b0;      rIncFBufferAddr = 1'b0;    end    `ggoto:    begin      rResult     = wOp1 ;      rRegWe      = 1'b0;      rBgBufferWe = 1'b0;      rJump       = 1'b1;      oMcuReadRequest = 1'b0;      rIncFBufferAddr = 1'b0;    end    `gand:    begin      rResult     = wOp1 & wOp0 ;      rRegWe      = 1'b1;      rBgBufferWe = 1'b0;      rJump       = 1'b0;      oMcuReadRequest = 1'b0;      rIncFBufferAddr = 1'b0;    end    `gsprtt:    begin      rResult     = {15'b0,wIsSpriteInCurrentTile};      rRegWe      = 1'b1;      rBgBufferWe = 1'b0;      rJump       = 1'b0;      oMcuReadRequest = 1'b0;      rIncFBufferAddr = 1'b0;    end    `gwx:    begin      rResult     = {15'b0,wIsWyOnScreen};      rRegWe      = 1'b1;      rBgBufferWe = 1'b0;      rJump       = 1'b0;      oMcuReadRequest = 1'b0;      rIncFBufferAddr = 1'b0;    end    `gwy:    begin      rResult     = {15'b0,wIsWyOnScreen};      rRegWe      = 1'b1;      rBgBufferWe = 1'b0;      rJump       = 1'b0;      oMcuReadRequest = 1'b0;      rIncFBufferAddr = 1'b0;    end    default:    begin      rResult     = 16'hdead ;      rRegWe      = 1'b0;      rBgBufferWe = 1'b0;      rJump       = 1'b0;      oMcuReadRequest = 1'b0;      rIncFBufferAddr = 1'b0;    end  endcaseend\n\ngpu_ucode_rom UCODE_ROM( .iAddr( wIp ), .oUop(  wUop));endmodule"}
{"task_id": 1957, "completion": "reg [15:0] data, address;\n        reg rw;\n\n        always @(posedge clock) begin\n                rw <= 1'b1;\n        end\n\n        always @(negedge clock) begin\n                rw <= 1'b0;\n        end\n\nendmodule"}
{"task_id": 1881, "completion": "reg [15:0] error_reg;    reg [7:0] bmRequestType;    reg [15:0] count;    reg [15:0] wValue;    reg [15:0] wIndex;    reg [15:0] wLength;    reg [31:0] addresstemp1;    reg [31:0] addresstemp2;    reg [31:0] datotemp1;    reg [31:0] datotemp2;    reg singl_data;    reg [31:0] config_data;    reg [63:0] tempoadress;    reg [31:0] dato;    reg [4:0] state, next_state;    parameter [4:0] IDLE = 5'b00001, RECEIVE = 5'b00010, SET_CONFIG_DATA_SINGLE = 5'b00110, SET_ALT_STACK = 5'b00111, SET_OPERATING_MODE = 5'b01000, SET_TRACE = 5'b01001, SET_BUFFER = 5'b01010, SET_RESET = 5'b01011, GET_CONFIG_DATA = 5'b01100, GET_CONFIG_SINGLE = 5'b01101, GET_CONFIG_ADDRESS = 5'b01110, GET_ALT_STACK = 5'b01111, GET_OPERATION_MODE = 5'b10000, GET_TRACE = 5'b10001, GET_INFO = 5'b10010, SET_CONFIG_DATA = 5'b10011, SET_CONFIG_ADDRESS = 5'b10100, GET_ERROR = 5'b10101, GET_BUFFER =  5'b10110;    always @(posedge clk) begin        if (enable != 1) begin state = state; end        else begin            if (rst) begin state = IDLE; end            else begin state = next_state; end        end        if (busy == 1) begin            error_reg = 15'b1;        end else begin            error_reg = 0;        end    end    always @(posedge clk) begin        config_data = 31'b10000110011111;        case (state)            IDLE : begin                bmRequestType = data[63:56];                bRequest = data[56:47];                wValue = data[46:33];                wIndex = data[32:16];                wLength = data[15:0];                singl_data = 0;                busy = 0;                next_state = RECEIVE;                reset_endpoint = 0;            end            RECEIVE : begin                // \u5904\u7406\u4e0d\u540c\u7684\u8bf7\u6c42\uff0c\u6839\u636e bmRequestType \u548c bRequest \u66f4\u65b0\u72b6\u6001 next_state            end            // \u7ee7\u7eed\u5904\u7406\u5176\u4ed6\u72b6\u6001        endcase    endendmodule"}
{"task_id": 1955, "completion": "reg [3:0] s;\n    reg [16:0] data_in=0;\n    reg start=0;\n    wire [6:0] data_out;\n    wire done;\n\n    always @(*) begin\n        case (addr)\n            4'h0:begin s = (cs && wr) ? 4'b0001 : 4'b0000 ;end\n            4'h2:begin s = (cs && wr) ? 4'b0010 : 4'b0000 ;end\n            4'h4:begin s = (cs && rd) ? 4'b0100 : 4'b0000 ;end\n            4'h6:begin s = (cs && rd) ? 4'b1000 : 4'b0000 ;end\n            default:begin s = 4'b0000 ; end\n        endcase\n    end\n\n    always @(negedge clk) begin\n        data_in = (s[0]) ? d_in : data_in;\n        start = s[1];\n    end\n\n    always @(negedge clk) begin\n        case (s[3:2])\n            2'b01: d_out[0] = done ;\n            2'b10: d_out[6:0]  = data_out ;\n            default: d_out   = 0 ;\n        endcase\n    end\n\n    crc_7 c_7 ( .clk(clk), .rst(rst), .data_in(data_in), .start(start), .data_out(data_out), .done(done) );\nendmodule"}
{"task_id": 1830, "completion": "localparam Ks = {32'h428a2f98, 32'h71374491, 32'hb5c0fbcf, 32'he9b5dba5, 32'h3956c25b, 32'h59f111f1, 32'h923f82a4, 32'hab1c5ed5, 32'hd807aa98, 32'h12835b01, 32'h243185be, 32'h550c7dc3, 32'h72be5d74, 32'h80deb1fe, 32'h9bdc06a7, 32'hc19bf174, 32'he49b69c1, 32'hefbe4786, 32'h0fc19dc6, 32'h240ca1cc, 32'h2de92c6f, 32'h4a7484aa, 32'h5cb0a9dc, 32'h76f988da, 32'h983e5152, 32'ha831c66d, 32'hb00327c8, 32'hbf597fc7, 32'hc6e00bf3, 32'hd5a79147, 32'h06ca6351, 32'h14292967, 32'h27b70a85, 32'h2e1b2138, 32'h4d2c6dfc, 32'h53380d13, 32'h650a7354, 32'h766a0abb, 32'h81c2c92e, 32'h92722c85, 32'ha2bfe8a1, 32'ha81a664b, 32'hc24b8b70, 32'hc76c51a3, 32'hd192e819, 32'hd6990624, 32'hf40e3585, 32'h106aa070, 32'h19a4c116, 32'h1e376c08, 32'h2748774c, 32'h34b0bcb5, 32'h391c0cb3, 32'h4ed8aa4a, 32'h5b9cca4f, 32'h682e6ff3, 32'h748f82ee, 32'h78a5636f, 32'h84c87814, 32'h8cc70208, 32'h90befffa, 32'ha4506ceb, 32'hbef9a3f7, 32'hc67178f2};\n\n\tgenvar i, j;\n\n\treg [31:0] round0_t1_partial = 32'd0;\n\treg [511:0] delay_input = {384'h000002800000000000000000000000000000000000000000000000000000000000000000000000000000000080000000, 128'h0};\n\n\tgenerate\n\n\t\tfor (i = 0; i < NUM_ROUNDS; i = i + 1) begin : HASHERS\n\t\t\twire [31:0] new_w15;\n\t\t\twire [255:0] state;\n\t\t\twire [31:0] K_next;\n\t\t\twire [31:0] t1_part_next;\n\n\t\t\tlocalparam k_next_idx = (i + 1) & 63;\n\t\t\tassign K_next = Ks[32*(63-k_next_idx) +: 32];\n\n\t\t\twire [31:0] cur_w0, cur_w1, cur_w9, cur_w14;\n\n\t\t\tif(i == 0)\n\t\t\tbegin\n\t\t\t\tassign cur_w0 = delay_input[31:0];\n\t\t\tend\n\t\t\telse\n\t\t\t\tshifter_32b #(.LENGTH(1)) shift_w0 (clk, HASHERS[i-1].cur_w1, cur_w0);\n\t\t\t\n\t\t\tif(i == 0)\n\t\t\tbegin\n\t\t\t\tassign cur_w1 = delay_input[63:32];\n\t\t\tend \n\t\t\telse if(i < 8)\n\t\t\tbegin\n\t\t\t\tshifter_32b #(.LENGTH(i)) shift_w1 (clk, delay_input[`IDX(1+i)], cur_w1);\n\t\t\tend\n\t\t\telse\n\t\t\t\tshifter_32b #(.LENGTH(8)) shift_w1 (clk, HASHERS[i-8].cur_w9, cur_w1);\n\t\t\t\n\t\t\tif(i == 0)\n\t\t\tbegin\n\t\t\t\tassign cur_w9 = delay_input[319:288];\n\t\t\tend\n\t\t\telse if(i < 5)\n\t\t\tbegin\n\t\t\t\tshifter_32b #(.LENGTH(i)) shift_w9 (clk, delay_input[`IDX(9+i)], cur_w9);\n\t\t\tend\n\t\t\telse if (i <= (NUM_ROUNDS - 9))\t// i <= 55 if NUM_ROUNDS=64\n\t\t\t\tshifter_32b #(.LENGTH(5)) shift_w9 (clk, HASHERS[i-5].cur_w14, cur_w9);\n\n\t\t\tif(i == 0)\n\t\t\tbegin\n\t\t\t\tassign cur_w14 = delay_input[479:448];\n\t\t\tend\n\t\t\telse if(i == 1)\n\t\t\tbegin\n\t\t\t\tshifter_32b #(.LENGTH(1)) shift_w14 (clk, delay_input[511:480], cur_w14);\n\t\t\tend\n\t\t\telse if (i <= (NUM_ROUNDS - 14))\t// i <= 50 if NUM_ROUNDS=64\n\t\t\t\tshifter_32b #(.LENGTH(1)) shift_w14 (clk, HASHERS[i-2].new_w15, cur_w14);\n\n\t\t\tif(i == 0)\n\t\t\t\tsha256_digester U (\n\t\t\t\t\t.clk(clk),\n\t\t\t\t\t.k_next(K_next),\n\t\t\t\t\t.rx_state(rx_state),\n\t\t\t\t\t.rx_t1_part(round0_t1_partial),\n\t\t\t\t\t.rx_w1(cur_w1),\n\t\t\t\t\t.tx_state(state),\n\t\t\t\t\t.tx_t1_part(t1_part_next)\n\t\t\t\t);\n\t\t\telse\n\t\t\t\tsha256_digester U (\n\t\t\t\t\t.clk(clk),\n\t\t\t\t\t.k_next(K_next),\n\t\t\t\t\t.rx_state(HASHERS[i-1].state),\n\t\t\t\t\t.rx_t1_part(HASHERS[i-1].t1_part_next),\n\t\t\t\t\t.rx_w1(cur_w1),\n\t\t\t\t\t.tx_state(state),\n\t\t\t\t\t.tx_t1_part(t1_part_next)\n\t\t\t\t);\n\n\t\t\tif (i <= (NUM_ROUNDS - 16))\t// i <= 48 if NUM_ROUNDS=64\n\t\t\tbegin\n\t\t\t\tsha256_update_w upd_w (\n\t\t\t\t\t.clk(clk),\n\t\t\t\t\t.rx_w0(cur_w0),\n\t\t\t\t\t.rx_w1(cur_w1),\n\t\t\t\t\t.rx_w9(cur_w9),\n\t\t\t\t\t.rx_w14(cur_w14),\n\t\t\t\t\t.tx_w15(new_w15)\n\t\t\t\t);\n\t\t\tend\n\t\tend\n\tendgenerate\n\n\talways @ (posedge clk)\n\tbegin\n\t\tround0_t1_partial <= rx_state[`IDX(7)] + rx_input[31:0] + 32'h428a2f98;\n\t\tdelay_input <= rx_input;\n\n\t\tif (NUM_ROUNDS == 64) begin\n\t\t\ttx_hash[`IDX(0)] <= rx_state[`IDX(0)] + HASHERS[NUM_ROUNDS-6'd1].state[`IDX(0)];\n\t\t\ttx_hash[`IDX(1)] <= rx_state[`IDX(1)] + HASHERS[NUM_ROUNDS-6'd1].state[`IDX(1)];\n\t\t\ttx_hash[`IDX(2)] <= rx_state[`IDX(2)] + HASHERS[NUM_ROUNDS-6'd1].state[`IDX(2)];\n\t\t\ttx_hash[`IDX(3)] <= rx_state[`IDX(3)] + HASHERS[NUM_ROUNDS-6'd1].state[`IDX(3)];\n\t\t\ttx_hash[`IDX(4)] <= rx_state[`IDX(4)] + HASHERS[NUM_ROUNDS-6'd1].state[`IDX(4)];\n\t\t\ttx_hash[`IDX(5)] <= rx_state[`IDX(5)] + HASHERS[NUM_ROUNDS-6'd1].state[`IDX(5)];\n\t\t\ttx_hash[`IDX(6)] <= rx_state[`IDX(6)] + HASHERS[NUM_ROUNDS-6'd1].state[`IDX(6)];\n\t\t\ttx_hash[`IDX(7)] <= rx_state[`IDX(7)] + HASHERS[NUM_ROUNDS-6'd1].state[`IDX(7)];\n\t\tend else begin\n\t\t\ttx_hash[`IDX(0)] <= HASHERS[NUM_ROUNDS-6'd1].state[`IDX(0)];\n\t\t\ttx_hash[`IDX(1)] <= HASHERS[NUM_ROUNDS-6'd1].state[`IDX(1)];\n\t\t\ttx_hash[`IDX(2)] <= HASHERS[NUM_ROUNDS-6'd1].state[`IDX(2)];\n\t\t\ttx_hash[`IDX(3)] <= HASHERS[NUM_ROUNDS-6'd1].state[`IDX(3)];\n\t\t\ttx_hash[`IDX(4)] <= HASHERS[NUM_ROUNDS-6'd1].state[`IDX(4)];\n\t\t\ttx_hash[`IDX(5)] <= HASHERS[NUM_ROUNDS-6'd1].state[`IDX(5)];\n\t\t\ttx_hash[`IDX(6)] <= HASHERS[NUM_ROUNDS-6'd1].state[`IDX(6)];\n\t\t\ttx_hash[`IDX(7)] <= HASHERS[NUM_ROUNDS-6'd1].state[`IDX(7)];\n\t\tend\n\tend\n\nendmodule"}
{"task_id": 1950, "completion": "parameter SIZE = 3;\n    parameter IDLE  = 3'b001, GNT0 = 3'b010, GNT1 = 3'b100;\n    reg [SIZE-1:0] state;\n    reg [SIZE-1:0] next_state;\n\n    always @ (state or req_0 or req_1) begin : FSM_COMBO\n        next_state = 3'b000;\n        case(state)\n            IDLE : if (req_0 == 1'b1) begin\n                        next_state = GNT0;\n                    end else if (req_1 == 1'b1) begin\n                        next_state= GNT1;\n                    end else begin\n                        next_state = IDLE;\n                    end\n            GNT0 : if (req_0 == 1'b1) begin\n                        next_state = GNT0;\n                    end else begin\n                        next_state = IDLE;\n                    end\n            GNT1 : if (req_1 == 1'b1) begin\n                        next_state = GNT1;\n                    end else begin\n                        next_state = IDLE;\n                    end\n            default : next_state = IDLE;\n        endcase\n    end\n\n    always @ (posedge clock) begin : FSM_SEQ\n        if (reset == 1'b1) begin\n            state <= #1 IDLE;\n        end else begin\n            state <= #1 next_state;\n        end\n    end\n\n    always @ (posedge clock) begin : OUTPUT_LOGIC\n        if (reset == 1'b1) begin\n            gnt_0 <= #1 1'b0;\n            gnt_1 <= #1 1'b0;\n        end else begin\n            case(state)\n                IDLE : begin\n                    gnt_0 <= #1 1'b0;\n                    gnt_1 <= #1 1'b0;\n                end\n                GNT0 : begin\n                    gnt_0 <= #1 1'b1;\n                    gnt_1 <= #1 1'b0;\n                end\n                GNT1 : begin\n                    gnt_0 <= #1 1'b0;\n                    gnt_1 <= #1 1'b1;\n                end\n                default : begin\n                    gnt_0 <= #1 1'b0;\n                    gnt_1 <= #1 1'b0;\n                end\n            endcase\n        end\n    end\nendmodule"}
{"task_id": 1948, "completion": "reg [3:0] out_sgpr_dest_wr_en; reg [3:0] out_vgpr_dest_wr_en; reg out_sgpr_instr_done; reg out_vgpr_instr_done; assign out_sgpr_dest_addr = in_lddst_stsrc_addr[8:0]; assign out_sgpr_dest_data = in_rd_data[127:0]; assign out_sgpr_instr_done_wfid = in_wftag_resp[6:1]; assign out_vgpr_dest_addr = in_lddst_stsrc_addr[9:0]; assign out_vgpr_dest_data = in_rd_data; assign out_vgpr_dest_wr_mask = in_exec_value; assign out_vgpr_instr_done_wfid = in_wftag_resp[6:1]; assign out_tracemon_retire_pc = in_instr_pc; assign out_gm_or_lds = in_gm_or_lds; always @* begin casex({in_ack, in_wftag_resp[0], in_lddst_stsrc_addr[11:10]}) 4'b0_?_??: begin out_sgpr_dest_wr_en <= 4'b0; out_vgpr_dest_wr_en <= 4'b0; out_sgpr_instr_done <= 1'b0; out_vgpr_instr_done <= 1'b0; end 4'b1_1_10: begin out_sgpr_dest_wr_en <= 4'b0; out_vgpr_dest_wr_en <= in_reg_wr_en; out_sgpr_instr_done <= 1'b0; out_vgpr_instr_done <= 1'b1; end 4'b1_1_11: begin out_sgpr_dest_wr_en <= in_reg_wr_en; out_vgpr_dest_wr_en <= 4'b0; out_sgpr_instr_done <= 1'b1; out_vgpr_instr_done <= 1'b0; end 4'b1_0_10: begin out_sgpr_dest_wr_en <= 4'b0; out_vgpr_dest_wr_en <= 4'b0; out_sgpr_instr_done <= 1'b0; out_vgpr_instr_done <= 1'b1; end 4'b1_0_11: begin out_sgpr_dest_wr_en <= 4'b0; out_vgpr_dest_wr_en <= 4'b0; out_sgpr_instr_done <= 1'b1; out_vgpr_instr_done <= 1'b0; end 4'b1_?_0?: begin out_sgpr_dest_wr_en <= 4'b0; out_vgpr_dest_wr_en <= 4'b0; out_sgpr_instr_done <= 1'b0; out_vgpr_instr_done <= 1'b0; end default: begin out_sgpr_dest_wr_en <= 4'bx; out_vgpr_dest_wr_en <= 4'bx; out_sgpr_instr_done <= 1'bx; out_vgpr_instr_done <= 1'bx; end endcase end assign out_rfa_dest_wr_req = (|out_vgpr_dest_wr_en) | (|out_sgpr_dest_wr_en);endmodule"}
{"task_id": 1886, "completion": "always @(x or ci or y or e)\\n    case (y)\\n      default: {co,w} <= {ci,x};\\n      5'd01: {co,w} <= e ? {x[0], ci, x[15:1]} : {ci, x[0], x[15:1]};\\n      5'd02: {co,w} <= e ? {x[ 1:0], ci, x[15: 2]} : {ci, x[ 1:0], x[15: 2]};\\n      5'd03: {co,w} <= e ? {x[ 2:0], ci, x[15: 3]} : {ci, x[ 2:0], x[15: 3]};\\n      5'd04: {co,w} <= e ? {x[ 3:0], ci, x[15: 4]} : {ci, x[ 3:0], x[15: 4]};\\n      5'd05: {co,w} <= e ? {x[ 4:0], ci, x[15: 5]} : {ci, x[ 4:0], x[15: 5]};\\n      5'd06: {co,w} <= e ? {x[ 5:0], ci, x[15: 6]} : {ci, x[ 5:0], x[15: 6]};\\n      5'd07: {co,w} <= e ? {x[ 6:0], ci, x[15: 7]} : {ci, x[ 6:0], x[15: 7]};\\n      5'd08: {co,w} <= e ? {x[ 7:0], ci, x[15: 8]} : {ci, x[ 7:0], x[15: 8]};\\n      5'd09: {co,w} <= e ? {x[ 8:0], ci, x[15: 9]} : {ci, x[ 8:0], x[15: 9]};\\n      5'd10: {co,w} <= e ? {x[ 9:0], ci, x[15:10]} : {ci, x[ 9:0], x[15:10]};\\n      5'd11: {co,w} <= e ? {x[10:0], ci, x[15:11]} : {ci, x[10:0], x[15:11]};\\n      5'd12: {co,w} <= e ? {x[11:0], ci, x[15:12]} : {ci, x[11:0], x[15:12]};\\n      5'd13: {co,w} <= e ? {x[12:0], ci, x[15:13]} : {ci, x[12:0], x[15:13]};\\n      5'd14: {co,w} <= e ? {x[13:0], ci, x[15:14]} : {ci, x[13:0], x[15:14]};\\n      5'd15: {co,w} <= e ? {x[14:0], ci, x[15]} : {ci, x[14:0], x[15]};\\n      5'd16: {co,w} <= {x,ci};\\n    endcase\\nendmodule"}
{"task_id": 1961, "completion": "always @*\n begin\n    case(operation)\n        2'b00:\n        begin\n            if((data1 == 32'h7f800000) && (data2 == 32'h7f800000))\n                NaN_flag = 1'b1;\n            else if((data1 == 32'hff800000) && (data2 == 32'hff800000))\n                NaN_flag = 1'b1;\n            else if((data1 == 32'h7f800000) && (data2 == 32'hff800000))\n\t\t\tNaN_flag = 1'b1;\n            else if((data1 == 32'hff800000) && (data2 == 32'h7f800000))\n\t\t\tNaN_flag = 1'b1;\n            else\n                NaN_flag = 1'b0;            \n        end        \n        2'b01:\n        begin\n            if(data1 == 32'h7f800000)\n                NaN_flag = 1'b1;\n            else if(data1 == 32'hff800000)\n                NaN_flag = 1'b1;\n            else\n                NaN_flag = 1'b0;            \n        end        \n        2'b10:\n        begin\n\t\t\tif((data1 == 32'h00000000) && (data2 == 32'h7f800000))\n                NaN_flag = 1'b1;\n            else if((data1 == 32'h00000000) && (data2 == 32'hff800000))\n                NaN_flag = 1'b1;\n            else if((data1 == 32'hff800000) && (data2 == 32'h00000000))\n\t\t\tNaN_flag = 1'b1;\n            else if((data1 == 32'h7f800000) && (data2 == 32'h00000000))\n\t\t\tNaN_flag = 1'b1;\n            else\n                NaN_flag = 1'b0;\n        end        \n        default:\n            NaN_flag = 1'b0;\n    endcase\n end\nendmodule"}
{"task_id": 1875, "completion": "input\t\t\t\tclk;\n\n\tinput\t\t\t\tmeasure_start;\n\tinput\t[2:0]\t\t\tmeasure_ch;\n\toutput\treg\t\t\tmeasure_done;\n\toutput\t[11:0]\t\tmeasure_dataread;\n\n\n\toutput\t\t\t\tADC_CONVST;\n\toutput\t\t\t\tADC_SCK;\n\toutput\treg\t\t\tADC_SDI;\n\tinput\t\t\t\tADC_SDO;\n\n\n\t/////////////////////////////////\n\t// Timing definition \n\n\t// using 40MHz clock\n\t// to acheive fsample = 500KHz\n\t// ntcyc = 2us / 25ns  = 80\n\n\n\t`define DATA_BITS_NUM\t\t12\n\t`define CMD_BITS_NUM\t\t6\n\t`define CH_NUM\t\t\t8\n\n\t`define tWHCONV\t\t\t3\n\t`define tCONV\t\t\t64\n\t`define tHCONVST\t\t320\n\t`define tCONVST_HIGH_START\t0\n\t`define tCONVST_HIGH_END\t(`tCONVST_HIGH_START+`tWHCONV)\n\t`define tCONFIG_START\t\t(`tCONVST_HIGH_END)\n\t`define tCONFIG_END\t\t(`tCLK_START+`CMD_BITS_NUM - 1)\n\t`define tCLK_START\t\t(`tCONVST_HIGH_START+`tCONV)\n\t`define tCLK_END\t\t(`tCLK_START+`DATA_BITS_NUM)\n\t`define tDONE\t\t\t(`tCLK_END+`tHCONVST)\n\n\treg pre_measure_start;\n\talways @ (posedge clk) \n\tbegin\n\t\tpre_measure_start <= measure_start;\n\tend\n\n\twire reset_n;\n\tassign reset_n = (~pre_measure_start & measure_start)?1'b0:1'b1;\n\n\treg [15:0] tick; \n\talways @ (posedge clk or negedge reset_n) \n\tbegin\n\t\tif (~reset_n)\n\t\t\ttick <= 0;\n\t\telse if (tick < `tDONE)\n\t\t\ttick <= tick + 1;\n\tend\n\n\t/////////////////////////////////\n\t// ADC_CONVST \n\tassign ADC_CONVST = (tick >= `tCONVST_HIGH_START && tick < `tCONVST_HIGH_END)?1'b1:1'b0;\n\n\t/////////////////////////////////\n\t// ADC_SCK \n\treg clk_enable;\n\talways @ (negedge clk or negedge reset_n) \n\tbegin\n\t\tif (~reset_n)\n\t\t\tclk_enable <= 1'b0;\n\t\telse if ((tick >= `tCLK_START && tick < `tCLK_END))\n\t\t\tclk_enable <= 1'b1;\n\t\telse\n\t\t\tclk_enable <= 1'b0;\n\tend\n\n\tassign ADC_SCK = clk_enable?clk:1'b0;\n\n\t///////////////////////////////\n\t// read data\n\treg [(`DATA_BITS_NUM-1):0] read_data;\n\treg [3:0] write_pos;\n\n\tassign measure_dataread = read_data;\n\n\talways @ (negedge clk or negedge reset_n) \n\tbegin\n\t\tif (~reset_n)\n\t\tbegin\n\t\t\tread_data <= 0;\n\t\t\twrite_pos <= `DATA_BITS_NUM-1;\n\t\tend\n\t\telse if (clk_enable)\n\t\tbegin\n\t\t\tread_data[write_pos] <= ADC_SDO;\n\t\t\twrite_pos <= write_pos - 1;\n\t\tend\n\tend\n\n\t///////////////////////////////\n\t// measure done\n\twire read_ch_done;\n\n\tassign read_ch_done = (tick == `tDONE)?1'b1:1'b0;\n\n\talways @ (posedge clk or negedge reset_n) \n\tbegin\n\t\tif (~reset_n)\n\t\t\tmeasure_done <= 1'b0;\n\t\telse if (read_ch_done)\n\t\t\tmeasure_done <= 1'b1;\n\tend\n\n\t///////////////////////////////\n\t// adc channel config\n\n\treg [(`CMD_BITS_NUM-1):0] config_cmd;\n\n\t`define UNI_MODE\t\t1'b1\n\t`define SLP_MODE\t\t1'b0\n\n\talways @(negedge reset_n)\n\tbegin\n\t\tif (~reset_n)\n\t\tbegin\n\t\t\tcase (measure_ch)\n\t\t\t\t0 : config_cmd <= {4'h8, `UNI_MODE, `SLP_MODE}; \n\t\t\t\t1 : config_cmd <= {4'hC, `UNI_MODE, `SLP_MODE}; \n\t\t\t\t2 : config_cmd <= {4'h9, `UNI_MODE, `SLP_MODE}; \n\t\t\t\t3 : config_cmd <= {4'hD, `UNI_MODE, `SLP_MODE}; \n\t\t\t\t4 : config_cmd <= {4'hA, `UNI_MODE, `SLP_MODE}; \n\t\t\t\t5 : config_cmd <= {4'hE, `UNI_MODE, `SLP_MODE}; \n\t\t\t\t6 : config_cmd <= {4'hB, `UNI_MODE, `SLP_MODE}; \n\t\t\t\t7 : config_cmd <= {4'hF, `UNI_MODE, `SLP_MODE}; \n\t\t\t\tdefault : config_cmd <= {4'hF, 2'b00}; \n\t\t\tendcase\n\t\tend\n\tend\n\n\t// serial config command to adc chip\n\twire config_init;\n\twire config_enable;\n\twire config_done;\n\treg [2:0] sdi_index;\n\n\tassign config_init = (tick == `tCONFIG_START)?1'b1:1'b0;\n\tassign config_enable = (tick > `tCLK_START && tick <= `tCONFIG_END)?1'b1:1'b0;\n\tassign config_done = (tick > `tCONFIG_END)?1'b1:1'b0;\n\talways @(negedge clk) \n\tbegin\n\t\tif (config_init)\n\t\tbegin\n\t\t\tADC_SDI <= config_cmd[`CMD_BITS_NUM-1];\n\t\t\tsdi_index <= `CMD_BITS_NUM-2;\n\t\tend\n\t\telse if (config_enable)\n\t\tbegin\n\t\t\tADC_SDI <= config_cmd[sdi_index];\n\t\t\tsdi_index <= sdi_index - 1;\n\t\tend\n\t\telse if (config_done)\n\t\t\tADC_SDI <= 1'b0;\n\tend\n\n\nendmodule"}
{"task_id": 1931, "completion": "wire [5:0] sub_wire0;\n\twire [0:0] sub_wire2 = 1'h0;\n\twire [0:0] sub_wire4 = 1'h1;\n\twire [0:0] sub_wire1 = sub_wire0[0:0];\n\twire  c0 = sub_wire1;\n\twire [5:0] sub_wire3 = {sub_wire2, sub_wire2, sub_wire2, sub_wire2, sub_wire2, sub_wire4};\n\twire  sub_wire5 = inclk0;\n\twire [1:0] sub_wire6 = {sub_wire2, sub_wire5};\n\twire [3:0] sub_wire7 = {sub_wire2, sub_wire2, sub_wire2, sub_wire2};\n\n\taltpll\taltpll_component (\n\t\t\t.clkena (sub_wire3),\n\t\t\t.inclk (sub_wire6),\n\t\t\t.extclkena (sub_wire7),\n\t\t\t.areset (areset),\n\t\t\t.clk (sub_wire0)\n\t\t\t// synopsys translate_off\n\t\t\t,\n\t\t\t.scanclk (),\n\t\t\t.pllena (),\n\t\t\t.sclkout1 (),\n\t\t\t.sclkout0 (),\n\t\t\t.fbin (),\n\t\t\t.scandone (),\n\t\t\t.clkloss (),\n\t\t\t.extclk (),\n\t\t\t.clkswitch (),\n\t\t\t.pfdena (),\n\t\t\t.scanaclr (),\n\t\t\t.clkbad (),\n\t\t\t.scandata (),\n\t\t\t.enable1 (),\n\t\t\t.scandataout (),\n\t\t\t.enable0 (),\n\t\t\t.scanwrite (),\n\t\t\t.locked (),\n\t\t\t.activeclock (),\n\t\t\t.scanread ()\n\t\t\t// synopsys translate_on\n\t\t);\n\tdefparam\n\t\taltpll_component.bandwidth = 500000,\n\t\taltpll_component.bandwidth_type = \"CUSTOM\",\n\t\taltpll_component.clk0_divide_by = 1,\n\t\taltpll_component.clk0_duty_cycle = 50,\n\t\taltpll_component.clk0_multiply_by = 2,\n\t\taltpll_component.clk0_phase_shift = \"0\",\n\t\taltpll_component.compensate_clock = \"CLK0\",\n\t\taltpll_component.inclk0_input_frequency = 8000,\n\t\taltpll_component.intended_device_family = \"Stratix GX\",\n\t\taltpll_component.lpm_type = \"altpll\",\n\t\taltpll_component.operation_mode = \"NORMAL\",\n\t\taltpll_component.pll_type = \"ENHANCED\",\n\t\taltpll_component.spread_frequency = 0;\n\nendmodule"}
{"task_id": 1987, "completion": "wire  sub_wire0;\n\twire  sub_wire1;\n\twire [11:0] sub_wire2;\n\twire  empty = sub_wire0;\n\twire  full = sub_wire1;\n\twire [11:0] q = sub_wire2[11:0];\n\n\tscfifo\tscfifo_component (\n\t\t\t.aclr (aclr),\n\t\t\t.clock (clock),\n\t\t\t.data (data),\n\t\t\t.rdreq (rdreq),\n\t\t\t.wrreq (wrreq),\n\t\t\t.empty (sub_wire0),\n\t\t\t.full (sub_wire1),\n\t\t\t.q (sub_wire2),\n\t\t\t.almost_empty (),\n\t\t\t.almost_full (),\n\t\t\t.sclr (),\n\t\t\t.usedw ());\n\tdefparam\n\t\tscfifo_component.add_ram_output_register = \"OFF\",\n\t\tscfifo_component.intended_device_family = \"Cyclone III\",\n\t\tscfifo_component.lpm_numwords = 256,\n\t\tscfifo_component.lpm_showahead = \"OFF\",\n\t\tscfifo_component.lpm_type = \"scfifo\",\n\t\tscfifo_component.lpm_width = 12,\n\t\tscfifo_component.lpm_widthu = 8,\n\t\tscfifo_component.overflow_checking = \"ON\",\n\t\tscfifo_component.underflow_checking = \"ON\",\n\t\tscfifo_component.use_eab = \"ON\";\n\nendmodule"}
{"task_id": 1943, "completion": "input [7-1:0] dll_delayctrl_in;\n    input core_clock_in;\n    input reset_n_core_clock_in;\n    input fr_clock_in;\n    input hr_clock_in;\n    input write_strobe_clock_in;\n    input [3:0] write_strobe;\n    input strobe_ena_hr_clock_in;\n    output capture_strobe_tracking;\n    inout [8-1:0] read_write_data_io;\n    input [2*8-1:0] write_oe_in;\n    inout strobe_io;\n    input [2-1:0] output_strobe_ena;\n    inout strobe_n_io;\n    input [2-1:0] oct_ena_in;\n    output [2 * 2 * 8-1:0] read_data_out;\n    output capture_strobe_out;\n    input [2 * 2 * 8-1:0] write_data_in;\n    input [2 * 2 * 1-1:0] extra_write_data_in;\n    output [1-1:0] extra_write_data_out;\n    input [16-1:0] parallelterminationcontrol_in;\n    input [16-1:0] seriesterminationcontrol_in;\n    input config_data_in;\n    input config_update;\n    input config_dqs_ena;\n    input [8-1:0] config_io_ena;\n    input [1-1:0] config_extra_io_ena;\n    input config_dqs_io_ena;\n    input config_clock_in;\n    input [2-1:0] lfifo_rdata_en;\n    input [2-1:0] lfifo_rdata_en_full;\n    input [4:0] lfifo_rd_latency;\n    input lfifo_reset_n;\n    output lfifo_rdata_valid;\n    input [2-1:0] vfifo_qvld;\n    input [2-1:0] vfifo_inc_wr_ptr;\n    input vfifo_reset_n;\n    input rfifo_reset_n;\n\n    parameter ALTERA_ALTDQ_DQS2_FAST_SIM_MODEL = \"\"; \n\n    altdq_dqs2_acv_connect_to_hard_phy_cyclonev altdq_dqs2_inst (\n        .core_clock_in( core_clock_in),\n        .reset_n_core_clock_in (reset_n_core_clock_in),\n        .fr_clock_in( fr_clock_in),\n        .hr_clock_in( hr_clock_in),\n        .write_strobe_clock_in (write_strobe_clock_in),\n        .write_strobe(write_strobe),\n        .strobe_ena_hr_clock_in( strobe_ena_hr_clock_in),\n        .capture_strobe_tracking (capture_strobe_tracking),\n        .read_write_data_io( read_write_data_io),\n        .write_oe_in( write_oe_in),\n        .strobe_io( strobe_io),\n        .output_strobe_ena( output_strobe_ena),\n        .strobe_n_io( strobe_n_io),\n        .oct_ena_in( oct_ena_in),\n        .read_data_out( read_data_out),\n        .capture_strobe_out( capture_strobe_out),\n        .write_data_in( write_data_in),\n        .extra_write_data_in( extra_write_data_in),\n        .extra_write_data_out( extra_write_data_out),\n        .parallelterminationcontrol_in( parallelterminationcontrol_in),\n        .seriesterminationcontrol_in( seriesterminationcontrol_in),\n        .config_data_in( config_data_in),\n        .config_update( config_update),\n        .config_dqs_ena( config_dqs_ena),\n        .config_io_ena( config_io_ena),\n        .config_extra_io_ena( config_extra_io_ena),\n        .config_dqs_io_ena( config_dqs_io_ena),\n        .config_clock_in( config_clock_in),\n        .lfifo_rdata_en(lfifo_rdata_en),\n        .lfifo_rdata_en_full(lfifo_rdata_en_full),\n        .lfifo_rd_latency(lfifo_rd_latency),\n        .lfifo_reset_n(lfifo_reset_n),\n        .lfifo_rdata_valid(lfifo_rdata_valid),\n        .vfifo_qvld(vfifo_qvld),\n        .vfifo_inc_wr_ptr(vfifo_inc_wr_ptr),\n        .vfifo_reset_n(vfifo_reset_n),\n        .rfifo_reset_n(rfifo_reset_n),\n        .dll_delayctrl_in(dll_delayctrl_in)\n    );\n    defparam altdq_dqs2_inst.PIN_WIDTH = 8;\n    defparam altdq_dqs2_inst.PIN_TYPE = \"bidir\";\n    defparam altdq_dqs2_inst.USE_INPUT_PHASE_ALIGNMENT = \"false\";\n    defparam altdq_dqs2_inst.USE_OUTPUT_PHASE_ALIGNMENT = \"false\";\n    defparam altdq_dqs2_inst.USE_LDC_AS_LOW_SKEW_CLOCK = \"false\";\n    defparam altdq_dqs2_inst.USE_HALF_RATE_INPUT = \"false\";\n    defparam altdq_dqs2_inst.USE_HALF_RATE_OUTPUT = \"true\";\n    defparam altdq_dqs2_inst.DIFFERENTIAL_CAPTURE_STROBE = \"true\";\n    defparam altdq_dqs2_inst.SEPARATE_CAPTURE_STROBE = \"false\";\n    defparam altdq_dqs2_inst.INPUT_FREQ = 400.0;\n    defparam altdq_dqs2_inst.INPUT_FREQ_PS = \"2500 ps\";\n    defparam altdq_dqs2_inst.DELAY_CHAIN_BUFFER_MODE = \"high\";\n    defparam altdq_dqs2_inst.DQS_PHASE_SETTING = 0;\n    defparam altdq_dqs2_inst.DQS_PHASE_SHIFT = 0;\n    defparam altdq_dqs2_inst.DQS_ENABLE_PHASE_SETTING = 3;\n    defparam altdq_dqs2_inst.USE_DYNAMIC_CONFIG = \"true\";\n    defparam altdq_dqs2_inst.INVERT_CAPTURE_STROBE = \"true\";\n    defparam altdq_dqs2_inst.SWAP_CAPTURE_STROBE_POLARITY = \"false\";\n    defparam altdq_dqs2_inst.USE_TERMINATION_CONTROL = \"true\";\n    defparam altdq_dqs2_inst.USE_DQS_ENABLE = \"true\";\n    defparam altdq_dqs2_inst.USE_OUTPUT_STROBE = \"true\";\n    defparam altdq_dqs2_inst.USE_OUTPUT_STROBE_RESET = \"false\";\n    defparam altdq_dqs2_inst.DIFFERENTIAL_OUTPUT_STROBE = \"true\";\n    defparam altdq_dqs2_inst.USE_BIDIR_STROBE = \"true\";\n    defparam altdq_dqs2_inst.REVERSE_READ_WORDS = \"false\";\n    defparam altdq_dqs2_inst.EXTRA_OUTPUT_WIDTH = 1;\n    defparam altdq_dqs2_inst.DYNAMIC_MODE = \"dynamic\";\n    defparam altdq_dqs2_inst.OCT_SERIES_TERM_CONTROL_WIDTH   = 16; \n    defparam altdq_dqs2_inst.OCT_PARALLEL_TERM_CONTROL_WIDTH = 16; \n    defparam altdq_dqs2_inst.DLL_WIDTH = 7;\n    defparam altdq_dqs2_inst.USE_DATA_OE_FOR_OCT = \"false\";\n    defparam altdq_dqs2_inst.DQS_ENABLE_WIDTH = 1;\n    defparam altdq_dqs2_inst.USE_OCT_ENA_IN_FOR_OCT = \"true\";\n    defparam altdq_dqs2_inst.PREAMBLE_TYPE = \"high\";\n    defparam altdq_dqs2_inst.EMIF_UNALIGNED_PREAMBLE_SUPPORT = \"false\";\n    defparam altdq_dqs2_inst.USE_OFFSET_CTRL = \"false\";\n    defparam altdq_dqs2_inst.HR_DDIO_OUT_HAS_THREE_REGS = \"false\";\n    defparam altdq_dqs2_inst.DQS_ENABLE_PHASECTRL = \"true\";\n    defparam altdq_dqs2_inst.USE_2X_FF = \"false\";\n    defparam altdq_dqs2_inst.DLL_USE_2X_CLK = \"false\";\n    defparam altdq_dqs2_inst.USE_DQS_TRACKING = \"true\";\n    defparam altdq_dqs2_inst.USE_HARD_FIFOS = \"true\";\n    defparam altdq_dqs2_inst.USE_DQSIN_FOR_VFIFO_READ = \"false\";\n    defparam altdq_dqs2_inst.CALIBRATION_SUPPORT = \"false\";\n    defparam altdq_dqs2_inst.NATURAL_ALIGNMENT = \"true\";\n    defparam altdq_dqs2_inst.SEPERATE_LDC_FOR_WRITE_STROBE = \"false\";\n    defparam altdq_dqs2_inst.HHP_HPS = \"true\";\n\nendmodule"}
{"task_id": 1898, "completion": "parameter ugal_threshold = 3;\n   parameter num_flit_buffers = 8;\n   parameter num_message_classes = 1;\n   parameter num_resource_classes = 2;\n   localparam num_packet_classes = num_message_classes * num_resource_classes;\n   parameter num_vcs_per_class = 1;\n   localparam num_vcs = num_packet_classes * num_vcs_per_class;\n   parameter port_id = 6;\n   parameter num_routers_per_dim = 4;\n   localparam dim_addr_width = clogb(num_routers_per_dim);\n   parameter num_dimensions = 2;\n   localparam router_addr_width = num_dimensions * dim_addr_width;\n   parameter num_nodes_per_router = 4;\n   localparam node_addr_width = clogb(num_nodes_per_router);\n   localparam addr_width = router_addr_width + node_addr_width;\n   parameter connectivity = `CONNECTIVITY_FULL;\n   localparam num_neighbors_per_dim = ((connectivity == `CONNECTIVITY_LINE) || (connectivity == `CONNECTIVITY_RING)) ? 2 : (connectivity == `CONNECTIVITY_FULL) ? (num_routers_per_dim - 1) : -1;\n   localparam num_ports = num_dimensions * num_neighbors_per_dim + num_nodes_per_router;\n   localparam port_idx_width = clogb(num_ports);\n   parameter routing_type = `ROUTING_TYPE_DOR;\n   parameter dim_order = `DIM_ORDER_ASCENDING;\n   localparam route_info_width = num_resource_classes * router_addr_width + node_addr_width;\n   parameter reset_type = `RESET_TYPE_ASYNC;\n   localparam credit_count_width = clogb(num_vcs*num_flit_buffers)+1;\n   localparam [0:num_resource_classes-1] sel_irc = (1 << (num_resource_classes - 1-1));\n   wire [0:num_ports-1] min_route_unmasked;\n   wire inc_rc;\n   vcr_routing_logic #(.num_resource_classes(num_resource_classes), .num_routers_per_dim(num_routers_per_dim), .num_dimensions(num_dimensions), .num_nodes_per_router(num_nodes_per_router), .connectivity(connectivity), .routing_type(routing_type), .dim_order(dim_order), .reset_type(reset_type)) min_routing (.clk(clk), .reset(reset), .router_address(src_router_address), .route_info({src_router_address,route_info}), .route_op(min_route_unmasked), .inc_rc(inc_rc), .sel_rc(sel_irc));\n   localparam [0:num_resource_classes-1] sel_irc_nonmin = (1 << (num_resource_classes - 1-0));\n   wire [0:num_ports-1] nonmin_route_unmasked;\n   wire inc_rc_nonmin;\n   vcr_routing_logic_ugal #(.num_resource_classes(num_resource_classes), .num_routers_per_dim(num_routers_per_dim), .num_dimensions(num_dimensions), .num_nodes_per_router(num_nodes_per_router), .connectivity(connectivity), .routing_type(routing_type), .dim_order(dim_order), .reset_type(reset_type)) nonmin_routing (.clk(clk), .reset(reset), .router_address(src_router_address), .route_info({intm_router_address,route_info}), .route_op(nonmin_route_unmasked), .inc_rc(inc_rc_nonmin), .sel_rc(sel_irc_nonmin));\n   wire [0:credit_count_width-1] min_count;\n   wire [0:credit_count_width-1] nonmin_count;\n   c_select_1ofn #(.num_ports(num_ports-num_nodes_per_router), .width(credit_count_width)) min_count_select (.data_out(min_count[0:credit_count_width-1]), .select(min_route_unmasked[0:num_ports-num_nodes_per_router-1]), .data_in(credit_count[0:(num_ports-num_nodes_per_router)*credit_count_width-1]));\n   c_select_1ofn #(.num_ports(num_ports-num_nodes_per_router), .width(credit_count_width)) nonmin_count_select (.data_out(nonmin_count[0:credit_count_width-1]), .select(nonmin_route_unmasked[0:num_ports-num_nodes_per_router-1]), .data_in(credit_count[0:(num_ports-num_nodes_per_router)*credit_count_width-1]));\n   wire compare;\n   wire compare_q;\n   wire [0:credit_count_width-1+2] ext_min_count;\n   assign ext_min_count[0:credit_count_width-1+2] = {min_count[0:credit_count_width-1],2'b0};\n   wire [0:credit_count_width-1+2] ext_nonmin_count;\n   assign ext_nonmin_count[0:credit_count_width-1+2] = {1'b0,nonmin_count[0:credit_count_width-1],1'b0};\n   assign compare = ((ext_nonmin_count+ugal_threshold) > ext_min_count);\n   wire decision = (flit_head&flit_valid)?compare:compare_q;\n   localparam eligible = num_ports-num_nodes_per_router;\n   assign route_min = |(min_route_unmasked[eligible:num_ports-1])|decision;\n   c_dff #(.width(1), .reset_type(reset_type), .reset_value(1'b1)) last_compare (.q(compare_q), .clk(clk), .reset(reset), .d((flit_head&flit_valid)?compare:compare_q));\n   wire [0:router_addr_width-1] rand_value;\n   wire [0:router_addr_width-1] rand_feedback;\n   c_fbgen #(.width(router_addr_width), .index(1)) rand_fbgen (.feedback(rand_feedback));\n   c_lfsr #(.width(router_addr_width), .iterations(router_addr_width), .reset_type(reset_type)) rand_gen (.q(rand_value[0:router_addr_width-1]), .clk(clk), .reset(reset), .load(reset), .run(flit_head&flit_valid), .feedback(rand_feedback[0:router_addr_width-1]), .complete(1'b0), .d(rand_value[0:router_addr_width-1]));\n   wire carry;\n   assign {intm_router_address[0:router_addr_width-1],carry} = {src_router_address[0:router_addr_width-1],1'b0}+{rand_value[0:router_addr_width-1],1'b0};\nendmodule"}
{"task_id": 1964, "completion": "localparam [C_AWIDTH-1:0] C_EMPTY = ~(0);localparam [C_AWIDTH-1:0] C_EMPTY_PRE =  (0);localparam [C_AWIDTH-1:0] C_FULL  = C_EMPTY-1;localparam [C_AWIDTH-1:0] C_FULL_PRE  = (C_DEPTH < 8) ? C_FULL-1 : C_FULL-(C_DEPTH/8);reg [C_WIDTH-1:0]  memory [C_DEPTH-1:0];reg [C_AWIDTH-1:0] cnt_read;always @(posedge clk) begin : BLKSRLinteger i;if (wr_en) beginfor (i = 0; i < C_DEPTH-1; i = i + 1) beginmemory[i+1] <= memory[i];endmemory[0] <= din;endendalways @(posedge clk) beginif (rst) cnt_read <= C_EMPTY;else if ( wr_en & !rd_en) cnt_read <= cnt_read + 1'b1;else if (!wr_en &  rd_en) cnt_read <= cnt_read - 1'b1;endassign full  = (cnt_read == C_FULL);assign empty = (cnt_read == C_EMPTY);assign a_full  = ((cnt_read >= C_FULL_PRE) && (cnt_read != C_EMPTY));assign a_empty = (cnt_read == C_EMPTY_PRE);assign dout  = (C_DEPTH == 1) ? memory[0] : memory[cnt_read];endmodule"}
{"task_id": 1999, "completion": "reg [3:0] counter_value_preserver;\n\nassign counter_value = counter_value_preserver;\n\nalways@(posedge clk or posedge rst) begin\n if(rst == 1'b1) begin\n   counter_value_preserver = 4'h0;\n end\n else if ( count == 1'b1 ) begin\n   counter_value_preserver = counter_value_preserver + 1;\n end\n else begin\n   counter_value_preserver = counter_value;\n end\nend\nendmodule"}
{"task_id": 823, "completion": "parameter   PCORE_VERSION = 32'h00040062;    parameter   PCORE_ID = 0;    reg     [31:0]  up_scratch = 'd0;    reg             up_mmcm_resetn = 'd0;    reg             up_resetn = 'd0;    reg             up_adc_r1_mode = 'd0;    reg             up_adc_ddr_edgesel = 'd0;    reg             up_adc_pin_mode = 'd0;    reg             up_delay_sel = 'd0;    reg             up_delay_rwn = 'd0;    reg     [ 7:0]  up_delay_addr = 'd0;    reg     [ 4:0]  up_delay_wdata = 'd0;    reg             up_drp_sel_t = 'd0;    reg             up_drp_rwn = 'd0;    reg     [11:0]  up_drp_addr = 'd0;    reg     [15:0]  up_drp_wdata = 'd0;    reg             up_dma_stream = 'd0;    reg             up_dma_start = 'd0;    reg     [31:0]  up_dma_count = 'd0;    reg     [ 7:0]  up_usr_chanmax = 'd0;    reg             up_ack = 'd0;    reg     [31:0]  up_rdata = 'd0;    reg             adc_r1_mode_m1 = 'd0;    reg             adc_r1_mode = 'd0;    reg             adc_ddr_edgesel_m1 = 'd0;    reg             adc_ddr_edgesel = 'd0;    reg             adc_pin_mode_m1 = 'd0;    reg             adc_pin_mode = 'd0;    reg     [ 3:0]  up_adc_status_m1 = 'd0;    reg     [ 3:0]  up_adc_status = 'd0;    reg             up_count_toggle_m1 = 'd0;    reg             up_count_toggle_m2 = 'd0;    reg             up_count_toggle_m3 = 'd0;    reg             up_count_toggle = 'd0;    reg     [15:0]  up_count = 'd0;    reg     [31:0]  up_adc_clk_count = 'd0;    reg             adc_clk_count_toggle_m1 = 'd0;    reg             adc_clk_count_toggle_m2 = 'd0;    reg             adc_clk_count_toggle_m3 = 'd0;    reg             adc_clk_count_toggle = 'd0;    reg     [31:0]  adc_clk_count_hold = 'd0;    reg     [32:0]  adc_clk_count = 'd0;    reg             delay_sel_m1 = 'd0;    reg             delay_sel_m2 = 'd0;    reg             delay_sel_m3 = 'd0;    reg             delay_sel = 'd0;    reg             delay_rwn = 'd0;    reg     [ 7:0]  delay_addr = 'd0;    reg     [ 4:0]  delay_wdata = 'd0;    reg             up_delay_locked_m1 = 'd0;    reg             up_delay_locked = 'd0;    reg             up_delay_ack_t_m1 = 'd0;    reg             up_delay_ack_t_m2 = 'd0;    reg             up_delay_ack_t_m3 = 'd0;    reg             up_delay_sel_d = 'd0;    reg             up_delay_status = 'd0;    reg     [ 4:0]  up_delay_rdata = 'd0;    reg             drp_sel_t_m1 = 'd0;    reg             drp_sel_t_m2 = 'd0;    reg             drp_sel_t_m3 = 'd0;    reg             drp_sel = 'd0;    reg             drp_wr = 'd0;    reg     [11:0]  drp_addr = 'd0;    reg     [15:0]  drp_wdata = 'd0;    reg             up_drp_ack_t_m1 = 'd0;    reg             up_drp_ack_t_m2 = 'd0;    reg             up_drp_ack_t_m3 = 'd0;    reg             up_drp_sel_t_d = 'd0;    reg             up_drp_status = 'd0;    reg     [15:0]  up_drp_rdata = 'd0;    reg             dma_start_m1 = 'd0;    reg             dma_start_m2 = 'd0;    reg             dma_start_m3 = 'd0;    reg             dma_start = 'd0;    reg             dma_stream = 'd0;    reg     [31:0]  dma_count = 'd0;    reg     [ 5:0]  dma_xfer_cnt = 'd0;    reg             dma_xfer_toggle = 'd0;    reg             dma_xfer_ovf = 'd0;    reg             dma_xfer_unf = 'd0;    reg             dma_acc_ovf = 'd0;    reg             dma_acc_unf = 'd0;    reg             up_dma_xfer_toggle_m1 = 'd0;    reg             up_dma_xfer_toggle_m2 = 'd0;    reg             up_dma_xfer_toggle_m3 = 'd0;    reg             up_dma_xfer_ovf = 'd0;    reg             up_dma_xfer_unf = 'd0;    reg             up_dma_ovf = 'd0;    reg             up_dma_unf = 'd0;    reg             up_dma_status_m1 = 'd0;    reg             up_dma_status = 'd0;    wire            up_sel_s;    wire            up_wr_s;    wire            up_preset_s;    wire            up_mmcm_preset_s;    wire    [ 3:0]  adc_status_s;    wire            up_count_toggle_s;    wire            adc_clk_count_toggle_s;    wire            up_delay_ack_t_s;    wire            up_delay_sel_s;    wire            drp_sel_t_s;    wire            up_drp_ack_t_s;    wire            up_drp_sel_t_s;    wire            up_dma_xfer_toggle_s;    assign up_sel_s = (up_addr[13:8] == 6'h00) ? up_sel : 1'b0;    assign up_wr_s = up_sel_s & up_wr;    assign up_preset_s = ~up_resetn;    assign up_mmcm_preset_s = ~up_mmcm_resetn;    always @(negedge up_rstn or posedge up_clk) begin    if (up_rstn == 0) begin      up_scratch <= 'd0;      up_mmcm_resetn <= 'd0;      up_resetn <= 'd0;      up_adc_r1_mode <= 'd0;      up_adc_ddr_edgesel <= 'd0;      up_adc_pin_mode <= 'd0;      up_delay_sel <= 'd0;      up_delay_rwn <= 'd0;      up_delay_addr <= 'd0;      up_delay_wdata <= 'd0;      up_drp_sel_t <= 'd0;      up_drp_rwn <= 'd0;      up_drp_addr <= 'd0;      up_drp_wdata <= 'd0;      up_dma_stream <= 'd0;      up_dma_start <= 'd0;      up_dma_count <= 'd0;      up_usr_chanmax <= 'd0;    end else begin      if ((up_wr_s == 1'b1) && (up_addr[7:0] == 8'h02)) begin        up_scratch <= up_wdata;      end      if ((up_wr_s == 1'b1) && (up_addr[7:0] == 8'h10)) begin        up_mmcm_resetn <= up_wdata[1];        up_resetn <= up_wdata[0];      end      if ((up_wr_s == 1'b1) && (up_addr[7:0] == 8'h11)) begin        up_adc_r1_mode <= up_wdata[2];        up_adc_ddr_edgesel <= up_wdata[1];        up_adc_pin_mode <= up_wdata[0];      end      if ((up_wr_s == 1'b1) && (up_addr[7:0] == 8'h18)) begin        up_delay_sel <= up_wdata[17];        up_delay_rwn <= up_wdata[16];        up_delay_addr <= up_wdata[15:8];        up_delay_wdata <= up_wdata[4:0];      end      if ((up_wr_s == 1'b1) && (up_addr[7:0] == 8'h1c)) begin        up_drp_sel_t <= ~up_drp_sel_t;        up_drp_rwn <= up_wdata[28];        up_drp_addr <= up_wdata[27:16];        up_drp_wdata <= up_wdata[15:0];      end      if ((up_wr_s == 1'b1) && (up_addr[7:0] == 8'h20)) begin        up_dma_stream <= up_wdata[1];        up_dma_start <= up_wdata[0];      end      if ((up_wr_s == 1'b1) && (up_addr[7:0] == 8'h21)) begin        up_dma_count <= up_wdata;      end      if ((up_wr_s == 1'b1) && (up_addr[7:0] == 8'h28)) begin        up_usr_chanmax <= up_wdata[7:0];      end    end  end  always @(negedge up_rstn or posedge up_clk) begin    if (up_rstn == 0) begin      up_ack <= 'd0;      up_rdata <= 'd0;    end else begin      up_ack <= up_sel_s;      if (up_sel_s == 1'b1) begin        case (up_addr[7:0])          8'h00: up_rdata <= PCORE_VERSION;          8'h01: up_rdata <= PCORE_ID;          8'h02: up_rdata <= up_scratch;          8'h10: up_rdata <= {30'd0, up_mmcm_resetn, up_resetn};          8'h11: up_rdata <= {29'd0, up_adc_r1_mode, up_adc_ddr_edgesel, up_adc_pin_mode};          8'h15: up_rdata <= up_adc_clk_count;          8'h16: up_rdata <= adc_clk_ratio;          8'h17: up_rdata <= {28'd0, up_adc_status};          8'h18: up_rdata <= {14'd0, up_delay_sel, up_delay_rwn, up_delay_addr, 3'd0, up_delay_wdata};          8'h19: up_rdata <= {22'd0, up_delay_locked, up_delay_status, 3'd0, up_delay_rdata};          8'h1c: up_rdata <= {3'd0, up_drp_rwn, up_drp_addr, up_drp_wdata};          8'h1d: up_rdata <= {15'd0, up_drp_status, up_drp_rdata};          8'h20: up_rdata <= {30'd0, up_dma_stream, up_dma_start};          8'h21: up_rdata <= up_dma_count;          8'h22: up_rdata <= {29'd0, up_dma_ovf, up_dma_unf, up_dma_status};          8'h23: up_rdata <= dma_bw;          8'h28: up_rdata <= {24'd0, adc_usr_chanmax};          default: up_rdata <= 0;        endcase      end else begin        up_rdata <= 32'd0;      end    end  end  FDPE #(.INIT(1'b1)) i_mmcm_rst_reg (    .CE (1'b1),    .D (1'b0),    .PRE (up_mmcm_preset_s),    .C (drp_clk),    .Q (mmcm_rst));  FDPE #(.INIT(1'b1)) i_adc_rst_reg (    .CE (1'b1),    .D (1'b0),    .PRE (up_preset_s),    .C (adc_clk),    .Q (adc_rst));  always @(posedge adc_clk) begin    if (adc_rst == 1'b1) begin      adc_r1_mode_m1 <= 'd0;      adc_r1_mode <= 'd0;      adc_ddr_edgesel_m1 <= 'd0;      adc_ddr_edgesel <= 'd0;      adc_pin_mode_m1 <= 'd0;      adc_pin_mode <= 'd0;    end else begin      adc_r1_mode_m1 <= up_adc_r1_mode;      adc_r1_mode <= adc_r1_mode_m1;      adc_ddr_edgesel_m1 <= up_adc_ddr_edgesel;      adc_ddr_edgesel <= adc_ddr_edgesel_m1;      adc_pin_mode_m1 <= up_adc_pin_mode;      adc_pin_mode <= adc_pin_mode_m1;    end  end  assign adc_status_s[3] = adc_status_pn_err;  assign adc_status_s[2] = adc_status_pn_oos;  assign adc_status_s[1] = adc_status_or;  assign adc_status_s[0] = adc_status;  always @(negedge up_rstn or posedge up_clk) begin    if (up_rstn == 0) begin      up_adc_status_m1 <= 'd0;      up_adc_status <= 'd0;    end else begin      up_adc_status_m1 <= adc_status_s;      up_adc_status <= up_adc_status_m1;    end  end  assign up_count_toggle_s = up_count_toggle_m3 ^ up_count_toggle_m2;  always @(negedge up_rstn or posedge up_clk) begin    if (up_rstn == 0) begin      up_count_toggle_m1 <= 'd0;      up_count_toggle_m2 <= 'd0;      up_count_toggle_m3 <= 'd0;      up_count_toggle <= 'd0;      up_count <= 'd0;      up_adc_clk_count <= 'd0;    end else begin      up_count_toggle_m1 <= adc_clk_count_toggle;      up_count_toggle_m2 <= up_count_toggle_m1;      up_count_toggle_m3 <= up_count_toggle_m2;      if (up_count == 16'd0) begin        up_count_toggle <= ~up_count_toggle;      end      up_count <= up_count + 1'b1;      if (up_count_toggle_s == 1'b1) begin        up_adc_clk_count <= adc_clk_count_hold;      end    end  end  assign adc_clk_count_toggle_s = adc_clk_count_toggle_m3 ^ adc_clk_count_toggle_m2;  always @(posedge adc_clk) begin    if (adc_rst == 1'b1) begin      adc_clk_count_toggle_m1 <= 'd0;      adc_clk_count_toggle_m2 <= 'd0;      adc_clk_count_toggle_m3 <= 'd0;    end else begin      adc_clk_count_toggle_m1 <= up_count_toggle;      adc_clk_count_toggle_m2 <= adc_clk_count_toggle_m1;      adc_clk_count_toggle_m3 <= adc_clk_count_toggle_m2;    end    if (adc_clk_count_toggle_s == 1'b1) begin      adc_clk_count_toggle <= ~adc_clk_count_toggle;      adc_clk_count_hold <= adc_clk_count[31:0];    end    if (adc_clk_count_toggle_s == 1'b1) begin      adc_clk_count <= 33'd1;    end else if (adc_clk_count[32] == 1'b0) begin      adc_clk_count <= adc_clk_count + 1'b1;    end else begin      adc_clk_count <= {33{1'b1}};    end  end  FDPE #(.INIT(1'b1)) i_delay_rst_reg (    .CE (1'b1),    .D (1'b0),    .PRE (up_preset_s),    .C (delay_clk),    .Q (delay_rst));  always @(posedge delay_clk) begin    if (delay_rst == 1'b1) begin      delay_sel_m1 <= 'd0;      delay_sel_m2 <= 'd0;      delay_sel_m3 <= 'd0;    end else begin      delay_sel_m1 <= up_delay_sel;      delay_sel_m2 <= delay_sel_m1;      delay_sel_m3 <= delay_sel_m2;    end    delay_sel <= delay_sel_m2 & ~delay_sel_m3;    if ((delay_sel_m2 == 1'b1) && (delay_sel_m3 == 1'b0)) begin      delay_rwn <= up_delay_rwn;      delay_addr <= up_delay_addr;      delay_wdata <= up_delay_wdata;    end  end  assign up_delay_ack_t_s = up_delay_ack_t_m3 ^ up_delay_ack_t_m2;  assign up_delay_sel_s = up_delay_sel & ~up_delay_sel_d;  always @(negedge up_rstn or posedge up_clk) begin    if (up_rstn == 0) begin      up_delay_locked_m1 <= 'd0;      up_delay_locked <= 'd0;      up_delay_ack_t_m1 <= 'd0;      up_delay_ack_t_m2 <= 'd0;      up_delay_ack_t_m3 <= 'd0;      up_delay_sel_d <= 'd0;      up_delay_status <= 'd0;      up_delay_rdata <= 'd0;    end else begin      up_delay_locked_m1 <= delay_locked;      up_delay_locked <= up_delay_locked_m1;      up_delay_ack_t_m1 <= delay_ack_t;      up_delay_ack_t_m2 <= up_delay_ack_t_m1;      up_delay_ack_t_m3 <= up_delay_ack_t_m2;      up_delay_sel_d <= up_delay_sel;      if (up_delay_ack_t_s == 1'b1) begin        up_delay_status <= 1'b0;      end else if (up_delay_sel_s == 1'b1) begin        up_delay_status <= 1'b1;      end      if (up_delay_ack_t_s == 1'b1) begin        up_delay_rdata <= delay_rdata;      end    end  end  FDPE #(.INIT(1'b1)) i_drp_rst_reg (    .CE (1'b1),    .D (1'b0),    .PRE (up_preset_s),    .C (drp_clk),    .Q (drp_rst));  assign drp_sel_t_s = drp_sel_t_m2 ^ drp_sel_t_m3;  always @(posedge drp_clk) begin    if (drp_rst == 1'b1) begin      drp_sel_t_m1 <= 'd0;      drp_sel_t_m2 <= 'd0;      drp_sel_t_m3 <= 'd0;    end else begin      drp_sel_t_m1 <= up_drp_sel_t;      drp_sel_t_m2 <= drp_sel_t_m1;      drp_sel_t_m3 <= drp_sel_t_m2;    end    if (drp_sel_t_s == 1'b1) begin      drp_sel <= 1'b1;      drp_wr <= ~up_drp_rwn;      drp_addr <= up_drp_addr;      drp_wdata <= up_drp_wdata;    end else begin      drp_sel <= 1'b0;      drp_wr <= 1'b0;      drp_addr <= 12'd0;      drp_wdata <= 16'd0;    end  end  assign up_drp_ack_t_s = up_drp_ack_t_m3 ^ up_drp_ack_t_m2;  assign up_drp_sel_t_s = up_drp_sel_t ^ up_drp_sel_t_d;  always @(negedge up_rstn or posedge up_clk) begin    if (up_rstn == 0) begin      up_drp_ack_t_m1 <= 'd0;      up_drp_ack_t_m2 <= 'd0;      up_drp_ack_t_m3 <= 'd0;      up_drp_sel_t_d <= 'd0;      up_drp_status <= 'd0;      up_drp_rdata <= 'd0;    end else begin      up_drp_ack_t_m1 <= drp_ack_t;      up_drp_ack_t_m2 <= up_drp_ack_t_m1;      up_drp_ack_t_m3 <= up_drp_ack_t_m2;      up_drp_sel_t_d <= up_drp_sel_t;      if (up_drp_ack_t_s == 1'b1) begin        up_drp_status <= 1'b0;      end else if (up_drp_sel_t_s == 1'b1) begin        up_drp_status <= 1'b1;      end      if (up_drp_ack_t_s == 1'b1) begin        up_drp_rdata <= drp_rdata;      end    end  end  FDPE #(.INIT(1'b1)) i_dma_rst_reg (    .CE (1'b1),    .D (1'b0),    .PRE (up_preset_s),    .C (dma_clk),    .Q (dma_rst));  always @(posedge dma_clk) begin    if (dma_rst == 1'b1) begin      dma_start_m1 <= 'd0;      dma_start_m2 <= 'd0;      dma_start_m3 <= 'd0;    end else begin      dma_start_m1 <= up_dma_start;      dma_start_m2 <= dma_start_m1;      dma_start_m3 <= dma_start_m2;    end    dma_start <= dma_start_m2 & ~dma_start_m3;    if ((dma_start_m2 == 1'b1) && (dma_start_m3 == 1'b0)) begin      dma_stream <= up_dma_stream;      dma_count <= up_dma_count;    end  end  always @(posedge dma_clk) begin    dma_xfer_cnt <= dma_xfer_cnt + 1'b1;    if (dma_xfer_cnt == 6'd0) begin      dma_xfer_toggle <= ~dma_xfer_toggle;      dma_xfer_ovf <= dma_acc_ovf;      dma_xfer_unf <= dma_acc_unf;    end    if (dma_xfer_cnt == 6'd0) begin      dma_acc_ovf <= dma_ovf;      dma_acc_unf <= dma_unf;    end else begin      dma_acc_ovf <= dma_acc_ovf | dma_ovf;      dma_acc_unf <= dma_acc_unf | dma_unf;    end  end  assign up_dma_xfer_toggle_s = up_dma_xfer_toggle_m2 ^ up_dma_xfer_toggle_m3;  always @(negedge up_rstn or posedge up_clk) begin    if (up_rstn == 0) begin      up_dma_xfer_toggle_m1 <= 'd0;      up_dma_xfer_toggle_m2 <= 'd0;      up_dma_xfer_toggle_m3 <= 'd0;      up_dma_xfer_ovf <= 'd0;      up_dma_xfer_unf <= 'd0;      up_dma_ovf <= 'd0;      up_dma_unf <= 'd0;      up_dma_status_m1 <= 'd0;      up_dma_status <= 'd0;    end else begin      up_dma_xfer_toggle_m1 <= dma_xfer_toggle;      up_dma_xfer_toggle_m2 <= up_dma_xfer_toggle_m1;      up_dma_xfer_toggle_m3 <= up_dma_xfer_toggle_m2;      if (up_dma_xfer_toggle_s == 1'b1) begin        up_dma_xfer_ovf <= dma_xfer_ovf;        up_dma_xfer_unf <= dma_xfer_unf;      end      if (up_dma_xfer_ovf == 1'b1) begin        up_dma_ovf <= 1'b1;      end else if ((up_wr_s == 1'b1) && (up_addr[7:0] == 8'h22)) begin        up_dma_ovf <= up_dma_ovf & ~up_wdata[2];      end      if (up_dma_xfer_unf == 1'b1) begin        up_dma_unf <= 1'b1;      end else if ((up_wr_s == 1'b1) && (up_addr[7:0] == 8'h22)) begin        up_dma_unf <= up_dma_unf & ~up_wdata[1];      end    end  end  always @(negedge up_rstn or posedge up_clk) begin    if (up_rstn == 0) begin      up_dma_status_m1 <= 'd0;      up_dma_status <= 'd0;    end else begin      up_dma_status_m1 <= dma_status;      up_dma_status <= up_dma_status_m1;    end  endendmodule"}
{"task_id": 1773, "completion": "parameter Tcq = 1;  input  [63:0] raddr;  input         rmem32;  input         rmem64;  input         rio;  input         rcheck_bus_id;  input         rcheck_dev_id;  input         rcheck_fun_id;  output        rhit;  output [6:0]  bar_hit;  output        cmmt_rbar_hit_lat2_n;  input  [15:0] command;  input  [31:0] bar0_reg;  input  [31:0] bar1_reg;  input  [31:0] bar2_reg;  input  [31:0] bar3_reg;  input  [31:0] bar4_reg;  input  [31:0] bar5_reg;  input  [31:0] xrom_reg;  input  [15:0] pme_pmcsr;  input   [7:0] bus_num;  input   [4:0] device_num;  input   [2:0] function_num;  input [671:0] cfg;  input         rst;  input         clk;  input   [1:0] phantom_functions_supported;  input         phantom_functions_enabled;  reg        rhit;  reg [6:0]  bar_hit;  reg        cmmt_rbar_hit_lat2_n;  wire allow_mem;  wire allow_io;  wire bar01_64;  wire bar12_64;  wire bar23_64;  wire bar34_64;  wire bar45_64;  assign allow_mem = command[1] & !pme_pmcsr[1] & !pme_pmcsr[0];  assign allow_io = command[0] & !pme_pmcsr[1] & !pme_pmcsr[0];  assign bar01_64 = (bar0_reg[2:0] == 3'b100);  assign bar12_64 = (bar1_reg[2:0] == 3'b100);  assign bar23_64 = (bar2_reg[2:0] == 3'b100);  assign bar34_64 = (bar3_reg[2:0] == 3'b100);  assign bar45_64 = (bar4_reg[2:0] == 3'b100);  wire bar0_32_hit;  wire bar1_32_hit;  wire bar2_32_hit;  wire bar3_32_hit;  wire bar4_32_hit;  wire bar5_32_hit;  wire bar6_32_hit;  reg  bar0_32_hit_nc;  reg  bar1_32_hit_nc;  reg  bar2_32_hit_nc;  reg  bar3_32_hit_nc;  reg  bar4_32_hit_nc;  reg  bar5_32_hit_nc;  reg  bar6_32_hit_nc;  reg  bar0_eq_raddr;  reg  bar1_eq_raddr;  reg  bar2_eq_raddr;  reg  bar3_eq_raddr;  reg  bar4_eq_raddr;  reg  bar5_eq_raddr;  reg  bar6_eq_raddr;  always @(posedge clk or posedge rst) begin  if (rst) begin  bar0_eq_raddr  <= #Tcq 0;  bar1_eq_raddr  <= #Tcq 0;  bar2_eq_raddr  <= #Tcq 0;  bar3_eq_raddr  <= #Tcq 0;  bar4_eq_raddr  <= #Tcq 0;  bar5_eq_raddr  <= #Tcq 0;  bar6_eq_raddr  <= #Tcq 0;  bar0_32_hit_nc <= #Tcq  0;  bar1_32_hit_nc <= #Tcq  0;  bar2_32_hit_nc <= #Tcq  0;  bar3_32_hit_nc <= #Tcq  0;  bar4_32_hit_nc <= #Tcq  0;  bar5_32_hit_nc <= #Tcq  0;  bar6_32_hit_nc <= #Tcq  0;  end  else begin  bar0_eq_raddr <= #Tcq ((raddr[63:36] & cfg[95:68])   == bar0_reg[31:4]);  bar1_eq_raddr <= #Tcq ((raddr[63:36] & cfg[127:100]) == bar1_reg[31:4]);  bar2_eq_raddr <= #Tcq ((raddr[63:36] & cfg[159:132]) == bar2_reg[31:4]);  bar3_eq_raddr <= #Tcq ((raddr[63:36] & cfg[191:164]) == bar3_reg[31:4]);  bar4_eq_raddr <= #Tcq ((raddr[63:36] & cfg[223:196]) == bar4_reg[31:4]);  bar5_eq_raddr <= #Tcq ((raddr[63:36] & cfg[255:228]) == bar5_reg[31:4]);  bar6_eq_raddr <= #Tcq ((raddr[63:43] & cfg[351:331]) == xrom_reg[31:11]);  bar0_32_hit_nc <= #Tcq  ((rmem32 & allow_mem & !cfg[64]) | (rio & allow_io & cfg[64])) & (|cfg[95:64]) & (!bar01_64 | (bar01_64 && (bar1_reg == 0)));  bar1_32_hit_nc <= #Tcq  ((rmem32 & allow_mem & !cfg[96]) | (rio & allow_io & cfg[96])) & (|cfg[127:96]) & (!bar12_64 | (bar12_64 && (bar2_reg == 0))) & (!bar01_64);  bar2_32_hit_nc <= #Tcq  ((rmem32 & allow_mem & !cfg[128]) | (rio & allow_io & cfg[128])) & (|cfg[159:128]) & (!bar23_64 | (bar23_64 && (bar3_reg == 0))) & (!bar12_64);  bar3_32_hit_nc <= #Tcq  ((rmem32 & allow_mem & !cfg[160]) | (rio & allow_io & cfg[160])) & (|cfg[191:160]) & (!bar34_64 | (bar34_64 && (bar4_reg == 0))) & (!bar23_64);  bar4_32_hit_nc <= #Tcq  ((rmem32 & allow_mem & !cfg[192]) | (rio & allow_io & cfg[192])) & (|cfg[224:192]) & (!bar45_64 | (bar45_64 && (bar5_reg == 0))) & (!bar34_64);  bar5_32_hit_nc <= #Tcq  (((rmem32 & allow_mem & !cfg[224]) | (rio & allow_io & cfg[224])) & (|cfg[255:224]) & !bar45_64);  bar6_32_hit_nc <= #Tcq   (rmem32 & xrom_reg[0] & allow_mem) & |cfg[351:327];  end  end  assign  bar0_32_hit = bar0_32_hit_nc & bar0_eq_raddr;  assign  bar1_32_hit = bar1_32_hit_nc & bar1_eq_raddr;  assign  bar2_32_hit = bar2_32_hit_nc & bar2_eq_raddr;  assign  bar3_32_hit = bar3_32_hit_nc & bar3_eq_raddr;  assign  bar4_32_hit = bar4_32_hit_nc & bar4_eq_raddr;  assign  bar5_32_hit = bar5_32_hit_nc & bar5_eq_raddr;  assign  bar6_32_hit = bar6_32_hit_nc & bar6_eq_raddr;  reg   bar01_64_hit_low;  reg   bar12_64_hit_low;  reg   bar23_64_hit_low;  reg   bar34_64_hit_low;  reg   bar45_64_hit_low;  reg   bar01_64_hit_high;  reg   bar12_64_hit_high;  reg   bar23_64_hit_high;  reg   bar34_64_hit_high;  reg   bar45_64_hit_high;  wire  bar01_64_hit;  wire  bar12_64_hit;  wire  bar23_64_hit;  wire  bar34_64_hit;  wire  bar45_64_hit;  assign  bar01_64_hit = bar01_64_hit_low &&  bar01_64_hit_high;  assign  bar12_64_hit = bar12_64_hit_low &&  bar12_64_hit_high;  assign  bar23_64_hit = bar23_64_hit_low &&  bar23_64_hit_high;  assign  bar34_64_hit = bar34_64_hit_low &&  bar34_64_hit_high;  assign  bar45_64_hit = bar45_64_hit_low &&  bar45_64_hit_high;  always @(posedge clk or posedge rst) begin  if (rst) begin  bar01_64_hit_low  <= #Tcq  0;  bar01_64_hit_high <= #Tcq  0;  bar12_64_hit_low  <= #Tcq  0;  bar12_64_hit_high <= #Tcq  0;  bar23_64_hit_low  <= #Tcq  0;  bar23_64_hit_high <= #Tcq  0;  bar34_64_hit_low  <= #Tcq  0;  bar34_64_hit_high <= #Tcq  0;  bar45_64_hit_low  <= #Tcq  0;  bar45_64_hit_high <= #Tcq  0;  end  else begin  bar01_64_hit_low  <= #Tcq  (rmem64 & allow_mem) & ((raddr[63:32] & cfg[127:96]) == bar1_reg[31:0]) & |cfg[127:96];  bar01_64_hit_high <= #Tcq  ((raddr[31:4] & cfg[95:68]) == bar0_reg[31:4]) &  bar01_64 & |cfg[95:64];  bar12_64_hit_low  <= #Tcq  (rmem64 & allow_mem) & ((raddr[63:32] & cfg[159:128]) == bar2_reg[31:0]) & |cfg[159:128];  bar12_64_hit_high <= #Tcq  ((raddr[31:4] & cfg[127:100]) == bar1_reg[31:4]) &  bar12_64 & |cfg[127:96];  bar23_64_hit_low  <= #Tcq  (rmem64 & allow_mem) & ((raddr[63:32] & cfg[191:160]) == bar3_reg[31:0]) & |cfg[191:160];  bar23_64_hit_high <= #Tcq  ((raddr[31:4] & cfg[159:132]) == bar2_reg[31:4]) &  bar23_64 & |cfg[159:128];  bar34_64_hit_low  <= #Tcq  (rmem64 & allow_mem) & ((raddr[63:32] & cfg[223:192]) == bar4_reg[31:0]) & |cfg[223:192];  bar34_64_hit_high <= #Tcq  ((raddr[31:4] & cfg[191:164]) == bar3_reg[31:4]) &  bar34_64 & |cfg[191:160];  bar45_64_hit_low  <= #Tcq  (rmem64 & allow_mem) & ((raddr[63:32] & cfg[255:224]) == bar5_reg[31:0]) & |cfg[255:224];  bar45_64_hit_high <= #Tcq  ((raddr[31:4] & cfg[223:196]) == bar4_reg[31:4]) &  bar45_64 & |cfg[223:192];  end  end  reg bdf_hit;  reg bdf_check;  reg phantom_function_check;  always @* begin  casex ({phantom_functions_enabled, phantom_functions_supported})  3'b0xx : phantom_function_check = (function_num[2:0] == raddr[50:48]);  3'b100 : phantom_function_check = (function_num[2:0] == raddr[50:48]);  3'b101 : phantom_function_check = (function_num[1:0] == raddr[49:48]);  3'b110 : phantom_function_check = (function_num[0]   == raddr[48]);  3'b111 : phantom_function_check = 1;  default: phantom_function_check = (function_num[2:0] == raddr[50:48]);  endcase  end  always @(posedge clk or posedge rst) begin  if (rst) begin   bdf_hit   <= #Tcq  0;   bdf_check <= #Tcq  0;  end else begin  bdf_hit <= #Tcq  ({bus_num,device_num} == raddr[63:51]) && phantom_function_check;  bdf_check <= #Tcq  rcheck_bus_id | rcheck_dev_id | rcheck_fun_id;  end  end  always@(posedge clk or posedge rst)  begin  if (rst) begin  rhit <= #Tcq  0;  end  else begin  rhit <= #Tcq  (bdf_hit && bdf_check) | bar01_64_hit | bar12_64_hit |  bar23_64_hit | bar34_64_hit | bar45_64_hit |  bar0_32_hit | bar1_32_hit | bar2_32_hit | bar3_32_hit |  bar4_32_hit | bar5_32_hit | bar6_32_hit;  end  end  always@(posedge clk or posedge rst)  begin  if (rst) begin  bar_hit[6:0] <= #Tcq 6'b000000;  cmmt_rbar_hit_lat2_n <= #Tcq 0;  end  else begin  bar_hit[0] <= #Tcq bar0_32_hit | bar01_64_hit;  bar_hit[1] <= #Tcq bar1_32_hit | bar12_64_hit | bar01_64_hit;  bar_hit[2] <= #Tcq bar2_32_hit | bar23_64_hit | bar12_64_hit;  bar_hit[3] <= #Tcq bar3_32_hit | bar34_64_hit | bar23_64_hit;  bar_hit[4] <= #Tcq bar4_32_hit | bar45_64_hit | bar34_64_hit;  bar_hit[5] <= #Tcq bar5_32_hit | bar45_64_hit;  bar_hit[6] <= #Tcq bar6_32_hit ;  cmmt_rbar_hit_lat2_n <= #Tcq 0;  end  end  endmodule"}
{"task_id": 1869, "completion": "wire [SW/2+1:0] result_A_adder;    wire [SW/2+1:0] result_B_adder;    wire [2*(SW/2)-1:0] Q_left;    wire [2*(SW/2+1)-1:0] Q_right;    wire [2*(SW/2+2)-1:0] Q_middle;    wire [2*(SW/2+2)-1:0] S_A;    wire [2*(SW/2+2)-1:0] S_B;    wire [4*(SW/2)+2:0] Result;    wire [1:0] zero1;    wire [3:0] zero2;    assign zero1 =2'b00;    assign zero2 =4'b0000;    wire [SW/2-1:0] rightside1;    wire [SW/2:0] rightside2;    wire [SW/2-3:0] leftside1;    wire [SW/2-4:0] leftside2;    wire [4*(SW/2)-1:0] sgf_r;     assign rightside1 = (SW/2) *1'b0;    assign rightside2 = (SW/2+1)*1'b0;    assign leftside1 = (SW/2-2) *1'b0;    assign leftside2 = (SW/2-3)*1'b0;    localparam half = SW/2;    generate        if (SW<=18) begin            multiplier_C #(.W(SW)) main(                .Data_A_i(Data_A_i),                .Data_B_i(Data_B_i),                .Data_S_o(sgf_result_o)            );        end else begin            case (SW%2)                0:begin                    KOA_FPGA #(.SW(SW/2)) left(                        .Data_A_i(Data_A_i[SW-1:SW-SW/2]),                        .Data_B_i(Data_B_i[SW-1:SW-SW/2]),                        .sgf_result_o(Q_left)                    );                    KOA_FPGA #(.SW(SW/2)) right(                        .Data_A_i(Data_A_i[SW-SW/2-1:0]),                        .Data_B_i(Data_B_i[SW-SW/2-1:0]),                        .sgf_result_o(Q_right[2*(SW/2)-1:0])                    );                    adder #(.W(SW/2)) A_operation (                        .Data_A_i(Data_A_i[SW-1:SW-SW/2]),                        .Data_B_i(Data_A_i[SW-SW/2-1:0]),                        .Data_S_o(result_A_adder[SW/2:0])                    );                    adder #(.W(SW/2)) B_operation (                        .Data_A_i(Data_B_i[SW-1:SW-SW/2]),                        .Data_B_i(Data_B_i[SW-SW/2-1:0]),                        .Data_S_o(result_B_adder[SW/2:0])                    );                    KOA_FPGA #(.SW(SW/2+1)) middle (                        .Data_A_i(result_A_adder[SW/2:0]),                        .Data_B_i(result_B_adder[SW/2:0]),                        .sgf_result_o(Q_middle[2*(SW/2)+1:0])                    );                    substractor #(.W(SW+2)) Subtr_1 (                        .Data_A_i(Q_middle[2*(SW/2)+1:0]),                        .Data_B_i({zero1, Q_left}),                        .Data_S_o(S_A[2*(SW/2)+1:0])                    );                    substractor #(.W(SW+2)) Subtr_2 (                        .Data_A_i(S_A[2*(SW/2)+1:0]),                        .Data_B_i({zero1, Q_right[2*(SW/2)-1:0]}),                        .Data_S_o(S_B[2*(SW/2)+1:0])                    );                    adder #(.W(4*(SW/2))) Final(                        .Data_A_i({Q_left,Q_right[2*(SW/2)-1:0]}),                        .Data_B_i({leftside1,S_B[2*(SW/2)+1:0],rightside1}),                        .Data_S_o(Result[4*(SW/2):0])                    );                    assign sgf_result_o = Result[2*SW-1:0];                end                1:begin                    KOA_FPGA #(.SW(SW/2)) left_high(                        .Data_A_i(Data_A_i[SW-1:SW/2+1]),                        .Data_B_i(Data_B_i[SW-1:SW/2+1]),                        .sgf_result_o(Q_left)                    );                    KOA_FPGA #(.SW((SW/2)+1)) right_lower(                        .Data_A_i(Data_A_i[SW/2:0]),                        .Data_B_i(Data_B_i[SW/2:0]),                        .sgf_result_o(Q_right)                    );                    adder #(.W(SW/2+1)) A_operation (                        .Data_A_i({1'b0,Data_A_i[SW-1:SW-SW/2]}),                        .Data_B_i(Data_A_i[SW-SW/2-1:0]),                        .Data_S_o(result_A_adder)                    );                    adder #(.W(SW/2+1)) B_operation (                        .Data_A_i({1'b0,Data_B_i[SW-1:SW-SW/2]}),                        .Data_B_i(Data_B_i[SW-SW/2-1:0]),                        .Data_S_o(result_B_adder)                    );                    KOA_FPGA #(.SW(SW/2+2)) middle (                        .Data_A_i(result_A_adder),                        .Data_B_i(result_B_adder),                        .sgf_result_o(Q_middle)                    );                    substractor #(.W(2*(SW/2+2))) Subtr_1 (                        .Data_A_i(Q_middle),                        .Data_B_i({zero2, Q_left}),                        .Data_S_o(S_A)                    );                    substractor #(.W(2*(SW/2+2))) Subtr_2 (                        .Data_A_i(S_A),                        .Data_B_i({zero1, Q_right}),                        .Data_S_o(S_B)                    );                    adder #(.W(4*(SW/2)+2)) Final(                        .Data_A_i({Q_left,Q_right}),                        .Data_B_i({leftside2,S_B,rightside2}),                        .Data_S_o(Result[4*(SW/2)+2:0])                    );                    assign sgf_result_o = Result[2*SW-1:0];                end            endcase        end    endgenerateendmodule"}
{"task_id": 1895, "completion": "reg s_axi_awready_i;\n  reg s_axi_wready_i;\n  reg s_axi_bvalid_i;\n  reg s_axi_arready_i;\n  reg s_axi_rvalid_i;\n  localparam P_WRITE_IDLE = 2'b00;\n  localparam P_WRITE_DATA = 2'b01;\n  localparam P_WRITE_RESP = 2'b10;\n  localparam P_READ_IDLE = 1'b0;\n  localparam P_READ_DATA = 1'b1;\n  localparam integer  P_AXI4 = 0;\n  localparam integer  P_AXI3 = 1;\n  localparam integer  P_AXILITE = 2;\n   \n  assign S_AXI_BRESP = C_RESP;\n  assign S_AXI_RRESP = C_RESP;\n  assign S_AXI_RDATA = {C_AXI_DATA_WIDTH{1'b0}};\n  assign S_AXI_BUSER = {C_AXI_BUSER_WIDTH{1'b0}};\n  assign S_AXI_RUSER = {C_AXI_RUSER_WIDTH{1'b0}};\n  assign S_AXI_AWREADY = s_axi_awready_i;\n  assign S_AXI_WREADY = s_axi_wready_i;\n  assign S_AXI_BVALID = s_axi_bvalid_i;\n  assign S_AXI_ARREADY = s_axi_arready_i;\n  assign S_AXI_RVALID = s_axi_rvalid_i;\n  generate\n  if (C_AXI_PROTOCOL == P_AXILITE) begin : gen_axilite\n    assign S_AXI_RLAST = 1'b1;\n    assign S_AXI_BID = 0;\n    assign S_AXI_RID = 0;\n    always @(posedge S_AXI_ACLK) begin\n      if (S_AXI_ARESET) begin\n        s_axi_awready_i <= 1'b0;\n        s_axi_wready_i <= 1'b0;\n        s_axi_bvalid_i <= 1'b0;\n      end else begin\n        if (s_axi_bvalid_i) begin\n          if (S_AXI_BREADY) begin\n            s_axi_bvalid_i <= 1'b0;\n          end\n        end else if (S_AXI_AWVALID & S_AXI_WVALID) begin\n          if (s_axi_awready_i) begin\n            s_axi_awready_i <= 1'b0;\n            s_axi_wready_i <= 1'b0;\n            s_axi_bvalid_i <= 1'b1;\n          end else begin\n            s_axi_awready_i <= 1'b1;\n            s_axi_wready_i <= 1'b1;\n          end\n        end\n      end\n    end\n    always @(posedge S_AXI_ACLK) begin\n      if (S_AXI_ARESET) begin\n        s_axi_arready_i <= 1'b0;\n        s_axi_rvalid_i <= 1'b0;\n      end else begin\n        if (s_axi_rvalid_i) begin\n          if (S_AXI_RREADY) begin\n            s_axi_rvalid_i <= 1'b0;\n          end\n        end else if (S_AXI_ARVALID & s_axi_arready_i) begin\n          s_axi_arready_i <= 1'b0;\n          s_axi_rvalid_i <= 1'b1;\n        end else begin\n          s_axi_arready_i <= 1'b1;\n        end\n      end\n    end\n  end else begin : gen_axi\n    reg s_axi_rlast_i;\n    reg [(C_AXI_ID_WIDTH-1):0] s_axi_bid_i;\n    reg [(C_AXI_ID_WIDTH-1):0] s_axi_rid_i;\n    reg [7:0] read_cnt;\n    reg [1:0] write_cs;\n    reg [0:0] read_cs;\n    assign S_AXI_RLAST = s_axi_rlast_i;\n    assign S_AXI_BID = s_axi_bid_i;\n    assign S_AXI_RID = s_axi_rid_i;\n    always @(posedge S_AXI_ACLK) begin\n      if (S_AXI_ARESET) begin\n        write_cs <= P_WRITE_IDLE;\n        s_axi_awready_i <= 1'b0;\n        s_axi_wready_i <= 1'b0;\n        s_axi_bvalid_i <= 1'b0;\n        s_axi_bid_i <= 0;\n      end else begin\n        case (write_cs) \n          P_WRITE_IDLE: \n            begin\n              if (S_AXI_AWVALID & s_axi_awready_i) begin\n                s_axi_awready_i <= 1'b0;\n                s_axi_bid_i <= S_AXI_AWID;\n                s_axi_wready_i <= 1'b1;\n                write_cs <= P_WRITE_DATA;\n              end else begin\n                s_axi_awready_i <= 1'b1;\n              end\n            end\n          P_WRITE_DATA:\n            begin\n              if (S_AXI_WVALID & S_AXI_WLAST) begin\n                s_axi_wready_i <= 1'b0;\n                s_axi_bvalid_i <= 1'b1;\n                write_cs <= P_WRITE_RESP;\n              end\n            end\n          P_WRITE_RESP:\n            begin\n              if (S_AXI_BREADY) begin\n                s_axi_bvalid_i <= 1'b0;\n                s_axi_awready_i <= 1'b1;\n                write_cs <= P_WRITE_IDLE;\n              end\n            end\n        endcase\n      end\n    end\n    always @(posedge S_AXI_ACLK) begin\n      if (S_AXI_ARESET) begin\n        read_cs <= P_READ_IDLE;\n        s_axi_arready_i <= 1'b0;\n        s_axi_rvalid_i <= 1'b0;\n        s_axi_rlast_i <= 1'b0;\n        s_axi_rid_i <= 0;\n        read_cnt <= 0;\n      end else begin\n        case (read_cs) \n          P_READ_IDLE: \n            begin\n              if (S_AXI_ARVALID & s_axi_arready_i) begin\n                s_axi_arready_i <= 1'b0;\n                s_axi_rid_i <= S_AXI_ARID;\n                read_cnt <= S_AXI_ARLEN;\n                s_axi_rvalid_i <= 1'b1;\n                if (S_AXI_ARLEN == 0) begin\n                  s_axi_rlast_i <= 1'b1;\n                end else begin\n                  s_axi_rlast_i <= 1'b0;\n                end\n                read_cs <= P_READ_DATA;\n              end else begin\n                s_axi_arready_i <= 1'b1;\n              end\n            end\n          P_READ_DATA:\n            begin\n              if (S_AXI_RREADY) begin\n                if (read_cnt == 0) begin\n                  s_axi_rvalid_i <= 1'b0;\n                  s_axi_rlast_i <= 1'b0;\n                  s_axi_arready_i <= 1'b1;\n                  read_cs <= P_READ_IDLE;\n                end else begin\n                  if (read_cnt == 1) begin\n                    s_axi_rlast_i <= 1'b1;\n                  end\n                  read_cnt <= read_cnt - 1;\n                end\n              end\n            end\n        endcase\n      end\n    end\n  end  \n  endgenerate\nendmodule"}
{"task_id": 1891, "completion": "parameter DEVICE_FAMILY = \"\";\n    parameter MEM_ADDRESS_WIDTH     = \"\"; \n    parameter MEM_BANK_WIDTH        = \"\"; \n    parameter MEM_CHIP_SELECT_WIDTH = \"\"; \n    parameter MEM_CLK_EN_WIDTH      = \"\"; \n    parameter MEM_CK_WIDTH          = \"\"; \n    parameter MEM_ODT_WIDTH        = \"\"; \n    parameter MEM_CONTROL_WIDTH     = \"\"; \n\n    parameter AFI_ADDRESS_WIDTH         = \"\"; \n    parameter AFI_BANK_WIDTH            = \"\"; \n    parameter AFI_CHIP_SELECT_WIDTH     = \"\"; \n    parameter AFI_CLK_EN_WIDTH          = \"\"; \n    parameter AFI_ODT_WIDTH             = \"\"; \n    parameter AFI_CONTROL_WIDTH         = \"\"; \n    parameter DLL_WIDTH = \"\";\n    parameter ADC_PHASE_SETTING = \"\";\n    parameter ADC_INVERT_PHASE = \"\";\n    parameter IS_HHP_HPS = \"\";\n\n    localparam CMD_WIDTH = \n        MEM_CHIP_SELECT_WIDTH + \n        MEM_CLK_EN_WIDTH + \n        MEM_ODT_WIDTH + \n        MEM_CONTROL_WIDTH + \n        MEM_CONTROL_WIDTH + \n        MEM_CONTROL_WIDTH; \n        \n    localparam AC_CLK_WIDTH = MEM_ADDRESS_WIDTH + MEM_BANK_WIDTH + CMD_WIDTH + 1;\n    localparam IMPLEMENT_MEM_CLK_IN_SOFT_LOGIC = \"false\";\n    wire [AC_CLK_WIDTH-1:0] ac_clk;\n    generate\n    genvar i;\n    for (i = 0; i < AC_CLK_WIDTH; i = i + 1)\n    begin: address_gen\n        wire addr_cmd_clk;\n        hps_sdram_p0_acv_ldc # (\n            .DLL_DELAY_CTRL_WIDTH(DLL_WIDTH),\n            .ADC_PHASE_SETTING(ADC_PHASE_SETTING),\n            .ADC_INVERT_PHASE(ADC_INVERT_PHASE),\n            .IS_HHP_HPS(IS_HHP_HPS)\n        ) acv_ac_ldc (\n            .pll_hr_clk(pll_avl_phy_clk),\n            .pll_dq_clk(pll_write_clk),\n            .pll_dqs_clk (pll_mem_clk),\n            .dll_phy_delayctrl(dll_delayctrl_in),\n            .adc_clk_cps(ac_clk[i])\n        );\n    end\n    endgenerate\n    hps_sdram_p0_generic_ddio uaddress_pad(\n        .datain(phy_ddio_address),\n        .halfratebypass(1'b1), \n        .dataout(phy_mem_address),\n        .clk_hr({MEM_ADDRESS_WIDTH{pll_hr_clk}}),\n        .clk_fr(ac_clk[MEM_ADDRESS_WIDTH-1:0])\n    );\n    defparam uaddress_pad.WIDTH = MEM_ADDRESS_WIDTH;\n    hps_sdram_p0_generic_ddio ubank_pad(\n        .datain(phy_ddio_bank),\n        .halfratebypass(1'b1), \n        .dataout(phy_mem_bank),\n        .clk_hr({MEM_BANK_WIDTH{pll_hr_clk}}),\n        .clk_fr(ac_clk[MEM_ADDRESS_WIDTH + MEM_BANK_WIDTH - 1: MEM_ADDRESS_WIDTH])\n    );\n    defparam ubank_pad.WIDTH = MEM_BANK_WIDTH;\n    hps_sdram_p0_generic_ddio ucmd_pad(\n        .datain({ \n            phy_ddio_we_n,\n            phy_ddio_cas_n,\n            phy_ddio_ras_n,\n            phy_ddio_odt,\n            phy_ddio_cke,\n            phy_ddio_cs_n\n        }),\n        .halfratebypass(1'b1), \n        .dataout({ \n            phy_mem_we_n,\n            phy_mem_cas_n,\n            phy_mem_ras_n,\n            phy_mem_odt,\n            phy_mem_cke,\n            phy_mem_cs_n\n        }),\n        .clk_hr({CMD_WIDTH{pll_hr_clk}}),\n        .clk_fr(ac_clk[MEM_ADDRESS_WIDTH + MEM_BANK_WIDTH + CMD_WIDTH - 1: MEM_ADDRESS_WIDTH + MEM_BANK_WIDTH])\n    );\n    defparam ucmd_pad.WIDTH = CMD_WIDTH;\n    hps_sdram_p0_generic_ddio ureset_n_pad(\n        .datain(phy_ddio_reset_n),\n        .halfratebypass(1'b1), \n        .dataout(phy_mem_reset_n),\n        .clk_hr(pll_hr_clk),\n        .clk_fr(ac_clk[MEM_ADDRESS_WIDTH + MEM_BANK_WIDTH + CMD_WIDTH])\n    );\n    defparam ureset_n_pad.WIDTH = 1;\n    wire [4:0] outputdelaysetting;\n    wire [4:0] outputenabledelaysetting;\n    wire outputhalfratebypass;\n    wire [4:0] inputdelaysetting;\n    wire [1:0] rfifo_clock_select;\n    wire [2:0] rfifo_mode;\n    wire    [MEM_CK_WIDTH-1:0] mem_ck_source;\n    wire    [MEM_CK_WIDTH-1:0] mem_ck;\n    generate\n    genvar clock_width;\n        for (clock_width=0; clock_width<MEM_CK_WIDTH; clock_width=clock_width+1)\n        begin: clock_gen\n            if(IMPLEMENT_MEM_CLK_IN_SOFT_LOGIC == \"true\")\n            begin\n                hps_sdram_p0_acv_ldc # (\n                    .DLL_DELAY_CTRL_WIDTH(DLL_WIDTH),\n                    .ADC_PHASE_SETTING(ADC_PHASE_SETTING),\n                    .ADC_INVERT_PHASE(ADC_INVERT_PHASE),\n                    .IS_HHP_HPS(IS_HHP_HPS)\n                ) acv_ck_ldc (\n                    .pll_hr_clk(pll_avl_phy_clk),\n                    .pll_dq_clk(pll_write_clk),\n                    .pll_dqs_clk (pll_mem_clk),\n                    .dll_phy_delayctrl(dll_delayctrl_in),\n                    .adc_clk_cps(mem_ck_source[clock_width])\n                );\n            end\n            else\n            begin\n                wire [3:0] phy_clk_in;\n                wire [3:0] phy_clk_out;\n                assign phy_clk_in = {pll_avl_phy_clk,pll_write_clk,pll_mem_clk,1'b0};\n\n                if (IS_HHP_HPS == \"true\") begin\n                    assign phy_clk_out = phy_clk_in;\n                end else begin\n                    cyclonev_phy_clkbuf phy_clkbuf (\n                        .inclk (phy_clk_in),\n                        .outclk (phy_clk_out)\n                    );\n                end\n                wire [3:0] leveled_dqs_clocks;\n                cyclonev_leveling_delay_chain leveling_delay_chain_dqs (\n                    .clkin (phy_clk_out[1]),\n                    .delayctrlin (dll_delayctrl_in),\n                    .clkout(leveled_dqs_clocks)\n                );\n                defparam leveling_delay_chain_dqs.physical_clock_source = \"DQS\";\n                cyclonev_clk_phase_select clk_phase_select_dqs (\n                    .clkin (leveled_dqs_clocks[0]),\n                    .clkout (mem_ck_source[clock_width])\n                );\n                defparam clk_phase_select_dqs.physical_clock_source = \"DQS\";\n                defparam clk_phase_select_dqs.use_phasectrlin = \"false\";\n                defparam clk_phase_select_dqs.phase_setting = 0;\n            end\n            wire mem_ck_hi;\n            wire mem_ck_lo;\n            if(IMPLEMENT_MEM_CLK_IN_SOFT_LOGIC == \"true\")\n            begin\n                assign mem_ck_hi = 1'b0;\n                assign mem_ck_lo = 1'b1;\n            end\n            else\n            begin\n                assign mem_ck_hi = phy_ddio_ck[0];\n                assign mem_ck_lo = phy_ddio_ck[1];\n            end\n            altddio_out umem_ck_pad(\n                .aclr       (1'b0),\n                .aset       (1'b0),\n                .datain_h   (mem_ck_hi),\n                .datain_l   (mem_ck_lo),\n                .dataout    (mem_ck[clock_width]),\n                .oe         (1'b1),\n                .outclock   (mem_ck_source[clock_width]),\n                .outclocken (1'b1)\n            );\n            defparam\n                umem_ck_pad.extend_oe_disable = \"UNUSED\",\n                umem_ck_pad.intended_device_family = DEVICE_FAMILY,\n                umem_ck_pad.invert_output = \"OFF\",\n                umem_ck_pad.lpm_hint = \"UNUSED\",\n                umem_ck_pad.lpm_type = \"altddio_out\",\n                umem_ck_pad.oe_reg = \"UNUSED\",\n                umem_ck_pad.power_up_high = \"OFF\",\n                umem_ck_pad.width = 1;\n            wire mem_ck_temp;\n            assign mem_ck_temp = mem_ck[clock_width];\n            hps_sdram_p0_clock_pair_generator uclk_generator(\n                .datain     (mem_ck_temp),\n                .dataout    (phy_mem_ck[clock_width]),\n                .dataout_b  (phy_mem_ck_n[clock_width])\n            );\n        end\n    endgenerate\n\nendmodule"}
{"task_id": 1983, "completion": "localparam DQ_PER_DQS = DQ_WIDTH / DQS_WIDTH;\nreg [DQ_WIDTH-1:0] fi_xor_data = {DQ_WIDTH{1'b0}};\ngenerate\nbegin\n  genvar i;\n  for (i = 0; i < DQS_WIDTH; i = i + 1) begin : assign_fi_xor_data\n    always @(posedge clk) begin\n      if (wrdata_en) begin\n        fi_xor_data[i*DQ_PER_DQS+:DQ_PER_DQS] <= {DQ_PER_DQS{1'b0}};\n      end\n      else if (fi_xor_we[i]) begin\n        fi_xor_data[i*DQ_PER_DQS+:DQ_PER_DQS] <= fi_xor_wrdata[i*DQ_PER_DQS+:DQ_PER_DQS];\n      end \n      else begin\n        fi_xor_data[i*DQ_PER_DQS+:DQ_PER_DQS] <= fi_xor_data[i*DQ_PER_DQS+:DQ_PER_DQS];\n      end\n    end\n  end\nend\nendgenerate\nassign wrdata_out[0+:DQ_WIDTH] = wrdata_in[0+:DQ_WIDTH] ^ fi_xor_data[0+:DQ_WIDTH]; \nassign wrdata_out[DQ_WIDTH+:(2*nCK_PER_CLK-1)*DQ_WIDTH] = wrdata_in[DQ_WIDTH+:(2*nCK_PER_CLK-1)*DQ_WIDTH];\nendmodule"}
{"task_id": 1857, "completion": "reg [31:0] cnt;\n\n    always @(posedge clk_cog)\n    if (nres)\n        cnt <= cnt + 1'b1;\n\n    reg ena_bus;\n\n    always @(posedge clk_cog or negedge nres)\n    if (!nres)\n        ena_bus <= 1'b0;\n    else\n        ena_bus <= !ena_bus;\n\n    reg [7:0] bus_sel;\n\n    always @(posedge clk_cog or negedge nres)\n    if (!nres)\n        bus_sel <= 8'b0;\n    else if (ena_bus)\n        bus_sel <= {bus_sel[6:0], ~|bus_sel[6:0]};\n\n    wire [7:0] bus_r;\n    wire [7:0] bus_e;\n    wire [7:0] bus_w;\n    wire [7:0] [1:0] bus_s;\n    wire [7:0] [15:0] bus_a;\n    wire [7:0] [31:0] bus_d;\n    wire [7:0] pll;\n    wire [7:0] [31:0] outx;\n    wire [7:0] [31:0] dirx;\n\n    genvar i;\n    generate\n        for (i=0; i<8; i++)\n        begin : coggen\n            cog cog_( .nres(nres),\n                       .clk_cog(clk_cog),\n                       .clk_pll(clk_pll),\n                       .ena_bus(ena_bus),\n                       .ptr_w(ptr_w[i]),\n                       .ptr_d(ptr_d),\n                       .ena(cog_ena[i]),\n                       .bus_sel(bus_sel[i]),\n                       .bus_r(bus_r[i]),\n                       .bus_e(bus_e[i]),\n                       .bus_w(bus_w[i]),\n                       .bus_s(bus_s[i]),\n                       .bus_a(bus_a[i]),\n                       .bus_d(bus_d[i]),\n                       .bus_q(bus_q),\n                       .bus_c(bus_c),\n                       .bus_ack(bus_ack[i]),\n                       .cnt(cnt),\n                       .pll_in(pll),\n                       .pll_out(pll[i]),\n                       .pin_in(pin_in),\n                       .pin_out(outx[i]),\n                       .pin_dir(dirx[i]) );\n        end\n    endgenerate\n\n    wire hub_bus_r = |bus_r;\n    wire hub_bus_e = |bus_e;\n    wire hub_bus_w = |bus_w;\n    wire [1:0] hub_bus_s = bus_s[7] | bus_s[6] | bus_s[5] | bus_s[4] | bus_s[3] | bus_s[2] | bus_s[1] | bus_s[0];\n    wire [15:0] hub_bus_a = bus_a[7] | bus_a[6] | bus_a[5] | bus_a[4] | bus_a[3] | bus_a[2] | bus_a[1] | bus_a[0];\n    wire [31:0] hub_bus_d = bus_d[7] | bus_d[6] | bus_d[5] | bus_d[4] | bus_d[3] | bus_d[2] | bus_d[1] | bus_d[0];\n    wire [31:0] bus_q;\n    wire bus_c;\n    wire [7:0] bus_ack;\n    wire [7:0] cog_ena;\n    wire [7:0] ptr_w;\n    wire [27:0] ptr_d;\n\n    hub hub_( .clk_cog(clk_cog),\n                .ena_bus(ena_bus),\n                .nres(nres),\n                .bus_sel(bus_sel),\n                .bus_r(hub_bus_r),\n                .bus_e(hub_bus_e),\n                .bus_w(hub_bus_w),\n                .bus_s(hub_bus_s),\n                .bus_a(hub_bus_a),\n                .bus_d(hub_bus_d),\n                .bus_q(bus_q),\n                .bus_c(bus_c),\n                .bus_ack(bus_ack),\n                .cog_ena(cog_ena),\n                .ptr_w(ptr_w),\n                .ptr_d(ptr_d),\n                .cfg(cfg) );\n\n    assign pin_out = outx[7] | outx[6] | outx[5] | outx[4] | outx[3] | outx[2] | outx[1] | outx[0];\n    assign pin_dir = dirx[7] | dirx[6] | dirx[5] | dirx[4] | dirx[3] | dirx[2] | dirx[1] | dirx[0];\n\n    assign cog_led = cog_ena;\n\nendmodule"}
{"task_id": 1933, "completion": "wire [SW/2+1:0] result_A_adder;\n    wire [SW/2+1:0] result_B_adder;\n\n    wire [2*(SW/2)-1:0] Q_left;\n    wire [2*(SW/2+1)-1:0] Q_right;\n    wire [2*(SW/2+2)-1:0] Q_middle;\n\n    wire [2*(SW/2+2)-1:0] S_A;\n    wire [2*(SW/2+2)-1:0] S_B;\n\n    wire [4*(SW/2)+2:0] Result;\n    ///////////////////////////////////////////////////////////\n    wire [1:0] zero1;\n    wire [3:0] zero2;\n    assign zero1 =2'b00;\n    assign zero2 =4'b0000;\n    ///////////////////////////////////////////////////////////\n    wire [SW/2-1:0] rightside1;\n    wire [SW/2:0] rightside2;\n    wire [SW/2-3:0] leftside1;\n    wire [SW/2-4:0] leftside2;\n\n    wire [4*(SW/2)-1:0] sgf_r; \n    assign rightside1 = (SW/2) *1'b0;\n    assign rightside2 = (SW/2+1)*1'b0;\n\n    assign leftside1 = (SW/2-2) *1'b0;\n    assign leftside2 = (SW/2-3)*1'b0;\n\n    localparam half = SW/2;\n    generate\n    if (SW<=3 && precision == 0) begin\n        multiplier_C #(.W(SW)) main(\n            .Data_A_i(Data_A_i),\n            .Data_B_i(Data_B_i),\n            .Data_S_o(sgf_result_o)\n        );\n    end if (SW<=7 && precision == 1) begin\n        multiplier_C #(.W(SW)) main(\n            .Data_A_i(Data_A_i),\n            .Data_B_i(Data_B_i),\n            .Data_S_o(sgf_result_o)\n        ); \n    end else begin\n    case (SW%2)\n        0:begin\n            KOA_c #(.SW(SW/2), .precision(precision)) left(\n                .Data_A_i(Data_A_i[SW-1:SW-SW/2]),\n                .Data_B_i(Data_B_i[SW-1:SW-SW/2]),\n                .sgf_result_o(Q_left)\n            );\n\n            KOA_c #(.SW(SW/2), .precision(precision)) right(\n                .Data_A_i(Data_A_i[SW-SW/2-1:0]),\n                .Data_B_i(Data_B_i[SW-SW/2-1:0]),\n                .sgf_result_o(Q_right[2*(SW/2)-1:0])\n            );          \n\n            adder #(.W(SW/2)) A_operation (\n                .Data_A_i(Data_A_i[SW-1:SW-SW/2]),\n                .Data_B_i(Data_A_i[SW-SW/2-1:0]),\n                .Data_S_o(result_A_adder[SW/2:0])\n            );\n        \n            adder #(.W(SW/2)) B_operation (\n                .Data_A_i(Data_B_i[SW-1:SW-SW/2]),\n                .Data_B_i(Data_B_i[SW-SW/2-1:0]),\n                .Data_S_o(result_B_adder[SW/2:0])\n            );\n\n             KOA_c #(.SW(SW/2+1), .precision(precision)) middle (\n                .Data_A_i(result_A_adder[SW/2:0]),\n                .Data_B_i(result_B_adder[SW/2:0]),\n                .sgf_result_o(Q_middle[2*(SW/2)+1:0])\n            );\n        \n            substractor #(.W(SW+2)) Subtr_1 (\n                .Data_A_i(Q_middle[2*(SW/2)+1:0]),\n                .Data_B_i({zero1, Q_left}),\n                .Data_S_o(S_A[2*(SW/2)+1:0])\n            );\n        \n            substractor #(.W(SW+2)) Subtr_2 (\n                .Data_A_i(S_A[2*(SW/2)+1:0]),\n                .Data_B_i({zero1, Q_right[2*(SW/2)-1:0]}),\n                .Data_S_o(S_B[2*(SW/2)+1:0])\n            );\n        \n            adder #(.W(4*(SW/2))) Final(\n                .Data_A_i({Q_left,Q_right[2*(SW/2)-1:0]}),\n                .Data_B_i({leftside1,S_B[2*(SW/2)+1:0],rightside1}),\n                .Data_S_o(Result[4*(SW/2):0])\n            );\n          \n            assign sgf_result_o = Result[2*SW-1:0];\n        end\n    1:begin\n        KOA_c #(.SW(SW/2), .precision(precision)) left_high(\n            .Data_A_i(Data_A_i[SW-1:SW/2+1]),\n            .Data_B_i(Data_B_i[SW-1:SW/2+1]),\n            .sgf_result_o(Q_left)\n        );\n        KOA_c #(.SW((SW/2)+1), .precision(precision)) right_lower(\n                .Data_A_i(Data_A_i[SW/2:0]),\n                .Data_B_i(Data_B_i[SW/2:0]),\n                .sgf_result_o(Q_right)\n            );       \n            adder #(.W(SW/2+1)) A_operation (\n                .Data_A_i({1'b0,Data_A_i[SW-1:SW-SW/2]}),\n                .Data_B_i(Data_A_i[SW-SW/2-1:0]),\n                .Data_S_o(result_A_adder)\n            );\n            \n            adder #(.W(SW/2+1)) B_operation (\n                .Data_A_i({1'b0,Data_B_i[SW-1:SW-SW/2]}),\n                .Data_B_i(Data_B_i[SW-SW/2-1:0]),\n                .Data_S_o(result_B_adder)\n            );\n            KOA_c #(.SW(SW/2+2), .precision(precision)) middle (\n                .Data_A_i(result_A_adder),\n                .Data_B_i(result_B_adder),\n                .sgf_result_o(Q_middle)\n            );\n            substractor #(.W(2*(SW/2+2))) Subtr_1 (\n                .Data_A_i(Q_middle),\n                .Data_B_i({zero2, Q_left}),\n                .Data_S_o(S_A)\n            );\n            substractor #(.W(2*(SW/2+2))) Subtr_2 (\n                .Data_A_i(S_A),\n                .Data_B_i({zero1, Q_right}),\n                .Data_S_o(S_B)\n            );\n            adder #(.W(4*(SW/2)+2)) Final(\n                .Data_A_i({Q_left,Q_right}),\n                .Data_B_i({leftside2,S_B,rightside2}),\n                .Data_S_o(Result[4*(SW/2)+2:0])\n            );\n            assign sgf_result_o = Result[2*SW-1:0];\n        end\n    endcase\n    end\nendgenerate\nendmodule"}
{"task_id": 1980, "completion": "dcfifo dcfifo_component (\n\t.wrclk (wrclk),\n\t.wrreq (wrreq),\n\t.data (data),\n\t.rdclk (rdclk),\n\t.rdreq (rdreq),\n\t.wrusedw (wrusedw),\n\t.wrfull (wrfull),\n\t.q (q),\n\t.rdusedw (rdusedw),\n\t.rdempty (rdempty)\n);\n\ndefparam\n\tdcfifo_component.intended_device_family = \"Cyclone II\",\n\tdcfifo_component.lpm_hint = \"MAXIMIZE_SPEED=5,\",\n\tdcfifo_component.lpm_numwords = 128,\n\tdcfifo_component.lpm_showahead = \"ON\",\n\tdcfifo_component.lpm_type = \"dcfifo\",\n\tdcfifo_component.lpm_width = DW,\n\tdcfifo_component.lpm_widthu = 7,\n\tdcfifo_component.overflow_checking = \"ON\",\n\tdcfifo_component.rdsync_delaypipe = 4,\n\tdcfifo_component.underflow_checking = \"ON\",\n\tdcfifo_component.use_eab = \"ON\",\n\tdcfifo_component.wrsync_delaypipe = 4;\n\nendmodule"}
{"task_id": 1965, "completion": "localparam TAP_CNT_LIMIT = 63;\n   localparam FREQ_REF_DIV           = (tCK > 5000 ? 4 :\n                                        tCK > 2500 ? 2 : 1);\n   localparam integer PHASER_TAP_RES = ((tCK/2)/64);\n   localparam CALC_TAP_CNT = (tCK >= 1250) ? 350 : 300;\n   localparam TAP_CNT = 0;\n   localparam TAP_DEC = (SIM_CAL_OPTION == \"FAST_CAL\") ? 0 : 29;\n   reg       delay_dec_done;\n   reg       delay_done_r1;\n   reg       delay_done_r2;\n   reg       delay_done_r3;\n   reg       delay_done_r4 /* synthesis syn_maxfan = 10 */;\n   reg [5:0] delay_cnt_r;\n   reg [5:0] delaydec_cnt_r;\n   reg       po_cnt_inc;\n   reg       po_cnt_dec;\n   reg [3:0] wait_cnt_r;\n   assign po_ck_addr_cmd_delay_done = ((TAP_CNT == 0) && (TAP_DEC == 0)) ? 1'b1 : delay_done_r4;\n   always @(posedge clk) begin\n     if (rst || po_cnt_dec || po_cnt_inc)\n       wait_cnt_r <= #TCQ 'd8;\n     else if (cmd_delay_start && (wait_cnt_r > 'd0))\n       wait_cnt_r <= #TCQ wait_cnt_r - 1;\n   end\n   always @(posedge clk) begin\n     if (rst || (delaydec_cnt_r > 6'd0) || (delay_cnt_r == 'd0) || (TAP_DEC == 0))\n       po_cnt_inc      <= #TCQ 1'b0;\n     else if ((delay_cnt_r > 'd0) && (wait_cnt_r == 'd1))\n       po_cnt_inc      <= #TCQ 1'b1;\n     else\n       po_cnt_inc      <= #TCQ 1'b0;\n   end\n   always @(posedge clk) begin\n     if (rst || (delaydec_cnt_r == 'd0))\n       po_cnt_dec      <= #TCQ 1'b0;\n     else if (cmd_delay_start && (delaydec_cnt_r > 'd0) && (wait_cnt_r == 'd1))\n       po_cnt_dec      <= #TCQ 1'b1;\n     else\n       po_cnt_dec      <= #TCQ 1'b0;\n   end\n   always @(posedge clk) begin\n     if (rst) begin\n       po_stg2_f_incdec <= #TCQ 1'b0;\n       po_en_stg2_f     <= #TCQ 1'b0;\n       po_stg2_c_incdec <= #TCQ 1'b0;\n       po_en_stg2_c     <= #TCQ 1'b0;\n     end else begin\n       if (po_cnt_dec) begin\n         po_stg2_f_incdec <= #TCQ 1'b0;\n         po_en_stg2_f     <= #TCQ 1'b1;\n       end else begin\n         po_stg2_f_incdec <= #TCQ 1'b0;\n         po_en_stg2_f     <= #TCQ 1'b0;\n       end\n       if (po_cnt_inc) begin\n         po_stg2_c_incdec <= #TCQ 1'b1;\n         po_en_stg2_c     <= #TCQ 1'b1;\n       end else begin\n         po_stg2_c_incdec <= #TCQ 1'b0;\n         po_en_stg2_c     <= #TCQ 1'b0;\n       end\n     end\n   end\n   always @(posedge clk) begin\n     if (rst || (tCK >= 2500) || (SIM_CAL_OPTION == \"FAST_CAL\"))\n       delay_cnt_r  <= #TCQ 'd0;\n     else if ((delaydec_cnt_r > 6'd0) ||((delay_cnt_r == 6'd0) && (ctl_lane_cnt != N_CTL_LANES-1)))\n       delay_cnt_r  <= #TCQ 'd1;\n     else if (po_cnt_inc && (delay_cnt_r > 6'd0))\n       delay_cnt_r  <= #TCQ delay_cnt_r - 1;\n   end\n   always @(posedge clk) begin\n     if (rst || ~cmd_delay_start ||((delaydec_cnt_r == 6'd0) && (delay_cnt_r == 6'd0) && (ctl_lane_cnt != N_CTL_LANES-1)))\n       delaydec_cnt_r  <= #TCQ TAP_DEC;\n     else if (po_cnt_dec && (delaydec_cnt_r > 6'd0))\n       delaydec_cnt_r  <= #TCQ delaydec_cnt_r - 1;\n   end\n   always @(posedge clk) begin\n     if (rst || ~cmd_delay_start )\n       ctl_lane_cnt <= #TCQ 6'b0;\n     else if (~delay_dec_done && (ctl_lane_cnt == N_CTL_LANES-1) && (delaydec_cnt_r == 6'd1))\n       ctl_lane_cnt <= #TCQ ctl_lane_cnt;\n     else if ((ctl_lane_cnt != N_CTL_LANES-1) && (delaydec_cnt_r == 6'd0) && (delay_cnt_r == 'd0))\n       ctl_lane_cnt <= #TCQ ctl_lane_cnt + 1;\n   end\n   always @(posedge clk) begin\n     if (rst || ~cmd_delay_start)  begin\n       delay_dec_done    <= #TCQ 1'b0;\n     end else if (((TAP_CNT == 0) && (TAP_DEC == 0)) ||\n                 ((delaydec_cnt_r == 6'd0) && (delay_cnt_r == 'd0) && (ctl_lane_cnt == N_CTL_LANES-1))) begin\n       delay_dec_done    <= #TCQ 1'b1;\n     end\n   end\n   always @(posedge clk) begin\n     delay_done_r1 <= #TCQ delay_dec_done;\n     delay_done_r2 <= #TCQ delay_done_r1;\n     delay_done_r3 <= #TCQ delay_done_r2;\n     delay_done_r4 <= #TCQ delay_done_r3;\n   end\nendmodule"}
{"task_id": 1783, "completion": "reg s_txc_axis_tready_nxt;\n   reg [1:0] s_txc_axis_tid_r, s_txc_axis_tid_r_nxt;\n   reg [7:0] txc_state, txc_state_nxt;\n   localparam  TXC_IDLE = 1,\n               TXC_APP0 = 2,\n               TXC_APP_REST = 4;\n   wire tid_fifo_full;\n   wire tid_fifo_empty;\n   wire [1:0] tid_fifo_dout;\n   reg tid_fifo_rd;\n   reg tid_fifo_wr;\n   rxs_tid_fifo_8x16 txc_tid_fifo(\n      .clk     (aclk),\n      .rst     (!aresetn),\n      .din     ({6'b0,s_txc_axis_tid_r_nxt}),\n      .wr_en   (tid_fifo_wr & !tid_fifo_full),\n      .rd_en   (tid_fifo_rd),\n      .dout    (tid_fifo_dout),\n      .full    (tid_fifo_full),\n      .empty   (tid_fifo_empty)\n   );\n   always @(*) begin\n      if(!aresetn)begin\n         s_txc_axis_tready_nxt = 0;\n         txc_state_nxt = 0;\n         s_txc_axis_tid_r_nxt = 0;\n         tid_fifo_wr = 0;\n      end\n      else begin\n         txc_state_nxt = txc_state;\n         s_txc_axis_tid_r_nxt = s_txc_axis_tid_r;\n         s_txc_axis_tready_nxt = s_txc_axis_tready;\n         tid_fifo_wr = 0;\n         case(txc_state)\n            TXC_IDLE: begin \n               if(s_txc_axis_tvalid && s_txc_axis_tready) begin \n                  txc_state_nxt = TXC_APP0;\n               end\n            end\n            TXC_APP0: begin\n               if(s_txc_axis_tvalid && s_txc_axis_tready) begin\n                  txc_state_nxt = TXC_APP_REST;\n                  s_txc_axis_tid_r_nxt = s_txc_axis_tdata[31:16];\n                  tid_fifo_wr = 1;\n               end\n            end\n            TXC_APP_REST: begin\n               if(s_txc_axis_tvalid && s_txc_axis_tlast && s_txc_axis_tready) begin \n                  txc_state_nxt = TXC_IDLE;\n                  s_txc_axis_tready_nxt = !tid_fifo_full;\n               end\n            end\n         endcase\n      end\n   end\n   always @(posedge aclk)begin\n      if(!aresetn)begin\n         txc_state <= TXC_IDLE;\n         s_txc_axis_tid_r <= 0;\n         s_txc_axis_tready <= 1;\n      end\n      else begin\n         txc_state <= txc_state_nxt;\n         s_txc_axis_tid_r <= s_txc_axis_tid_r_nxt;\n         s_txc_axis_tready <= s_txc_axis_tready_nxt;\n      end\n   end\n   reg [3:0] m_txd_axis_tvalid;\n   reg [31:0] m_txd_axis_tdata[3:0];\n   reg [3:0] m_txd_axis_tkeep[3:0];\n   reg [3:0] m_txd_axis_tlast;\n   reg [1:0] m_txd_axis_tid[3:0];\n   wire [3:0] m_txd_axis_tready;\n   always @(*)begin\n      if(!aresetn) begin\n         m_txd_axis_tvalid[0] = 0;\n         m_txd_axis_tvalid[1] = 0;\n         m_txd_axis_tvalid[2] = 0;\n         m_txd_axis_tvalid[3] = 0;\n         m_txd_axis_tdata[0] = 0;\n         m_txd_axis_tdata[1] = 0;\n         m_txd_axis_tdata[2] = 0;\n         m_txd_axis_tdata[3] = 0;\n         m_txd_axis_tkeep[0] = 0;\n         m_txd_axis_tkeep[1] = 0;\n         m_txd_axis_tkeep[2] = 0;\n         m_txd_axis_tkeep[3] = 0;\n         m_txd_axis_tlast[0] = 0;\n         m_txd_axis_tlast[1] = 0;\n         m_txd_axis_tlast[2] = 0;\n         m_txd_axis_tlast[3] = 0;\n         s_txd_axis_tready = 0;\n      end\n      else begin\n         m_txd_axis_tvalid[0] = 0;\n         m_txd_axis_tvalid[1] = 0;\n         m_txd_axis_tvalid[2] = 0;\n         m_txd_axis_tvalid[3] = 0;\n         m_txd_axis_tdata[0] = 0;\n         m_txd_axis_tdata[1] = 0;\n         m_txd_axis_tdata[2] = 0;\n         m_txd_axis_tdata[3] = 0;\n         m_txd_axis_tkeep[0] = 0;\n         m_txd_axis_tkeep[1] = 0;\n         m_txd_axis_tkeep[2] = 0;\n         m_txd_axis_tkeep[3] = 0;\n         m_txd_axis_tlast[0] = 0;\n         m_txd_axis_tlast[1] = 0;\n         m_txd_axis_tlast[2] = 0;\n         m_txd_axis_tlast[3] = 0;\n         s_txd_axis_tready = 0;\n         if(!tid_fifo_empty)begin\n            m_txd_axis_tvalid[tid_fifo_dout] = s_txd_axis_tvalid;\n            m_txd_axis_tdata[tid_fifo_dout] = s_txd_axis_tdata;\n            m_txd_axis_tkeep[tid_fifo_dout] = s_txd_axis_tkeep;\n            m_txd_axis_tlast[tid_fifo_dout] = s_txd_axis_tlast;\n            s_txd_axis_tready = m_txd_axis_tready[tid_fifo_dout];\n         end\n      end\n   end\n   always @(*) begin\n      if(!aresetn) begin\n         tid_fifo_rd = 0;\n      end\n      else begin \n         if(!tid_fifo_empty && s_txd_axis_tlast && s_txd_axis_tready)\n            tid_fifo_rd = 1;\n         else tid_fifo_rd = 0;\n      end\n   end\n   assign m_txd0_axis_tvalid = m_txd_axis_tvalid[0];\n   assign m_txd0_axis_tdata = m_txd_axis_tdata[0];\n   assign m_txd0_axis_tkeep = m_txd_axis_tkeep[0];\n   assign m_txd0_axis_tlast = m_txd_axis_tlast[0];\n   assign m_txd_axis_tready[0] = m_txd0_axis_tready;\n   assign m_txd1_axis_tvalid = m_txd_axis_tvalid[1];\n   assign m_txd1_axis_tdata = m_txd_axis_tdata[1];\n   assign m_txd1_axis_tkeep = m_txd_axis_tkeep[1];\n   assign m_txd1_axis_tlast = m_txd_axis_tlast[1];\n   assign m_txd_axis_tready[1] = m_txd1_axis_tready;\n   assign m_txd2_axis_tvalid = m_txd_axis_tvalid[2];\n   assign m_txd2_axis_tdata = m_txd_axis_tdata[2];\n   assign m_txd2_axis_tkeep = m_txd_axis_tkeep[2];\n   assign m_txd2_axis_tlast = m_txd_axis_tlast[2];\n   assign m_txd_axis_tready[2] = m_txd2_axis_tready;\n   assign m_txd3_axis_tvalid = m_txd_axis_tvalid[3];\n   assign m_txd3_axis_tdata = m_txd_axis_tdata[3];\n   assign m_txd3_axis_tkeep = m_txd_axis_tkeep[3];\n   assign m_txd3_axis_tlast = m_txd_axis_tlast[3];\n   assign m_txd_axis_tready[3] = m_txd3_axis_tready;\n   wire [3:0] m_txc_axis_tvalid;\n   wire [31:0] m_txc_axis_tdata[3:0];\n   wire [3:0] m_txc_axis_tkeep[3:0];\n   wire [3:0] m_txc_axis_tlast;\n   wire [1:0] m_txc_axis_tid[3:0];\n   wire [3:0] m_txc_axis_tready;\n   assign m_txc0_axis_tvalid = m_txc_axis_tvalid[0];\n   assign m_txc0_axis_tdata = m_txc_axis_tdata[0];\n   assign m_txc0_axis_tkeep = m_txc_axis_tkeep[0];\n   assign m_txc0_axis_tlast = m_txc_axis_tlast[0];\n   assign m_txc0_axis_tid = m_txc_axis_tid[0];\n   assign m_txc_axis_tready[0] = m_txc0_axis_tready;\n   assign m_txc1_axis_tvalid = m_txc_axis_tvalid[1];\n   assign m_txc1_axis_tdata = m_txc_axis_tdata[1];\n   assign m_txc1_axis_tkeep = m_txc_axis_tkeep[1];\n   assign m_txc1_axis_tlast = m_txc_axis_tlast[1];\n   assign m_txc1_axis_tid = m_txc_axis_tid[1];\n   assign m_txc_axis_tready[1] = m_txc1_axis_tready;\n   assign m_txc2_axis_tvalid = m_txc_axis_tvalid[2];\n   assign m_txc2_axis_tdata = m_txc_axis_tdata[2];\n   assign m_txc2_axis_tkeep = m_txc_axis_tkeep[2];\n   assign m_txc2_axis_tlast = m_txc_axis_tlast[2];\n   assign m_txc2_axis_tid = m_txc_axis_tid[2];\n   assign m_txc_axis_tready[2] = m_txc2_axis_tready;\n   assign m_txc3_axis_tvalid = m_txc_axis_tvalid[3];\n   assign m_txc3_axis_tdata = m_txc_axis_tdata[3];\n   assign m_txc3_axis_tkeep = m_txc_axis_tkeep[3];\n   assign m_txc3_axis_tlast = m_txc_axis_tlast[3];\n   assign m_txc3_axis_tid = m_txc_axis_tid[3];\n   assign m_txc_axis_tready[3] = m_txc3_axis_tready;\n   generate \n      genvar i;\n      for(i=0; i<4; i=i+1)begin:m_txc_ifs\n         dma_axis_control_if  \n         #(\n            .ENABLE_LEN    (0)\n         )dma_axis_control_if(\n            .m_axis_txd_tvalid            (m_txd_axis_tvalid[i]), \n            .m_axis_txd_tlast             (m_txd_axis_tlast[i]), \n            .m_axis_txd_tready            (m_txd_axis_tready[i]), \n            .m_axis_txc_aclk              (aclk), \n            .m_axis_txc_aresetn           (aresetn), \n            .m_axis_txc_tvalid            (m_txc_axis_tvalid[i]), \n            .m_axis_txc_tdata             (m_txc_axis_tdata[i]), \n            .m_axis_txc_tkeep             (m_txc_axis_tkeep[i]), \n            .m_axis_txc_tlast             (m_txc_axis_tlast[i]), \n            .m_axis_txc_tready            (m_txc_axis_tready[i]) \n         );\n      end\n   endgenerate\nendmodule"}
{"task_id": 1945, "completion": "reg [7:0] frame_data;\n\twire NotReady;\n\treg msg_r_p_signal;\n\treg msg_r_n_signal;\n\tparameter MSG_HEADER = 8'hF5;\n\tparameter MSG_SIZE = 8'h06;\n\tparameter ACK_SYM = 8'h5F;\n\tparameter NACK_SYM = 8'hAF;\n\tparameter DUMMY_WAIT = 8'h44;\n\tparameter TIME_OUT = 9'h150;\n\tparameter RETRY_MAX = 3'b011;\n\tparameter IDLE = 10'b00_0000_0001;\n\tparameter HEADER = 10'b00_0000_0010;\n\tparameter SIZE = 10'b00_0000_0100;\n\tparameter ADDR = 10'b00_0000_1000;\n\tparameter DATA_1 = 10'b00_0001_0000;\n\tparameter DATA_2 = 10'b00_0010_0000;\n\tparameter DATA_3 = 10'b00_0100_0000;\n\tparameter DATA_4 = 10'b00_1000_0000;\n\tparameter CRC = 10'b01_0000_0000;\n\tparameter WAIT_FOR_ACK = 10'b10_0000_0000;\n\treg [9:0] msg_framer_state;\n\treg [8:0] cnt;\n\twire [7:0] CRC8;\n\tCRC8_gen RCB_FRL_CRC_gen_inst (\n\t\t.D({MSG_SIZE,data_in[39:0]}), \n\t\t.NewCRC(CRC8)\n\t);\n\tassign NotReady = empty | (~training_done);\n\treg [3:0] retry_cnt;\n\talways@(posedge clkdiv) begin\n\t\tif (rst) begin\n\t\t\trden <= 1'b0;\n\t\t\tretry_cnt <= 3'b000;\n\t\t\tcnt <= 9'h000;\n\t\t\tframe_data[7:0] <= 8'h00;\n\t\t\tmsg_framer_state <= IDLE;\n\t\tend else begin\n\t\t\tcase(msg_framer_state)\n\t\t\t\tIDLE: begin\n\t\t\t\t\tcnt <= 9'h000;\n\t\t\t\t\tretry_cnt <= 3'b000;\n\t\t\t\t\tif(msg_r_p_signal) begin\n\t\t\t\t\t\trden <= 1'b0;\n\t\t\t\t\t\tframe_data[7:0] <= ACK_SYM;\n\t\t\t\t\t\tmsg_framer_state <= IDLE;\n\t\t\t\t\tend else if (msg_r_n_signal) begin\n\t\t\t\t\t\trden <= 1'b0;\n\t\t\t\t\t\tframe_data[7:0] <= NACK_SYM;\n\t\t\t\t\t\tmsg_framer_state <= IDLE;\n\t\t\t\t\tend else if (!NotReady) begin\n\t\t\t\t\t\trden <= 1'b1;\n\t\t\t\t\t\tframe_data[7:0] <= 8'h00;\n\t\t\t\t\t\tmsg_framer_state <= HEADER;\n\t\t\t\t\tend else begin\n\t\t\t\t\t\trden <= 1'b0;\n\t\t\t\t\t\tframe_data[7:0] <= 8'h00;\n\t\t\t\t\t\tmsg_framer_state <= IDLE;\n\t\t\t\t\tend\n\t\t\t\tend\n\n\t\t\t\tHEADER: begin\n\t\t\t\t\trden <= 1'b0;\n\t\t\t\t\tretry_cnt <= retry_cnt;\n\t\t\t\t\tcnt <= 9'h000;\n\t\t\t\t\tframe_data[7:0] <= MSG_HEADER;\n\t\t\t\t\tmsg_framer_state <= SIZE;\n\t\t\t\tend\n\n\t\t\t\tSIZE: begin\n\t\t\t\t\trden <= 1'b0;\n\t\t\t\t\tretry_cnt <= retry_cnt;\n\t\t\t\t\tcnt <= 9'h000;\n\t\t\t\t\tframe_data[7:0] <= MSG_SIZE;\n\t\t\t\t\tmsg_framer_state <= ADDR;\n\t\t\t\tend\n\n\t\t\t\tADDR: begin\n\t\t\t\t\trden <= 1'b0;\n\t\t\t\t\tretry_cnt <= retry_cnt;\n\t\t\t\t\tcnt <= 9'h000;\n\t\t\t\t\tframe_data[7:0] <= data_in[39:32];\n\t\t\t\t\tmsg_framer_state <= DATA_1;\n\t\t\t\tend\n\n\t\t\t\tDATA_1: begin\n\t\t\t\t\trden <= 1'b0;\n\t\t\t\t\tretry_cnt <= retry_cnt;\n\t\t\t\t\tcnt <= 9'h000;\n\t\t\t\t\tframe_data[7:0] <= data_in[31:24];\n\t\t\t\t\tmsg_framer_state <= DATA_2;\n\t\t\t\tend\n\n\t\t\t\tDATA_2: begin\n\t\t\t\t\trden <= 1'b0;\n\t\t\t\t\tretry_cnt <= retry_cnt;\n\t\t\t\t\tcnt <= 9'h000;\n\t\t\t\t\tframe_data[7:0] <= data_in[23:16];\n\t\t\t\t\tmsg_framer_state <= DATA_3;\n\t\t\t\tend\n\n\t\t\t\tDATA_3: begin\n\t\t\t\t\trden <= 1'b0;\n\t\t\t\t\tretry_cnt <= retry_cnt;\n\t\t\t\t\tcnt <= 9'h000;\n\t\t\t\t\tframe_data[7:0] <= data_in[15:8];\n\t\t\t\t\tmsg_framer_state <= DATA_4;\n\t\t\t\tend\n\n\t\t\t\tDATA_4: begin\n\t\t\t\t\trden <= 1'b0;\n\t\t\t\t\tretry_cnt <= retry_cnt;\n\t\t\t\t\tcnt <= 9'h000;\n\t\t\t\t\tframe_data[7:0] <= data_in[7:0];\n\t\t\t\t\tmsg_framer_state <= CRC;\n\t\t\t\tend\n\n\t\t\t\tCRC: begin\n\t\t\t\t\trden <= 1'b0;\n\t\t\t\t\tretry_cnt <= retry_cnt;\n\t\t\t\t\tcnt <= 9'h000;\n\t\t\t\t\tframe_data[7:0] <= CRC8;\n\t\t\t\t\tmsg_framer_state <= WAIT_FOR_ACK;\n\t\t\t\tend\n\n\t\t\t\tWAIT_FOR_ACK: begin\n\t\t\t\t\t\t\n\t\t\t\t\trden <= 1'b0;\n\t\t\t\t\t\tcnt <= cnt + 9'h001;\n\t\t\t\t\t\tif (cnt > 9'h001) begin\n\t\t\t\t\t\t\tif (msg_r_p_signal)\n\t\t\t\t\t\t\t\tframe_data[7:0] <= ACK_SYM;\n\t\t\t\t\t\t\telse if (msg_r_n_signal)\n\t\t\t\t\t\t\t\tframe_data[7:0] <= NACK_SYM;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tframe_data[7:0] <= DUMMY_WAIT;\n\t\t\t\t\t\tend else\n\t\t\t\t\t\t\tframe_data[7:0] <= DUMMY_WAIT;\n\t\t\t\t\t\tif (ack_r_one) begin\n\t\t\t\t\t\t\tretry_cnt <= 3'b000;\n\t\t\t\t\t\t\tmsg_framer_state <= IDLE;\n\t\t\t\t\t\tend else if ( nack_r_one | (cnt > TIME_OUT) ) begin\n\t\t\t\t\t\t\tif (retry_cnt >= RETRY_MAX) begin\n\t\t\t\t\t\t\t\tretry_cnt <= 3'b000;\n\t\t\t\t\t\t\t\tmsg_framer_state <= IDLE;\n\t\t\t\t\t\t\tend else begin\n\t\t\t\t\t\t\t\tretry_cnt <= retry_cnt + 3'b001;\n\t\t\t\t\t\t\t\tmsg_framer_state <= HEADER;\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\tend else begin\n\t\t\t\t\t\t\tretry_cnt <= retry_cnt;\n\t\t\t\t\t\t\tmsg_framer_state <= WAIT_FOR_ACK;\n\t\t\t\t\t\tend\n\t\t\t\t\tend\n\n\t\t\t\tdefault: begin\n\t\t\t\t\trden <= 1'b0;\n\t\t\t\t\tretry_cnt <= 3'b000;\n\t\t\t\t\tcnt <= 9'h000;\n\t\t\t\t\tframe_data[7:0] <= 8'h00;\n\t\t\t\t\tmsg_framer_state <= IDLE;\n\t\t\t\tend\n\t\t\tendcase\n\t\tend\n\tend\n\n\talways@(posedge clkdiv) begin\n\t\tif (rst) \n\t\t\tmsg_r_p_signal <= 1'b0;\n\t\telse if (msg_r_p_one)\n\t\t\tmsg_r_p_signal <= 1'b1;\n\t\telse if ( (msg_framer_state == IDLE) | ((msg_framer_state == WAIT_FOR_ACK)&(cnt > 9'h001)) )\n\t\t\tmsg_r_p_signal <= 1'b0;\n\t\telse\n\t\t\tmsg_r_p_signal <= msg_r_p_signal;\n\tend\n\n\talways@(posedge clkdiv) begin\n\t\tif (rst) \n\t\t\tmsg_r_n_signal <= 1'b0;\n\t\telse if (msg_r_n_one)\n\t\t\tmsg_r_n_signal <= 1'b1;\n\t\telse if ( (msg_framer_state == IDLE) | ((msg_framer_state == WAIT_FOR_ACK)&(cnt > 9'h001)) )\n\t\t\tmsg_r_n_signal <= 1'b0;\n\t\telse\n\t\t\tmsg_r_n_signal <= msg_r_n_signal;\n\tend\n\n\talways@(posedge clkdiv) begin\n\t\tif(rst)\n\t\t\ttxmsg_miss_one <= 1'b0;\n\t\telse if ( (retry_cnt >= RETRY_MAX) & (cnt > TIME_OUT | nack_r_one) )\n\t\t\ttxmsg_miss_one <= 1'b1;\n\t\telse\n\t\t\ttxmsg_miss_one <= 1'b0;\n\tend\n\n\talways@(posedge clkdiv) begin\n\t\tif(rst)\n\t\t\ttxmsg_pass_one <= 1'b0;\n\t\telse if ( (msg_framer_state == WAIT_FOR_ACK) & (ack_r_one) )\n\t\t\ttxmsg_pass_one <= 1'b1;\n\t\telse\n\t\t\ttxmsg_pass_one <= 1'b0;\n\tend\n\n\twire [7:0] data_to_oserdes;\n\tassign data_to_oserdes = training_done ? frame_data : 8'h5c;\n\t\n\tRCB_FRL_OSERDES_MSG RCB_FRL_OSERDES_MSG_inst (\n\t\t.OQ(OSER_OQ), \n\t\t.clk(clk), \n\t\t.clkdiv(clkdiv), \n\t\t.DI(data_to_oserdes), \n\t\t.OCE(1'b1), \n\t\t.SR(rst)\n\t);\n\nendmodule"}
{"task_id": 1860, "completion": "input fxclk_in, reset, clk_reset, pll_stop, dcm_progclk, dcm_progdata, dcm_progen, rd_clk, wr_clk, wr_start;\n    input [7:0] read;\n    output [7:0] write;\n\n    reg [3:0] rd_clk_b, wr_clk_b;\n    reg wr_start_b1, wr_start_b2, reset_buf;\n    reg dcm_progclk_buf, dcm_progdata_buf, dcm_progen_buf;\n    reg [4:0] wr_delay;\n    reg [351:0] inbuf, inbuf_tmp;\n    reg [127:0] outbuf;\n    reg [7:0] read_buf, write_buf;\n    reg [31:0] golden_nonce1, golden_nonce2;\n    \n    wire fxclk, clk, dcm_clk, pll_fb, pll_clk0, dcm_locked, pll_reset;\n    wire [2:1] dcm_status;\n    wire [31:0] golden_nonce, nonce2, hash2;\n    \n    miner253 m (\n        .clk(clk),\n        .reset(reset_buf),\n        .midstate(inbuf[351:96]),\n        .data(inbuf[95:0]),\n        .golden_nonce(golden_nonce),\n        .nonce2(nonce2),\n        .hash2(hash2)\n    );\n\n    BUFG bufg_fxclk (\n          .I(fxclk_in),\n          .O(fxclk)\n        );\n\n    BUFG bufg_clk (\n          .I(pll_clk0),\n          .O(clk)\n        );\n\n        DCM_CLKGEN #(\n      .CLKFX_DIVIDE(4.0),\n          .CLKFX_MULTIPLY(32),\n          .CLKFXDV_DIVIDE(2),\n          .CLKIN_PERIOD(20.8333)\n    ) \n    dcm0 (\n          .CLKIN(fxclk),\n          .CLKFXDV(dcm_clk),\n          .FREEZEDCM(1'b0),\n          .PROGCLK(dcm_progclk_buf),\n          .PROGDATA(dcm_progdata_buf),\n          .PROGEN(dcm_progen_buf),\n          .LOCKED(dcm_locked),\n          .STATUS(dcm_status),\n          .RST(clk_reset)\n    );\n\n    PLL_BASE #(\n        .BANDWIDTH(\"LOW\"),\n        .CLKFBOUT_MULT(4),\n        .CLKOUT0_DIVIDE(4),\n        .CLKOUT0_DUTY_CYCLE(0.5),\n        .CLK_FEEDBACK(\"CLKFBOUT\"), \n        .COMPENSATION(\"INTERNAL\"),\n        .DIVCLK_DIVIDE(1),\n        .REF_JITTER(0.10),\n        .RESET_ON_LOSS_OF_LOCK(\"FALSE\")\n   )\n   pll0 (\n        .CLKFBOUT(pll_fb),\n        .CLKOUT0(pll_clk0),\n        .CLKFBIN(pll_fb),\n        .CLKIN(dcm_clk),\n        .RST(pll_reset)\n    );\n\n    assign write = write_buf;\n    assign pll_reset = pll_stop | ~dcm_locked | clk_reset | dcm_status[2];\n    \n    always @ (posedge clk)\n    begin\n            if ( (rd_clk_b[3] == rd_clk_b[2]) && (rd_clk_b[2] == rd_clk_b[1]) && (rd_clk_b[1] != rd_clk_b[0]) )\n        begin\n            inbuf_tmp[351:344] <= read_buf;\n            inbuf_tmp[343:0] <= inbuf_tmp[351:8];\n        end;\n        inbuf <= inbuf_tmp;\n            \n        if ( wr_start_b1 && wr_start_b2 )\n        begin\n                wr_delay <= 5'd0;\n        end else \n        begin\n            wr_delay[0] <= 1'b1;\n            wr_delay[4:1] <= wr_delay[3:0];\n        end\n        \n        if ( ! wr_delay[4] ) \n        begin\n            outbuf <= { golden_nonce2, hash2, nonce2, golden_nonce1 };\n        end else\n        begin\n            if ( (wr_clk_b[3] == wr_clk_b[2]) && (wr_clk_b[2] == wr_clk_b[1]) && (wr_clk_b[1] != wr_clk_b[0]) ) \n                outbuf[119:0] <= outbuf[127:8];\n        end\n        \n        if ( reset_buf )\n        begin\n            golden_nonce2 <= 32'd0;\n            golden_nonce1 <= 32'd0;\n        end else if ( golden_nonce != golden_nonce1 ) \n        begin\n            golden_nonce2 <= golden_nonce1;\n            golden_nonce1 <= golden_nonce;\n        end\n\n        read_buf <= read;\n        write_buf <= outbuf[7:0];\n\n        rd_clk_b[0] <= rd_clk;\n        rd_clk_b[3:1] <= rd_clk_b[2:0];\n\n        wr_clk_b[0] <= wr_clk;\n        wr_clk_b[3:1] <= wr_clk_b[2:0];\n\n        wr_start_b1 <= wr_start;\n        wr_start_b2 <= wr_start_b1;\n            \n        reset_buf <= reset;\n    end\n\n    always @ (posedge fxclk)\n    begin\n        dcm_progclk_buf <= dcm_progclk;\n        dcm_progdata_buf <= dcm_progdata;\n        dcm_progen_buf <= dcm_progen;\n    end\n\nendmodule"}
{"task_id": 1978, "completion": "wire [SW/2+1:0] result_A_adder;    wire [SW/2+1:0] result_B_adder;    wire [2*(SW/2)-1:0] Q_left;    wire [2*(SW/2+1)-1:0] Q_right;    wire [2*(SW/2+2)-1:0] Q_middle;    wire [2*(SW/2+2)-1:0] S_A;    wire [2*(SW/2+2)-1:0] S_B;    wire [4*(SW/2)+2:0] Result;    wire [1:0] zero1;    wire [3:0] zero2;    assign zero1 =2'b00;    assign zero2 =4'b0000;    wire [SW/2-1:0] rightside1;    wire [SW/2:0] rightside2;    wire [SW/2-3:0] leftside1;    wire [SW/2-4:0] leftside2;    wire [4*(SW/2)-1:0] sgf_r;     assign rightside1 = (SW/2) *1'b0;    assign rightside2 = (SW/2+1)*1'b0;    assign leftside1 = (SW/2-2) *1'b0;    assign leftside2 = (SW/2-3)*1'b0;    localparam half = SW/2;    generate        if (SW<=3 && precision == 0) begin            multiplier_C #(.W(SW)/*,.level(level1)*/) main(                .Data_A_i(Data_A_i),                .Data_B_i(Data_B_i),                .Data_S_o(sgf_result_o)            );        end if (SW<=7 && precision == 1) begin            multiplier_C #(.W(SW)/*,.level(level1)*/) main(                .Data_A_i(Data_A_i),                .Data_B_i(Data_B_i),                .Data_S_o(sgf_result_o)            );        end else begin            case (SW%2)                0:begin                    KOA_c #(.SW(SW/2), .precision(precision) /*,.level(level1)*/) left(                        .Data_A_i(Data_A_i[SW-1:SW-SW/2]),                        .Data_B_i(Data_B_i[SW-1:SW-SW/2]),                        .sgf_result_o(/*result_left_mult*/Q_left)                    );                    KOA_c #(.SW(SW/2), .precision(precision)/*,.level(level1)*/) right(                        .Data_A_i(Data_A_i[SW-SW/2-1:0]),                        .Data_B_i(Data_B_i[SW-SW/2-1:0]),                        .sgf_result_o(/*result_right_mult[2*(SW/2)-1:0]*/Q_right[2*(SW/2)-1:0])                    );                    adder #(.W(SW/2)) A_operation (                        .Data_A_i(Data_A_i[SW-1:SW-SW/2]),                        .Data_B_i(Data_A_i[SW-SW/2-1:0]),                        .Data_S_o(result_A_adder[SW/2:0])                    );                    adder #(.W(SW/2)) B_operation (                        .Data_A_i(Data_B_i[SW-1:SW-SW/2]),                        .Data_B_i(Data_B_i[SW-SW/2-1:0]),                        .Data_S_o(result_B_adder[SW/2:0])                    );                    KOA_c        #(.SW(SW/2+1), .precision(precision)/*,.level(level1)*/) middle (                        .Data_A_i(/*Q_result_A_adder[SW/2:0]*/result_A_adder[SW/2:0]),                        .Data_B_i(/*Q_result_B_adder[SW/2:0]*/result_B_adder[SW/2:0]),                        .sgf_result_o(/*result_middle_mult[2*(SW/2)+1:0]*/Q_middle[2*(SW/2)+1:0])                    );                    substractor #(.W(SW+2)) Subtr_1 (                        .Data_A_i(/*result_middle_mult//*/Q_middle[2*(SW/2)+1:0]),                        .Data_B_i({zero1, /*result_left_mult//*/Q_left}),                        .Data_S_o(S_A[2*(SW/2)+1:0])                    );                    substractor #(.W(SW+2)) Subtr_2 (                        .Data_A_i(S_A[2*(SW/2)+1:0]),                        .Data_B_i({zero1, /*result_right_mult//*/Q_right[2*(SW/2)-1:0]}),                        .Data_S_o(S_B[2*(SW/2)+1:0])                    );                    adder #(.W(4*(SW/2))) Final(                        .Data_A_i({/*result_left_mult,result_right_mult*/Q_left,Q_right[2*(SW/2)-1:0]}),                        .Data_B_i({leftside1,S_B[2*(SW/2)+1:0],rightside1}),                        .Data_S_o(Result[4*(SW/2):0])                    );                    assign sgf_result_o = Result[2*SW-1:0];                end                1:begin                    KOA_c      #(.SW(SW/2), .precision(precision)/*,.level(level2)*/) left_high(                        .Data_A_i(Data_A_i[SW-1:SW/2+1]),                        .Data_B_i(Data_B_i[SW-1:SW/2+1]),                        .sgf_result_o(/*result_left_mult*/Q_left)                    );                    KOA_c #(.SW((SW/2)+1), .precision(precision)/*,.level(level2)*/) right_lower(                        .Data_A_i(Data_A_i[SW/2:0]),                        .Data_B_i(Data_B_i[SW/2:0]),                        .sgf_result_o(/*result_right_mult*/Q_right)                    );                    adder #(.W(SW/2+1)) A_operation (                        .Data_A_i({1'b0,Data_A_i[SW-1:SW-SW/2]}),                        .Data_B_i(Data_A_i[SW-SW/2-1:0]),                        .Data_S_o(result_A_adder)                    );                    adder #(.W(SW/2+1)) B_operation (                        .Data_A_i({1'b0,Data_B_i[SW-1:SW-SW/2]}),                        .Data_B_i(Data_B_i[SW-SW/2-1:0]),                        .Data_S_o(result_B_adder)                    );                    KOA_c #(.SW(SW/2+2), .precision(precision)/*,.level(level2)*/) middle (                        .Data_A_i(/*Q_result_A_adder*/result_A_adder),                        .Data_B_i(/*Q_result_B_adder*/result_B_adder),                        .sgf_result_o(/*result_middle_mult*/Q_middle)                    );                    substractor #(.W(2*(SW/2+2))) Subtr_1 (                        .Data_A_i(/*result_middle_mult//*/Q_middle),                        .Data_B_i({zero2, /*result_left_mult//*/Q_left}),                        .Data_S_o(S_A)                    );                    substractor #(.W(2*(SW/2+2))) Subtr_2 (                        .Data_A_i(S_A),                        .Data_B_i({zero1, /*result_right_mult//*/Q_right}),                        .Data_S_o(S_B)                    );                    adder #(.W(4*(SW/2)+2)) Final(                        .Data_A_i({/*result_left_mult,result_right_mult*/Q_left,Q_right}),                        .Data_B_i({leftside2,S_B,rightside2}),                        .Data_S_o(Result[4*(SW/2)+2:0])                    );                    assign sgf_result_o = Result[2*SW-1:0];                end            endcase        end    endgenerateendmodule"}
{"task_id": 1986, "completion": "parameter\tCLOCK_CYCLES_FOR_IDLE_STATE\t\t= 7'h7F;\nparameter\tIC\t\t\t\t\t\t\t= 7;\nparameter\tIDLE_COUNTER_INCREMENT\t= 7'h01;\nparameter\tCLOCK_CYCLES_FOR_OPERATION_STATE\t= 3;\nparameter\tCLOCK_CYCLES_FOR_ENABLE_STATE\t= 15;\nparameter\tCLOCK_CYCLES_FOR_HOLD_STATE\t= 1;\nparameter\tSC\t\t\t\t\t\t\t= 4;\nparameter\tCOUNTER_INCREMENT\t= 4'h1;\n\nparameter\tLCD_STATE_4_IDLE\t= 3'h4,\n\t\t\tLCD_STATE_0_OPERATION\t= 3'h0,\n\t\t\tLCD_STATE_1_ENABLE\t= 3'h1,\n\t\t\tLCD_STATE_2_HOLD\t= 3'h2,\n\t\t\tLCD_STATE_3_END\t= 3'h3;\n\nreg\t[7:0]\tdata_to_lcd;\nreg\t[IC:1]\tidle_counter;\nreg\t[SC:1]\tstate_0_counter;\nreg\t[SC:1]\tstate_1_counter;\nreg\t[SC:1]\tstate_2_counter;\nreg\t[2:0]\tns_lcd;\nreg\t[2:0]\ts_lcd;\n\nalways @(posedge clk)\nbegin\n\tif (reset)\n\t\ts_lcd <= LCD_STATE_4_IDLE;\n\telse\n\t\ts_lcd <= ns_lcd;\nend\n\nalways @(*)\nbegin\n\tns_lcd = LCD_STATE_4_IDLE;\n\n   case (s_lcd)\n\tLCD_STATE_4_IDLE:\n\t\tbegin\n\t\t\tif ((idle_counter == CLOCK_CYCLES_FOR_IDLE_STATE) & enable)\n\t\t\t\tns_lcd = LCD_STATE_0_OPERATION;\n\t\t\telse\n\t\t\t\tns_lcd = LCD_STATE_4_IDLE;\n\t\tend\n\tLCD_STATE_0_OPERATION:\n\t\tbegin\n\t\t\tif (state_0_counter == CLOCK_CYCLES_FOR_OPERATION_STATE)\n\t\t\t\tns_lcd = LCD_STATE_1_ENABLE;\n\t\t\telse\n\t\t\t\tns_lcd = LCD_STATE_0_OPERATION;\n\t\tend\n\tLCD_STATE_1_ENABLE:\n\t\tbegin\n\t\t\tif (state_1_counter == CLOCK_CYCLES_FOR_ENABLE_STATE)\n\t\t\t\tns_lcd = LCD_STATE_2_HOLD;\n\t\t\telse\n\t\t\t\tns_lcd = LCD_STATE_1_ENABLE;\n\t\tend\n\tLCD_STATE_2_HOLD:\n\t\tbegin\n\t\t\tif (state_2_counter == CLOCK_CYCLES_FOR_HOLD_STATE)\n\t\t\t\tns_lcd = LCD_STATE_3_END;\n\t\t\telse\n\t\t\t\tns_lcd = LCD_STATE_2_HOLD;\n\t\tend\n\tLCD_STATE_3_END:\n\t\tbegin\n\t\t\tif (enable == 1'b0)\n\t\t\t\tns_lcd = LCD_STATE_4_IDLE;\n\t\t\telse\n\t\t\t\tns_lcd = LCD_STATE_3_END;\n\t\tend\n\tdefault:\n\t\tbegin\n\t\t\tns_lcd = LCD_STATE_4_IDLE;\n\t\tend\n\tendcase\nend\n\nalways @(posedge clk)\nbegin\n\tif (reset)\n\tbegin\n\t\tLCD_ON\t<= 1'b0;\n\t\tLCD_BLON <= 1'b0;\n\tend\n\telse\n\tbegin\n\t\tLCD_ON\t<= display_on;\n\t\tLCD_BLON <= back_light_on;\n\tend\nend\n\nalways @(posedge clk)\nbegin\n\tif (reset)\n\tbegin\n\t\tLCD_EN\t\t<= 1'b0;\n\t\tLCD_RS\t\t<= 1'b0;\n\t\tLCD_RW\t\t<= 1'b0;\n\t\tdata_out\t<= 8'h00;\n\t\ttransfer_complete\t<= 1'b0;\n\tend\n\telse\n\tbegin\n\t\tif (s_lcd == LCD_STATE_1_ENABLE)\n\t\t\tLCD_EN\t<= 1'b1;\n\t\telse\n\t\t\tLCD_EN\t<= 1'b0;\n\n\t\tif (s_lcd == LCD_STATE_4_IDLE)\n\t\tbegin\n\t\t\tLCD_RS\t<= rs;\n\t\t\tLCD_RW\t<= rw;\n\t\t\tdata_to_lcd <= data_in;\n\t\tend\n\n\t\tif (s_lcd == LCD_STATE_1_ENABLE)\n\t\t\tdata_out\t<= LCD_DATA;\n\n\t\tif (s_lcd == LCD_STATE_3_END)\n\t\t\ttransfer_complete\t<= 1'b1;\n\t\telse\n\t\t\ttransfer_complete\t<= 1'b0;\n\tend\nend\n\nalways @(posedge clk)\nbegin\n\tif (reset)\n\t\tidle_counter <= {IC{1'b0}};\n\telse if (s_lcd == LCD_STATE_4_IDLE)\n\t\tidle_counter <= idle_counter + IDLE_COUNTER_INCREMENT;\n\telse\n\t\tidle_counter <= {IC{1'b0}};\nend\n\nalways @(posedge clk)\nbegin\n\tif (reset)\n\tbegin\n\t\tstate_0_counter <= {SC{1'b0}};\n\t\tstate_1_counter <= {SC{1'b0}};\n\t\tstate_2_counter <= {SC{1'b0}};\n\tend\n\telse\n\tbegin\n\t\tif (s_lcd == LCD_STATE_0_OPERATION)\n\t\t\tstate_0_counter <= state_0_counter + COUNTER_INCREMENT;\n\t\telse\n\t\t\tstate_0_counter <= {SC{1'b0}};\n\n\t\tif (s_lcd == LCD_STATE_1_ENABLE)\n\t\t\tstate_1_counter <= state_1_counter + COUNTER_INCREMENT;\n\t\telse\n\t\t\tstate_1_counter <= {SC{1'b0}};\n\n\t\tif (s_lcd == LCD_STATE_2_HOLD)\n\t\t\tstate_2_counter <= state_2_counter + COUNTER_INCREMENT;\n\t\telse\n\t\t\tstate_2_counter <= {SC{1'b0}};\n\tend\nend\n\nassign LCD_DATA\t= \n\t\t(((s_lcd == LCD_STATE_1_ENABLE) ||\n\t\t  (s_lcd == LCD_STATE_2_HOLD)) &&\n\t\t  (LCD_RW == 1'b0)) ? data_to_lcd : 8'hzz;\n\nendmodule"}
{"task_id": 1311, "completion": "parameter TCQ = 1;\n  localparam USERCLK2_FREQ = (USER_CLK2_DIV2 == \"FALSE\") ? USER_CLK_FREQ :\n                                (USER_CLK_FREQ == 4) ? 3 :\n                                (USER_CLK_FREQ == 3) ? 2 :\n                                 USER_CLK_FREQ;\n\n  localparam PCIE_LPM_DFE = (PL_FAST_TRAIN == \"TRUE\") ? \"DFE\" : \"LPM\";\n  localparam PCIE_LINK_SPEED = (PL_FAST_TRAIN == \"TRUE\") ? 2 : 3;\n  localparam PCIE_OOBCLK_MODE_ENABLE = (PL_FAST_TRAIN == \"TRUE\") ? 0 : 1;\n  localparam PCIE_TX_EIDLE_ASSERT_DELAY = (PL_FAST_TRAIN == \"TRUE\") ? 4 : 2;\n  wire [  7:0] gt_rx_phy_status_wire;\n  wire [  7:0] gt_rxchanisaligned_wire;\n  wire [ 31:0] gt_rx_data_k_wire;\n  wire [255:0] gt_rx_data_wire;\n  wire [  7:0] gt_rx_elec_idle_wire;\n  wire [ 23:0] gt_rx_status_wire;\n  wire [  7:0] gt_rx_valid_wire;\n  wire [  7:0] gt_rx_polarity;\n  wire [ 15:0] gt_power_down;\n  wire [  7:0] gt_tx_char_disp_mode;\n  wire [ 31:0] gt_tx_data_k;\n  wire [255:0] gt_tx_data;\n  wire gt_tx_detect_rx_loopback;\n  wire [  7:0] gt_tx_elec_idle;\n  wire [  7:0] gt_rx_elec_idle_reset;\n  wire [LINK_CAP_MAX_LINK_WIDTH-1:0] plllkdet;\n  wire [LINK_CAP_MAX_LINK_WIDTH-1:0] phystatus_rst;\n  wire clock_locked;\n  wire [  7:0] gt_rx_phy_status_wire_filter;\n  wire [ 31:0] gt_rx_data_k_wire_filter;\n  wire [255:0] gt_rx_data_wire_filter;\n  wire [  7:0] gt_rx_elec_idle_wire_filter;\n  wire [ 23:0] gt_rx_status_wire_filter;\n  wire [  7:0] gt_rx_valid_wire_filter;\n  wire pipe_clk_int;\n  reg phy_rdy_n_int;\n  reg reg_clock_locked;\n  wire all_phystatus_rst;\n  reg [5:0] pl_ltssm_state_q;\n\n  always @(posedge pipe_clk_int or negedge clock_locked) begin\n    if (!clock_locked)\n      pl_ltssm_state_q <= #TCQ 6'b0;\n    else\n      pl_ltssm_state_q <= #TCQ pl_ltssm_state;\n  end\n  assign pipe_clk = pipe_clk_int;\n  wire plm_in_l0 = (pl_ltssm_state_q == 6'h16);\n  wire plm_in_rl = (pl_ltssm_state_q == 6'h1c);\n  wire plm_in_dt = (pl_ltssm_state_q == 6'h2d);\n  wire plm_in_rs = (pl_ltssm_state_q == 6'h1f);\n  genvar i;\n  generate for (i=0; i<LINK_CAP_MAX_LINK_WIDTH; i=i+1) begin : gt_rx_valid_filter\n    pcie_7x_v1_8_gt_rx_valid_filter_7x # (\n      .CLK_COR_MIN_LAT(28)\n    ) GT_RX_VALID_FILTER_7x_inst (\n      .USER_RXCHARISK   ( gt_rx_data_k_wire [(2*i)+1 + (2*i):(2*i)+ (2*i)] ),\n      .USER_RXDATA      ( gt_rx_data_wire [(16*i)+15+(16*i) :(16*i)+0 + (16*i)] ),\n      .USER_RXVALID     ( gt_rx_valid_wire [i] ),\n      .USER_RXELECIDLE  ( gt_rx_elec_idle_wire [i] ),\n      .USER_RX_STATUS   ( gt_rx_status_wire [(3*i)+2:(3*i)] ),\n      .USER_RX_PHY_STATUS ( gt_rx_phy_status_wire [i] ),\n      .GT_RXCHARISK     ( gt_rx_data_k_wire_filter [(2*i)+1+ (2*i):2*i+ (2*i)] ),\n      .GT_RXDATA        ( gt_rx_data_wire_filter [(16*i)+15:(16*i)+0+(16*i)] ),\n      .GT_RXVALID       ( gt_rx_valid_wire_filter [i] ),\n      .GT_RXELECIDLE    ( gt_rx_elec_idle_wire_filter [i] ),\n      .GT_RX_STATUS     ( gt_rx_status_wire_filter [(3*i)+2:(3*i)] ),\n      .GT_RX_PHY_STATUS ( gt_rx_phy_status_wire_filter [i] ),\n      .PLM_IN_L0        ( plm_in_l0 ),\n      .PLM_IN_RS        ( plm_in_rs ),\n      .USER_CLK         ( pipe_clk_int ),\n      .RESET            ( phy_rdy_n_int )\n    );\n  end\n  endgenerate\n  pcie_7x_v1_8_pipe_wrapper #(\n    .PCIE_SIM_MODE                  ( PL_FAST_TRAIN ),\n    .PCIE_EXT_CLK                   ( PCIE_EXT_CLK ),\n    .PCIE_TXBUF_EN                  ( PCIE_TXBUF_EN ),\n    .PCIE_ASYNC_EN                  ( PCIE_ASYNC_EN ),\n    .PCIE_CHAN_BOND                 ( PCIE_CHAN_BOND ),\n    .PCIE_PLL_SEL                   ( PCIE_PLL_SEL ),\n    .PCIE_GT_DEVICE                 ( PCIE_GT_DEVICE ),\n    .PCIE_USE_MODE                  ( PCIE_USE_MODE ),\n    .PCIE_LANE                      ( LINK_CAP_MAX_LINK_WIDTH ),\n    .PCIE_LPM_DFE                   ( PCIE_LPM_DFE ),\n    .PCIE_LINK_SPEED                ( PCIE_LINK_SPEED ),\n    .PCIE_TX_EIDLE_ASSERT_DELAY     ( PCIE_TX_EIDLE_ASSERT_DELAY ),\n    .PCIE_OOBCLK_MODE               ( PCIE_OOBCLK_MODE_ENABLE ),\n    .PCIE_REFCLK_FREQ               ( REF_CLK_FREQ ),\n    .PCIE_USERCLK1_FREQ             ( USER_CLK_FREQ +1 ),\n    .PCIE_USERCLK2_FREQ             ( USERCLK2_FREQ +1 )\n  ) pipe_wrapper_i (\n    .PIPE_CLK                        ( sys_clk ),\n    .PIPE_RESET_N                    ( sys_rst_n ),\n    .PIPE_PCLK                       ( pipe_clk_int ),\n    .PIPE_TXDATA                    ( gt_tx_data[((32*LINK_CAP_MAX_LINK_WIDTH)-1):0] ),\n    .PIPE_TXDATAK                   ( gt_tx_data_k[((4*LINK_CAP_MAX_LINK_WIDTH)-1):0] ),\n    .PIPE_TXP                       ( pci_exp_txp[((LINK_CAP_MAX_LINK_WIDTH)-1):0] ),\n    .PIPE_TXN                       ( pci_exp_txn[((LINK_CAP_MAX_LINK_WIDTH)-1):0] ),\n    .PIPE_RXP                       ( pci_exp_rxp[((LINK_CAP_MAX_LINK_WIDTH)-1):0] ),\n    .PIPE_RXN                       ( pci_exp_rxn[((LINK_CAP_MAX_LINK_WIDTH)-1):0] ),\n    .PIPE_RXDATA                    ( gt_rx_data_wire_filter[((32*LINK_CAP_MAX_LINK_WIDTH)-1):0] ),\n    .PIPE_RXDATAK                   ( gt_rx_data_k_wire_filter[((4*LINK_CAP_MAX_LINK_WIDTH)-1):0] ),\n    .PIPE_TXDETECTRX                ( gt_tx_detect_rx_loopback ),\n    .PIPE_TXELECIDLE                ( gt_tx_elec_idle[((LINK_CAP_MAX_LINK_WIDTH)-1):0] ),\n    .PIPE_TXCOMPLIANCE              ( gt_tx_char_disp_mode[((LINK_CAP_MAX_LINK_WIDTH)-1):0] ),\n    .PIPE_RXPOLARITY                ( gt_rx_polarity[((LINK_CAP_MAX_LINK_WIDTH)-1):0] ),\n    .PIPE_POWERDOWN                 ( gt_power_down[((2*LINK_CAP_MAX_LINK_WIDTH)-1):0] ),\n    .PIPE_RATE                      ( {1'b0,pipe_tx_rate} ),\n    .PIPE_TXMARGIN                  ( pipe_tx_margin[2] ),\n    .PIPE_TXSWING                   ( pipe_tx_swing ),\n    .PIPE_TXDEEMPH                  ( {(LINK_CAP_MAX_LINK_WIDTH){pipe_tx_deemph}} ),\n    .PIPE_RXVALID                   ( gt_rx_valid_wire_filter[((LINK_CAP_MAX_LINK_WIDTH)-1):0] ),\n    .PIPE_PHYSTATUS                 ( gt_rx_phy_status_wire_filter[((LINK_CAP_MAX_LINK_WIDTH)-1):0] ),\n    .PIPE_PHYSTATUS_RST             ( phystatus_rst ),\n    .PIPE_RXELECIDLE                ( gt_rx_elec_idle_wire_filter[((LINK_CAP_MAX_LINK_WIDTH)-1):0] ),\n    .PIPE_RXSTATUS                  ( gt_rx_status_wire_filter[((3*LINK_CAP_MAX_LINK_WIDTH)-1):0] ),\n    .PIPE_USERCLK1                  ( user_clk ),\n    .PIPE_USERCLK2                  ( user_clk2 ),\n    .PIPE_RXUSRCLK                  ( ),\n    .PIPE_CPLL_LOCK                 ( plllkdet ),\n    .PIPE_QPLL_LOCK                 ( ),\n    .PIPE_PCLK_LOCK                 ( clock_locked ),\n    .PIPE_RXCDRLOCK                 ( ),\n    .PIPE_RXCHANISALIGNED           ( gt_rxchanisaligned_wire ),\n    .PIPE_ACTIVE_LANE               ( ),\n    .PIPE_DEBUG                     ( ),\n    .PIPE_DMONITOROUT                ( )\n  );\n  assign pipe_rx0_phy_status = gt_rx_phy_status_wire[0];\n  assign pipe_rx1_phy_status = (LINK_CAP_MAX_LINK_WIDTH >= 2 ) ? gt_rx_phy_status_wire[1] : 1'b0;\n  assign pipe_rx2_phy_status = (LINK_CAP_MAX_LINK_WIDTH >= 4 ) ? gt_rx_phy_status_wire[2] : 1'b0;\n  assign pipe_rx3_phy_status = (LINK_CAP_MAX_LINK_WIDTH >= 4 ) ? gt_rx_phy_status_wire[3] : 1'b0;\n  assign pipe_rx4_phy_status = (LINK_CAP_MAX_LINK_WIDTH >= 8 ) ? gt_rx_phy_status_wire[4] : 1'b0;\n  assign pipe_rx5_phy_status = (LINK_CAP_MAX_LINK_WIDTH >= 8 ) ? gt_rx_phy_status_wire[5] : 1'b0;\n  assign pipe_rx6_phy_status = (LINK_CAP_MAX_LINK_WIDTH >= 8 ) ? gt_rx_phy_status_wire[6] : 1'b0;\n  assign pipe_rx7_phy_status = (LINK_CAP_MAX_LINK_WIDTH >= 8 ) ? gt_rx_phy_status_wire[7] : 1'b0;\n  assign pipe_rx0_chanisaligned = gt_rxchanisaligned_wire[0];\n  assign pipe_rx1_chanisaligned = (LINK_CAP_MAX_LINK_WIDTH >= 2 ) ? gt_rxchanisaligned_wire[1] : 1'b0;\n  assign pipe_rx2_chanisaligned = (LINK_CAP_MAX_LINK_WIDTH >= 4 ) ? gt_rxchanisaligned_wire[2] : 1'b0;\n  assign pipe_rx3_chanisaligned = (LINK_CAP_MAX_LINK_WIDTH >= 4 ) ? gt_rxchanisaligned_wire[3] : 1'b0;\n  assign pipe_rx4_chanisaligned = (LINK_CAP_MAX_LINK_WIDTH >= 8 ) ? gt_rxchanisaligned_wire[4] : 1'b0;\n  assign pipe_rx5_chanisaligned = (LINK_CAP_MAX_LINK_WIDTH >= 8 ) ? gt_rxchanisaligned_wire[5] : 1'b0;\n  assign pipe_rx6_chanisaligned = (LINK_CAP_MAX_LINK_WIDTH >= 8 ) ? gt_rxchanisaligned_wire[6] : 1'b0;\n  assign pipe_rx7_chanisaligned = (LINK_CAP_MAX_LINK_WIDTH >= 8 ) ? gt_rxchanisaligned_wire[7] : 1'b0;\n  assign pipe_rx0_char_is_k =  {gt_rx_data_k_wire[1], gt_rx_data_k_wire[0]};\n  assign pipe_rx1_char_is_k =  (LINK_CAP_MAX_LINK_WIDTH >= 2 ) ? {gt_rx_data_k_wire[5], gt_rx_data_k_wire[4]} : 2'b0;\n  assign pipe_rx2_char_is_k =  (LINK_CAP_MAX_LINK_WIDTH >= 4 ) ? {gt_rx_data_k_wire[9], gt_rx_data_k_wire[8]} : 2'b0;\n  assign pipe_rx3_char_is_k =  (LINK_CAP_MAX_LINK_WIDTH >= 4 ) ? {gt_rx_data_k_wire[13], gt_rx_data_k_wire[12]} : 2'b0;\n  assign pipe_rx4_char_is_k =  (LINK_CAP_MAX_LINK_WIDTH >= 8 ) ? {gt_rx_data_k_wire[17], gt_rx_data_k_wire[16]} : 2'b0;\n  assign pipe_rx5_char_is_k =  (LINK_CAP_MAX_LINK_WIDTH >= 8 ) ? {gt_rx_data_k_wire[21], gt_rx_data_k_wire[20]} : 2'b0;\n  assign pipe_rx6_char_is_k =  (LINK_CAP_MAX_LINK_WIDTH >= 8 ) ? {gt_rx_data_k_wire[25], gt_rx_data_k_wire[24]} : 2'b0;\n  assign pipe_rx7_char_is_k =  (LINK_CAP_MAX_LINK_WIDTH >= 8 ) ? {gt_rx_data_k_wire[29], gt_rx_data_k_wire[28]} : 2'b0;\n  assign pipe_rx0_data = {gt_rx_data_wire[ 15: 8], gt_rx_data_wire[ 7: 0]};\n  assign pipe_rx1_data = (LINK_CAP_MAX_LINK_WIDTH >= 2 ) ? {gt_rx_data_wire[47:40], gt_rx_data_wire[39:32]} : 16'h0;\n  assign pipe_rx2_data = (LINK_CAP_MAX_LINK_WIDTH >= 4 ) ? {gt_rx_data_wire[79:72], gt_rx_data_wire[71:64]} : 16'h0;\n  assign pipe_rx3_data = (LINK_CAP_MAX_LINK_WIDTH >= 4 ) ? {gt_rx_data_wire[111:104], gt_rx_data_wire[103:96]} : 16'h0;\n  assign pipe_rx4_data = (LINK_CAP_MAX_LINK_WIDTH >= 8 ) ? {gt_rx_data_wire[143:136], gt_rx_data_wire[135:128]} : 16'h0;\n  assign pipe_rx5_data = (LINK_CAP_MAX_LINK_WIDTH >= 8 ) ? {gt_rx_data_wire[175:168], gt_rx_data_wire[167:160]} : 16'h0;\n  assign pipe_rx6_data = (LINK_CAP_MAX_LINK_WIDTH >= 8 ) ? {gt_rx_data_wire[207:200], gt_rx_data_wire[199:192]} : 16'h0;\n  assign pipe_rx7_data = (LINK_CAP_MAX_LINK_WIDTH >= 8 ) ? {gt_rx_data_wire[239:232], gt_rx_data_wire[231:224]} : 16'h0;\n  assign pipe_rx0_status = gt_rx_status_wire[ 2: 0];\n  assign pipe_rx1_status = (LINK_CAP_MAX_LINK_WIDTH >= 2 ) ? gt_rx_status_wire[ 5: 3] : 3'b0;\n  assign pipe_rx2_status = (LINK_CAP_MAX_LINK_WIDTH >= 4 ) ? gt_rx_status_wire[ 8: 6] : 3'b0;\n  assign pipe_rx3_status = (LINK_CAP_MAX_LINK_WIDTH >= 4 ) ? gt_rx_status_wire[11: 9] : 3'b0;\n  assign pipe_rx4_status = (LINK_CAP_MAX_LINK_WIDTH >= 8 ) ? gt_rx_status_wire[14:12] : 3'b0;\n  assign pipe_rx5_status = (LINK_CAP_MAX_LINK_WIDTH >= 8 ) ? gt_rx_status_wire[17:15] : 3'b0;\n  assign pipe_rx6_status = (LINK_CAP_MAX_LINK_WIDTH >= 8 ) ? gt_rx_status_wire[20:18] : 3'b0;\n  assign pipe_rx7_status = (LINK_CAP_MAX_LINK_WIDTH >= 8 ) ? gt_rx_status_wire[23:21] : 3'b0;\n  assign pipe_rx0_elec_idle = gt_rx_elec_idle_wire[0];\n  assign pipe_rx1_elec_idle = (LINK_CAP_MAX_LINK_WIDTH >= 2 ) ? gt_rx_elec_idle_wire[1] : 1'b1;\n  assign pipe_rx2_elec_idle = (LINK_CAP_MAX_LINK_WIDTH >= 4 ) ? gt_rx_elec_idle_wire[2] : 1'b1;\n  assign pipe_rx3_elec_idle = (LINK_CAP_MAX_LINK_WIDTH >= 4 ) ? gt_rx_elec_idle_wire[3] : 1'b1;\n  assign pipe_rx4_elec_idle = (LINK_CAP_MAX_LINK_WIDTH >= 8 ) ? gt_rx_elec_idle_wire[4] : 1'b1;\n  assign pipe_rx5_elec_idle = (LINK_CAP_MAX_LINK_WIDTH >= 8 ) ? gt_rx_elec_idle_wire[5] : 1'b1;\n  assign pipe_rx6_elec_idle = (LINK_CAP_MAX_LINK_WIDTH >= 8 ) ? gt_rx_elec_idle_wire[6] : 1'b1;\n  assign pipe_rx7_elec_idle = (LINK_CAP_MAX_LINK_WIDTH >= 8 ) ? gt_rx_elec_idle_wire[7] : 1'b1;\n  assign pipe_rx0_valid = gt_rx_valid_wire[0];\n  assign pipe_rx1_valid = (LINK_CAP_MAX_LINK_WIDTH >= 2 ) ? gt_rx_valid_wire[1] : 1'b0;\n  assign pipe_rx2_valid = (LINK_CAP_MAX_LINK_WIDTH >= 4 ) ? gt_rx_valid_wire[2] : 1'b0;\n  assign pipe_rx3_valid = (LINK_CAP_MAX_LINK_WIDTH >= 4 ) ? gt_rx_valid_wire[3] : 1'b0;\n  assign pipe_rx4_valid = (LINK_CAP_MAX_LINK_WIDTH >= 8 ) ? gt_rx_valid_wire[4] : 1'b0;\n  assign pipe_rx5_valid = (LINK_CAP_MAX_LINK_WIDTH >= 8 ) ? gt_rx_valid_wire[5] : 1'b0;\n  assign pipe_rx6_valid = (LINK_CAP_MAX_LINK_WIDTH >= 8 ) ? gt_rx_valid_wire[6] : 1'b0;\n  assign pipe_rx7_valid = (LINK_CAP_MAX_LINK_WIDTH >= 8 ) ? gt_rx_valid_wire[7] : 1'b0;\n  assign gt_rx_polarity[0] = pipe_rx0_polarity;\n  assign gt_rx_polarity[1] = pipe_rx1_polarity;\n  assign gt_rx_polarity[2] = pipe_rx2_polarity;\n  assign gt_rx_polarity[3] = pipe_rx3_polarity;\n  assign gt_rx_polarity[4] = pipe_rx4_polarity;\n  assign gt_rx_polarity[5] = pipe_rx5_polarity;\n  assign gt_rx_polarity[6] = pipe_rx6_polarity;\n  assign gt_rx_polarity[7] = pipe_rx7_polarity;\n  assign gt_power_down[ 1: 0] = pipe_tx0_powerdown;\n  assign gt_power_down[ 3: 2] = pipe_tx1_powerdown;\n  assign gt_power_down[ 5: 4] = pipe_tx2_powerdown;\n  assign gt_power_down[ 7: 6] = pipe_tx3_powerdown;\n  assign gt_power_down[ 9: 8] = pipe_tx4_powerdown;\n  assign gt_power_down[11:10] = pipe_tx5_powerdown;\n  assign gt_power_down[13:12] = pipe_tx6_powerdown;\n  assign gt_power_down[15:14] = pipe_tx7_powerdown;\n  assign gt_tx_char_disp_mode = {pipe_tx7_compliance,\n                               pipe_tx6_compliance,\n                               pipe_tx5_compliance,\n                               pipe_tx4_compliance,\n                               pipe_tx3_compliance,\n                               pipe_tx2_compliance,\n                               pipe_tx1_compliance,\n                               pipe_tx0_compliance};\n  assign gt_tx_data_k = {2'd0,\n                       pipe_tx7_char_is_k,\n                       2'd0,\n                       pipe_tx6_char_is_k,\n                       2'd0,\n                       pipe_tx5_char_is_k,\n                       2'd0,\n                       pipe_tx4_char_is_k,\n                       2'd0,\n                       pipe_tx3_char_is_k,\n                       2'd0,\n                       pipe_tx2_char_is_k,\n                       2'd0,\n                       pipe_tx1_char_is_k,\n                       2'd0,\n                       pipe_tx0_char_is_k};\n  assign gt_tx_data = {16'd0,\n                     pipe_tx7_data,\n                     16'd0,\n                     pipe_tx6_data,\n                     16'd0,\n                     pipe_tx5_data,\n                     16'd0,\n                     pipe_tx4_data,\n                     16'd0,\n                     pipe_tx3_data,\n                     16'd0,\n                     pipe_tx2_data,\n                     16'd0,\n                     pipe_tx1_data,\n                     16'd0,\n                     pipe_tx0_data};\n  assign gt_tx_detect_rx_loopback = pipe_tx_rcvr_det;\n  assign gt_tx_elec_idle = {pipe_tx7_elec_idle,\n                          pipe_tx6_elec_idle,\n                          pipe_tx5_elec_idle,\n                          pipe_tx4_elec_idle,\n                          pipe_tx3_elec_idle,\n                          pipe_tx2_elec_idle,\n                          pipe_tx1_elec_idle,\n                          pipe_tx0_elec_idle};\n  always @(posedge pipe_clk_int or negedge clock_locked) begin\n    if (!clock_locked)\n      reg_clock_locked <= #TCQ 1'b0;\n    else\n      reg_clock_locked <= #TCQ 1'b1;\n  end\n  always @(posedge pipe_clk_int) begin\n    if (!reg_clock_locked)\n      phy_rdy_n_int <= #TCQ 1'b0;\n    else\n      phy_rdy_n_int <= #TCQ all_phystatus_rst;\n  end\n  assign all_phystatus_rst = (&phystatus_rst[LINK_CAP_MAX_LINK_WIDTH-1:0]);\n  assign phy_rdy_n = phy_rdy_n_int;\nendmodule"}
{"task_id": 1884, "completion": "wire[ADDR_WIDTH - 1:0]         ZEROS;\n  reg [SEED_WIDTH - 1:0]         prbs;\n  reg [PRBS_WIDTH :1]            lfsr_q;\n\nassign ZEROS = 'b0;\n\ngenerate\n  if(PRBS_CMD == \"ADDRESS\" && PRBS_WIDTH == 64) begin :gen64_taps\n    always @ (posedge clk_i) begin\n      if(prbs_seed_init) begin\n        lfsr_q <= #TCQ {31'b0,prbs_seed_i};\n      end else if(clk_en) begin\n        lfsr_q[64] <= #TCQ lfsr_q[64] ^ lfsr_q[63];\n        lfsr_q[63] <= #TCQ lfsr_q[62];\n        lfsr_q[62] <= #TCQ lfsr_q[64] ^ lfsr_q[61];\n        lfsr_q[61] <= #TCQ lfsr_q[64] ^ lfsr_q[60];\n        lfsr_q[60:2] <= #TCQ lfsr_q[59:1];\n        lfsr_q[1] <= #TCQ lfsr_q[64];\n      end\n    end\n\n    always @(lfsr_q[32:1]) begin\n      prbs = lfsr_q[32:1];\n    end\n  end\nendgenerate\n\nfunction integer logb2;\n  input [31:0] in;\n  integer i;\n  begin\n    i = in;\n      for(logb2=1; i>0; logb2=logb2+1)\n        i = i >> 1;\n  end\nendfunction\n\ngenerate\n  if(PRBS_CMD == \"ADDRESS\" && PRBS_WIDTH == 32) begin :gen32_taps\n    always @ (posedge clk_i) begin\n      if(prbs_seed_init) begin\n        lfsr_q <= #TCQ {prbs_seed_i};\n      end else if(clk_en) begin\n        lfsr_q[32:9] <= #TCQ lfsr_q[31:8];\n        lfsr_q[8]    <= #TCQ lfsr_q[32] ^ lfsr_q[7];\n        lfsr_q[7]    <= #TCQ lfsr_q[32] ^ lfsr_q[6];\n        lfsr_q[6:4]  <= #TCQ lfsr_q[5:3];\n\n        lfsr_q[3]    <= #TCQ lfsr_q[32] ^ lfsr_q[2];\n        lfsr_q[2]    <= #TCQ lfsr_q[1];\n        lfsr_q[1]    <= #TCQ lfsr_q[32];\n      end\n    end\n\n    integer i;\n    always @(lfsr_q[32:1]) begin\n     if (FAMILY == \"SPARTAN6\" ) begin\n      for(i = logb2(DWIDTH) + 1; i <= SEED_WIDTH - 1; i = i + 1)\n       if(PRBS_SADDR_MASK_POS[i] == 1)\n          prbs[i] = PRBS_SADDR[i] | lfsr_q[i+1];\n       else if(PRBS_EADDR_MASK_POS[i] == 1)\n          prbs[i] = PRBS_EADDR[i] & lfsr_q[i+1];\n       else\n          prbs[i] =  lfsr_q[i+1];\n          \n       prbs[logb2(DWIDTH )  :0] = {logb2(DWIDTH ) + 1{1'b0}};  \n\n      end\n    else begin\n     for(i = logb2(DWIDTH)-4; i <= SEED_WIDTH - 1; i = i + 1)\n       if(PRBS_SADDR_MASK_POS[i] == 1)\n          prbs[i] = PRBS_SADDR[i] | lfsr_q[i+1];\n       else if(PRBS_EADDR_MASK_POS[i] == 1)\n          prbs[i] = PRBS_EADDR[i] & lfsr_q[i+1];\n       else\n          prbs[i] =  lfsr_q[i+1];\n     prbs[logb2(DWIDTH)-5:0] = {logb2(DWIDTH) - 4{1'b0}};\n\n    end  \n  end  \nend endgenerate\n\ngenerate\n  if(PRBS_CMD == \"INSTR\" | PRBS_CMD == \"BLEN\") begin :gen20_taps\n    always @(posedge clk_i) begin\n      if(prbs_seed_init) begin\n        lfsr_q <= #TCQ {5'b0,prbs_seed_i[14:0]};\n      end else if(clk_en) begin\n        lfsr_q[20]   <= #TCQ lfsr_q[19];\n        lfsr_q[19]   <= #TCQ lfsr_q[18];\n\n        lfsr_q[18]   <= #TCQ lfsr_q[20] ^lfsr_q[17];\n\n        lfsr_q[17:2] <= #TCQ lfsr_q[16:1];\n        lfsr_q[1]    <= #TCQ lfsr_q[20];\n      end\n    end\n\n    always @ (lfsr_q) begin\n      prbs = lfsr_q[32:1];\n    end\n  end\nendgenerate\n\nassign prbs_o = prbs;\n\nendmodule"}
{"task_id": 1975, "completion": "reg [351:0] jtag_data_shift = 352'd0;\n    reg [255:0] midstate = 256'd0;\n    reg [95:0] data = 96'd0;\n\n    assign tx_midstate = midstate;\n    assign tx_data = data;\n\n    reg [31:0] golden_out = 32'd0;\n    reg [3:0] golden_count = 3'd0;\n    reg read = 1'b0;\n    wire [8:0] jtag_data;\n    wire full, empty;\n    reg [5:0] jtag_data_count = 6'd0;\n\n    wire golden_writing = golden_count[0];\n\n    jtag_fifo jtag_fifo_blk (\n        .rx_clk (hash_clk),\n        .rx_data ({golden_count, golden_out[7:0]}),\n        .wr_en (golden_writing & ~full),\n        .rd_en (read),\n        .tx_data (jtag_data),\n        .tx_full (full),\n        .tx_empty (empty)\n    );\n\n    always @ (posedge hash_clk)\n    begin\n        if (!golden_writing & rx_new_nonce)\n        begin\n            golden_out <= rx_golden_nonce;\n            golden_count <= 4'b1111;\n        end\n        else if (golden_writing & !full)\n        begin\n            golden_out <= golden_out >> 8;\n            golden_count <= {1'b0, golden_count[3:1]};\n        end\n\n        if (!empty & !read)\n            read <= 1'b1;\n\n        if (read)\n        begin\n            read <= 1'b0;\n\n            jtag_data_shift <= {jtag_data_shift[343:0], jtag_data[7:0]};\n\n            if (jtag_data[8] == 1'b0)\n                jtag_data_count <= 6'd1;\n            else if (jtag_data_count == 6'd43)\n            begin\n                jtag_data_count <= 6'd0;\n                {midstate, data} <= {jtag_data_shift[343:0], jtag_data[7:0]};\n            end\n            else\n                jtag_data_count <= jtag_data_count + 6'd1;\n        end\n    end\n\nendmodule"}
{"task_id": 1909, "completion": "function [C_NUM_S-1:0] f_prio_mask(input integer null_arg);\n    reg   [C_NUM_S-1:0] mask;\n    integer i;\n    begin\n      mask = 0;\n      for (i=0; i < C_NUM_S; i=i+1) begin\n        mask[i] = (C_ARB_PRIORITY[i*32+:32] != 0);\n      end\n      f_prio_mask = mask;\n    end\n  endfunction\n  function [3:0] f_hot2enc(input [15:0] one_hot);\n    begin\n      f_hot2enc[0] = |(one_hot & 16'b1010101010101010);\n      f_hot2enc[1] = |(one_hot & 16'b1100110011001100);\n      f_hot2enc[2] = |(one_hot & 16'b1111000011110000);\n      f_hot2enc[3] = |(one_hot & 16'b1111111100000000);\n    end\n  endfunction\n  localparam [C_NUM_S-1:0] P_PRIO_MASK = f_prio_mask(0);\n  reg m_valid_i;\n  reg [C_NUM_S-1:0] s_ready_i;\n  reg [C_NUM_S-1:0] s_awvalid_reg;\n  reg [C_NUM_S-1:0] s_arvalid_reg;\n  wire [15:0] s_avalid;\n  wire m_aready;\n  wire [C_NUM_S-1:0] rnw;\n  reg grant_rnw;\n  reg [C_NUM_S_LOG-1:0] m_grant_enc_i;\n  reg [C_NUM_S-1:0] m_grant_hot_i;\n  reg [C_NUM_S-1:0] last_rr_hot;\n  reg any_grant;\n  reg any_prio;\n  reg [C_NUM_S-1:0] which_prio_hot;\n  reg [C_NUM_S_LOG-1:0] which_prio_enc;\n  reg [4:0] current_highest;\n  reg [15:0] next_prio_hot;\n  reg [C_NUM_S_LOG-1:0] next_prio_enc;\n  reg found_prio;\n  wire [C_NUM_S-1:0] valid_rr;\n  reg [15:0] next_rr_hot;\n  reg [C_NUM_S_LOG-1:0] next_rr_enc;\n  reg [C_NUM_S*C_NUM_S-1:0] carry_rr;\n  reg [C_NUM_S*C_NUM_S-1:0] mask_rr;\n  reg found_rr;\n  wire [C_NUM_S-1:0] next_hot;\n  wire [C_NUM_S_LOG-1:0] next_enc;\n  integer i;\n  wire [C_AMESG_WIDTH-1:0] amesg_mux;\n  reg [C_AMESG_WIDTH-1:0] m_amesg_i;\n  wire [C_NUM_S*C_AMESG_WIDTH-1:0] s_amesg;\n  genvar gen_si;\n  always @(posedge ACLK) begin\n    if (ARESET) begin\n      s_awvalid_reg <= 0;\n      s_arvalid_reg <= 0;\n    end else if (|s_ready_i) begin\n      s_awvalid_reg <= 0;\n      s_arvalid_reg <= 0;\n    end else begin\n      s_arvalid_reg <= S_ARVALID & ~s_awvalid_reg;\n      s_awvalid_reg <= S_AWVALID & ~s_arvalid_reg & (~S_ARVALID | s_awvalid_reg);\n    end\n  end\n  assign s_avalid = S_AWVALID | S_ARVALID;\n  assign M_AWVALID = m_valid_i & ~grant_rnw;\n  assign M_ARVALID = m_valid_i & grant_rnw;\n  assign S_AWREADY = s_ready_i & {C_NUM_S{~grant_rnw}};\n  assign S_ARREADY = s_ready_i & {C_NUM_S{grant_rnw}};\n  assign M_GRANT_ENC = C_GRANT_ENC ? m_grant_enc_i : 0;\n  assign M_GRANT_HOT = m_grant_hot_i;\n  assign M_GRANT_RNW = grant_rnw;\n  assign rnw = S_ARVALID & ~s_awvalid_reg;\n  assign M_AMESG = m_amesg_i;\n  assign m_aready = grant_rnw ? M_ARREADY : M_AWREADY;\n  generate\n    for (gen_si=0; gen_si<C_NUM_S; gen_si=gen_si+1) begin : gen_mesg_mux\n      assign s_amesg[C_AMESG_WIDTH*gen_si +: C_AMESG_WIDTH] = rnw[gen_si] ? S_ARMESG[C_AMESG_WIDTH*gen_si +: C_AMESG_WIDTH] : S_AWMESG[C_AMESG_WIDTH*gen_si +: C_AMESG_WIDTH];\n    end\n    if (C_NUM_S>1) begin : gen_arbiter\n      assign M_GRANT_ANY = any_grant;\n      assign next_hot = found_prio ? next_prio_hot : next_rr_hot;\n      assign next_enc = found_prio ? next_prio_enc : next_rr_enc;\n      always @(posedge ACLK) begin\n        if (ARESET) begin\n          m_valid_i <= 0;\n          s_ready_i <= 0;\n          m_grant_hot_i <= 0;\n          m_grant_enc_i <= 0;\n          any_grant <= 1'b0;\n          last_rr_hot <= {1'b1, {C_NUM_S-1{1'b0}}};\n          grant_rnw <= 1'b0;\n        end else begin\n          s_ready_i <= 0;\n          if (m_valid_i) begin\n            if (m_aready) begin\n              m_valid_i <= 1'b0;\n              m_grant_hot_i <= 0;\n              any_grant <= 1'b0;\n            end\n          end else if (any_grant) begin\n            m_valid_i <= 1'b1;\n            s_ready_i <= m_grant_hot_i;\n          end else begin\n            if (found_prio | found_rr) begin\n              m_grant_hot_i <= next_hot;\n              m_grant_enc_i <= next_enc;\n              any_grant <= 1'b1;\n              grant_rnw <= |(rnw & next_hot);\n              if (~found_prio) begin\n                last_rr_hot <= next_rr_hot;\n              end\n            end\n          end\n        end\n      end\n      always @ * begin : ALG_PRIO\n        integer ip;\n        any_prio = 1'b0;\n        which_prio_hot = 0;\n        which_prio_enc = 0;\n        current_highest = 0;\n        for (ip=0; ip < C_NUM_S; ip=ip+1) begin\n          if (P_PRIO_MASK[ip] & ({1'b0, C_ARB_PRIORITY[ip*32+:4]} > current_highest)) begin\n            if (s_avalid[ip]) begin\n              current_highest[0+:4] = C_ARB_PRIORITY[ip*32+:4];\n              any_prio = 1'b1;\n              which_prio_hot = 1'b1 << ip;\n              which_prio_enc = ip;\n            end\n          end\n        end\n        found_prio = any_prio;\n        next_prio_hot = which_prio_hot;\n        next_prio_enc = which_prio_enc;\n      end\n      assign valid_rr = ~P_PRIO_MASK & s_avalid;\n      always @ * begin : ALG_RR\n        integer ir, jr, nr;\n        next_rr_hot = 0;\n        for (ir=0;ir<C_NUM_S;ir=ir+1) begin\n          nr = (ir>0) ? (ir-1) : (C_NUM_S-1);\n          carry_rr[ir*C_NUM_S] = last_rr_hot[nr];\n          mask_rr[ir*C_NUM_S] = ~valid_rr[nr];\n          for (jr=1;jr<C_NUM_S;jr=j+1) begin\n            nr = (ir-jr > 0) ? (ir-jr-1) : (C_NUM_S+ir-jr-1);\n            carry_rr[ir*C_NUM_S+jr] = carry_rr[ir*C_NUM_S+jr-1] | (last_rr_hot[nr] & mask_rr[ir*C_NUM_S+jr-1]);\n            if (jr < C_NUM_S-1) begin\n              mask_rr[ir*C_NUM_S+jr] = mask_rr[ir*C_NUM_S+jr-1] & ~valid_rr[nr];\n            end\n          end\n        end\n        next_rr_enc = f_hot2enc(next_rr_hot);\n        found_rr = |(next_rr_hot);\n      end\n      generic_baseblocks_v2_1_0_mux_enc # (\n        .C_FAMILY (\"rtl\"),\n        .C_RATIO (C_NUM_S),\n        .C_SEL_WIDTH (C_NUM_S_LOG),\n        .C_DATA_WIDTH (C_AMESG_WIDTH)\n      ) si_amesg_mux_inst (\n        .S (next_enc),\n        .A (s_amesg),\n        .O (amesg_mux),\n        .OE (1'b1)\n      );\n      always @(posedge ACLK) begin\n        if (ARESET) begin\n          m_amesg_i <= 0;\n        end else if (~any_grant) begin\n          m_amesg_i <= amesg_mux;\n        end\n      end\n    end else begin : gen_no_arbiter\n      assign M_GRANT_ANY = m_grant_hot_i;\n      always @ (posedge ACLK) begin\n        if (ARESET) begin\n          m_valid_i <= 1'b0;\n          s_ready_i <= 1'b0;\n          m_grant_enc_i <= 0;\n          m_grant_hot_i <= 1'b0;\n          grant_rnw <= 1'b0;\n        end else begin\n          s_ready_i <= 1'b0;\n          if (m_valid_i) begin\n            if (m_aready) begin\n              m_valid_i <= 1'b0;\n              m_grant_hot_i <= 1'b0;\n            end\n          end else if (m_grant_hot_i) begin\n            m_valid_i <= 1'b1;\n            s_ready_i[0] <= 1'b1;\n          end else if (s_avalid[0]) begin\n            m_grant_hot_i <= 1'b1;\n            grant_rnw <= rnw[0];\n          end\n        end\n      end\n      always @ (posedge ACLK) begin\n        if (ARESET) begin\n          m_amesg_i <= 0;\n        end else if (~m_grant_hot_i) begin\n          m_amesg_i <= s_amesg;\n        end\n      end\n    end\n  endgenerate\nendmodule"}
{"task_id": 1938, "completion": "input start;\n    input[`NWIDTH-1:0] N;\n    input[`DDRSIZEWIDTH-1:0] offset;\n    output done;\n    input clk;\n\n    output burst_begin;\n    output [`MEMCONNUMBYTES-1:0] mem_local_be;\n    output mem_local_read_req;\n    output [`BURSTLEN-1:0] mem_local_size;\n    output [`MEMCONWIDTH-1:0] mem_local_wdata;\n    output mem_local_write_req;\n    output [`DDRSIZEWIDTH-1:0] mem_local_addr;\n    input [`MEMCONWIDTH-1:0] mem_local_rdata;\n    input mem_local_rdata_valid;\n    input mem_local_ready;\n    input reset_n;\n    input mem_local_wdata_req;\n\n    wire[`BLOCKWIDTH-1:0] m, n, loop;\n    wire[1:0] mode;\n    wire comp_start, comp_done;\n    wire dtu_write_req, dtu_read_req, dtu_ack, dtu_done;\n    wire [`DDRSIZEWIDTH-1:0] dtu_mem_addr;\n    wire [`RAMSIZEWIDTH-1:0] dtu_ram_addr;\n    wire [`BLOCKWIDTH-1:0] dtu_size;\n    wire left_sel;\n\n    wire[`RAMWIDTH-1:0] curWriteDataMem, curReadDataMem;\n    wire[`RAMSIZEWIDTH-1:0] curWriteAddrMem, curReadAddrMem;\n    wire[`RAMNUMBYTES-1:0] curWriteByteEnMem;\n    wire curWriteEnMem;\n    wire[`RAMWIDTH-1:0] leftWriteDataMem;\n    wire[`RAMSIZEWIDTH-1:0] leftWriteAddrMem;\n    wire[`RAMNUMBYTES-1:0] leftWriteByteEnMem;\n    wire leftWriteEnMem;\n    wire curMemSel, leftMemSel;\n\n    wire burst_begin;\n    wire [`MEMCONNUMBYTES-1:0] mem_local_be;\n    wire mem_local_read_req;\n    wire [`BURSTLEN-1:0] mem_local_size;\n    wire [`MEMCONWIDTH-1:0] mem_local_wdata;\n    wire mem_local_write_req;\n    wire [`MEMCONWIDTH-1:0] mem_local_rdata;\n    wire mem_local_rdata_valid;\n    wire mem_local_ready;\n    wire mem_local_wdata_req;\n    wire reset_n;\n    wire [`DDRSIZEWIDTH-1:0] mem_local_addr;\n\n    wire[`RAMWIDTH-1:0] ram_write_data, ram_read_data;\n    wire[`RAMSIZEWIDTH-1:0] ram_write_addr, ram_read_addr;\n    wire[`RAMNUMBYTES-1:0] ram_write_byte_en;\n    wire ram_write_en;\n\n    MarshallerController MC (clk, start, done, N, offset, comp_start, m, n, loop, mode, comp_done, curMemSel, leftMemSel, dtu_write_req, dtu_read_req, dtu_mem_addr, dtu_ram_addr, dtu_size, dtu_ack, dtu_done, left_sel);\n\n    LU compBlock (clk, comp_start, m, n, loop, mode, comp_done, curReadAddrMem, curReadDataMem, curWriteByteEnMem, curWriteDataMem, curWriteAddrMem, curWriteEnMem, curMemSel, leftWriteByteEnMem, leftWriteDataMem, leftWriteAddrMem, leftWriteEnMem, leftMemSel);\n\n    DataTransferUnit DTU (.clk(clk), .dtu_write_req(dtu_write_req), .dtu_read_req(dtu_read_req), .dtu_mem_addr(dtu_mem_addr), .dtu_ram_addr(dtu_ram_addr), .dtu_size(dtu_size), .dtu_ack(dtu_ack), .dtu_done(dtu_done), .ram_read_addr(ram_read_addr), .ram_read_data(ram_read_data), .ram_write_byte_en(ram_write_byte_en), .ram_write_data(ram_write_data), .ram_write_addr(ram_write_addr), .ram_write_en(ram_write_en), .mem_rdata(mem_local_rdata), .mem_rdata_valid(mem_local_rdata_valid), .mem_ready(mem_local_ready), .mem_wdata_req(mem_local_wdata_req), .reset_n(reset_n), .burst_begin(burst_begin), .mem_local_addr(mem_local_addr), .mem_be(mem_local_be), .mem_read_req(mem_local_read_req), .mem_size(mem_local_size), .mem_wdata(mem_local_wdata), .mem_write_req(mem_local_write_req));\n\n    assign curReadAddrMem = ram_read_addr;\n    assign curWriteByteEnMem = ram_write_byte_en;\n    assign curWriteDataMem = ram_write_data;\n    assign curWriteAddrMem = ram_write_addr;\n    assign curWriteEnMem = ram_write_en && (left_sel == 0);\n    assign leftWriteByteEnMem = ram_write_byte_en;\n    assign leftWriteDataMem = ram_write_data;\n    assign leftWriteAddrMem = ram_write_addr;\n    assign leftWriteEnMem = ram_write_en && (left_sel == 1);\n    assign ram_read_data = curReadDataMem;\nendmodule"}
{"task_id": 1648, "completion": "reg poweron_reset = 1'b1;\n    reg reset = 1'b1;\n\n    always @ (posedge hash_clk)\n    begin\n        poweron_reset <= 1'b0;\n        reset <= poweron_reset;\n    end\n    \n    `ifndef ICARUS\n    reg [31:0] nonce_prevous_load = 32'hffffffff;\n    `endif\n\n    `ifndef NOMULTICORE\n        reg [27:0] nonce_cnt = 28'd0;\n        wire [31:0] nonce;\n        assign nonce = { nonce_msb, nonce_cnt };\n    `else\n        reg [31:0] nonce = 32'd0;\n    `endif\n\n    assign nonce_out = nonce;\n\n    reg [31:0] nonce_1 = 32'd0;\n    reg [31:0] nonce_2 = 32'd0;\n    reg [31:0] golden_nonce = 32'd0;\n    assign golden_nonce_out = golden_nonce;\n    reg golden_nonce_match = 1'b0;\n    \n    reg [255:0] rx_state;\n    reg [511:0] rx_input;\n    wire [255:0] tx_hash;\n    reg [255:0] khash = 256'd0;\n    reg [255:0] ihash = 256'd0;\n    reg [255:0] ohash = 256'd0;\n    `ifdef SIM\n    reg [255:0] final_hash = 256'd0;\n    `endif\n    reg [31:0] blockcnt = 32'd0;\n    reg [1023:0] Xbuf = 1024'd0;\n    reg [1023:0] MixOut;\n    wire [5:0] cnt;\n    wire feedback;\n    assign feedback = (cnt != 6'b0);\n    \n    sha256_transform  # (.LOOP(64)) sha256_blk (\n        .clk(hash_clk),\n        .feedback(feedback),\n        .cnt(cnt),\n        .rx_state(rx_state),\n        .rx_input(rx_input),\n        .tx_hash(tx_hash)\n    );\n\n    parameter S_IDLE=0,\n            S_H1= 1, S_H2= 2, S_H3= 3, S_H4= 4, S_H5= 5, S_H6= 6,\n            S_I1= 7, S_I2= 8, S_I3= 9, S_I4=10, S_I5=11, S_I6=12,\n            S_O1=13, S_O2=14, S_O3=15,\n            S_B1=16, S_B2=17, S_B3=18, S_B4=19, S_B5=20, S_B6=21,\n            S_XX=22,\n            S_R1=23, S_R2=24, S_R3=25, S_R4=26, S_R5=27, S_R6=28,\n            S_R7=29, S_R8=30, S_R9=31, S_R10=32, S_R11=33, S_R12=34,\n            S_R13=35, S_R14=36, S_R15=37, S_R16=38, S_R17=39, S_R18=40;\n    \n    reg [5:0] state = S_IDLE;\n    reg mode = 0;\n    always @ (posedge hash_clk)\n    begin\n        Set_SMixInRdy <= 1'b0;\n        Clr_SMixOutRdy <= 1'b0;\n        golden_nonce_match <= 1'b0;\n        \n        if (reset == 1'b1)\n            state <= S_IDLE;\n        else\n        begin\n            case (state)\n                S_IDLE: begin\n                    if (SMixOutRdy ||\n                        !SMixInRdy)\n                    begin\n                        rx_state <= 256'h5be0cd191f83d9ab9b05688c510e527fa54ff53a3c6ef372bb67ae856a09e667;\n                        rx_input <= { data2, data1 };\n                        blockcnt <= 32'd1;\n                        cnt <= 6'd0;\n                        if (SMixOutRdy)\n                            mode <= 1'b1;\n                        else\n                            mode <= 1'b0;\n                        state <= S_H1;\n                    end\n                end\n                S_H1: begin\n                    cnt <= cnt + 6'd1;\n                    if (cnt == 6'd63)\n                    {\n                        cnt <= 6'd0;\n                        state <= S_H2;\n                    end\n                end\n                S_H2: begin\n                    state <= S_H3;\n                end\n        end\n    end\n    // \u7701\u7565\u4ee3\u7801\u5757\n\nendmodule"}
{"task_id": 242, "completion": "`include \"parameters_global.v\"\n    wire [`byte_width-1:0] i2c_rx_byte;\n    reg [`byte_width-1:0] i2c_tx_byte;\n    reg i2c_tx_data, i2c_rx_data;\n    reg i2c_tx_start_condition, i2c_tx_stop_condition;\n    reg i2c_start;\n    wire i2c_done;\n    reg [`tck_count_width-1:0] tck_count;\n    reg sct_start;\n    reg timer_start;\n    reg i2c_command_executed;\n    reg [`byte_width-1:0] lcp_state_last;\n    scan_clock_timer sct (\n        .clk(clk),\n        .reset_n(reset_n),\n        .reset(reset),\n        .delay(scan_clock_frequency),\n        .start(sct_start),\n        .done(sct_done),\n        .step_mode_tck(1'b0),\n        .go_step_tck(1'b0)\n    );\n    i2c_master im(\n        .clk(clk),  \n        .reset_n(reset_n),  \n        .reset(reset), \n        .sda(sda),  \n        .scl(scl),  \n        .tx_byte(i2c_tx_byte),  \n        .rx_byte(i2c_rx_byte),  \n        .tx_start_condition(i2c_tx_start_condition),  \n        .tx_stop_condition(i2c_tx_stop_condition),  \n        .tx_data(i2c_tx_data),  \n        .rx_data(i2c_rx_data),  \n        .start(i2c_start),  \n        .done(i2c_done),  \n        .i2c_master_state(i2c_master_state)\n    );\n    timer ti(\n        .clk(clk),\n        .reset_n(reset_n),\n        .reset(reset),\n        .delay(arg1),\n        .start(timer_start),\n        .done(timer_done),\n        .timer_state(timer_state)\n    );\n    always @(posedge clk or negedge reset_n) begin\n        if (~reset_n) begin\n            done                    <= #`DEL 1'b0;\n            i2c_command_executed    <= #`DEL 1'b0;\n            i2c_tx_start_condition  <= #`DEL 1'b0;\n            i2c_tx_stop_condition   <= #`DEL 1'b0;\n            i2c_tx_data             <= #`DEL 1'b0;\n            i2c_rx_data             <= #`DEL 1'b0;\n            i2c_start               <= #`DEL 1'b0;\n            i2c_tx_byte             <= #`DEL `byte_width'h00;\n            lcp_state               <= #`DEL LCP_STATE_IDLE;\n            lcp_state_last          <= #`DEL LCP_STATE_IDLE;\n            timer_start             <= #`DEL 1'b0;\n            sct_start               <= #`DEL 1'b0;\n            tck_count               <= #`DEL tck_count_init;\n            sp_trst                 <= #`DEL init_state_trst;\n            sp_tms                  <= #`DEL init_state_tms;\n            sp_tck                  <= #`DEL init_state_tck;\n            sp_tdo                  <= #`DEL init_state_tdo;\n            tap_states_send         <= #`DEL {`scanpath_count_max * TAP_TEST_LOGIG_RESET};\n        end else begin\n            if (reset) begin\n                done                    <= #`DEL 1'b0;\n                i2c_command_executed    <= #`DEL 1'b0;\n                i2c_tx_start_condition  <= #`DEL 1'b0;\n                i2c_tx_stop_condition   <= #`DEL 1'b0;\n                i2c_tx_data             <= #`DEL 1'b0;\n                i2c_rx_data             <= #`DEL 1'b0;\n                i2c_start               <= #`DEL 1'b0;\n                i2c_tx_byte             <= #`DEL `byte_width'h00;\n                lcp_state               <= #`DEL LCP_STATE_IDLE;\n                lcp_state_last          <= #`DEL LCP_STATE_IDLE;\n                timer_start             <= #`DEL 1'b0;\n                sct_start               <= #`DEL 1'b0;\n                tck_count               <= #`DEL tck_count_init;\n                sp_trst                 <= #`DEL init_state_trst;\n                sp_tms                  <= #`DEL init_state_tms;\n                sp_tck                  <= #`DEL init_state_tck;\n                sp_tdo                  <= #`DEL init_state_tdo;\n                tap_states_send         <= #`DEL {`scanpath_count_max * TAP_TEST_LOGIG_RESET};\n            end else begin\n                case (lcp_state)\n                    LCP_STATE_IDLE: begin\n                        done       <= #`DEL 1'b0;\n                        if (start) begin\n                            case (command) \n                                lc_set_frq_tck: begin\n                                    scan_clock_frequency <= #`DEL arg1;\n                                    case (arg2)\n                                        lc_null_argument: lcp_state <= #`DEL LCP_STATE_SET_FRQ;\n                                        default: lcp_state <= #`DEL LCP_STATE_ERROR_ARG2;\n                                    endcase\n                                end\n                                lc_set_sp_thrshld_tdi: begin\n                                    case (arg1)\n                                        lc_scanport_1, lc_scanport_2: lcp_state <= #`DEL LCP_STATE_SET_SUB_BUS_1_DAC_5;\n                                        default: lcp_state <= #`DEL LCP_STATE_ERROR_ARG1;\n                                    endcase\n                                end\n                                lc_set_sp_vltg_out: begin\n                                    case (arg1)\n                                        lc_scanport_1, lc_scanport_2: lcp_state <= #`DEL LCP_STATE_SET_MAIN_DRV_VLTGE_1;\n                                        default: lcp_state <= #`DEL LCP_STATE_ERROR_ARG1;\n                                    endcase\n                                end\n                                lc_set_drv_chr_tms_tck, lc_set_drv_chr_trst_tdo: begin\n                                    case (arg1)\n                                        lc_scanport_1, lc_scanport_2: lcp_state <= #`DEL LCP_STATE_SET_MAIN_DRV_CHAR_1;\n                                        default: lcp_state <= #`DEL LCP_STATE_ERROR_ARG1;\n                                    endcase\n                                end\n                                lc_delay: begin\n                                    case (arg2)\n                                        lc_delay_arg2:\n                                            lcp_state <= #`DEL LCP_STATE_START_TIMER_1;\n                                        default:\n                                            lcp_state <= #`DEL LCP_STATE_ERROR_ARG2;\n                                    endcase\n                                end\n                                lc_power_on_off: begin\n                                    case (arg1)\n                                        lc_pwr_gnd, lc_pwr_1, lc_pwr_2, lc_pwr_3, lc_pwr_all: begin\n                                            case (arg2)\n                                                lc_off, lc_on:\n                                                    lcp_state <= #`DEL LCP_STATE_SEND_DONE_TO_EX;\n                                                default: lcp_state <= #`DEL LCP_STATE_ERROR_ARG2;\n                                            endcase\n                                        end\n                                        default: lcp_state <= #`DEL LCP_STATE_ERROR_ARG1;\n                                    endcase\n                                end\n                                lc_set_imax: begin\n                                    case (arg1)\n                                        lc_pwr_1, lc_pwr_2, lc_pwr_3:\n                                            lcp_state <= #`DEL LCP_STATE_SEND_DONE_TO_EX;\n                                        default: lcp_state <= #`DEL LCP_STATE_ERROR_ARG1;\n                                    endcase\n                                end\n                                lc_set_timeout: begin\n                                    case (arg1)\n                                        lc_pwr_1, lc_pwr_2, lc_pwr_3:\n                                            lcp_state <= #`DEL LCP_STATE_SEND_DONE_TO_EX;\n                                        default: lcp_state <= #`DEL LCP_STATE_ERROR_ARG1;\n                                    endcase\n                                end\n                                lc_connect_disconnect: begin\n                                    case (arg1)\n                                        lc_scanport_1, lc_scanport_2: begin\n                                            case (arg2)\n                                                lc_off, lc_on:\n                                                    lcp_state <= #`DEL LCP_STATE_SEND_DONE_TO_EX;\n                                                default: lcp_state <= #`DEL LCP_STATE_ERROR_ARG2;\n                                            endcase\n                                        end\n                                        default: lcp_state <= #`DEL LCP_STATE_ERROR_ARG1;\n                                    endcase\n                                end\n                                lc_tap_state: begin\n                                    case (arg1)\n                                        lc_tap_trst, lc_tap_strst, lc_tap_htrst: begin\n                                            case (arg2)\n                                                lc_null_argument:\n                                                    lcp_state <= #`DEL LCP_STATE_TAP_TRST_1;\n                                                default: lcp_state <= #`DEL LCP_STATE_ERROR_ARG2;\n                                            endcase\n                                        end\n                                        default: lcp_state <= #`DEL LCP_STATE_ERROR_ARG1;\n                                    endcase\n                                end\n                                default:\n                                    lcp_state <= #`DEL LCP_STATE_ERROR_CMD;\n                            endcase\n                        end\n                    end\n                    LCP_STATE_SEND_DONE_TO_EX: begin\n                        done <= #`DEL 1'b1;\n                        lcp_state <= #`DEL LCP_STATE_IDLE;\n                    end\n                    LCP_STATE_SET_FRQ: begin\n                        done <= #`DEL 1'b1;\n                        lcp_state <= #`DEL LCP_STATE_IDLE;\n                    end\n                    LCP_STATE_I2C_RDY: begin\n                        i2c_start <= #`DEL 1'b0;\n                        if (i2c_done) begin\n                            lcp_state <= #`DEL lcp_state_last;\n                            i2c_command_executed <= #`DEL 1'b1;\n                        end\n                    end\n                    LCP_STATE_SET_SUB_BUS_1_DAC_5: begin\n                        if (i2c_command_executed) begin\n                            i2c_command_executed <= #`DEL 1'b0;\n                            i2c_tx_start_condition <= #`DEL 1'b0;\n                            i2c_start <= #`DEL 1'b0;\n                            lcp_state <= #`DEL LCP_STATE_SET_SUB_BUS_1_DAC_6;\n                        end else begin\n                            i2c_tx_start_condition <= #`DEL 1'b1;\n                            i2c_start <= #`DEL 1'b1;\n                            lcp_state_last <= #`DEL lcp_state;\n                            lcp_state <= #`DEL LCP_STATE_I2C_RDY;\n                        end\n                    end\n                    LCP_STATE_SET_SUB_BUS_1_DAC_6: begin\n                        if (i2c_command_executed) begin\n                            i2c_command_executed <= #`DEL 1'b0;\n                            i2c_tx_data <= #`DEL 1'b0;\n                            i2c_start <= #`DEL 1'b0;\n                            lcp_state <= #`DEL LCP_STATE_SET_SUB_BUS_1_DAC_7;\n                        end else begin\n                            case (arg1)\n                                lc_scanport_1: i2c_tx_byte <= #`DEL i2c_addr_thrshld_tdi_1;\n                                lc_scanport_2: i2c_tx_byte <= #`DEL i2c_addr_thrshld_tdi_2;\n                            endcase\n                            i2c_tx_data <= #`DEL 1'b1;\n                            i2c_start <= #`DEL 1'b1;\n                            lcp_state_last <= #`DEL lcp_state;\n                            lcp_state <= #`DEL LCP_STATE_I2C_RDY;\n                        end\n                    end\n                    LCP_STATE_SET_SUB_BUS_1_DAC_7: begin\n                        if (i2c_command_executed) begin\n                            i2c_command_executed <= #`DEL 1'b0;\n                            i2c_tx_data <= #`DEL 1'b0;\n                            i2c_start <= #`DEL 1'b0;\n                            lcp_state <= #`DEL LCP_STATE_SET_SUB_BUS_1_DAC_8;\n                        end else begin\n                            i2c_tx_byte <= #`DEL i2c_data_dac_cmd;\n                            i2c_tx_data <= #`DEL 1'b1;\n                            i2c_start <= #`DEL 1'b1;\n                            lcp_state_last <= #`DEL lcp_state;\n                            lcp_state <= #`DEL LCP_STATE_I2C_RDY;\n                        end\n                    end\n                    LCP_STATE_SET_SUB_BUS_1_DAC_8: begin\n                        if (i2c_command_executed) begin\n                            i2c_command_executed <= #`DEL 1'b0;\n                            i2c_tx_data <= #`DEL 1'b0;\n                            i2c_start <= #`DEL 1'b0;\n                            lcp_state <= #`DEL LCP_STATE_SET_SUB_BUS_1_DAC_9;\n                        end else begin\n                            i2c_tx_byte <= #`DEL arg2;\n                            i2c_tx_data <= #`DEL 1'b1;\n                            i2c_start <= #`DEL 1'b1;\n                            lcp_state_last <= #`DEL lcp_state;\n                            lcp_state <= #`DEL LCP_STATE_I2C_RDY;\n                        end\n                    end\n                    LCP_STATE_SET_SUB_BUS_1_DAC_9: begin\n                        if (i2c_command_executed) begin\n                            i2c_command_executed <= #`DEL 1'b0;\n                            i2c_tx_stop_condition <= #`DEL 1'b0;\n                            i2c_start <= #`DEL 1'b0;\n                            done <= #`DEL 1'b1;\n                            lcp_state <= #`DEL LCP_STATE_IDLE;\n                        end else begin\n                            i2c_tx_stop_condition <= #`DEL 1'b1;\n                            i2c_start <= #`DEL 1'b1;\n                            lcp_state_last <= #`DEL lcp_state;\n                            lcp_state <= #`DEL LCP_STATE_I2C_RDY;\n                        end\n                    end\n                    LCP_STATE_SET_MAIN_DRV_CHAR_1: begin\n                        // Implement main driver characteristics here.\n                    end\n                    // Add other states as needed\n                endcase\n            end\n        end\n    end\nendmodule"}
{"task_id": 1967, "completion": "parameter TCK_FREQ_MHZ = 20;\nlocalparam TCK_HALF_PERIOD_US = (1000/TCK_FREQ_MHZ)/2;\nlocalparam IRWIDTH = 3;\n\ninput [IRWIDTH - 1:0] ir_out;\ninput tdo;\noutput reg [IRWIDTH - 1:0] ir_in;\noutput tck;\noutput reg tdi = 1'b0;\noutput virtual_state_cdr;\noutput virtual_state_cir;\noutput virtual_state_e1dr;\noutput virtual_state_e2dr;\noutput virtual_state_pdr;\noutput virtual_state_sdr;\noutput virtual_state_udr;\noutput virtual_state_uir;\n\n`ifndef ALTERA_RESERVED_QIS\n    reg simulation_clock;\n    reg sdrs;\n    reg cdr;\n    reg sdr;\n    reg e1dr;\n    reg udr;\n    reg [7:0] bit_index;\n`endif\n\n`ifdef ALTERA_RESERVED_QIS\n    wire tdi_port;\n    wire [IRWIDTH - 1:0] ir_in_port;\n    always @(tdi_port)\n      tdi = tdi_port;\n    always @(ir_in_port)\n      ir_in = ir_in_port;\n    sld_virtual_jtag_basic  sld_virtual_jtag_component (\n                .ir_out (ir_out),\n                .tdo (tdo),\n                .tdi (tdi_port),\n                .tck (tck),\n                .ir_in (ir_in_port),\n                .virtual_state_cir (virtual_state_cir),\n                .virtual_state_pdr (virtual_state_pdr),\n                .virtual_state_uir (virtual_state_uir),\n                .virtual_state_sdr (virtual_state_sdr),\n                .virtual_state_cdr (virtual_state_cdr),\n                .virtual_state_udr (virtual_state_udr),\n                .virtual_state_e1dr (virtual_state_e1dr),\n                .virtual_state_e2dr (virtual_state_e2dr)\n                ,\n                .jtag_state_cdr (),\n                .jtag_state_cir (),\n                .jtag_state_e1dr (),\n                .jtag_state_e1ir (),\n                .jtag_state_e2dr (),\n                .jtag_state_e2ir (),\n                .jtag_state_pdr (),\n                .jtag_state_pir (),\n                .jtag_state_rti (),\n                .jtag_state_sdr (),\n                .jtag_state_sdrs (),\n                .jtag_state_sir (),\n                .jtag_state_sirs (),\n                .jtag_state_tlr (),\n                .jtag_state_udr (),\n                .jtag_state_uir (),\n                .tms ()\n                );\n    defparam\n        sld_virtual_jtag_component.sld_mfg_id = 110,\n        sld_virtual_jtag_component.sld_type_id = 132,\n        sld_virtual_jtag_component.sld_version = 1,\n        sld_virtual_jtag_component.sld_auto_instance_index = \"YES\",\n        sld_virtual_jtag_component.sld_instance_index = 0,\n        sld_virtual_jtag_component.sld_ir_width = IRWIDTH,\n        sld_virtual_jtag_component.sld_sim_action = \"\",\n        sld_virtual_jtag_component.sld_sim_n_scan = 0,\n        sld_virtual_jtag_component.sld_sim_total_length = 0;\n`endif\n\n`ifndef ALTERA_RESERVED_QIS\n\n    localparam DATA     = 0;\n    localparam LOOPBACK = 1;\n    localparam DEBUG    = 2;\n    localparam INFO     = 3;\n    localparam CONTROL  = 4;\n    localparam MGMT     = 5;\n\n    always\n        //#TCK_HALF_PERIOD_US simulation_clock = $random;\n        #TCK_HALF_PERIOD_US simulation_clock = ~simulation_clock;\n    \n    assign tck = simulation_clock;\n    assign virtual_state_cdr = cdr;\n    assign virtual_state_sdr = sdr;\n    assign virtual_state_e1dr = e1dr;\n    assign virtual_state_udr = udr;\n    \n    task reset_jtag_state;\n      begin\n        simulation_clock = 0;\n        enter_data_mode;\n        clear_states_async;\n      end\n    endtask\n    \n    task enter_data_mode;\n      begin\n        ir_in = DATA;\n        clear_states;\n      end\n    endtask\n    \n    task enter_loopback_mode;\n      begin\n        ir_in = LOOPBACK;\n        clear_states;\n      end\n    endtask\n    \n    task enter_debug_mode;\n      begin\n        ir_in = DEBUG;\n        clear_states;\n      end\n    endtask\n    \n    task enter_info_mode;\n      begin\n        ir_in = INFO;\n        clear_states;\n      end\n    endtask\n    \n    task enter_control_mode;\n      begin\n        ir_in = CONTROL;\n        clear_states;\n      end\n    endtask\n    \n    task enter_mgmt_mode;\n      begin\n        ir_in = MGMT;\n        clear_states;\n      end\n    endtask\n    \n    task enter_sdrs_state;\n      begin\n        {sdrs, cdr, sdr, e1dr, udr} = 5'b10000;\n        tdi = 1'b0;\n        @(posedge tck);\n      end\n    endtask\n    \n    task enter_cdr_state;\n      begin\n        {sdrs, cdr, sdr, e1dr, udr} = 5'b01000;\n        tdi = 1'b0;\n        @(posedge tck);\n      end\n    endtask\n\n    task enter_e1dr_state;\n      begin\n        {sdrs, cdr, sdr, e1dr, udr} = 5'b00010;\n        tdi = 1'b0;\n        @(posedge tck);\n      end\n    endtask\n    \n    task enter_udr_state;\n      begin\n        {sdrs, cdr, sdr, e1dr, udr} = 5'b00001;\n        tdi = 1'b0;\n        @(posedge tck);\n      end\n    endtask\n    \n    task clear_states;\n      begin\n        clear_states_async;\n        @(posedge tck);\n      end\n    endtask\n    \n    task clear_states_async;\n      begin\n        {cdr, sdr, e1dr, udr} = 4'b0000;\n      end\n    endtask\n    \n    task shift_one_bit;\n      input bit_to_send;\n      output reg bit_received;\n      begin\n        {cdr, sdr, e1dr, udr} = 4'b0100;\n        tdi = bit_to_send;\n        @(posedge tck);\n        bit_received = tdo;\n      end\n    endtask\n    \n    task shift_one_byte;\n      input [7:0] byte_to_send;\n      output reg [7:0] byte_received;\n      integer i;\n      reg bit_received;\n      begin\n        for (i=0; i<8; i=i+1)\n        begin\n          bit_index = i;\n          shift_one_bit(byte_to_send[i], bit_received);\n          byte_received[i] = bit_received;\n        end\n      end\n    endtask\n\n`endif\n\nendmodule"}
{"task_id": 1059, "completion": "// ... module implementation details omitted for brevity ... \n    endmodule"}
{"task_id": 654, "completion": "parameter INTRA = 0,\n              INTER = 1;\n\n    reg [2:0] rotate;\n    reg duo_rotate;\n\n    reg [3:0] cur_00_4x4_x;\n    reg [3:0] cur_00_4x4_y;\n    reg [4:0] cur_00_idx;\n    reg [0:0] cur_00_sel;\n    reg [1:0] cur_00_size;\n    reg [0:0] cur_00_ren;\n    reg [32*`PIXEL_WIDTH-1:0] cur_00_pel;\n\n    reg [3:0] cur_01_4x4_x;\n    reg [3:0] cur_01_4x4_y;\n    reg [4:0] cur_01_idx;\n    reg [0:0] cur_01_sel;\n    reg [1:0] cur_01_size;\n    reg [0:0] cur_01_ren;\n    reg [32*`PIXEL_WIDTH-1:0] cur_01_pel;\n\n    reg [3:0] cur_02_4x4_x;\n    reg [3:0] cur_02_4x4_y;\n    reg [4:0] cur_02_idx;\n    reg [0:0] cur_02_sel;\n    reg [1:0] cur_02_size;\n    reg [0:0] cur_02_ren;\n    reg [32*`PIXEL_WIDTH-1:0] cur_02_pel;\n\n    reg [3:0] cur_03_4x4_x;\n    reg [3:0] cur_03_4x4_y;\n    reg [4:0] cur_03_idx;\n    reg [0:0] cur_03_sel;\n    reg [1:0] cur_03_size;\n    reg [0:0] cur_03_ren;\n    reg [32*`PIXEL_WIDTH-1:0] cur_03_pel;\n\n    reg [3:0] cur_04_4x4_x;\n    reg [3:0] cur_04_4x4_y;\n    reg [4:0] cur_04_idx;\n    reg [0:0] cur_04_sel;\n    reg [1:0] cur_04_size;\n    reg [0:0] cur_04_ren;\n    reg [32*`PIXEL_WIDTH-1:0] cur_04_pel;\n\n    reg [32*`PIXEL_WIDTH-1:0] fime_cur_pel0, fime_cur_pel1;\n\n    reg cur_00_wen;\n    reg [7:0] cur_00_waddr;\n    reg [32*`PIXEL_WIDTH-1:0] cur_00_wdata;\n    wire [32*`PIXEL_WIDTH-1:0] cur_00_rdata;\n\n    reg cur_01_wen;\n    reg [7:0] cur_01_waddr;\n    reg [32*`PIXEL_WIDTH-1:0] cur_01_wdata;\n    wire [32*`PIXEL_WIDTH-1:0] cur_01_rdata;\n\n    reg cur_02_wen;\n    reg [7:0] cur_02_waddr;\n    reg [32*`PIXEL_WIDTH-1:0] cur_02_wdata;\n    wire [32*`PIXEL_WIDTH-1:0] cur_02_rdata;\n\n    reg cur_03_wen;\n    reg [7:0] cur_03_waddr;\n    reg [32*`PIXEL_WIDTH-1:0] cur_03_wdata;\n    wire [32*`PIXEL_WIDTH-1:0] cur_03_rdata;\n\n    reg cur_04_wen;\n    reg [7:0] cur_04_waddr;\n    reg [32*`PIXEL_WIDTH-1:0] cur_04_wdata;\n    wire [32*`PIXEL_WIDTH-1:0] cur_04_rdata;\n\n    reg cur_duo1_wen;\n    reg [7:0] cur_duo1_waddr;\n    reg [32*`PIXEL_WIDTH-1:0] cur_duo1_wdata;\n    wire [32*`PIXEL_WIDTH-1:0] cur_duo1_rdata;\n\n    reg cur_duo2_wen;\n    reg [7:0] cur_duo2_waddr;\n    reg [32*`PIXEL_WIDTH-1:0] cur_duo2_wdata;\n    wire [32*`PIXEL_WIDTH-1:0] cur_duo2_rdata;\n\n    reg [32*`PIXEL_WIDTH-1:0] fme_cur_pel_o;\n    reg [32*`PIXEL_WIDTH-1:0] mc_cur_pel_o;\n    reg [32*`PIXEL_WIDTH-1:0] db_cur_pel_o;\n    reg [32*`PIXEL_WIDTH-1:0] pre_i_pel_o;\n\n    always @(posedge clk or negedge rstn) begin\n        if (!rstn) begin\n            rotate <= 0;\n            duo_rotate <= 0;\n        end else if (sysif_start_i) begin\n            duo_rotate <= ~duo_rotate;\n            if (rotate == 4)\n                rotate <= 0;\n            else begin\n                rotate <= rotate + 1;\n            end\n        end\n    end\n\n    always @(*) begin\n        case (rotate)\n            'd0: begin\n                cur_00_wen = ext_load_valid_i;\n                cur_00_waddr = ext_load_addr_i;\n                cur_00_wdata = ext_load_data_i;\n                cur_00_ren = 0;\n                cur_00_sel = 0;\n                cur_00_size = 0;\n                cur_00_4x4_x = 0;\n                cur_00_4x4_y = 0;\n                cur_00_idx = 0;\n            end\n            // (remaining cases follow the same pattern)\n        endcase\n    end\n\n    // (the rest of the module code follows)\n\nendmodule"}
{"task_id": 1993, "completion": "always @*\nbegin : sbox_update\n\n\treg U0, U1, U2, U3, U4, U5, U6, U7;\n\treg S0, S1, S2, S3, S4, S5, S6, S7;\n\treg Y5;\n\treg T1, T2, T3, T4, T6, T8, T9, T10, T13, T14, T15, T16, T17, T19;\n\treg T20, T22, T23, T24, T25, T26, T27;\n\treg M1, M2, M3, M4, M5, M6, M7, M8, M9, M10, M11, M12, M13, M14;\n\treg M15, M16, M17, M18, M19, M20, M21, M22, M23, M24, M25, M26, M27;\n\treg M28, M29, M30, M31, M32, M33, M34, M35, M36, M37, M38, M39, M40;\n\treg M41, M42, M43, M44, M45, M46, M47, M48, M49, M50, M51, M52, M53;\n\treg M54, M55, M56, M57, M58, M59, M60, M61, M62, M63;\n\t\n\t{ U0, U1, U2, U3, U4, U5, U6, U7 } = U;\n\t\n\tif(dec)\n\tbegin : decrypt_top\n\t\treg R5, R13, R17, R18, R19;\n\t\t\n\t\tT23 = U0 ^ U3;\n\t\tT22 = ~(U1 ^ U3);\n\t\tT2 = ~(U0 ^ U1); \n\t\tT1 = U3 ^ U4; \n\t\tT24 = ~(U4 ^ U7);\n\t\tR5 = U6 ^ U7; \n\t\tT8 = ~(U1 ^ T23);\n\t\tT19 = T22 ^ R5;\n\t\tT9 = ~(U7 ^ T1);\n\t\tT10 = T2 ^ T24;\n\t\tT13 = T2 ^ R5;\n\t\tT3 = T1 ^ R5;\n\t\tT25 = ~(U2 ^ T1);\n\t\tR13 = U1 ^ U6;\n\t\tT17 = ~(U2 ^ T19);\n\t\tT20 = T24 ^ R13;\n\t\tT4 = U4 ^ T8;\n\t\tR17 = ~(U2 ^ U5);\n\t\tR18 = ~(U5 ^ U6);\n\t\tR19 = ~(U2 ^ U4);\n\t\tY5 = U0 ^ R17;\n\t\tT6 = T22 ^ R17;\n\t\tT16 = R13 ^ R19;\n\t\tT27 = T1 ^ R18;\n\t\tT15 = T10 ^ T27;\n\t\tT14 = T10 ^ R18;\n\t\tT26 = T3 ^ T16;\n\tend\n\telse // !dec\n\tbegin : encrypt_top\n\t\treg T5, T7, T11, T12, T18, T21;\n\t\t\n\t\tT1 = U0 ^ U3; /* T1 = U0 + U3 */\n\t\tT2 = U0 ^ U5; /* T2 = U0 + U5 */\n\t\tT3 = U0 ^ U6; /* T3 = U0 + U6 */\n\t\tT4 = U3 ^ U5; /* T4 = U3 + U5 */\n\t\tT5 = U4 ^ U6; /* T5 = U4 + U6 */\n\t\tT6 = T1 ^ T5; /* T6 = T1 + T5 */\n\t\tT7 = U1 ^ U2; /* T7 = U1 + U2 */\n\t\tT8 = U7 ^ T6; /* T8 = U7 + T6 */\n\t\tT9 = U7 ^ T7; /* T9 = U7 + T7 */\n\t\tT10 = T6 ^ T7; /* T10 = T6 + T7 */\n\t\tT11 = U1 ^ U5; /* T11 = U1 + U5 */\n\t\tT12 = U2 ^ U5; /* T12 = U2 + U5 */\n\t\tT13 = T3 ^ T4; /* T13 = T3 + T4 */\n\t\tT14 = T6 ^ T11; /* T14 = T6 + T11 */\n\t\tT15 = T5 ^ T11; /* T15 = T5 + T11 */\n\t\tT16 = T5 ^ T12; /* T16 = T5 + T12 */\n\t\tT17 = T9 ^ T16; /* T17 = T9 + T16 */\n\t\tT18 = U3 ^ U7; /* T18 = U3 + U7 */\n\t\tT19 = T7 ^ T18; /* T19 = T7 + T18 */\n\t\tT20 = T1 ^ T19; /* T20 = T1 + T19 */\n\t\tT21 = U6 ^ U7; /* T21 = U6 + U7 */\n\t\tT22 = T7 ^ T21; /* T22 = T7 + T21 */\n\t\tT23 = T2 ^ T22; /* T23 = T2 + T22 */\n\t\tT24 = T2 ^ T10; /* T24 = T2 + T10 */\n\t\tT25 = T20 ^ T17; /* T25 = T20 + T17 */\n\t\tT26 = T3 ^ T16; /* T26 = T3 + T16 */\n\t\tT27 = T1 ^ T12; /* T27 = T1 + T12 */\n\t\tY5 = U7;\n\tend\n\t\n\tM1 = T13 & T6; /* M1 = T13 x T6 */\n\tM2 = T23 & T8; /* M2 = T23 x T8 */\n\tM3 = T14 ^ M1; /* M3 = T14 + M1 */\n\tM4 = T19 & Y5; /* M4 = T19 x Y5 */\n\tM5 = M4 ^ M1; /* M5 = M4 + M1 */\n\tM6 = T3 & T16; /* M6 = T3 x T16 */\n\tM7 = T22 & T9; /* M7 = T22 x T9 */\n\tM8 = T26 ^ M6; /* M8 = T26 + M6 */\n\tM9 = T20 & T17; /* M9 = T20 x T17 */\n\tM10 = M9 ^ M6; /* M10 = M9 + M6 */\n\tM11 = T1 & T15; /* M11 = T1 x T15 */\n\tM12 = T4 & T27; /* M12 = T4 x T27 */\n\tM13 = M12 ^ M11; /* M13 = M12 + M11 */\n\tM14 = T2 & T10; /* M14 = T2 x T10 */\n\tM15 = M14 ^ M11; /* M15 = M14 + M11 */\n\tM16 = M3 ^ M2; /* M16 = M3 + M2 */\n\tM17 = M5 ^ T24; /* M17 = M5 + T24 */\n\tM18 = M8 ^ M7; /* M18 = M8 + M7 */\n\tM19 = M10 ^ M15; /* M19 = M10 + M15 */\n\tM20 = M16 ^ M13; /* M20 = M16 + M13 */\n\tM21 = M17 ^ M15; /* M21 = M17 + M15 */\n\tM22 = M18 ^ M13; /* M22 = M18 + M13 */\n\tM23 = M19 ^ T25; /* M23 = M19 + T25 */\n\tM24 = M22 ^ M23; /* M24 = M22 + M23 */\n\tM25 = M22 & M20; /* M25 = M22 x M20 */\n\tM26 = M21 ^ M25; /* M26 = M21 + M25 */\n\tM27 = M20 ^ M21; /* M27 = M20 + M21 */\n\tM28 = M23 ^ M25; /* M28 = M23 + M25 */\n\tM29 = M28 & M27; /* M29 = M28 x M27 */\n\tM30 = M26 & M24; /* M30 = M26 x M24 */\n\tM31 = M20 & M23; /* M31 = M20 x M23 */\n\tM32 = M27 & M31; /* M32 = M27 x M31 */\n\tM33 = M27 ^ M25; /* M33 = M27 + M25 */\n\tM34 = M21 & M22; /* M34 = M21 x M22 */\n\tM35 = M24 & M34; /* M35 = M24 x M34 */\n\tM36 = M24 ^ M25; /* M36 = M24 + M25 */\n\tM37 = M21 ^ M29; /* M37 = M21 + M29 */\n\tM38 = M32 ^ M33; /* M38 = M32 + M33 */\n\tM39 = M23 ^ M30; /* M39 = M23 + M30 */\n\tM40 = M35 ^ M36; /* M40 = M35 + M36 */\n\tM41 = M38 ^ M40; /* M41 = M38 + M40 */\n\tM42 = M37 ^ M39; /* M42 = M37 + M39 */\n\tM43 = M37 ^ M38; /* M43 = M37 + M38 */\n\tM44 = M39 ^ M40; /* M44 = M39 + M40 */\n\tM45 = M42 ^ M41; /* M45 = M42 + M41 */\n\tM46 = M44 & T6; /* M46 = M44 x T6 */\n\tM47 = M40 & T8; /* M47 = M40 x T8 */\n\tM48 = M39 & Y5; /* M48 = M39 x Y5 */\n\tM49 = M43 & T16; /* M49 = M43 x T16 */\n\tM50 = M38 & T9; /* M50 = M38 x T9 */\n\tM51 = M37 & T17; /* M51 = M37 x T17 */\n\tM52 = M42 & T15; /* M52 = M42 x T15 */\n\tM53 = M45 & T27; /* M53 = M45 x T27 */\n\tM54 = M41 & T10; /* M54 = M41 x T10 */\n\tM55 = M44 & T13; /* M55 = M44 x T13 */\n\tM56 = M40 & T23; /* M56 = M40 x T23 */\n\tM57 = M39 & T19; /* M57 = M39 x T19 */\n\tM58 = M43 & T3; /* M58 = M43 x T3 */\n\tM59 = M38 & T22; /* M59 = M38 x T22 */\n\tM60 = M37 & T20; /* M60 = M37 x T20 */\n\tM61 = M42 & T1; /* M61 = M42 x T1 */\n\tM62 = M45 & T4; /* M62 = M45 x T4 */\n\tM63 = M41 & T2; /* M63 = M41 x T2 */\n\n\tif(dec)\n\tbegin : decrypt_bot\n\t\treg P0, P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14;\n\t\treg P15, P16, P17, P18, P19, P20, P22, P23, P24, P25, P26, P27;\n\t\treg P28, P29;\n\t\t\n\t\tP0 = M52 ^ M61;\n\t\tP1 = M58 ^ M59;\n\t\tP2 = M54 ^ M62;\n\t\tP3 = M47 ^ M50;\n\t\tP4 = M48 ^ M56;\n\t\tP5 = M46 ^ M51;\n\t\tP6 = M49 ^ M60;\n\t\tP7 = P0 ^ P1;\n\t\tP8 = M50 ^ M53;\n\t\tP9 = M55 ^ M63;\n\t\tP10 = M57 ^ P4;\n\t\tP11 = P0 ^ P3;\n\t\tP12 = M46 ^ M48;\n\t\tP13 = M49 ^ M51;\n\t\tP14 = M49 ^ M62;\n\t\tP15 = M54 ^ M59;\n\t\tP16 = M57 ^ M61;\n\t\tP17 = M58 ^ P2;\n\t\tP18 = M63 ^ P5;\n\t\tP19 = P2 ^ P3;\n\t\tP20 = P4 ^ P6;\n\t\tP22 = P2 ^ P7;\n\t\tP23 = P7 ^ P8;\n\t\tP24 = P5 ^ P7;\n\t\tP25 = P6 ^ P10;\n\t\tP26 = P9 ^ P11;\n\t\tP27 = P10 ^ P18;\n\t\tP28 = P11 ^ P25;\n\t\tP29 = P15 ^ P20;\n\n\t\tS0 = P13 ^ P22;\n\t\tS1 = P26 ^ P29;\n\t\tS2 = P17 ^ P28;\n\t\tS3 = P12 ^ P22;\n\t\tS4 = P23 ^ P27;\n\t\tS5 = P19 ^ P24;\n\t\tS6 = P14 ^ P23;\n\t\tS7 = P9 ^ P16;\n\tend\n\telse // !dec\n\tbegin : encrypt_bot\n\t\treg L0, L1, L2, L3, L4, L5, L6, L7, L8, L9, L10, L11, L12, L13, L14;\n\t\treg L15, L16, L17, L18, L19, L20, L21, L22, L23, L24, L25, L26, L27;\n\t\treg L28, L29;\n\t\t \n\t\tL0 = M61 ^ M62; /* L0 = M61 + M62 */\n\t\tL1 = M50 ^ M56; /* L1 = M50 + M56 */\n\t\tL2 = M46 ^ M48; /* L2 = M46 + M48 */\n\t\tL3 = M47 ^ M55; /* L3 = M47 + M55 */\n\t\tL4 = M54 ^ M58; /* L4 = L4 + M58 */\n\t\tL5 = M49 ^ M61; /* L5 = M49 + M61 */\n\t\tL6 = M62 ^ L5; /* L6 = M62 + L5 */\n\t\tL7 = M46 ^ L3; /* L7 = M46 + L3 */\n\t\tL8 = M51 ^ M59; /* L8 = M51 + M59 */\n\t\tL9 = M52 ^ M53; /* L9 = M52 + M53 */\n\t\tL10 = M53 ^ L4; /* L10 = M53 + L4 */\n\t\tL11 = M60 ^ L2; /* L11 = M60 + L2 */\n\t\tL12 = M48 ^ M51; /* L12 = M48 + M51 */\n\t\tL13 = M50 ^ L0; /* L13 = M50 + L0 */\n\t\tL14 = M52 ^ M61; /* L14 = M52 + M61 */\n\t\tL15 = M55 ^ L1; /* L15 = M55 + L1 */\n\t\tL16 = M56 ^ L0; /* L16 = M56 + L0 */\n\t\tL17 = M57 ^ L1; /* L17 = M57 + L1 */\n\t\tL18 = M58 ^ L8; /* L18 = M58 + L8 */\n\t\tL19 = M63 ^ L4; /* L19 = M63 + L4 */\n\t\tL20 = L0 ^ L1; /* L20 = L0 + L1 */\n\t\tL21 = L1 ^ L7; /* L21 = L1 + L7 */\n\t\tL22 = L3 ^ L12; /* L22 = L3 + L12 */\n\t\tL23 = L18 ^ L2; /* L23 = L18 + L2 */\n\t\tL24 = L15 ^ L9; /* L24 = L15 + L9 */\n\t\tL25 = L6 ^ L10; /* L25 = L6 + L10 */\n\t\tL26 = L7 ^ L9; /* L26 = L7 + L9 */\n\t\tL27 = L8 ^ L10; /* L27 = L8 + L10 */\n\t\tL28 = L11 ^ L14; /* L28 = L11 + L14 */\n\t\tL29 = L11 ^ L17; /* L29 = L11 + L17 */\n\n\t\tS0 = L6 ^ L24; /* S0 = L6 + L24 */\n\t\tS1 = ~(L16 ^ L26); /* S1 = L16 # L26 */\n\t\tS2 = ~(L19 ^ L28); /* S2 = L19 # L28 */\n\t\tS3 = L6 ^ L21; /* S3 = L6 + L21 */\n\t\tS4 = L20 ^ L22; /* S4 = L20 + L22 */\n\t\tS5 = L25 ^ L29; /* S5 = L25 + L29 */\n\t\tS6 = ~(L13 ^ L27); /* S6 = L13 # L27 */\n\t\tS7 = ~(L6 ^ L23); /* S7 = L6 # L23 */\n\tend\n\t\n\tS = { S0, S1, S2, S3, S4, S5, S6, S7 };\nend\n\nendmodule"}
{"task_id": 698, "completion": "wire [7:0]                      ide_3f6_writedata;\n    wire                            ide_3f6_write;\n    wire                            ide_3f6_read;\n    wire [7:0]                      ide_3f6_readdata;\n    wire                            pic_interrupt_do;\n    wire [7:0]                      pic_interrupt_vector;\n    wire                            ao486_interrupt_done;\n\n    wire                            bios_loader_waitrequest;\n    wire [31:0]                     bios_loader_writedata;\n    wire [27:0]                     bios_loader_address;\n    wire                            bios_loader_write;\n    wire                            bios_loader_read;\n    wire [31:0]                     bios_loader_readdata;\n    wire                            bios_loader_debugaccess;\n    wire [3:0]                      bios_loader_byteenable;\n\n    wire                            hdd_avalon_master_waitrequest;\n    wire [31:0]                     hdd_avalon_master_writedata;\n    wire [31:0]                     hdd_avalon_master_address;\n    wire                            hdd_avalon_master_write;\n    wire                            hdd_avalon_master_read;\n    wire [31:0]                     hdd_avalon_master_readdata;\n    wire                            hdd_avalon_master_readdatavalid;\n\n    wire                            ao486_avalon_memory_waitrequest;\n    wire [2:0]                      ao486_avalon_memory_burstcount;\n    wire [31:0]                     ao486_avalon_memory_writedata;\n    wire [31:0]                     ao486_avalon_memory_address;\n    wire                            ao486_avalon_memory_write;\n    wire                            ao486_avalon_memory_read;\n    wire [31:0]                     ao486_avalon_memory_readdata;\n    wire                            ao486_avalon_memory_readdatavalid;\n    wire [3:0]                      ao486_avalon_memory_byteenable;\n\n    wire                            ao486_avalon_io_waitrequest;\n    wire [31:0]                     ao486_avalon_io_writedata;\n    wire [15:0]                     ao486_avalon_io_address;\n    wire                            ao486_avalon_io_write;\n    wire                            ao486_avalon_io_read;\n    wire [31:0]                     ao486_avalon_io_readdata;\n    wire                            ao486_avalon_io_readdatavalid;\n    wire [3:0]                      ao486_avalon_io_byteenable;\n\n    wire [3:0]                      vga_io_b_address;\n    wire                            vga_io_b_write;\n    wire [7:0]                      vga_io_b_writedata;\n    wire                            vga_io_b_read;\n    wire [7:0]                      vga_io_b_readdata;\n\n    ... \n\n    io_bus io_bus(\n                  .clk_sys                       (clk_sys),\n                  .rst                           (reset_sys),\n                  .ao486_avalon_io_address       (ao486_avalon_io_address),\n                  .ao486_avalon_io_waitrequest   (ao486_avalon_io_waitrequest),\n                  .ao486_avalon_io_byteenable    (ao486_avalon_io_byteenable),\n                  .ao486_avalon_io_read          (ao486_avalon_io_read),\n                  .ao486_avalon_io_readdata      (ao486_avalon_io_readdata),\n                  .ao486_avalon_io_readdatavalid (ao486_avalon_io_readdatavalid),\n                  .ao486_avalon_io_write         (ao486_avalon_io_write),\n                  .ao486_avalon_io_writedata     (ao486_avalon_io_writedata),\n                  .vga_io_b_address              (vga_io_b_address),\n                  .vga_io_b_write                (vga_io_b_write),\n                  .vga_io_b_writedata            (vga_io_b_writedata),\n                  .vga_io_b_read                 (vga_io_b_read),\n                  .vga_io_b_readdata             (vga_io_b_readdata),\n                  .vga_io_c_address              (vga_io_c_address),\n                  .vga_io_c_write                (vga_io_c_write),\n                  .vga_io_c_writedata            (vga_io_c_writedata),\n                  .vga_io_c_read                 (vga_io_c_read),\n                  .vga_io_c_readdata             (vga_io_c_readdata),\n                  .vga_io_d_address              (vga_io_d_address),\n                  .vga_io_d_write                (vga_io_d_write),\n                  .vga_io_d_writedata            (vga_io_d_writedata),\n                  .vga_io_d_read                 (vga_io_d_read),\n                  .vga_io_d_readdata             (vga_io_d_readdata),\n                  .ps2_io_address                (ps2_io_address),\n                  .ps2_io_write                  (ps2_io_write),\n                  .ps2_io_writedata              (ps2_io_writedata),\n                  .ps2_io_read                   (ps2_io_read),\n                  .ps2_io_readdata               (ps2_io_readdata),\n                  .ps2_sysctl_address            (ps2_sysctl_address),\n                  .ps2_sysctl_write              (ps2_sysctl_write),\n                  .ps2_sysctl_writedata          (ps2_sysctl_writedata),\n                  .ps2_sysctl_read               (ps2_sysctl_read),\n                  .ps2_sysctl_readdata           (ps2_sysctl_readdata),\n                  .pit_io_address                (pit_io_address),\n                  .pit_io_write                  (pit_io_write),\n                  .pit_io_writedata              (pit_io_writedata),\n                  .pit_io_read                   (pit_io_read),\n                  .pit_io_readdata               (pit_io_readdata),\n                  .rtc_io_address                (rtc_io_address),\n                  .rtc_io_write                  (rtc_io_write),\n                  .rtc_io_writedata              (rtc_io_writedata),\n                  .rtc_io_read                   (rtc_io_read),\n                  .rtc_io_readdata               (rtc_io_readdata),\n                  .pic_master_address            (pic_master_address),\n                  .pic_master_write              (pic_master_write),\n                  .pic_master_writedata          (pic_master_writedata),\n                  .pic_master_read               (pic_master_read),\n                  .pic_master_readdata           (pic_master_readdata),\n                  .pic_slave_address             (pic_slave_address),\n                  .pic_slave_write               (pic_slave_write),\n                  .pic_slave_writedata           (pic_slave_writedata),\n                  .pic_slave_read                (pic_slave_read),\n                  .pic_slave_readdata            (pic_slave_readdata),\n                  .hdd_io_address                (hdd_io_address),\n                  .hdd_io_write                  (hdd_io_write),\n                  .hdd_io_writedata              (hdd_io_writedata),\n                  .hdd_io_read                   (hdd_io_read),\n                  .hdd_io_readdata               (hdd_io_readdata),\n                  .hdd_io_byteenable             (hdd_io_byteenable),\n                  .ide_3f6_write                 (ide_3f6_write),\n                  .ide_3f6_writedata             (ide_3f6_writedata),\n                  .ide_3f6_read                  (ide_3f6_read),\n                  .ide_3f6_readdata              (ide_3f6_readdata)\n                  );\n\nendmodule"}
{"task_id": 1946, "completion": "// registering the control_fixed_location bit\n\talways @ (posedge clk or posedge reset)\n\tbegin\n\t\tif (reset == 1)\n\t\tbegin\n\t\t\tcontrol_fixed_location_d1 <= 0;\n\t\tend\n\t\telse\n\t\tbegin\n\t\t\tif (control_go == 1)\n\t\t\tbegin\n\t\t\t\tcontrol_fixed_location_d1 <= control_fixed_location;\n\t\t\tend\n\t\tend\n\tend\n\n\n\t// master address logic \n\tassign master_address = address;\n\tassign master_byteenable = -1;  // all ones, always performing word size accesses\n\talways @ (posedge clk or posedge reset)\n\tbegin\n\t\tif (reset == 1)\n\t\tbegin\n\t\t\taddress <= 0;\n\t\tend\n\t\telse\n\t\tbegin\n\t\t\tif(control_go == 1)\n\t\t\tbegin\n\t\t\t\taddress <= control_read_base;\n\t\t\tend\n\t\t\telse if((increment_address == 1) & (control_fixed_location_d1 == 0))\n\t\t\tbegin\n\t\t\t\taddress <= address + BYTEENABLEWIDTH;  // always performing word size accesses\n\t\t\tend\n\t\tend\n\tend\n\n\t\n\t// master length logic\n\talways @ (posedge clk or posedge reset)\n\tbegin\n\t\tif (reset == 1)\n\t\tbegin\n\t\t\tlength <= 0;\n\t\tend\n\t\telse\n\t\tbegin\n\t\t\tif(control_go == 1)\n\t\t\tbegin\n\t\t\t\tlength <= control_read_length;\n\t\t\tend\n\t\t\telse if(increment_address == 1)\n\t\t\tbegin\n\t\t\t\tlength <= length - BYTEENABLEWIDTH;  // always performing word size accesses\n\t\t\tend\n\t\tend\n\tend\n\t\n\t\n\t// control logic\n\tassign too_many_pending_reads = (fifo_used + reads_pending) >= (FIFODEPTH - 4);\n\tassign master_read = (length != 0) & (too_many_pending_reads_d1 == 0);\n\tassign increment_address = (length != 0) & (too_many_pending_reads_d1 == 0) & (master_waitrequest == 0);\n\tassign control_done = (reads_pending == 0) & (length == 0);  // master done posting reads and all reads have returned\n\tassign control_early_done = (length == 0);  // if you need all the pending reads to return then use 'control_done' instead of this signal\n\n\talways @ (posedge clk)\n\tbegin\n\t\tif (reset == 1)\n\t\tbegin\n\t\t\ttoo_many_pending_reads_d1 <= 0;\n\t\tend\n\t\telse\n\t\tbegin\n\t\t\ttoo_many_pending_reads_d1 <= too_many_pending_reads;\n\t\tend\n\tend\n\n\t\n\talways @ (posedge clk or posedge reset)\n\tbegin\n\t\tif (reset == 1)\n\t\tbegin\n\t\t\treads_pending <= 0;\n\t\tend\n\t\telse\n\t\tbegin\n\t\t\tif(increment_address == 1)\n\t\t\tbegin\n\t\t\t\tif(master_readdatavalid == 0)\n\t\t\t\tbegin\n\t\t\t\t\treads_pending <= reads_pending + 1;\n\t\t\t\tend\n\t\t\t\telse\n\t\t\t\tbegin\n\t\t\t\t\treads_pending <= reads_pending;  // a read was posted, but another returned\n\t\t\t\tend\t\n\t\t\tend\n\t\t\telse\n\t\t\tbegin\n\t\t\t\tif(master_readdatavalid == 0)\n\t\t\t\tbegin\n\t\t\t\t\treads_pending <= reads_pending;  // read was not posted and no read returned\n\t\t\t\tend\n\t\t\t\telse\n\t\t\t\tbegin\n\t\t\t\t\treads_pending <= reads_pending - 1;  // read was not posted but a read returned\n\t\t\t\tend\t\n\t\t\tend\n\t\tend\n\tend\n\n\t\n\t// read data feeding user logic\t\n\tassign user_data_available = !fifo_empty;\n\tscfifo the_master_to_user_fifo (\n\t\t.aclr (reset),\n\t\t.clock (clk),\n\t\t.data (master_readdata),\n\t\t.empty (fifo_empty),\n\t\t.q (user_buffer_data),\n\t\t.rdreq (user_read_buffer),\n\t\t.usedw (fifo_used),\n\t\t.wrreq (master_readdatavalid)\n\t);\n\tdefparam the_master_to_user_fifo.lpm_width = DATAWIDTH;\n\tdefparam the_master_to_user_fifo.lpm_numwords = FIFODEPTH;\n\tdefparam the_master_to_user_fifo.lpm_showahead = \"ON\";\n\tdefparam the_master_to_user_fifo.use_eab = (FIFOUSEMEMORY == 1)? \"ON\" : \"OFF\";\n\tdefparam the_master_to_user_fifo.add_ram_output_register = \"OFF\";\n\tdefparam the_master_to_user_fifo.underflow_checking = \"OFF\";\n\tdefparam the_master_to_user_fifo.overflow_checking = \"OFF\";\n\nendmodule"}
{"task_id": 1080, "completion": "wire [16:0] sl_oport0;\n wire [36:0] sl_iport0;\n \n ila_v5_1_ila #(\n .C_XLNX_HW_PROBE_INFO(\"NUM_OF_PROBES=1,DATA_DEPTH=1024,PROBE0_WIDTH=1,PROBE0_MU_CNT=4,PROBE1_WIDTH=1,PROBE1_MU_CNT=4,...\"),\n .C_XDEVICEFAMILY(\"zynq\"),\n .C_CORE_TYPE(1),\n .C_CORE_INFO1(0),\n .C_CORE_INFO2(0),\n .C_CAPTURE_TYPE(0),\n .C_MU_TYPE(0),\n .C_TC_TYPE(0),\n .C_NUM_OF_PROBES(1),\n .C_DATA_DEPTH(1024),\n .C_MAJOR_VERSION(2015),\n .C_MINOR_VERSION(2),\n .C_BUILD_REVISION(0),\n .C_CORE_MAJOR_VER(5),\n .C_CORE_MINOR_VER(1),\n .C_XSDB_SLAVE_TYPE(17),\n .C_NEXT_SLAVE(0),\n .C_CSE_DRV_VER(1),\n .C_USE_TEST_REG(1),\n .C_PIPE_IFACE(1),\n .C_RAM_STYLE(\"SUBCORE\"),\n .C_TRIGOUT_EN(1),\n .C_TRIGIN_EN(1),\n .C_ADV_TRIGGER(1),\n .C_EN_DDR_ILA(0),\n .C_DDR_CLK_GEN(0),\n .C_CLK_FREQ(200.00),\n .C_CLK_PERIOD(5.0),\n .C_CLKFBOUT_MULT_F(10.0),\n .C_DIVCLK_DIVIDE(2),\n .C_CLKOUT0_DIVIDE_F(10.0),\n .C_EN_STRG_QUAL(1),\n .C_INPUT_PIPE_STAGES(0),\n .C_PROBE0_WIDTH(1),\n .C_PROBE1_WIDTH(1),\n .C_PROBE2_WIDTH(1),\n .C_PROBE3_WIDTH(1),\n .C_PROBE4_WIDTH(1),\n .C_PROBE5_WIDTH(1),\n .C_PROBE6_WIDTH(1),\n .C_PROBE7_WIDTH(1),\n...\n ) inst (\n .clk(clk),\n .sl_iport0(sl_iport0),\n .sl_oport0(sl_oport0),\n .trig_out(trig_out),\n .trig_out_ack(trig_out_ack),\n .trig_in(trig_in),\n .trig_in_ack(trig_in_ack),\n .probe0(probe0),\n .probe1(0),\n .probe2(0),\n .probe3(0),\n...\n )/* synthesis syn_noprune=1 */;\nendmodule"}
{"task_id": 1558, "completion": "localparam integer CFG_DATAID_ARRAY_DEPTH = (2**CFG_DATA_ID_WIDTH);\n\n    always @ (posedge ctl_clk or negedge ctl_reset_n)\n    begin\n        if (!ctl_reset_n)\n        begin\n            cfg_enable_partial_be_notification <= 1'b0;\n        end\n        else\n        begin\n            cfg_enable_partial_be_notification <= cfg_enable_ecc | cfg_enable_auto_corr | cfg_enable_no_dm;\n        end\n    end\n    \n    always @ (posedge ctl_clk or negedge ctl_reset_n)\n    begin\n        if (!ctl_reset_n)\n        begin\n            cfg_max_cmd_burstcount    <= 0;\n            cfg_max_cmd_burstcount_2x <= 0;\n        end\n        else\n        begin\n            cfg_max_cmd_burstcount    <= cfg_burst_length / CFG_DWIDTH_RATIO;\n            cfg_max_cmd_burstcount_2x <= 2 * cfg_max_cmd_burstcount;\n        end\n    end\n    \n    assign burstcount_list_write      = update_cmd_if_accepted;\n    assign burstcount_list_write_data = {{(CFG_DATAID_ARRAY_DEPTH - CFG_INT_SIZE_WIDTH){1'b0}}, update_cmd_if_burstcount};\n    assign burstcount_list_read       = notify_data_if_valid;\n    \n    alt_mem_ddrx_list\n    # (\n        .CTL_LIST_WIDTH             (CFG_INT_SIZE_WIDTH),\n        .CTL_LIST_DEPTH             (CFG_DATAID_ARRAY_DEPTH),\n        .CTL_LIST_INIT_VALUE_TYPE   (\"ZERO\"),\n        .CTL_LIST_INIT_VALID        (\"INVALID\")\n    )\n    burstcount_list\n    (\n        .ctl_clk                    (ctl_clk),\n        .ctl_reset_n                (ctl_reset_n),\n        .list_get_entry_valid       (burstcount_list_read_data_valid),\n        .list_get_entry_ready       (burstcount_list_read),\n        .list_get_entry_id          (burstcount_list_read_data),\n        .list_get_entry_id_vector   (),\n        .list_put_entry_valid       (burstcount_list_write),\n        .list_put_entry_ready       (),\n        .list_put_entry_id          (burstcount_list_write_data)\n    );\n    \n    always @ (*).\n    begin\n        if (burstcount_list_read_data_valid && (update_data_if_burstcount >= burstcount_list_read_data))\n        begin\n            update_data_if_burstcount_greatereq_burstcount_list = 1'b1;\n        end\n        else\n        begin\n            update_data_if_burstcount_greatereq_burstcount_list = 1'b0;\n        end\n        \n        if (burstcount_list_read_data_valid && (update_data_if_burstcount == burstcount_list_read_data))\n        begin\n            update_data_if_burstcount_same_burstcount_list = 1'b1;\n        end\n        else\n        begin\n            update_data_if_burstcount_same_burstcount_list = 1'b0;\n        end\n    end\n    \n    genvar i;\n    generate\n        for (i = 0; i < CFG_DATAID_ARRAY_DEPTH; i = i + 1) \n        begin : gen_dataid_array_management\n\n            assign update_data_if_burstcount_greatereq  [i] = (update_data_if_valid & (update_data_if_data_id_vector [i])) & update_data_if_burstcount_greatereq_burstcount_list;\n            assign update_data_if_burstcount_same       [i] = (update_data_if_valid & (update_data_if_data_id_vector [i])) & update_data_if_burstcount_same_burstcount_list;\n            \n            always @ (posedge ctl_clk or negedge ctl_reset_n) \n            begin\n                if (~ctl_reset_n)\n                begin\n                    dataid_array_address    [i] <= 0;\n                    dataid_array_burstcount [i] <= 0;\n                    dataid_array_tbp_id     [i] <= 0;\n                    dataid_array_data_ready [i] <= 1'b0;\n                    dataid_array_valid      [i] <= 1'b0;\n                    mux_dataid_array_done   [i] <= 1'b0;\n                    \n                    err_dataid_array_overwritten <= 0;\n                    err_dataid_array_invalidread <= 0;\n                end\n                else\n                begin\n                    if (update_cmd_if_accepted && (update_cmd_if_data_id == i))\n                    begin\n                        dataid_array_address    [i] <=  update_cmd_if_address;\n                        dataid_array_burstcount [i] <=  update_cmd_if_burstcount;\n                        dataid_array_tbp_id     [i] <=  update_cmd_if_tbp_id;\n                        dataid_array_valid      [i] <=  1'b1;\n                        mux_dataid_array_done   [i] <=  1'b0;\n                        \n                        if (dataid_array_valid[i])\n                        begin\n                            err_dataid_array_overwritten <= 1;\n                        end\n                    end\n                    \n                    if (update_data_if_burstcount_greatereq[i])\n                    begin\n                        dataid_array_data_ready         [i] <= 1'b1;\n                    end\n                    \n                    if (read_data_if_valid_first && (read_data_if_data_id_vector_first[i]))\n                    begin\n                        dataid_array_address    [i] <=  dataid_array_address    [i] + 1;\n                        dataid_array_burstcount [i] <=  dataid_array_burstcount [i] - 1;\n                        dataid_array_data_ready [i] <=  0;\n                        \n                        if (dataid_array_burstcount [i] == 1'b1)\n                        begin\n                            dataid_array_valid    [i] <=  1'b0;\n                            mux_dataid_array_done [i] <=  1'b1;\n                        end\n                        else\n                        begin\n                            mux_dataid_array_done [i] <=  1'b0;\n                        end\n                        \n                        if (~dataid_array_valid[i])\n                        begin\n                            err_dataid_array_invalidread <= 1;\n                        end\n                    end\n                    else\n                    begin\n                        mux_dataid_array_done [i] <=  1'b0;\n                    end\n\n                end\n            end\n\n            always @ (*)\n            begin\n                if (update_data_if_burstcount_greatereq[i])\n                begin\n                    mux_notify_data_if_valid [i] = 1'b1;\n                end\n                else\n                begin\n                    mux_notify_data_if_valid [i] = 1'b0;\n                end\n            end\n\n        end\n    endgenerate\n    \n    assign notify_data_if_valid     = update_data_if_burstcount_greatereq_burstcount_list;\n    assign notify_data_if_burstcount= burstcount_list_read_data;\n\n    assign read_data_if_burstcount  = mux_read_data_if_burstcount   [CFG_DATAID_ARRAY_DEPTH-1];\n    assign read_data_if_done        = |mux_dataid_array_done;\n    assign update_cmd_if_address_blocked= |mux_update_cmd_if_address_blocked;\n    \n    generate\n        if (CFG_DRAM_WLAT_GROUP == 1) \n        begin\n            always @ (*);\n            begin\n                read_data_if_address = mux_read_data_if_address [CFG_DATAID_ARRAY_DEPTH - 1];\n            end\n        end\n        else\n        begin\n            wire                                 rdata_address_list_read;\n            wire [CFG_BUFFER_ADDR_WIDTH - 1 : 0] rdata_address_list_read_data;\n            wire                                 rdata_address_list_read_data_valid;\n            wire                                 rdata_address_list_write;\n            wire [CFG_BUFFER_ADDR_WIDTH - 1 : 0] rdata_address_list_write_data;\n            \n            assign rdata_address_list_read       = read_data_if_valid_last;\n            assign rdata_address_list_write      = read_data_if_valid_first;\n            assign rdata_address_list_write_data = mux_read_data_if_address [CFG_DATAID_ARRAY_DEPTH - 1];\n            \n            alt_mem_ddrx_list\n            # (\n                .CTL_LIST_WIDTH             (CFG_BUFFER_ADDR_WIDTH),\n                .CTL_LIST_DEPTH             (CFG_DRAM_WLAT_GROUP),\n                .CTL_LIST_INIT_VALUE_TYPE   (\"ZERO\"),\n                .CTL_LIST_INIT_VALID        (\"INVALID\")\n            )\n            rdata_address_list\n            (\n                .ctl_clk                    (ctl_clk),\n                .ctl_reset_n                (ctl_reset_n),\n                .list_get_entry_valid       (rdata_address_list_read_data_valid),\n                .list_get_entry_ready       (rdata_address_list_read),\n                .list_get_entry_id          (rdata_address_list_read_data),\n                .list_get_entry_id_vector   (),\n                .list_put_entry_valid       (rdata_address_list_write),\n                .list_put_entry_ready       (),\n                .list_put_entry_id          (rdata_address_list_write_data)\n            );\n            \n            for (i = 0;i < CFG_LOCAL_WLAT_GROUP;i = i + 1)\n            begin : rdata_if_address_per_dqs_group\n                always @ (*);\n                begin\n                    if (read_data_if_valid_first_vector [i])\n                    begin\n                        read_data_if_address [(i + 1) * CFG_BUFFER_ADDR_WIDTH - 1 : i * CFG_BUFFER_ADDR_WIDTH] = rdata_address_list_write_data;\n                    end\n                    else\n                    begin\n                        read_data_if_address [(i + 1) * CFG_BUFFER_ADDR_WIDTH - 1 : i * CFG_BUFFER_ADDR_WIDTH] = rdata_address_list_read_data;\n                    end\n                end\n            end\n        end\n    endgenerate\n    \n    always @ (posedge ctl_clk or negedge ctl_reset_n) \n    begin\n        if (~ctl_reset_n)\n        begin\n            write_data_if_address_blocked <= 0;\n        end\n        else\n        begin\n            write_data_if_address_blocked <= |mux_write_data_if_address_blocked;\n        end\n    end\n    \n    always @ (*) \n    begin\n        mux_tbp_data_ready                          [0] = (mux_notify_data_if_valid          [0]) ? dataid_array_tbp_id     [0] : {CFG_TBP_NUM{1'b0}};\n        mux_notify_data_if_burstcount               [0] = (mux_notify_data_if_valid          [0]) ? dataid_array_burstcount [0] : 0;\n        mux_read_data_if_address                    [0] = (read_data_if_data_id_vector_first [0]) ? dataid_array_address    [0] : 0;\n        mux_read_data_if_burstcount                 [0] = (read_data_if_data_id_vector_first [0]) ? dataid_array_burstcount [0] : 0;\n\n        mux_write_data_if_address_blocked           [0] = (dataid_array_data_ready[0] & ( (dataid_array_address[0] == write_data_if_nextaddress) | (dataid_array_address[0] == write_data_if_address) ) );\n\n        if (update_cmd_if_nextmaxaddress_wrapped)\n        begin\n            mux_update_cmd_if_address_blocked   [0] =  (dataid_array_valid[0] & ~( (dataid_array_address[0] < update_cmd_if_address) & (dataid_array_address[0] > update_cmd_if_nextmaxaddress) ));\n        end\n        else\n        begin\n            mux_update_cmd_if_address_blocked   [0] =  (dataid_array_valid[0] &  ( (dataid_array_address[0] >= update_cmd_if_address) & (dataid_array_address[0] <= update_cmd_if_nextmaxaddress) ));\n        end\n\n    end\n\n    genvar j;\n    generate\n        for (j = 1; j < CFG_DATAID_ARRAY_DEPTH; j = j + 1)\n        begin : gen_mux_dataid_array_output\n            always @ (*) \n            begin\n                mux_tbp_data_ready                  [j] = mux_tbp_data_ready            [j-1] | ( (mux_notify_data_if_valid          [j]) ? dataid_array_tbp_id     [j] : {CFG_TBP_NUM{1'b0}} );\n                mux_notify_data_if_burstcount       [j] = mux_notify_data_if_burstcount [j-1] | ( (mux_notify_data_if_valid          [j]) ? dataid_array_burstcount [j] : 0 );\n                mux_read_data_if_address            [j] = mux_read_data_if_address      [j-1] | ( (read_data_if_data_id_vector_first [j]) ? dataid_array_address    [j] : 0 );\n                mux_read_data_if_burstcount         [j] = mux_read_data_if_burstcount   [j-1] | ( (read_data_if_data_id_vector_first [j]) ? dataid_array_burstcount [j] : 0 );\n\n                mux_write_data_if_address_blocked   [j] = (dataid_array_data_ready[j] & ( (dataid_array_address[j] == write_data_if_nextaddress) | (dataid_array_address[j] == write_data_if_address) ) );\n\n                if (update_cmd_if_nextmaxaddress_wrapped)\n                begin\n                    mux_update_cmd_if_address_blocked   [j] =  (dataid_array_valid[j] & ~( (dataid_array_address[j] < update_cmd_if_address) & (dataid_array_address[j] > update_cmd_if_nextmaxaddress) ));\n                end\n                else\n                begin\n                    mux_update_cmd_if_address_blocked   [j] =  (dataid_array_valid[j] &  ( (dataid_array_address[j] >= update_cmd_if_address) & (dataid_array_address[j] <= update_cmd_if_nextmaxaddress) ));\n                end\n\n            end\n        end\n    endgenerate\n   \n    assign notify_tbp_data_ready    = mux_tbp_data_ready [CFG_DATAID_ARRAY_DEPTH-1];\n\n    assign update_cmd_if_accepted = update_cmd_if_ready & update_cmd_if_valid;\n    assign update_cmd_if_nextaddress = update_cmd_if_address + update_cmd_if_burstcount;\n    \n    always @ (posedge ctl_clk or negedge ctl_reset_n) \n    begin\n        if (~ctl_reset_n)\n        begin\n            update_cmd_if_address                <= 0;\n            update_cmd_if_nextmaxaddress         <= 0;\n            update_cmd_if_nextmaxaddress_wrapped <= 1'b0;\n            write_data_if_address                <= 0;\n            write_data_if_nextaddress            <= 0;\n        end\n        else\n        begin\n            if (update_cmd_if_accepted)\n            begin\n                update_cmd_if_address                <= update_cmd_if_nextaddress;\n                update_cmd_if_nextmaxaddress         <= update_cmd_if_nextaddress + cfg_max_cmd_burstcount_2x;\n                \n                if (update_cmd_if_nextaddress > (update_cmd_if_nextaddress + cfg_max_cmd_burstcount_2x))\n                begin\n                    update_cmd_if_nextmaxaddress_wrapped <= 1'b1;\n                end\n                else\n                begin\n                    update_cmd_if_nextmaxaddress_wrapped <= 1'b0;\n                end\n            end\n\n            if (write_data_if_accepted)\n            begin\n                write_data_if_address     <= write_data_if_address + 1;\n                write_data_if_nextaddress <= write_data_if_address + 2;\n            end\n            else\n            begin\n                write_data_if_nextaddress <= write_data_if_address + 1;\n            end\n        end\n    end  \n    \n    always @ (*) \n    begin\n\n        if (update_cmd_if_accepted)\n        begin\n            update_cmd_if_next_unnotified_burstcount = update_cmd_if_unnotified_burstcount + update_cmd_if_burstcount - mux_notify_data_if_burstcount [CFG_DATAID_ARRAY_DEPTH-1];\n        end\n        else\n        begin\n            update_cmd_if_next_unnotified_burstcount = update_cmd_if_unnotified_burstcount - mux_notify_data_if_burstcount [CFG_DATAID_ARRAY_DEPTH-1];\n        end\n\n    end\n    \n    always @ (posedge ctl_clk or negedge ctl_reset_n) \n    begin\n        if (~ctl_reset_n)\n        begin\n            update_cmd_if_unnotified_burstcount <= 0;\n        end\n        else\n        begin\n            update_cmd_if_unnotified_burstcount <= update_cmd_if_next_unnotified_burstcount;\n        end\n    end\n\n    // debug purposes\n    always @ (posedge ctl_clk or negedge ctl_reset_n) \n    begin\n        if (~ctl_reset_n)\n        begin\n            buffer_cmd_unallocated_counter <= {CFG_BUFFER_ADDR_WIDTH{1'b1}};\n            err_buffer_cmd_unallocated_counter_overflow <= 0;\n        end\n        else\n        begin\n            if (update_cmd_if_accepted & read_data_if_valid_last)\n            begin\n                buffer_cmd_unallocated_counter <= buffer_cmd_unallocated_counter- update_cmd_if_burstcount + 1;\n            end\n            else if (update_cmd_if_accepted)\n            begin\n                {err_buffer_cmd_unallocated_counter_overflow, buffer_cmd_unallocated_counter} <= buffer_cmd_unallocated_counter - update_cmd_if_burstcount;\n            end\n            else if (read_data_if_valid_last)\n            begin\n                buffer_cmd_unallocated_counter <= buffer_cmd_unallocated_counter + 1;\n            end\n            else\n            begin\n                buffer_cmd_unallocated_counter <= buffer_cmd_unallocated_counter;\n            end\n        end\n    end\n\n    always @ (posedge ctl_clk or negedge ctl_reset_n) \n    begin\n        if (~ctl_reset_n)\n        begin\n            update_cmd_if_ready <= 0;\n        end\n        else\n        begin\n            update_cmd_if_ready <= ~update_cmd_if_address_blocked;\n        end\n    end\n\n    assign  write_data_if_accepted    = write_data_if_ready & write_data_if_valid;\n\n    always @ (*) \n    begin\n        if (write_data_if_address_blocked)\n        begin\n            write_data_if_ready = 1'b0;\n        end\n        else \n        begin\n            write_data_if_ready = ~buffer_valid_counter_full & ~partial_be_when_no_cmd_tracked;\n        end\n    end\n\n    always @ (posedge ctl_clk or negedge ctl_reset_n) \n    begin\n        if (~ctl_reset_n)\n        begin\n            read_data_if_datavalid <= 0;\n        end\n        else\n        begin\n            read_data_if_datavalid <= read_data_if_valid;\n        end\n    end\n\n    always @ (posedge ctl_clk or negedge ctl_reset_n) \n    begin\n        if (~ctl_reset_n)\n        begin\n            buffer_valid_counter              <= 0;\n            buffer_valid_counter_full         <= 1'b0;\n            err_buffer_valid_counter_overflow <= 0;\n        end\n        else\n        begin\n            if (write_data_if_accepted & read_data_if_valid_last)\n            begin\n                buffer_valid_counter      <= buffer_valid_counter;\n                buffer_valid_counter_full <= buffer_valid_counter_full;\n            end\n            else if (write_data_if_accepted)\n            begin\n                {err_buffer_valid_counter_overflow, buffer_valid_counter} <= buffer_valid_counter + 1;\n                if (buffer_valid_counter == {{(CFG_BUFFER_ADDR_WIDTH - 1){1'b1}}, 1'b0}) \n                begin\n                    buffer_valid_counter_full <= 1'b1;\n                end\n                else\n                begin\n                    buffer_valid_counter_full <= 1'b0;\n                end\n            end\n            else if (read_data_if_valid_last)\n            begin\n                buffer_valid_counter      <= buffer_valid_counter - 1;\n                buffer_valid_counter_full <= 1'b0;\n            end\n            else\n            begin\n                buffer_valid_counter      <= buffer_valid_counter;\n                buffer_valid_counter_full <= buffer_valid_counter_full;\n            end\n        end\n    end\n\n    always @ (*) \n    begin\n        if (partial_be_when_no_cmd_tracked)\n        begin\n            notify_tbp_data_partial_be = update_data_if_valid & (|update_data_if_burstcount_same);\n        end\n        else\n        begin\n            notify_tbp_data_partial_be = partial_be_detected;\n        end    \n    end\n\n    assign update_data_bc_gt_update_cmd_unnotified_bc = ~update_data_if_valid | (update_data_if_burstcount >= update_cmd_if_unnotified_burstcount);\n\n    always @ (posedge ctl_clk or negedge ctl_reset_n) \n    begin\n        if (~ctl_reset_n)\n        begin\n            partial_be_when_no_cmd_tracked <= 1'b0;\n            partial_be_detected <= 1'b0;\n        end\n        else\n        begin\n            if (cfg_enable_partial_be_notification)\n            begin\n                if (partial_be_when_no_cmd_tracked)\n                begin\n                    if (update_data_if_valid & ~notify_data_if_valid)\n                    begin\n                        partial_be_when_no_cmd_tracked <= 1'b0;\n                    end\n                    else if (update_data_if_valid & notify_data_if_valid)\n                    begin\n                        if (|update_data_if_burstcount_same)\n                        begin\n                            partial_be_when_no_cmd_tracked <= 1'b0;\n                            partial_be_detected <= write_data_if_accepted & write_data_if_partial_dm;\n                        end\n                        else\n                        begin\n                            // let partial_be_when_no_cmd_tracked continue asserted\n                        end\n                    end\n                end\n                else if (partial_be_detected & ~notify_data_if_valid)\n                begin\n                    partial_be_detected <= partial_be_detected;\n                end\n                else\n                begin\n                    partial_be_when_no_cmd_tracked <= write_data_if_accepted & write_data_if_partial_dm & update_data_bc_gt_update_cmd_unnotified_bc;\n                    partial_be_detected <= write_data_if_accepted & write_data_if_partial_dm;\n                end\n            end\n            else\n            begin\n                partial_be_when_no_cmd_tracked <= 1'b0;\n                partial_be_detected <= 1'b0;\n            end\n        end\n    end\n\nendmodule"}
{"task_id": 1867, "completion": "localparam    ISERDES_DQ_DATA_RATE          = \"DDR\";\nlocalparam    ISERDES_DQ_DATA_WIDTH         = 4;\nlocalparam    ISERDES_DQ_DYN_CLKDIV_INV_EN  = \"FALSE\";\nlocalparam    ISERDES_DQ_DYN_CLK_INV_EN     = \"FALSE\";\nlocalparam    ISERDES_DQ_INIT_Q1            = 1'b0;\nlocalparam    ISERDES_DQ_INIT_Q2            = 1'b0;\nlocalparam    ISERDES_DQ_INIT_Q3            = 1'b0;\nlocalparam    ISERDES_DQ_INIT_Q4            = 1'b0;\nlocalparam    ISERDES_DQ_INTERFACE_TYPE     = \"MEMORY_DDR3\";\nlocalparam    ISERDES_NUM_CE                = 2;\nlocalparam    ISERDES_DQ_IOBDELAY           = \"IFD\";\nlocalparam    ISERDES_DQ_OFB_USED           = \"FALSE\";\nlocalparam    ISERDES_DQ_SERDES_MODE        = \"MASTER\";\nlocalparam    ISERDES_DQ_SRVAL_Q1           = 1'b0;\nlocalparam    ISERDES_DQ_SRVAL_Q2           = 1'b0;\nlocalparam    ISERDES_DQ_SRVAL_Q3           = 1'b0;\nlocalparam    ISERDES_DQ_SRVAL_Q4           = 1'b0;\nlocalparam    IDELAY_FINEDELAY_USE          = (TCK > 1500) ? \"FALSE\" : \"TRUE\";\nwire [BUS_WIDTH-1:0]                    data_in_dly;\nwire [BUS_WIDTH-1:0]                    oserdes_dq_buf;\nwire [BUS_WIDTH-1:0]                    oserdes_dqts_buf;\nwire                                    oserdes_dqs_buf;\nwire                                    oserdes_dqsts_buf;\nwire [9:0]                              data_in;\nwire                                    tbyte_out;\nreg [29:0]                              fine_delay_r;\nassign mem_dq_out  = oserdes_dq_buf;\nassign mem_dq_ts   = oserdes_dqts_buf;\nassign data_in = mem_dq_in;\nassign mem_dqs_out = oserdes_dqs_buf;\nassign mem_dqs_ts  = oserdes_dqsts_buf;\nassign dqs_to_phaser = mem_dqs_in;\nreg iserdes_clk_d;\nalways @(*) \n   iserdes_clk_d = iserdes_clk;\nreg  idelay_ld_rst;\nreg  rst_r1;\nreg  rst_r2;\nreg  rst_r3;\nreg  rst_r4;\nalways @(posedge phy_clk) begin\n  rst_r1 <= #1 rst;\n  rst_r2 <= #1 rst_r1;\n  rst_r3 <= #1 rst_r2;\n  rst_r4 <= #1 rst_r3;\nend\nalways @(posedge phy_clk) begin\n  if (rst)\n    idelay_ld_rst <= #1 1'b1;\n  else if (rst_r4)\n    idelay_ld_rst <= #1 1'b0;\nend    \nalways @ (posedge phy_clk) begin\n if(rst)\n   fine_delay_r <= #1 1'b0;\n else if(fine_delay_sel)\n   fine_delay_r <= #1 fine_delay;\nend\ngenvar i;\ngenerate\nfor ( i = 0; i != 10 && PO_DATA_CTL == \"TRUE\" ; i=i+1) begin : input_\n  if ( BITLANES[i] && !BITLANES_OUTONLY[i]) begin  : iserdes_dq_\n     ISERDESE2 #(\n         .DATA_RATE                  ( ISERDES_DQ_DATA_RATE),\n         .DATA_WIDTH                 ( ISERDES_DQ_DATA_WIDTH),\n         .DYN_CLKDIV_INV_EN          ( ISERDES_DQ_DYN_CLKDIV_INV_EN),\n         .DYN_CLK_INV_EN             ( ISERDES_DQ_DYN_CLK_INV_EN),\n         .INIT_Q1                    ( ISERDES_DQ_INIT_Q1),\n         .INIT_Q2                    ( ISERDES_DQ_INIT_Q2),\n         .INIT_Q3                    ( ISERDES_DQ_INIT_Q3),\n         .INIT_Q4                    ( ISERDES_DQ_INIT_Q4),\n         .INTERFACE_TYPE             ( ISERDES_DQ_INTERFACE_TYPE),\n         .NUM_CE                     ( ISERDES_NUM_CE),\n         .IOBDELAY                   ( ISERDES_DQ_IOBDELAY),\n         .OFB_USED                   ( ISERDES_DQ_OFB_USED),\n         .SERDES_MODE                ( ISERDES_DQ_SERDES_MODE),\n         .SRVAL_Q1                   ( ISERDES_DQ_SRVAL_Q1),\n         .SRVAL_Q2                   ( ISERDES_DQ_SRVAL_Q2),\n         .SRVAL_Q3                   ( ISERDES_DQ_SRVAL_Q3),\n         .SRVAL_Q4                   ( ISERDES_DQ_SRVAL_Q4)\n         )\n         iserdesdq\n         (\n         .O                          (),\n         .Q1                         (iserdes_dout[4*i + 3]),\n         .Q2                         (iserdes_dout[4*i + 2]),\n         .Q3                         (iserdes_dout[4*i + 1]),\n         .Q4                         (iserdes_dout[4*i + 0]),\n         .Q5                         (),\n         .Q6                         (),\n         .Q7                         (),\n         .Q8                         (),\n         .SHIFTOUT1                  (),\n         .SHIFTOUT2                  (),\n         .BITSLIP                    (1'b0),\n         .CE1                        (1'b1),\n         .CE2                        (1'b1),\n         .CLK                        (iserdes_clk_d),\n         .CLKB                       (!iserdes_clk_d),\n         .CLKDIVP                    (iserdes_clkdiv),\n         .CLKDIV                     (),\n         .DDLY                       (data_in_dly[i]),\n         .D                          (data_in[i]),\n         .DYNCLKDIVSEL               (1'b0),\n         .DYNCLKSEL                  (1'b0),\n         .OCLK                       (oserdes_clk),\n         .OCLKB                      (),\n         .OFB                        (),\n         .RST                        (1'b0),\n         .SHIFTIN1                   (1'b0),\n         .SHIFTIN2                   (1'b0)\n         );\nlocalparam IDELAYE2_CINVCTRL_SEL          = \"FALSE\";\nlocalparam IDELAYE2_DELAY_SRC             = \"IDATAIN\";\nlocalparam IDELAYE2_HIGH_PERFORMANCE_MODE = \"TRUE\";\nlocalparam IDELAYE2_PIPE_SEL              = \"FALSE\";\nlocalparam IDELAYE2_ODELAY_TYPE           = \"FIXED\";\nlocalparam IDELAYE2_REFCLK_FREQUENCY      = ((FPGA_SPEED_GRADE == 2 || FPGA_SPEED_GRADE == 3) && TCK <= 1500) ? 400.0 : \n                                             (FPGA_SPEED_GRADE == 1 && TCK <= 1500) ?  300.0 : 200.0;\nlocalparam IDELAYE2_SIGNAL_PATTERN        = \"DATA\";\nlocalparam IDELAYE2_FINEDELAY_IN          = \"ADD_DLY\";\n    if(IDELAY_FINEDELAY_USE == \"TRUE\") begin: idelay_finedelay_dq\n      (* IODELAY_GROUP = IODELAY_GRP *)\n        IDELAYE2_FINEDELAY #(   \n         .CINVCTRL_SEL             ( IDELAYE2_CINVCTRL_SEL),\n         .DELAY_SRC                ( IDELAYE2_DELAY_SRC),\n         .HIGH_PERFORMANCE_MODE    ( IDELAYE2_HIGH_PERFORMANCE_MODE),\n         .IDELAY_TYPE              ( IDELAYE2_IDELAY_TYPE),\n         .IDELAY_VALUE             ( IDELAYE2_IDELAY_VALUE),\n         .PIPE_SEL                 ( IDELAYE2_PIPE_SEL),\n         .FINEDELAY                ( IDELAYE2_FINEDELAY_IN),\n         .REFCLK_FREQUENCY         ( IDELAYE2_REFCLK_FREQUENCY ),\n         .SIGNAL_PATTERN           ( IDELAYE2_SIGNAL_PATTERN)\n         )\n         idelaye2\n         (\n         .CNTVALUEOUT              (),\n         .DATAOUT                  (data_in_dly[i]),\n         .C                        (phy_clk),\n         .CE                       (idelay_ce),\n         .CINVCTRL                 (),\n         .CNTVALUEIN               (5'b00000), \n         .DATAIN                   (1'b0),\n         .IDATAIN                  (data_in[i]),\n         .IFDLY                    (fine_delay_r[i*3+:3]),\n         .INC                      (idelay_inc),\n         .LD                       (idelay_ld | idelay_ld_rst),\n         .LDPIPEEN                 (1'b0),\n         .REGRST                   (rst) \n     );\n    end else begin : idelay_dq\n      (* IODELAY_GROUP = IODELAY_GRP *)\n        IDELAYE2 #(\n         .CINVCTRL_SEL             ( IDELAYE2_CINVCTRL_SEL),\n         .DELAY_SRC                ( IDELAYE2_DELAY_SRC),\n         .HIGH_PERFORMANCE_MODE    ( IDELAYE2_HIGH_PERFORMANCE_MODE),\n         .IDELAY_TYPE              ( IDELAYE2_IDELAY_TYPE),\n         .IDELAY_VALUE             ( IDELAYE2_IDELAY_VALUE),\n         .PIPE_SEL                 ( IDELAYE2_PIPE_SEL),\n         .REFCLK_FREQUENCY         ( IDELAYE2_REFCLK_FREQUENCY ),\n         .SIGNAL_PATTERN           ( IDELAYE2_SIGNAL_PATTERN)\n         )\n         idelaye2\n         (\n         .CNTVALUEOUT              (),\n         .DATAOUT                  (data_in_dly[i]),\n         .C                        (phy_clk),\n         .CE                       (idelay_ce),\n         .CINVCTRL                 (),\n         .CNTVALUEIN               (5'b00000), \n         .DATAIN                   (1'b0),\n         .IDATAIN                  (data_in[i]),\n         .INC                      (idelay_inc),\n         .LD                       (idelay_ld | idelay_ld_rst),\n         .LDPIPEEN                 (1'b0),\n         .REGRST                   (rst) \n     );\n     end\n    end // iserdes_dq\n    else begin \n        assign iserdes_dout[4*i + 3] = 0;\n        assign iserdes_dout[4*i + 2] = 0;\n        assign iserdes_dout[4*i + 1] = 0;\n        assign iserdes_dout[4*i + 0] = 0;\n    end\nend // input_\nendgenerate\nlocalparam OSERDES_DQ_DATA_RATE_OQ    = OSERDES_DATA_RATE;\nlocalparam OSERDES_DQ_DATA_RATE_TQ    = OSERDES_DQ_DATA_RATE_OQ;\nlocalparam OSERDES_DQ_DATA_WIDTH      = OSERDES_DATA_WIDTH;\nlocalparam OSERDES_DQ_INIT_OQ         = 1'b1;\nlocalparam OSERDES_DQ_INIT_TQ         = 1'b1;\nlocalparam OSERDES_DQ_TRISTATE_WIDTH  = (OSERDES_DQ_DATA_RATE_OQ == \"DDR\") ? 4 : 1;\nlocalparam OSERDES_DQS_DATA_RATE_OQ   = \"DDR\";\nlocalparam OSERDES_DQS_DATA_RATE_TQ   = \"DDR\";\nlocalparam OSERDES_DQS_TRISTATE_WIDTH = 4;\nlocalparam OSERDES_DQS_DATA_WIDTH     = 4;\nlocalparam ODDR_CLK_EDGE              = \"SAME_EDGE\";\nlocalparam OSERDES_TBYTE_CTL          = \"TRUE\";\ngenerate \nlocalparam NUM_BITLANES = PO_DATA_CTL == \"TRUE\" ? 10 : BUS_WIDTH;\n     if ( PO_DATA_CTL == \"TRUE\" ) begin  : slave_ts\n           OSERDESE2 #(\n               .DATA_RATE_OQ         (OSERDES_DQ_DATA_RATE_OQ),\n               .DATA_RATE_TQ         (OSERDES_DQ_DATA_RATE_TQ),\n               .DATA_WIDTH           (OSERDES_DQ_DATA_WIDTH),\n               .INIT_OQ              (OSERDES_DQ_INIT_OQ),\n               .INIT_TQ              (OSERDES_DQ_INIT_TQ),\n               .SERDES_MODE          (OSERDES_DQ_SERDES_MODE),\n               .SRVAL_OQ             (OSERDES_DQ_SRVAL_OQ),\n               .SRVAL_TQ             (OSERDES_DQ_SRVAL_TQ),\n               .TRISTATE_WIDTH       (OSERDES_DQ_TRISTATE_WIDTH),\n               .TBYTE_CTL            (\"TRUE\"),\n               .TBYTE_SRC            (\"TRUE\")\n            )\n            oserdes_slave_ts\n            (\n                .OFB                 (),\n                .OQ                  (),\n                .SHIFTOUT1           (),\n                .SHIFTOUT2           (),\n                .TFB                 (),\n                .TQ                  (),\n                .CLK                 (oserdes_clk),\n                .CLKDIV              (oserdes_clkdiv),\n                .D1                  (),\n                .D2                  (),\n                .D3                  (),\n                .D4                  (),\n                .D5                  (),\n                .D6                  (),\n                .D7                  (),\n                .D8                  (),\n               .OCE                  (1'b1),\n               .RST                  (oserdes_rst),\n               .SHIFTIN1             (),\n               .SHIFTIN2             (),\n               .T1                   (oserdes_dqts[0]),\n               .T2                   (oserdes_dqts[0]),\n               .T3                   (oserdes_dqts[1]),\n               .T4                   (oserdes_dqts[1]),\n               .TCE                  (1'b1),\n               .TBYTEOUT             (tbyte_out),\n               .TBYTEIN              (tbyte_out)\n             );\n     end // slave_ts\n  for (i = 0; i != NUM_BITLANES; i=i+1) begin : output_\n     if ( BITLANES[i]) begin  : oserdes_dq_\n        if ( PO_DATA_CTL == \"TRUE\" ) begin  : ddr\n           OSERDESE2 #(\n               .DATA_RATE_OQ         (OSERDES_DQ_DATA_RATE_OQ),\n               .DATA_RATE_TQ         (OSERDES_DQ_DATA_RATE_TQ),\n               .DATA_WIDTH           (OSERDES_DQ_DATA_WIDTH),\n               .INIT_OQ              (OSERDES_DQ_INIT_OQ),\n               .INIT_TQ              (OSERDES_DQ_INIT_TQ),\n               .SERDES_MODE          (OSERDES_DQ_SERDES_MODE),\n               .SRVAL_OQ             (OSERDES_DQ_SRVAL_OQ),\n               .SRVAL_TQ             (OSERDES_DQ_SRVAL_TQ),\n               .TRISTATE_WIDTH       (OSERDES_DQ_TRISTATE_WIDTH),\n               .TBYTE_CTL            (OSERDES_TBYTE_CTL),\n               .TBYTE_SRC            (\"FALSE\")\n             )\n              oserdes_dq_i \n              (\n                .OFB               (),\n                .OQ                (oserdes_dq_buf[i]),\n                .SHIFTOUT1         (),\n                .SHIFTOUT2         (),\n                .TBYTEOUT          (),\n                .TFB               (),\n                .TQ                (oserdes_dqts_buf[i]),\n                .CLK               (oserdes_clk),\n                .CLKDIV            (oserdes_clkdiv),\n                .D1                (oserdes_dq[4 * i + 0]),\n                .D2                (oserdes_dq[4 * i + 1]),\n                .D3                (oserdes_dq[4 * i + 2]),\n                .D4                (oserdes_dq[4 * i + 3]),\n                .D5                (),\n                .D6                (),\n                .D7                (),\n                .D8                (),\n               .OCE                (1'b1),\n               .RST                (oserdes_rst),\n               .SHIFTIN1           (),\n               .SHIFTIN2           (),\n               .T1                 (/*oserdes_dqts[0]*/),\n               .T2                 (/*oserdes_dqts[0]*/),\n               .T3                 (/*oserdes_dqts[1]*/),\n               .T4                 (/*oserdes_dqts[1]*/),\n               .TCE                (1'b1),\n               .TBYTEIN            (tbyte_out)\n              );\n           end\n           else begin :  sdr \n           OSERDESE2 #(\n               .DATA_RATE_OQ         (OSERDES_DQ_DATA_RATE_OQ),\n               .DATA_RATE_TQ         (OSERDES_DQ_DATA_RATE_TQ),\n               .DATA_WIDTH           (OSERDES_DQ_DATA_WIDTH),\n               .INIT_OQ              (1'b0 /*OSERDES_DQ_INIT_OQ*/),\n               .INIT_TQ              (OSERDES_DQ_INIT_TQ),\n               .SERDES_MODE          (OSERDES_DQ_SERDES_MODE),\n               .SRVAL_OQ             (1'b0 /*OSERDES_DQ_SRVAL_OQ*/),\n               .SRVAL_TQ             (OSERDES_DQ_SRVAL_TQ),\n               .TRISTATE_WIDTH       (OSERDES_DQ_TRISTATE_WIDTH) \n              )\n              oserdes_dq_i \n              (\n                .OFB               (),\n                .OQ                (oserdes_dq_buf[i]),\n                .SHIFTOUT1         (),\n                .SHIFTOUT2         (),\n                .TBYTEOUT          (),\n                .TFB               (),\n                .TQ                (),\n                .CLK               (oserdes_clk),\n                .CLKDIV            (oserdes_clkdiv),\n                .D1                (oserdes_dq[4 * i + 0]),\n                .D2                (oserdes_dq[4 * i + 1]),\n                .D3                (oserdes_dq[4 * i + 2]),\n                .D4                (oserdes_dq[4 * i + 3]),\n                .D5                (),\n                .D6                (),\n                .D7                (),\n                .D8                (),\n               .OCE                (1'b1),\n               .RST                (oserdes_rst),\n               .SHIFTIN1           (),\n               .SHIFTIN2           (),\n               .T1                 (),\n               .T2                 (),\n               .T3                 (),\n               .T4                 (),\n               .TCE                (1'b1),\n               .TBYTEIN            ()\n              );\n           end // ddr\n     end // oserdes_dq_\n  end // output_\nendgenerate\n\ngenerate\n if ( PO_DATA_CTL == \"TRUE\" )  begin : dqs_gen\n   ODDR  \n      #(.DDR_CLK_EDGE  (ODDR_CLK_EDGE))\n      oddr_dqs \n   (\n       .Q   (oserdes_dqs_buf),\n       .D1  (oserdes_dqs[0]),\n       .D2  (oserdes_dqs[1]),\n       .C   (oserdes_clk_delayed),\n       .R   (1'b0),\n       .S   (),\n       .CE  (1'b1)\n   );\n   ODDR\n     #(.DDR_CLK_EDGE  (ODDR_CLK_EDGE))\n     oddr_dqsts \n   (    .Q  (oserdes_dqsts_buf),\n        .D1 (oserdes_dqsts[0]),\n        .D2 (oserdes_dqsts[0]),\n        .C  (oserdes_clk_delayed),\n        .R  (),\n        .S  (1'b0),\n        .CE (1'b1)\n   );\n end // sdr rate\n else begin:null_dqs \n end \nendgenerate\nendmodule"}
{"task_id": 1718, "completion": "`include \"include/mbus_def.v\"\n\n`include \"include/mbus_func.v\"\n\nparameter ADDRESS = 20'habcde;\nparameter ADDRESS_MASK = {(`PRFIX_WIDTH){1'b1}};\nparameter ADDRESS_MASK_SHORT = {`DYNA_WIDTH{1'b1}};\n\nparameter MODE_TX_NON_PRIO = 2'd0;\nparameter MODE_TX = 2'd1;\nparameter MODE_RX = 2'd2;\nparameter MODE_FWD = 2'd3;\n\nparameter BUS_IDLE = 0;\nparameter BUS_ARBITRATE = 1;\nparameter BUS_PRIO = 2;\nparameter BUS_ADDR = 3;\nparameter BUS_DATA_RX_ADDI = 4;\nparameter BUS_DATA = 5;\nparameter BUS_DATA_RX_CHECK = 6;\nparameter BUS_REQ_INTERRUPT = 7;\nparameter BUS_CONTROL0 = 8;\nparameter BUS_CONTROL1 = 9;\nparameter BUS_BACK_TO_IDLE = 10;\nparameter NUM_OF_BUS_STATE = 11;\n\nparameter ADDR_ENUM_RESPOND_T1 = 2'b00;\nparameter ADDR_ENUM_RESPOND_T2 = 2'b10;\nparameter ADDR_ENUM_RESPOND_NONE = 2'b11;\n\nparameter LENGTH_1BYTE = 2'b00;\nparameter LENGTH_2BYTE = 2'b01;\nparameter LENGTH_3BYTE = 2'b10;\nparameter LENGTH_4BYTE = 2'b11;\n\nparameter RX_ABOVE_TX = 1'b1;\nparameter RX_BELOW_TX = 1'b0;\n\nparameter MASTER_NODE = 1'b0;\nparameter CPU_LAYER = 1'b0;\n\nwire [1:0] CONTROL_BITS = `CONTROL_SEQ;\n\nreg [1:0] mode, next_mode, mode_neg, mode_temp;\nreg [log2(NUM_OF_BUS_STATE-1)-1:0] bus_state, next_bus_state, bus_state_neg;\nreg [log2(`DATA_WIDTH-1)-1:0] bit_position, next_bit_position;\nreg req_interrupt, next_req_interrupt;\nreg out_reg_pos, next_out_reg_pos, out_reg_neg;\n`ifdef POWER_GATING\nreg next_clr_busy;\n`endif\n\nreg [`ADDR_WIDTH-1:0] ADDR, next_addr;\nreg [`DATA_WIDTH-1:0] DATA, next_data;\nreg tx_pend, next_tx_pend;\nreg tx_underflow, next_tx_underflow;\nreg ctrl_bit_buf, next_ctrl_bit_buf;\n\nreg [`ADDR_WIDTH-1:0] next_rx_addr;\nreg [`DATA_WIDTH-1:0] next_rx_data;\nreg [`DATA_WIDTH+1:0] rx_data_buf, next_rx_data_buf;\nreg next_rx_fail;\n\nreg [1:0] enum_addr_resp, next_enum_addr_resp;\nreg next_assigned_addr_write;\nreg next_assigned_addr_invalidn;\n\nreg BUS_INT_RSTn;\nwire BUS_INT;\n\nreg next_tx_ack;\nreg next_tx_fail;\nreg next_tx_success;\nreg next_rx_req;\nreg next_rx_pend;\n\nwire addr_bit_extract = ((ADDR  & (1'b1<<bit_position))==0)? 1'b0 : 1'b1;\nwire data_bit_extract = ((DATA & (1'b1<<bit_position))==0)? 1'b0 : 1'b1;\nreg [1:0] addr_match_temp;\nwire address_match = (addr_match_temp[1] | addr_match_temp[0]);\n\nreg [`BROADCAST_CMD_WIDTH -1:0] rx_broadcast_command;\nwire rx_long_addr_en = (RX_ADDR[`ADDR_WIDTH-1:`ADDR_WIDTH-4]==4'hf)? 1'b1 : 1'b0;\nwire tx_long_addr_en = (TX_ADDR[`ADDR_WIDTH-1:`ADDR_WIDTH-4]==4'hf)? 1'b1 : 1'b0;\nwire tx_long_addr_en_latched = (ADDR[`ADDR_WIDTH-1:`ADDR_WIDTH-4]==4'hf)? 1'b1 : 1'b0;\nreg tx_broadcast_latched;\nreg [1:0] tx_dat_length, rx_dat_length;\nreg rx_position, rx_dat_length_valid;\nreg wakeup_req;\nwire [`DATA_WIDTH-1:0] broadcast_addr = `BROADCAST_ADDR;\nwire [`DATA_WIDTH-1:0] rx_data_buf_proc = (rx_dat_length_valid)? (rx_position==RX_BELOW_TX)? rx_data_buf[`DATA_WIDTH-1:0] : rx_data_buf[`DATA_WIDTH+1:2] : {`DATA_WIDTH{1'b0}};\n\n`ifdef POWER_GATING\nwire RESETn_local = (RESETn & (~MBC_RESET));\n`else\nwire RESETn_local = RESETn;\n`endif\n\n`ifdef POWER_GATING\nreg [1:0] powerup_seq_fsm;\nreg shutdown, next_shutdown;\nreg ext_int;\n`endif\n\nwire [15:0] layer_slot = (1'b1<<ASSIGNED_ADDR_IN);\n\nassign RX_BROADCAST = addr_match_temp[0];\nassign ASSIGNED_ADDR_OUT = DATA[`DYNA_WIDTH-1:0];\n\nalways @ *\nbegin\nmode_temp = MODE_RX;\nif (mode==MODE_TX_NON_PRIO)\nbegin\nif (DIN & (~TX_PRIORITY))\nmode_temp = MODE_RX;\nelse\nmode_temp = MODE_TX;\nend\nelse\nbegin\nif (TX_REQ & TX_PRIORITY & (~DIN))\nmode_temp = MODE_TX;\nelse\nmode_temp = MODE_RX;\nend\nend\n\nalways @ *\nbegin\ntx_broadcast_latched = 0;\nif (tx_long_addr_en_latched)\nbegin\nif (ADDR[`DATA_WIDTH-1:`FUNC_WIDTH]==broadcast_addr[`DATA_WIDTH-1:`FUNC_WIDTH])\ntx_broadcast_latched = 1;\nend\nelse\nbegin\nif (ADDR[`SHORT_ADDR_WIDTH-1:`FUNC_WIDTH]==broadcast_addr[`SHORT_ADDR_WIDTH-1:`FUNC_WIDTH])\ntx_broadcast_latched = 1;\nend\nend\n\nalways @ *\nbegin\nwakeup_req = 0;\nif (~RX_BROADCAST)\n\begin\nwakeup_req = address_match;\nelse\nif (MASTER_NODE==1'b1)\nk\u65f6\u9192\u6765\ndif ((wakeup_req)&&(bit_position==`DATA_WIDTH-`BROADCAST_CMD_WIDTH+1))\nbegin\nLRC_SLEEP <= `IO_RELEASE;\npowerup_seq_fsm <= powerup_seq_fsm + 1'b1;\nend\n\nalways @ *\nbegin\nDOUT = DIN;\ncase (bus_state_neg)\nBUS_IDLE:\nbegin\nDOUT = ((~TX_REQ) & DIN & enum_addr_resp[0]);\nend\n\nBUS_ARBITRATE:\nbegin\nif (mode_neg==MODE_TX_NON_PRIO)\nDOUT = 0;\nend\n\nBUS_PRIO:\nbegin\nif (mode_neg==MODE_TX_NON_PRIO)\nbegin\nif (TX_PRIORITY)\nDOUT = 1;\nelse\nDOUT = 0;\nend\nelse if ((mode_neg==MODE_RX)&&(TX_PRIORITY & TX_REQ))\nDOUT = 1;\nend\n\nBUS_ADDR:\nbegin\nif (~BUS_INT &(mode_neg==MODE_TX))\nDOUT = out_reg_neg;\nend\n\nBUS_DATA:\nbegin\nif (~BUS_INT &(mode_neg==MODE_TX))\nDOUT = out_reg_neg;\nend\n\nBUS_CONTROL0:\nbegin\nif (req_interrupt)\nDOUT = out_reg_neg;\nend\n\nBUS_CONTROL1:\nbegin\nif (mode_neg==MODE_RX)\nDOUT = out_reg_neg;\nelse if (req_interrupt)\nDOUT = out_reg_neg;\nend\n\nBUS_BACK_TO_IDLE:\nbegin\nDOUT = ((~TX_REQ) & DIN & enum_addr_resp[0]);\nend\nendcase\nend\n\nalways @(posedge CLKIN or negedge RESETn_local)\nbegin\nif (~RESETn_local)\nBEGIN\nif (MASTER_NODE==1'b1)\nbus_state <= BUS_IDLE;\nelse\nbus_state <= BUS_PRIO;\nelse\nbus_state <= BUS_IDLE;\nBUS_INT_RSTn <= 1;\nelse\nBEGIN\nif (BUS_INT)\nbus_state <= BUS_CONTROL0;\nBUS_INT_RSTn <= 0;\nelse\nbus_state <= next_bus_state;\nend\nend\nend\n\nmbus_swapper swapper0(\n.CLK(CLKIN),\n.RESETn(RESETn_local),\n.DATA(DIN),\n.INT_FLAG_RESETn(BUS_INT_RSTn),\n.LAST_CLK(),\n.INT_FLAG(BUS_INT));\nendmodule"}
{"task_id": 1947, "completion": "parameter WG_ID_WIDTH = 6;   parameter WF_COUNT_WIDTH = 4;   parameter WG_SLOT_ID_WIDTH = 6;   parameter NUMBER_WF_SLOTS = 40;   parameter NUMBER_CU = 8;   parameter CU_ID_WIDTH = 3;   parameter VGPR_ID_WIDTH = 8;   parameter SGPR_ID_WIDTH = 4;   parameter LDS_ID_WIDTH = 10;   parameter GDS_ID_WIDTH = 10;   parameter TAG_WIDTH = 15;   parameter MEM_ADDR_WIDTH = 32;   parameter WAVE_ITEM_WIDTH = 6;   parameter CU_VGPR_ID_WIDTH = 10;   parameter CU_SGPR_ID_WIDTH = 9;   parameter CU_LDS_ID_WIDTH = 16;   parameter CU_GDS_ID_WIDTH = 16;   input clk, rst;   input inflight_wg_buffer_gpu_valid;   input [WAVE_ITEM_WIDTH-1:0] inflight_wg_buffer_gpu_wf_size;   input [MEM_ADDR_WIDTH-1:0] inflight_wg_buffer_start_pc;   input [VGPR_ID_WIDTH :0] inflight_wg_buffer_gpu_vgpr_size_per_wf;   input [SGPR_ID_WIDTH :0] inflight_wg_buffer_gpu_sgpr_size_per_wf;   input [WG_ID_WIDTH-1:0] allocator_wg_id_out;   input [CU_ID_WIDTH-1 :0] allocator_cu_id_out;   input [WF_COUNT_WIDTH-1:0] allocator_wf_count;   input [VGPR_ID_WIDTH-1 :0] allocator_vgpr_start_out;   input [SGPR_ID_WIDTH-1 :0] allocator_sgpr_start_out;   input [LDS_ID_WIDTH-1 :0] allocator_lds_start_out;   input [GDS_ID_WIDTH-1 :0] allocator_gds_start_out;   input dis_controller_wg_alloc_valid;   input dis_controller_wg_dealloc_valid;   output gpu_interface_alloc_available, gpu_interface_dealloc_available;   output [CU_ID_WIDTH-1:0] gpu_interface_cu_id;   output [WG_ID_WIDTH-1:0] gpu_interface_dealloc_wg_id;   reg gpu_interface_dealloc_available_i;   reg dis_controller_wg_dealloc_valid_i;   reg [NUMBER_CU-1:0] handler_wg_done_ack;   reg chosen_done_cu_valid, chosen_done_cu_valid_comb;   reg [CU_ID_WIDTH-1:0] chosen_done_cu_id, chosen_done_cu_id_comb;   wire [NUMBER_CU-1:0] handler_wg_done_valid;   wire [NUMBER_CU*WG_ID_WIDTH-1:0] handler_wg_done_wg_id;   reg [NUMBER_CU-1:0] cu2dispatch_wf_done_i;   reg [NUMBER_CU*TAG_WIDTH-1:0] cu2dispatch_wf_tag_done_i;   localparam NUM_DEALLOC_ST = 5;   localparam ST_DEALLOC_IDLE = 1<<0;   localparam ST_DEALLOC_WAIT_ACK = 1<<1;   reg [NUM_DEALLOC_ST-1:0] dealloc_st;   reg dis_controller_wg_alloc_valid_i;   reg inflight_wg_buffer_gpu_valid_i;   reg [WAVE_ITEM_WIDTH-1:0] inflight_wg_buffer_gpu_wf_size_i;   reg [MEM_ADDR_WIDTH-1:0] inflight_wg_buffer_start_pc_i;   reg [VGPR_ID_WIDTH :0] inflight_wg_buffer_gpu_vgpr_size_per_wf_i;   reg [SGPR_ID_WIDTH :0] inflight_wg_buffer_gpu_sgpr_size_per_wf_i;   reg [WG_ID_WIDTH-1:0] allocator_wg_id_out_i;   reg [CU_ID_WIDTH-1 :0] allocator_cu_id_out_i;   reg [WF_COUNT_WIDTH-1:0] allocator_wf_count_i;   reg [VGPR_ID_WIDTH-1 :0] allocator_vgpr_start_out_i;   reg [SGPR_ID_WIDTH-1 :0] allocator_sgpr_start_out_i;   reg [LDS_ID_WIDTH-1 :0] allocator_lds_start_out_i;   reg [GDS_ID_WIDTH-1 :0] allocator_gds_start_out_i;   reg gpu_interface_alloc_available_i;   reg [CU_ID_WIDTH-1:0] gpu_interface_cu_id_i;   reg [WG_ID_WIDTH-1:0] gpu_interface_dealloc_wg_id_i;   wire [NUMBER_CU-1:0] dispatch2cu_wf_dispatch_handlers;   wire [NUMBER_CU*15-1:0] dispatch2cu_wf_tag_dispatch_handlers;   reg [NUMBER_CU-1:0] handler_wg_alloc_en;   reg [NUMBER_CU*WG_ID_WIDTH-1:0] handler_wg_alloc_wg_id;   reg [NUMBER_CU*(WF_COUNT_WIDTH)-1:0] handler_wg_alloc_wf_count;   reg [NUMBER_CU-1:0] dispatch2cu_wf_dispatch_i;   reg [WF_COUNT_WIDTH-1:0] dispatch2cu_wg_wf_count_i;   reg [WAVE_ITEM_WIDTH-1:0] dispatch2cu_wf_size_dispatch_i;   reg [SGPR_ID_WIDTH-1:0] dispatch2cu_sgpr_base_dispatch_i;   reg [VGPR_ID_WIDTH-1:0] dispatch2cu_vgpr_base_dispatch_i;   reg [TAG_WIDTH-1:0] dispatch2cu_wf_tag_dispatch_i;   reg [LDS_ID_WIDTH-1:0] dispatch2cu_lds_base_dispatch_i;   reg [MEM_ADDR_WIDTH-1:0] dispatch2cu_start_pc_dispatch_i;   localparam NUM_ALLOC_ST = 4;   localparam ST_ALLOC_IDLE = 1<<0;   localparam ST_ALLOC_WAIT_BUFFER = 1<<1;   localparam ST_ALLOC_WAIT_HANDLER = 1<<2;   localparam ST_ALLOC_PASS_WF = 1<<3;   reg [NUM_ALLOC_ST-1:0] alloc_st;   cu_handler #(/*AUTOINSTPARAM*/ .WF_COUNT_WIDTH(WF_COUNT_WIDTH), .WG_ID_WIDTH(WG_ID_WIDTH), .WG_SLOT_ID_WIDTH(WG_SLOT_ID_WIDTH), .NUMBER_WF_SLOTS(NUMBER_WF_SLOTS), .TAG_WIDTH(TAG_WIDTH)) handlers[NUMBER_CU-1:0] (.dispatch2cu_wf_dispatch(dispatch2cu_wf_dispatch_handlers), .dispatch2cu_wf_tag_dispatch(dispatch2cu_wf_tag_dispatch_handlers), .wg_done_valid(handler_wg_done_valid), .wg_done_wg_id(handler_wg_done_wg_id), .clk(clk), .rst(rst), .wg_alloc_en(handler_wg_alloc_en), .wg_alloc_wg_id(handler_wg_alloc_wg_id), .wg_alloc_wf_count(handler_wg_alloc_wf_count), .cu2dispatch_wf_done_i(cu2dispatch_wf_done_i), .cu2dispatch_wf_tag_done_i(cu2dispatch_wf_tag_done_i), .wg_done_ack(handler_wg_done_ack));   always @(posedge clk or posedge rst) begin if (rst) begin alloc_st <= ST_ALLOC_IDLE; dealloc_st <= ST_DEALLOC_IDLE; allocator_cu_id_out_i <= {CU_ID_WIDTH{1'b0}}; allocator_gds_start_out_i <= {GDS_ID_WIDTH{1'b0}}; allocator_lds_start_out_i <= {LDS_ID_WIDTH{1'b0}}; allocator_sgpr_start_out_i <= {SGPR_ID_WIDTH{1'b0}}; allocator_vgpr_start_out_i <= {VGPR_ID_WIDTH{1'b0}}; allocator_wf_count_i <= {WF_COUNT_WIDTH{1'b0}}; allocator_wg_id_out_i <= {WG_ID_WIDTH{1'b0}}; chosen_done_cu_id <= {CU_ID_WIDTH{1'b0}}; chosen_done_cu_valid <= 1'h0; cu2dispatch_wf_done_i <= {NUMBER_CU{1'b0}}; cu2dispatch_wf_tag_done_i <= {(1+(NUMBER_CU*TAG_WIDTH-1)){1'b0}}; dis_controller_wg_alloc_valid_i <= 1'h0; dis_controller_wg_dealloc_valid_i <= 1'h0; dispatch2cu_lds_base_dispatch_i <= 16'h0; dispatch2cu_sgpr_base_dispatch_i <= 9'h0; dispatch2cu_start_pc_dispatch_i <= {MEM_ADDR_WIDTH{1'b0}}; dispatch2cu_vgpr_base_dispatch_i <= 10'h0; dispatch2cu_wf_dispatch_i <= {NUMBER_CU{1'b0}}; dispatch2cu_wf_size_dispatch_i <= {WAVE_ITEM_WIDTH{1'b0}}; dispatch2cu_wf_tag_dispatch_i <= {TAG_WIDTH{1'b0}}; dispatch2cu_wg_wf_count_i <= {WF_COUNT_WIDTH{1'b0}}; gpu_interface_alloc_available_i <= 1'h0; gpu_interface_cu_id_i <= {CU_ID_WIDTH{1'b0}}; gpu_interface_dealloc_available_i <= 1'h0; gpu_interface_dealloc_wg_id_i <= {WG_ID_WIDTH{1'b0}}; handler_wg_alloc_en <= {NUMBER_CU{1'b0}}; handler_wg_alloc_wf_count <= {(1+(NUMBER_CU*(WF_COUNT_WIDTH)-1)){1'b0}}; handler_wg_alloc_wg_id <= {(1+(NUMBER_CU*WG_ID_WIDTH-1)){1'b0}}; handler_wg_done_ack <= {NUMBER_CU{1'b0}}; inflight_wg_buffer_gpu_sgpr_size_per_wf_i <= {(1+(SGPR_ID_WIDTH)){1'b0}}; inflight_wg_buffer_gpu_valid_i <= 1'h0; inflight_wg_buffer_gpu_vgpr_size_per_wf_i <= {(1+(VGPR_ID_WIDTH)){1'b0}}; inflight_wg_buffer_gpu_wf_size_i <= {WAVE_ITEM_WIDTH{1'b0}}; inflight_wg_buffer_start_pc_i <= {MEM_ADDR_WIDTH{1'b0}}; end else begin dis_controller_wg_alloc_valid_i <= dis_controller_wg_alloc_valid; inflight_wg_buffer_gpu_valid_i <= inflight_wg_buffer_gpu_valid; if(inflight_wg_buffer_gpu_valid) begin inflight_wg_buffer_gpu_wf_size_i <= inflight_wg_buffer_gpu_wf_size; inflight_wg_buffer_start_pc_i <= inflight_wg_buffer_start_pc; inflight_wg_buffer_gpu_vgpr_size_per_wf_i <= inflight_wg_buffer_gpu_vgpr_size_per_wf; inflight_wg_buffer_gpu_sgpr_size_per_wf_i <= inflight_wg_buffer_gpu_sgpr_size_per_wf; end if(dis_controller_wg_alloc_valid) begin allocator_wg_id_out_i <= allocator_wg_id_out; allocator_cu_id_out_i <= allocator_cu_id_out; allocator_wf_count_i <= allocator_wf_count; allocator_vgpr_start_out_i <= allocator_vgpr_start_out; allocator_sgpr_start_out_i <= allocator_sgpr_start_out; allocator_lds_start_out_i <= allocator_lds_start_out; allocator_gds_start_out_i <= allocator_gds_start_out; end handler_wg_alloc_en <= 0; dispatch2cu_wf_dispatch_i <= 0; case (alloc_st) ST_ALLOC_IDLE: begin gpu_interface_alloc_available_i <= 1'b1; if(dis_controller_wg_alloc_valid_i) begin if(inflight_wg_buffer_gpu_valid_i) begin handler_wg_alloc_en[allocator_cu_id_out_i] <= 1'b1; handler_wg_alloc_wg_id[allocator_cu_id_out_i*WG_ID_WIDTH+:WG_ID_WIDTH] <= allocator_wg_id_out_i; handler_wg_alloc_wf_count[allocator_cu_id_out_i*(WF_COUNT_WIDTH+1)+:WF_COUNT_WIDTH] <= allocator_wf_count_i; gpu_interface_alloc_available_i <= 1'b0; alloc_st <= ST_ALLOC_WAIT_HANDLER; end else begin gpu_interface_alloc_available_i <= 1'b0; alloc_st <= ST_ALLOC_WAIT_BUFFER; end end end case: ST_ALLOC_IDLE ST_ALLOC_WAIT_BUFFER: begin if(inflight_wg_buffer_gpu_valid_i) begin handler_wg_alloc_en[allocator_cu_id_out_i] <= 1'b1; handler_wg_alloc_wg_id[allocator_cu_id_out_i*(WG_ID_WIDTH)+:WG_ID_WIDTH] <= allocator_wg_id_out_i; handler_wg_alloc_wf_count[allocator_cu_id_out_i*(WF_COUNT_WIDTH)+:WF_COUNT_WIDTH] <= allocator_wf_count_i; alloc_st <= ST_ALLOC_WAIT_HANDLER; end end ST_ALLOC_WAIT_HANDLER: begin if(dispatch2cu_wf_dispatch_handlers[allocator_cu_id_out_i]) begin dispatch2cu_wf_dispatch_i[allocator_cu_id_out_i] <= 1'b1; dispatch2cu_wf_tag_dispatch_i <= dispatch2cu_wf_tag_dispatch_handlers[allocator_cu_id_out_i*15+:15]; dispatch2cu_wg_wf_count_i <= allocator_wf_count_i; dispatch2cu_wf_size_dispatch_i <= inflight_wg_buffer_gpu_wf_size; dispatch2cu_sgpr_base_dispatch_i <= allocator_sgpr_start_out_i; dispatch2cu_vgpr_base_dispatch_i <= allocator_vgpr_start_out_i; dispatch2cu_lds_base_dispatch_i <= allocator_lds_start_out_i; dispatch2cu_start_pc_dispatch_i <= inflight_wg_buffer_start_pc_i; alloc_st <= ST_ALLOC_PASS_WF; end end ST_ALLOC_PASS_WF: begin if(dispatch2cu_wf_dispatch_handlers[allocator_cu_id_out_i]) begin dispatch2cu_wf_dispatch_i[allocator_cu_id_out_i] <= 1'b1; dispatch2cu_wf_tag_dispatch_i <= dispatch2cu_wf_tag_dispatch_handlers[allocator_cu_id_out_i*15+:15]; dispatch2cu_sgpr_base_dispatch_i <= dispatch2cu_sgpr_base_dispatch_i + inflight_wg_buffer_gpu_sgpr_size_per_wf_i; dispatch2cu_vgpr_base_dispatch_i <= dispatch2cu_vgpr_base_dispatch_i + inflight_wg_buffer_gpu_vgpr_size_per_wf_i; end else begin gpu_interface_alloc_available_i <= 1'b1; alloc_st <= ST_ALLOC_IDLE; end end endcase cu2dispatch_wf_done_i <= cu2dispatch_wf_done; cu2dispatch_wf_tag_done_i <= cu2dispatch_wf_tag_done; dis_controller_wg_dealloc_valid_i <= dis_controller_wg_dealloc_valid; chosen_done_cu_valid <= chosen_done_cu_valid_comb; chosen_done_cu_id <= chosen_done_cu_id_comb; gpu_interface_dealloc_available_i <= 1'b0; handler_wg_done_ack <= 0; case (dealloc_st) ST_DEALLOC_IDLE: begin if(chosen_done_cu_valid) begin gpu_interface_dealloc_available_i <= 1'b1; gpu_interface_cu_id_i <= chosen_done_cu_id; handler_wg_done_ack[chosen_done_cu_id] <= 1'b1; gpu_interface_dealloc_wg_id_i <= handler_wg_done_wg_id[chosen_done_cu_id*WG_ID_WIDTH +: WG_ID_WIDTH]; dealloc_st <= ST_DEALLOC_WAIT_ACK; end end ST_DEALLOC_WAIT_ACK: begin if(dis_controller_wg_dealloc_valid_i) begin dealloc_st <= ST_DEALLOC_IDLE; end else begin gpu_interface_dealloc_available_i <= 1'b1; end end endcase end always @ (handler_wg_done_valid) begin integer i; reg cu_found_valid; reg [CU_ID_WIDTH-1:0] cu_found; cu_found_valid = 1'b0; cu_found = 0; for (i=0; i<NUMBER_CU; i=i+1) begin if(handler_wg_done_valid[i] && !cu_found_valid) begin cu_found_valid = 1'b1; cu_found = i; end end chosen_done_cu_valid_comb = cu_found_valid; chosen_done_cu_id_comb = cu_found; end assign gpu_interface_dealloc_available = gpu_interface_dealloc_available_i; assign gpu_interface_dealloc_wg_id = gpu_interface_dealloc_wg_id_i; assign gpu_interface_cu_id = gpu_interface_cu_id_i; assign gpu_interface_alloc_available = gpu_interface_alloc_available_i; assign dispatch2cu_wf_dispatch = dispatch2cu_wf_dispatch_i; assign dispatch2cu_wf_tag_dispatch = dispatch2cu_wf_tag_dispatch_i; assign dispatch2cu_wg_wf_count = dispatch2cu_wg_wf_count_i; assign dispatch2cu_wf_size_dispatch = dispatch2cu_wf_size_dispatch_i; localparam [CU_VGPR_ID_WIDTH-VGPR_ID_WIDTH-1:0] VGPR_LOW_BITS = {(CU_VGPR_ID_WIDTH-VGPR_ID_WIDTH){1'b0}}; localparam [CU_SGPR_ID_WIDTH-SGPR_ID_WIDTH-1:0] SGPR_LOW_BITS = {(CU_SGPR_ID_WIDTH-SGPR_ID_WIDTH){1'b0}}; localparam [CU_LDS_ID_WIDTH-LDS_ID_WIDTH-1:0] LDS_LOW_BITS = {(CU_LDS_ID_WIDTH-LDS_ID_WIDTH){1'b0}}; assign dispatch2cu_sgpr_base_dispatch = {dispatch2cu_sgpr_base_dispatch_i, SGPR_LOW_BITS}; assign dispatch2cu_vgpr_base_dispatch = {dispatch2cu_vgpr_base_dispatch_i, VGPR_LOW_BITS}; assign dispatch2cu_lds_base_dispatch = {dispatch2cu_lds_base_dispatch_i, LDS_LOW_BITS}; assign dispatch2cu_start_pc_dispatch = dispatch2cu_start_pc_dispatch_i; endmodule"}
{"task_id": 60, "completion": "localparam ADDR_WIDTH   = log2ceil(FIFO_DEPTH);\n    localparam DEPTH        = FIFO_DEPTH;\n    localparam PKT_SIGNALS_WIDTH = 2 + EMPTY_WIDTH;\n    localparam PAYLOAD_WIDTH     = (USE_PACKETS == 1) ? \n                   2 + EMPTY_WIDTH + DATA_WIDTH + ERROR_WIDTH + CHANNEL_WIDTH:\n                   DATA_WIDTH + ERROR_WIDTH + CHANNEL_WIDTH;\n\n    genvar i;\n\n    reg [PAYLOAD_WIDTH-1 : 0] mem [DEPTH-1 : 0];\n    reg [ADDR_WIDTH-1 : 0]  wr_ptr;\n    reg [ADDR_WIDTH-1 : 0]  rd_ptr;\n    reg [DEPTH-1      : 0]  mem_used;\n\n    wire [ADDR_WIDTH-1 : 0] next_wr_ptr;\n    wire [ADDR_WIDTH-1 : 0] next_rd_ptr;\n    wire [ADDR_WIDTH-1 : 0] incremented_wr_ptr;\n    wire [ADDR_WIDTH-1 : 0] incremented_rd_ptr;\n\n    wire [ADDR_WIDTH-1 : 0] mem_rd_ptr;\n\n    wire read;\n    wire write;\n\n    reg empty;\n    reg next_empty;\n    reg full;\n    reg next_full;\n\n    wire [PKT_SIGNALS_WIDTH-1 : 0] in_packet_signals;\n    wire [PKT_SIGNALS_WIDTH-1 : 0] out_packet_signals;\n    wire [PAYLOAD_WIDTH-1 : 0] in_payload;\n    reg  [PAYLOAD_WIDTH-1 : 0] internal_out_payload;\n    reg  [PAYLOAD_WIDTH-1 : 0] out_payload;\n\n    reg  internal_out_valid;\n    wire internal_out_ready;\n\n    reg  [ADDR_WIDTH : 0] fifo_fill_level;\n    reg  [ADDR_WIDTH : 0] fill_level;\n\n    reg  [ADDR_WIDTH-1 : 0]   sop_ptr = 0;\n    wire [ADDR_WIDTH-1 : 0]   curr_sop_ptr;\n    reg  [23:0]   almost_full_threshold;\n    reg  [23:0]   almost_empty_threshold;\n    reg  [23:0]   cut_through_threshold;\n    reg  [15:0]   pkt_cnt;\n    reg           drop_on_error_en;\n    reg           error_in_pkt;\n    reg           pkt_has_started;\n    reg           sop_has_left_fifo;\n    reg           fifo_too_small_r;\n    reg           pkt_cnt_eq_zero;\n    reg           pkt_cnt_eq_one;\n\n    wire          wait_for_threshold;\n    reg           pkt_mode;\n    wire          wait_for_pkt;\n    wire          ok_to_forward;\n    wire          in_pkt_eop_arrive;\n    wire          out_pkt_leave;\n    wire          in_pkt_start;\n    wire          in_pkt_error;\n    wire          drop_on_error;\n    wire          fifo_too_small;\n    wire          out_pkt_sop_leave;\n    wire [31:0]   max_fifo_size;\n    reg           fifo_fill_level_lt_cut_through_threshold;\n\n    generate\n        if (EMPTY_WIDTH > 0) begin : gen_blk1\n            assign in_packet_signals = {in_startofpacket, in_endofpacket, in_empty};\n            assign {out_startofpacket, out_endofpacket, out_empty} = out_packet_signals;\n        end \n        else begin : gen_blk1_else\n            assign out_empty = in_error;\n            assign in_packet_signals = {in_startofpacket, in_endofpacket};\n            assign {out_startofpacket, out_endofpacket} = out_packet_signals;\n        end\n    endgenerate\n\n    generate\n        if (USE_PACKETS) begin : gen_blk2\n            if (ERROR_WIDTH > 0) begin : gen_blk3\n                if (CHANNEL_WIDTH > 0) begin : gen_blk4\n                    assign in_payload = {in_packet_signals, in_data, in_error, in_channel};\n                    assign {out_packet_signals, out_data, out_error, out_channel} = out_payload;\n                end\n                else begin : gen_blk4_else\n                    assign out_channel = in_channel;\n                    assign in_payload = {in_packet_signals, in_data, in_error};\n                    assign {out_packet_signals, out_data, out_error} = out_payload;\n                end\n            end\n            else begin : gen_blk3_else\n                assign out_error = in_error;\n                if (CHANNEL_WIDTH > 0) begin : gen_blk5\n                    assign in_payload = {in_packet_signals, in_data, in_channel};\n                    assign {out_packet_signals, out_data, out_channel} = out_payload;\n                end\n                else begin : gen_blk5_else\n                    assign out_channel = in_channel;\n                    assign in_payload = {in_packet_signals, in_data};\n                    assign {out_packet_signals, out_data} = out_payload;\n                end\n            end\n        end\n        else begin : gen_blk2_else\n            assign out_packet_signals = 0;\n            if (ERROR_WIDTH > 0) begin : gen_blk6\n                if (CHANNEL_WIDTH > 0) begin : gen_blk7\n                    assign in_payload = {in_data, in_error, in_channel};\n                    assign {out_data, out_error, out_channel} = out_payload;\n                end\n                else begin : gen_blk7_else\n                    assign out_channel = in_channel;\n                    assign in_payload = {in_data, in_error};\n                    assign {out_data, out_error} = out_payload;\n                end\n            end\n            else begin : gen_blk6_else\n                assign out_error = in_error;\n                if (CHANNEL_WIDTH > 0) begin : gen_blk8\n                    assign in_payload = {in_data, in_channel};\n                    assign {out_data, out_channel} = out_payload;\n                end\n                else begin : gen_blk8_else\n                    assign out_channel = in_channel;\n                    assign in_payload = in_data;\n                    assign out_data = out_payload;\n                end\n            end\n        end\n    endgenerate\n\n    generate if (USE_MEMORY_BLOCKS == 1) begin  : gen_blk9\n\n        if (EMPTY_LATENCY == 1) begin : gen_blk10\n\n            always @(posedge clk) begin\n                if (in_valid && in_ready)\n                    mem[wr_ptr] = in_payload;\n\n                internal_out_payload = mem[mem_rd_ptr];\n            end\n\n        end else begin : gen_blk10_else\n\n            always @(posedge clk) begin\n                if (in_valid && in_ready)\n                    mem[wr_ptr] <= in_payload;\n\n                internal_out_payload <= mem[mem_rd_ptr];\n            end\n\n        end\n\n        assign mem_rd_ptr = next_rd_ptr;\n    end else begin : gen_blk9_else\n        for (i = 0; i < DEPTH-1; i = i + 1) begin : shift_reg\n            always @(posedge clk or posedge reset) begin\n                if (reset) begin\n                    mem[i] <= 0;\n                end \n                else if (read || !mem_used[i]) begin\n                    if (!mem_used[i+1])\n                        mem[i] <= in_payload;\n                    else\n                        mem[i] <= mem[i+1];\n                end\n            end\n        end\n\n        always @(posedge clk, posedge reset) begin\n            if (reset) begin\n                mem[DEPTH-1] <= 0;\n            end \n            else begin\n                if (DEPTH == 1) begin\n                    if (write)\n                        mem[DEPTH-1] <= in_payload;\n                end\n                else if (!mem_used[DEPTH-1])\n                    mem[DEPTH-1] <= in_payload;    \n            end\n        end\n    end\n    endgenerate\n\n    assign read  = internal_out_ready && internal_out_valid  && ok_to_forward;\n    assign write = in_ready && in_valid;\n\n    generate if (USE_MEMORY_BLOCKS == 1) begin : gen_blk11\n\n        assign incremented_wr_ptr = wr_ptr + 1'b1;\n        assign incremented_rd_ptr = rd_ptr + 1'b1;\n        assign next_wr_ptr =  drop_on_error ? curr_sop_ptr : write ?  incremented_wr_ptr : wr_ptr;\n        assign next_rd_ptr = (read) ? incremented_rd_ptr : rd_ptr;\n\n        always @(posedge clk or posedge reset) begin\n            if (reset) begin\n                wr_ptr <= 0;\n                rd_ptr <= 0;\n            end\n            else begin\n                wr_ptr <= next_wr_ptr;\n                rd_ptr <= next_rd_ptr;\n            end\n        end\n\n    end else begin : gen_blk11_else\n\n        always @(posedge clk or posedge reset) begin\n            if (reset) begin\n                mem_used[0] <= 0;\n            end \n            else begin\n                if (write ^ read) begin\n                    if (write)\n                        mem_used[0] <= 1;\n                    else if (read) begin\n                        if (DEPTH > 1)\n                            mem_used[0] <= mem_used[1];\n                        else\n                            mem_used[0] <= 0;\n                    end    \n                end\n            end\n        end\n\n        if (DEPTH > 1) begin : gen_blk12\n            always @(posedge clk or posedge reset) begin\n                if (reset) begin\n                    mem_used[DEPTH-1] <= 0;\n                end\n                else begin \n                    if (write ^ read) begin            \n                        mem_used[DEPTH-1] <= 0;\n                        if (write)\n                            mem_used[DEPTH-1] <= mem_used[DEPTH-2];\n                    end\n                end\n            end\n          end\n     \n        for (i = 1; i < DEPTH-1; i = i + 1) begin : storage_logic\n            always @(posedge clk, posedge reset) begin\n                if (reset) begin\n                    mem_used[i] <= 0;\n                end \n                else begin\n                    if (write ^ read) begin\n                        if (write)\n                            mem_used[i] <= mem_used[i-1];\n                        else if (read)\n                            mem_used[i] <= mem_used[i+1];     \n                    end\n                end\n            end\n        end\n     \n    end\n    endgenerate\n\n    generate if (USE_MEMORY_BLOCKS == 1) begin : gen_blk13\n\n        always @* begin\n            next_full = full;\n            next_empty = empty;\n     \n            if (read && !write) begin\n                next_full = 1'b0;\n     \n                if (incremented_rd_ptr == wr_ptr)\n                    next_empty = 1'b1;\n            end\n            \n            if (write && !read) begin\n                if (!drop_on_error)\n                  next_empty = 1'b0;\n                else if (curr_sop_ptr == rd_ptr)   // drop on error and only 1 pkt in fifo\n                  next_empty = 1'b1;\n     \n                if (incremented_wr_ptr == rd_ptr && !drop_on_error)\n                    next_full = 1'b1;\n            end\n\n            if (write && read && drop_on_error) begin\n                if (curr_sop_ptr == next_rd_ptr)\n                  next_empty = 1'b1;\n            end\n        end\n     \n        always @(posedge clk or posedge reset) begin\n            if (reset) begin\n                empty <= 1;\n                full  <= 0;\n            end\n            else begin \n                empty <= next_empty;\n                full  <= next_full;\n            end\n        end\n\n    end else begin : gen_blk13_else\n        always @* begin\n            full  = mem_used[DEPTH-1];\n            empty = !mem_used[0];\n\n            if (DEPTH == 1)\n                full = mem_used[0] && !read;\n\n            internal_out_payload = mem[0];\n\n            if (EMPTY_LATENCY == 0) begin\n                empty = !mem_used[0] && !in_valid;\n\n                if (!mem_used[0] && in_valid)\n                    internal_out_payload = in_payload;\n            end\n        end\n    end\n    endgenerate\n\n    assign in_ready = !full;\n    assign internal_out_ready = out_ready || !out_valid;\n\n    generate if (EMPTY_LATENCY > 1) begin : gen_blk14\n        always @(posedge clk or posedge reset) begin\n            if (reset)\n                internal_out_valid <= 0;\n            else begin\n                internal_out_valid <= !empty & ok_to_forward & ~drop_on_error;\n\n                if (read) begin\n                    if (incremented_rd_ptr == wr_ptr)\n                        internal_out_valid <= 1'b0;\n                end\n            end\n        end\n    end else begin : gen_blk14_else\n        always @* begin\n            internal_out_valid = !empty & ok_to_forward;\n        end\n    end\n    endgenerate\n\n    generate if (EMPTY_LATENCY == 3) begin : gen_blk15\n        always @(posedge clk or posedge reset) begin\n            if (reset) begin\n                out_valid   <= 0;\n                out_payload <= 0;\n            end\n            else begin\n                if (internal_out_ready) begin\n                    out_valid   <= internal_out_valid & ok_to_forward;\n                    out_payload <= internal_out_payload;\n                end\n            end\n        end\n    end\n    else begin : gen_blk15_else\n        always @* begin\n            out_valid   = internal_out_valid;\n            out_payload = internal_out_payload;\n        end\n    end\n    endgenerate\n\n    generate if (USE_FILL_LEVEL) begin : gen_blk16\n        wire [31:0] depth32;\n        assign depth32 = DEPTH;\n\n        if (USE_STORE_FORWARD) begin\n\n            reg [ADDR_WIDTH : 0] curr_packet_len_less_one;\n            \n            always @(posedge clk or posedge reset) begin\n                if (reset) begin\n                    curr_packet_len_less_one <= 0;\n                end else begin\n                    if (write) begin\n                        curr_packet_len_less_one <= curr_packet_len_less_one + 1'b1;\n                        if (in_endofpacket)\n                            curr_packet_len_less_one <= 0;\n                    end\n                end\n            end\n\n            always @(posedge clk or posedge reset) begin\n                if (reset) {\n                    fifo_fill_level <= 0;\n                end else if (drop_on_error) begin\n                    fifo_fill_level <= fifo_fill_level - curr_packet_len_less_one;\n                    if (read)\n                        fifo_fill_level <= fifo_fill_level - curr_packet_len_less_one - 1'b1;\n                end else if (write && !read) begin\n                    fifo_fill_level <= fifo_fill_level + 1'b1;\n                end else if (read && !write) begin\n                    fifo_fill_level <= fifo_fill_level - 1'b1;\n                end\n            end\n\n        end else begin\n\n            always @(posedge clk or posedge reset) begin\n                if (reset) \n                    fifo_fill_level <= 0;\n                else if (next_full & !drop_on_error)\n                    fifo_fill_level <= depth32[ADDR_WIDTH:0];\n                else begin\n                    fifo_fill_level[ADDR_WIDTH]     <= 1'b0;\n                    fifo_fill_level[ADDR_WIDTH-1 : 0] <= next_wr_ptr - next_rd_ptr;\n                end\n            end\n\n        end\n\n        always @* begin\n            fill_level = fifo_fill_level;\n\n            if (EMPTY_LATENCY == 3)\n                fill_level = fifo_fill_level + {{ADDR_WIDTH{1'b0}}, out_valid};\n        end\n    end\n    else begin : gen_blk16_else\n        always @* begin\n            fill_level = 0;\n        end  \n    end\n    endgenerate\n\n    generate if (USE_ALMOST_FULL_IF) begin : gen_blk17\n      assign almost_full_data = (fill_level >= almost_full_threshold);\n    end\n    else\n      assign almost_full_data = 0;\n    endgenerate\n\n    generate if (USE_ALMOST_EMPTY_IF) begin : gen_blk18\n      assign almost_empty_data = (fill_level <= almost_empty_threshold);\n    end\n    else\n      assign almost_empty_data = 0;\n    endgenerate\n\n    generate if (USE_STORE_FORWARD) begin : gen_blk19\n    assign max_fifo_size = FIFO_DEPTH - 1;\n      always @(posedge clk or posedge reset) begin\n          if (reset) begin\n              almost_full_threshold  <= max_fifo_size[23 : 0];\n              almost_empty_threshold <= 0;\n              cut_through_threshold  <= 0;\n              drop_on_error_en       <= 0;\n              csr_readdata           <= 0;\n              pkt_mode               <= 1'b1;\n          end\n          else begin\n              if (csr_read) begin\n                csr_readdata <= 32'b0;\n                if (csr_address == 5)\n                    csr_readdata <= {31'b0, drop_on_error_en};\n                else if (csr_address == 4)\n                    csr_readdata <= {8'b0, cut_through_threshold};\n                else if (csr_address == 3)\n                    csr_readdata <= {8'b0, almost_empty_threshold};\n                else if (csr_address == 2)\n                    csr_readdata <= {8'b0, almost_full_threshold};\n                else if (csr_address == 0)\n                    csr_readdata <= {{(31 - ADDR_WIDTH){1'b0}}, fill_level};\n             end\n             else if (csr_write) begin\n               if(csr_address == 3'b101)\n                   drop_on_error_en       <= csr_writedata[0];\n               else if(csr_address == 3'b100) begin\n                   cut_through_threshold  <= csr_writedata[23:0];\n                   pkt_mode <= (csr_writedata[23:0] == 0);\n               end\n               else if(csr_address == 3'b011)\n                    almost_empty_threshold <= csr_writedata[23:0];\n               else if(csr_address == 3'b010)\n                  almost_full_threshold  <= csr_writedata[23:0];\n             end     \n          end\n      end\n    end\n    else if (USE_ALMOST_FULL_IF || USE_ALMOST_EMPTY_IF) begin : gen_blk19_else1\n    assign max_fifo_size = FIFO_DEPTH - 1;\n      always @(posedge clk or posedge reset) begin\n          if (reset) begin\n              almost_full_threshold  <= max_fifo_size[23 : 0];\n              almost_empty_threshold <= 0;\n              csr_readdata           <= 0;\n          end\n          else begin\n             if (csr_read) begin\n                csr_readdata <= 32'b0;\n                if (csr_address == 3)\n                    csr_readdata <= {8'b0, almost_empty_threshold};\n                else if (csr_address == 2)\n                    csr_readdata <= {8'b0, almost_full_threshold};\n                else if (csr_address == 0)\n                    csr_readdata <= {{(31 - ADDR_WIDTH){1'b0}}, fill_level};\n             end\n             else if (csr_write) begin\n               if(csr_address == 3'b011)\n                   almost_empty_threshold <= csr_writedata[23:0];\n               else if(csr_address == 3'b010)\n                  almost_full_threshold  <= csr_writedata[23:0];\n             end       \n          end\n      end\n    end\n    else begin : gen_blk19_else2\n      always @(posedge clk or posedge reset) begin\n          if (reset) begin\n              csr_readdata <= 0;\n          end\n          else if (csr_read) begin\n              csr_readdata <= 0;\n\n              if (csr_address == 0) \n                  csr_readdata <= {{(31 - ADDR_WIDTH){1'b0}}, fill_level};\n          end\n      end\n    end\n    endgenerate\n\n    generate if (USE_STORE_FORWARD) begin : gen_blk20\n      assign wait_for_threshold   = (fifo_fill_level_lt_cut_through_threshold) & wait_for_pkt ;\n      assign wait_for_pkt         = pkt_cnt_eq_zero  | (pkt_cnt_eq_one  & out_pkt_leave);\n      assign ok_to_forward        = (pkt_mode ? (~wait_for_pkt | ~pkt_has_started) : \n                                     ~wait_for_threshold) | fifo_too_small_r;\n      assign in_pkt_eop_arrive    = in_valid & in_ready & in_endofpacket;\n      assign in_pkt_start         = in_valid & in_ready & in_startofpacket;\n      assign in_pkt_error         = in_valid & in_ready & |in_error;\n      assign out_pkt_sop_leave    = out_valid & out_ready & out_startofpacket;\n      assign out_pkt_leave        = out_valid & out_ready & out_endofpacket;\n      assign fifo_too_small       = (pkt_mode ? wait_for_pkt : wait_for_threshold) & full & out_ready;\n\n      always @(posedge clk or posedge reset) begin\n        if (reset) begin\n          pkt_cnt           <= 0;\n          pkt_has_started   <= 0;\n          sop_has_left_fifo <= 0;\n          fifo_too_small_r  <= 0;\n          pkt_cnt_eq_zero   <= 1'b1;\n          pkt_cnt_eq_one    <= 1'b0;\n          fifo_fill_level_lt_cut_through_threshold <= 1'b1;\n        end\n        else begin\n          fifo_fill_level_lt_cut_through_threshold <= fifo_fill_level < cut_through_threshold;\n          fifo_too_small_r <= fifo_too_small;\n\n          if( in_pkt_eop_arrive )\n            sop_has_left_fifo <= 1'b0;\n          else if (out_pkt_sop_leave & pkt_cnt_eq_zero )\n            sop_has_left_fifo <= 1'b1;\n\n          if (in_pkt_eop_arrive & ~out_pkt_leave & ~drop_on_error ) begin\n            pkt_cnt <= pkt_cnt + 1'b1;\n            pkt_cnt_eq_zero <= 0;\n            if (pkt_cnt == 0)\n              pkt_cnt_eq_one <= 1'b1;\n            else\n              pkt_cnt_eq_one <= 1'b0;\n          end\n          else if((~in_pkt_eop_arrive | drop_on_error) & out_pkt_leave) begin\n            pkt_cnt <= pkt_cnt - 1'b1;\n            if (pkt_cnt == 1) \n              pkt_cnt_eq_zero <= 1'b1;\n            else\n              pkt_cnt_eq_zero <= 1'b0;\n            if (pkt_cnt == 2) \n              pkt_cnt_eq_one <= 1'b1;\n            else\n              pkt_cnt_eq_one <= 1'b0;\n          end\n\n          if (in_pkt_start)\n            pkt_has_started <= 1'b1;\n          else if (in_pkt_eop_arrive)\n            pkt_has_started <= 1'b0;\n        end\n      end\n\n      always @(posedge clk or posedge reset) begin\n        if (reset) begin\n          sop_ptr <= 0;\n          error_in_pkt <= 0;\n        end\n        else begin\n          if ( in_pkt_start ) \n            sop_ptr <= wr_ptr;\n\n          if (in_pkt_eop_arrive)\n            error_in_pkt <= 1'b0;\n          else if ( in_pkt_error & (pkt_has_started | in_pkt_start))\n            error_in_pkt <= 1'b1;\n        end\n      end\n\n      assign drop_on_error = drop_on_error_en & (error_in_pkt | in_pkt_error) & in_pkt_eop_arrive & \n                            ~sop_has_left_fifo & ~(out_pkt_sop_leave & pkt_cnt_eq_zero);\n\n      assign curr_sop_ptr = (write && in_startofpacket && in_endofpacket) ? wr_ptr : sop_ptr;\n\n    end\n    else begin : gen_blk20_else\n      assign ok_to_forward = 1'b1;\n      assign drop_on_error = 1'b0;\n      if (ADDR_WIDTH <= 1)\n        assign curr_sop_ptr = 1'b0;\n      else\n        assign curr_sop_ptr = {ADDR_WIDTH - 1 { 1'b0 }};\n    end\n    endgenerate\n\n    function integer log2ceil;\n        input integer val;\n        reg[31:0] i;\n\n        begin\n            i = 1;\n            log2ceil = 0;\n\n            while (i < val) begin\n                log2ceil = log2ceil + 1;\n                i = i[30:0] << 1;\n            end\n        end\n    endfunction\nendmodule"}
{"task_id": 1651, "completion": "FIFO_GENERATOR_V9_1 #(\n    .C_ADD_NGC_CONSTRAINT(0),\n    .C_APPLICATION_TYPE_AXIS(0),\n    .C_APPLICATION_TYPE_RACH(0),\n    .C_APPLICATION_TYPE_RDCH(0),\n    .C_APPLICATION_TYPE_WACH(0),\n    .C_APPLICATION_TYPE_WDCH(0),\n    .C_APPLICATION_TYPE_WRCH(0),\n    .C_AXI_ADDR_WIDTH(32),\n    .C_AXI_ARUSER_WIDTH(1),\n    .C_AXI_AWUSER_WIDTH(1),\n    .C_AXI_BUSER_WIDTH(1),\n    .C_AXI_DATA_WIDTH(64),\n    .C_AXI_ID_WIDTH(4),\n    .C_AXI_RUSER_WIDTH(1),\n    .C_AXI_TYPE(0),\n    .C_AXIS_TDATA_WIDTH(64),\n    .C_AXIS_TDEST_WIDTH(4),\n    .C_AXIS_TID_WIDTH(8),\n    .C_AXIS_TKEEP_WIDTH(4),\n    .C_AXIS_TSTRB_WIDTH(4),\n    .C_AXIS_TUSER_WIDTH(4),\n    .C_AXIS_TYPE(0),\n    .C_COMMON_CLOCK(0),\n    .C_COUNT_TYPE(0),\n    .C_DATA_COUNT_WIDTH(9),\n    .C_DEFAULT_VALUE(\"BlankString\"),\n    .C_DIN_WIDTH(72),\n    .C_DIN_WIDTH_AXIS(1),\n    .C_DIN_WIDTH_RACH(32),\n    .C_DIN_WIDTH_RDCH(64),\n    .C_DIN_WIDTH_WACH(32),\n    .C_DIN_WIDTH_WDCH(64),\n    .C_DIN_WIDTH_WRCH(2),\n    .C_DOUT_RST_VAL(\"0\"),\n    .C_DOUT_WIDTH(36),\n    .C_ENABLE_RLOCS(0),\n    .C_ENABLE_RST_SYNC(1),\n    .C_ERROR_INJECTION_TYPE(0),\n    .C_ERROR_INJECTION_TYPE_AXIS(0),\n    .C_ERROR_INJECTION_TYPE_RACH(0),\n    .C_ERROR_INJECTION_TYPE_RDCH(0),\n    .C_ERROR_INJECTION_TYPE_WACH(0),\n    .C_ERROR_INJECTION_TYPE_WDCH(0),\n    .C_ERROR_INJECTION_TYPE_WRCH(0),\n    .C_FAMILY(\"zynq\"),\n    .C_FULL_FLAGS_RST_VAL(1),\n    .C_HAS_ALMOST_EMPTY(0),\n    .C_HAS_ALMOST_FULL(1),\n    .C_HAS_AXI_ARUSER(0),\n    .C_HAS_AXI_AWUSER(0),\n    .C_HAS_AXI_BUSER(0),\n    .C_HAS_AXI_RD_CHANNEL(0),\n    .C_HAS_AXI_RUSER(0),\n    .C_HAS_AXI_WR_CHANNEL(0),\n    .C_HAS_AXI_WUSER(0),\n    .C_HAS_AXIS_TDATA(0),\n    .C_HAS_AXIS_TDEST(0),\n    .C_HAS_AXIS_TID(0),\n    .C_HAS_AXIS_TKEEP(0),\n    .C_HAS_AXIS_TLAST(0),\n    .C_HAS_AXIS_TREADY(1),\n    .C_HAS_AXIS_TSTRB(0),\n    .C_HAS_AXIS_TUSER(0),\n    .C_HAS_BACKUP(0),\n    .C_HAS_DATA_COUNT(0),\n    .C_HAS_DATA_COUNTS_AXIS(0),\n    .C_HAS_DATA_COUNTS_RACH(0),\n    .C_HAS_DATA_COUNTS_RDCH(0),\n    .C_HAS_DATA_COUNTS_WACH(0),\n    .C_HAS_DATA_COUNTS_WDCH(0),\n    .C_HAS_DATA_COUNTS_WRCH(0),\n    .C_HAS_INT_CLK(0),\n    .C_HAS_MASTER_CE(0),\n    .C_HAS_MEMINIT_FILE(0),\n    .C_HAS_OVERFLOW(0),\n    .C_HAS_PROG_FLAGS_AXIS(0),\n    .C_HAS_PROG_FLAGS_RACH(0),\n    .C_HAS_PROG_FLAGS_RDCH(0),\n    .C_HAS_PROG_FLAGS_WACH(0),\n    .C_HAS_PROG_FLAGS_WDCH(0),\n    .C_HAS_PROG_FLAGS_WRCH(0),\n    .C_HAS_RD_DATA_COUNT(0),\n    .C_HAS_RD_RST(0),\n    .C_HAS_RST(1),\n    .C_HAS_SLAVE_CE(0),\n    .C_HAS_SRST(0),\n    .C_HAS_UNDERFLOW(0),\n    .C_HAS_VALID(0),\n    .C_HAS_WR_ACK(0),\n    .C_HAS_WR_DATA_COUNT(0),\n    .C_HAS_WR_RST(0),\n    .C_IMPLEMENTATION_TYPE(2),\n    .C_IMPLEMENTATION_TYPE_AXIS(1),\n    .C_IMPLEMENTATION_TYPE_RACH(1),\n    .C_IMPLEMENTATION_TYPE_RDCH(1),\n    .C_IMPLEMENTATION_TYPE_WACH(1),\n    .C_IMPLEMENTATION_TYPE_WDCH(1),\n    .C_IMPLEMENTATION_TYPE_WRCH(1),\n    .C_INIT_WR_PNTR_VAL(0),\n    .C_INTERFACE_TYPE(0),\n    .C_MEMORY_TYPE(1),\n    .C_MIF_FILE_NAME(\"BlankString\"),\n    .C_MSGON_VAL(1),\n    .C_OPTIMIZATION_MODE(0),\n    .C_OVERFLOW_LOW(0),\n    .C_PRELOAD_LATENCY(1),\n    .C_PRELOAD_REGS(0),\n    .C_PRIM_FIFO_TYPE(\"512x72\"),\n    .C_PROG_EMPTY_THRESH_ASSERT_VAL(2),\n    .C_PROG_EMPTY_THRESH_ASSERT_VAL_AXIS(1022),\n    .C_PROG_EMPTY_THRESH_ASSERT_VAL_RACH(1022),\n    .C_PROG_EMPTY_THRESH_ASSERT_VAL_RDCH(1022),\n    .C_PROG_EMPTY_THRESH_ASSERT_VAL_WACH(1022),\n    .C_PROG_EMPTY_THRESH_ASSERT_VAL_WDCH(1022),\n    .C_PROG_EMPTY_THRESH_NEGATE_VAL(3),\n    .C_PROG_EMPTY_TYPE(0),\n    .C_PROG_EMPTY_TYPE_AXIS(0),\n    .C_PROG_EMPTY_TYPE_RACH(0),\n    .C_PROG_EMPTY_TYPE_RDCH(0),\n    .C_PROG_EMPTY_TYPE_WACH(0),\n    .C_PROG_EMPTY_TYPE_WDCH(0),\n    .C_PROG_FULL_THRESH_ASSERT_VAL(509),\n    .C_PROG_FULL_THRESH_ASSERT_VAL_AXIS(1023),\n    .C_PROG_FULL_THRESH_ASSERT_VAL_RACH(1023),\n    .C_PROG_FULL_THRESH_ASSERT_VAL_RDCH(1023),\n    .C_PROG_FULL_THRESH_ASSERT_VAL_WACH(1023),\n    .C_PROG_FULL_THRESH_ASSERT_VAL_WDCH(1023),\n    .C_PROG_FULL_THRESH_NEGATE_VAL(508),\n    .C_PROG_FULL_TYPE(0),\n    .C_PROG_FULL_TYPE_AXIS(0),\n    .C_PROG_FULL_TYPE_RACH(0),\n    .C_PROG_FULL_TYPE_RDCH(0),\n    .C_PROG_FULL_TYPE_WACH(0),\n    .C_PROG_FULL_TYPE_WDCH(0),\n    .C_RACH_TYPE(0),\n    .C_RD_DATA_COUNT_WIDTH(10),\n    .C_RD_DEPTH(1024),\n    .C_RD_FREQ(1),\n    .C_RD_PNTR_WIDTH(10),\n    .C_RDCH_TYPE(0),\n    .C_REG_SLICE_MODE_AXIS(0),\n    .C_REG_SLICE_MODE_RACH(0),\n    .C_REG_SLICE_MODE_RDCH(0),\n    .C_REG_SLICE_MODE_WACH(0),\n    .C_REG_SLICE_MODE_WDCH(0),\n    .C_REG_SLICE_MODE_WRCH(0),\n    .C_SYNCHRONIZER_STAGE(2),\n    .C_UNDERFLOW_LOW(0),\n    .C_USE_COMMON_OVERFLOW(0),\n    .C_USE_COMMON_UNDERFLOW(0),\n    .C_USE_DEFAULT_SETTINGS(0),\n    .C_USE_DOUT_RST(1),\n    .C_USE_ECC(0),\n    .C_USE_ECC_AXIS(0),\n    .C_USE_ECC_RACH(0),\n    .C_USE_ECC_RDCH(0),\n    .C_USE_ECC_WACH(0),\n    .C_USE_ECC_WDCH(0),\n    .C_USE_ECC_WRCH(0),\n    .C_USE_EMBEDDED_REG(0),\n    .C_USE_FIFO16_FLAGS(0),\n    .C_USE_FWFT_DATA_COUNT(0),\n    .C_VALID_LOW(0),\n    .C_WACH_TYPE(0),\n    .C_WDCH_TYPE(0),\n    .C_WR_ACK_LOW(0),\n    .C_WR_DATA_COUNT_WIDTH(9),\n    .C_WR_DEPTH(512),\n    .C_WR_DEPTH_AXIS(1024),\n    .C_WR_DEPTH_RACH(16),\n    .C_WR_DEPTH_RDCH(1024),\n    .C_WR_DEPTH_WACH(16),\n    .C_WR_DEPTH_WDCH(1024),\n    .C_WR_DEPTH_WRCH(16),\n    .C_WR_FREQ(1),\n    .C_WR_PNTR_WIDTH(9),\n    .C_WR_PNTR_WIDTH_AXIS(10),\n    .C_WR_PNTR_WIDTH_RACH(4),\n    .C_WR_PNTR_WIDTH_RDCH(10),\n    .C_WR_PNTR_WIDTH_WACH(4),\n    .C_WR_PNTR_WIDTH_WDCH(10),\n    .C_WR_PNTR_WIDTH_WRCH(4),\n    .C_WR_RESPONSE_LATENCY(1),\n    .C_WRCH_TYPE(0)\n  )\n  inst (\n    .RST(rst),\n    .WR_CLK(wr_clk),\n    .RD_CLK(rd_clk),\n    .DIN(din),\n    .WR_EN(wr_en),\n    .RD_EN(rd_en),\n    .DOUT(dout),\n    .FULL(full),\n    .ALMOST_FULL(almost_full),\n    .EMPTY(empty),\n    .BACKUP(),\n    .BACKUP_MARKER(),\n    .CLK(),\n    .SRST(),\n    .WR_RST(),\n    .RD_RST(),\n    .PROG_EMPTY_THRESH(),\n    .PROG_EMPTY_THRESH_ASSERT(),\n    .PROG_EMPTY_THRESH_NEGATE(),\n    .PROG_FULL_THRESH(),\n    .PROG_FULL_THRESH_ASSERT(),\n    .PROG_FULL_THRESH_NEGATE(),\n    .INT_CLK(),\n    .INJECTDBITERR(),\n    .INJECTSBITERR(),\n    .WR_ACK(),\n    .OVERFLOW(),\n    .ALMOST_EMPTY(),\n    .VALID(),\n    .UNDERFLOW(),\n    .DATA_COUNT(),\n    .RD_DATA_COUNT(),\n    .WR_DATA_COUNT(),\n    .PROG_FULL(),\n    .PROG_EMPTY(),\n    .SBITERR(),\n    .DBITERR(),\n    .M_ACLK(),\n    .S_ACLK(),\n    .S_ARESETN(),\n    .M_ACLK_EN(),\n    .S_ACLK_EN(),\n    .S_AXI_AWID(),\n    .S_AXI_AWADDR(),\n    .S_AXI_AWLEN(),\n    .S_AXI_AWSIZE(),\n    .S_AXI_AWBURST(),\n    .S_AXI_AWLOCK(),\n    .S_AXI_AWCACHE(),\n    .S_AXI_AWPROT(),\n    .S_AXI_AWQOS(),\n    .S_AXI_AWREGION(),\n    .S_AXI_AWUSER(),\n    .S_AXI_AWVALID(),\n    .S_AXI_AWREADY(),\n    .S_AXI_WID(),\n    .S_AXI_WDATA(),\n    .S_AXI_WSTRB(),\n    .S_AXI_WLAST(),\n    .S_AXI_WUSER(),\n    .S_AXI_WVALID(),\n    .S_AXI_WREADY(),\n    .S_AXI_BID(),\n    .S_AXI_BRESP(),\n    .S_AXI_BUSER(),\n    .S_AXI_BVALID(),\n    .S_AXI_BREADY(),\n    .M_AXI_AWID(),\n    .M_AXI_AWADDR(),\n    .M_AXI_AWLEN(),\n    .M_AXI_AWSIZE(),\n    .M_AXI_AWBURST(),\n    .M_AXI_AWLOCK(),\n    .M_AXI_AWCACHE(),\n    .M_AXI_AWPROT(),\n    .M_AXI_AWQOS(),\n    .M_AXI_AWREGION(),\n    .M_AXI_AWUSER(),\n    .M_AXI_AWVALID(),\n    .M_AXI_AWREADY(),\n    .M_AXI_WID(),\n    .M_AXI_WDATA(),\n    .M_AXI_WSTRB(),\n    .M_AXI_WLAST(),\n    .M_AXI_WUSER(),\n    .M_AXI_WVALID(),\n    .M_AXI_WREADY(),\n    .M_AXI_BID(),\n    .M_AXI_BRESP(),\n    .M_AXI_BUSER(),\n    .M_AXI_BVALID(),\n    .M_AXI_BREADY(),\n    .S_AXI_ARID(),\n    .S_AXI_ARADDR(),\n    .S_AXI_ARLEN(),\n    .S_AXI_ARSIZE(),\n    .S_AXI_ARBURST(),\n    .S_AXI_ARLOCK(),\n    .S_AXI_ARCACHE(),\n    .S_AXI_ARPROT(),\n    .S_AXI_ARQOS(),\n    .S_AXI_ARREGION(),\n    .S_AXI_ARUSER(),\n    .S_AXI_ARVALID(),\n    .S_AXI_ARREADY(),\n    .S_AXI_RID(),\n    .S_AXI_RDATA(),\n    .S_AXI_RRESP(),\n    .S_AXI_RLAST(),\n    .S_AXI_RUSER(),\n    .S_AXI_RVALID(),\n    .S_AXI_RREADY(),\n    .M_AXI_ARID(),\n    .M_AXI_ARADDR(),\n    .M_AXI_ARLEN(),\n    .M_AXI_ARSIZE(),\n    .M_AXI_ARBURST(),\n    .M_AXI_ARLOCK(),\n    .M_AXI_ARCACHE(),\n    .M_AXI_ARPROT(),\n    .M_AXI_ARQOS(),\n    .M_AXI_ARREGION(),\n    .M_AXI_ARUSER(),\n    .M_AXI_ARVALID(),\n    .M_AXI_ARREADY(),\n    .M_AXI_RID(),\n    .M_AXI_RDATA(),\n    .M_AXI_RRESP(),\n    .M_AXI_RLAST(),\n    .M_AXI_RUSER(),\n    .M_AXI_RVALID(),\n    .M_AXI_RREADY(),\n    .S_AXIS_TVALID(),\n    .S_AXIS_TREADY(),\n    .S_AXIS_TDATA(),\n    .S_AXIS_TSTRB(),\n    .S_AXIS_TKEEP(),\n    .S_AXIS_TLAST(),\n    .S_AXIS_TID(),\n    .S_AXIS_TDEST(),\n    .S_AXIS_TUSER(),\n    .M_AXIS_TVALID(),\n    .M_AXIS_TREADY(),\n    .M_AXIS_TDATA(),\n    .M_AXIS_TSTRB(),\n    .M_AXIS_TKEEP(),\n    .M_AXIS_TLAST(),\n    .M_AXIS_TID(),\n    .M_AXIS_TDEST(),\n    .M_AXIS_TUSER(),\n    .AXI_AW_INJECTSBITERR(),\n    .AXI_AW_INJECTDBITERR(),\n    .AXI_AW_PROG_FULL_THRESH(),\n    .AXI_AW_PROG_EMPTY_THRESH(),\n    .AXI_AW_DATA_COUNT(),\n    .AXI_AW_WR_DATA_COUNT(),\n    .AXI_AW_RD_DATA_COUNT(),\n    .AXI_AW_SBITERR(),\n    .AXI_AW_DBITERR(),\n    .AXI_AW_OVERFLOW(),\n    .AXI_AW_UNDERFLOW(),\n    .AXI_AW_PROG_FULL(),\n    .AXI_AW_PROG_EMPTY(),\n    .AXI_W_INJECTSBITERR(),\n    .AXI_W_INJECTDBITERR(),\n    .AXI_W_PROG_FULL_THRESH(),\n    .AXI_W_PROG_EMPTY_THRESH(),\n    .AXI_W_DATA_COUNT(),\n    .AXI_W_WR_DATA_COUNT(),\n    .AXI_W_RD_DATA_COUNT(),\n    .AXI_W_SBITERR(),\n    .AXI_W_DBITERR(),\n    .AXI_W_OVERFLOW(),\n    .AXI_W_UNDERFLOW(),\n    .AXI_B_INJECTSBITERR(),\n    .AXI_W_PROG_FULL(),\n    .AXI_W_PROG_EMPTY(),\n    .AXI_B_INJECTDBITERR(),\n    .AXI_B_PROG_FULL_THRESH(),\n    .AXI_B_PROG_EMPTY_THRESH(),\n    .AXI_B_DATA_COUNT(),\n    .AXI_B_WR_DATA_COUNT(),\n    .AXI_B_RD_DATA_COUNT(),\n    .AXI_B_SBITERR(),\n    .AXI_B_DBITERR(),\n    .AXI_B_OVERFLOW(),\n    .AXI_B_UNDERFLOW(),\n    .AXI_AR_INJECTSBITERR(),\n    .AXI_B_PROG_FULL(),\n    .AXI_B_PROG_EMPTY(),\n    .AXI_AR_INJECTDBITERR(),\n    .AXI_AR_PROG_FULL_THRESH(),\n    .AXI_AR_PROG_EMPTY_THRESH(),\n    .AXI_AR_DATA_COUNT(),\n    .AXI_AR_WR_DATA_COUNT(),\n    .AXI_AR_RD_DATA_COUNT(),\n    .AXI_AR_SBITERR(),\n    .AXI_AR_DBITERR(),\n    .AXI_AR_OVERFLOW(),\n    .AXI_AR_UNDERFLOW(),\n    .AXI_AR_PROG_FULL(),\n    .AXI_AR_PROG_EMPTY(),\n    .AXI_R_INJECTSBITERR(),\n    .AXI_R_INJECTDBITERR(),\n    .AXI_R_PROG_FULL_THRESH(),\n    .AXI_R_PROG_EMPTY_THRESH(),\n    .AXI_R_DATA_COUNT(),\n    .AXI_R_WR_DATA_COUNT(),\n    .AXI_R_RD_DATA_COUNT(),\n    .AXI_R_SBITERR(),\n    .AXI_R_DBITERR(),\n    .AXI_R_OVERFLOW(),\n    .AXI_R_UNDERFLOW(),\n    .AXIS_INJECTSBITERR(),\n    .AXI_R_PROG_FULL(),\n    .AXI_R_PROG_EMPTY(),\n    .AXIS_INJECTDBITERR(),\n    .AXIS_PROG_FULL_THRESH(),\n    .AXIS_PROG_EMPTY_THRESH(),\n    .AXIS_DATA_COUNT(),\n    .AXIS_WR_DATA_COUNT(),\n    .AXIS_RD_DATA_COUNT(),\n    .AXIS_SBITERR(),\n    .AXIS_DBITERR(),\n    .AXIS_OVERFLOW(),\n    .AXIS_UNDERFLOW(),\n    .AXIS_PROG_FULL(),\n    .AXIS_PROG_EMPTY()\n  );\n\nendmodule"}
{"task_id": 1988, "completion": "localparam\n    ADDR_AP_CTRL = 4'h0,\n    ADDR_GIE     = 4'h4,\n    ADDR_IER     = 4'h8,\n    ADDR_ISR     = 4'hc,\n    WRIDLE       = 2'd0,\n    WRDATA       = 2'd1,\n    WRRESP       = 2'd2,\n    WRRESET      = 2'd3,\n    RDIDLE       = 2'd0,\n    RDDATA       = 2'd1,\n    RDRESET      = 2'd2,\n    ADDR_BITS         = 4;\n\n    reg  [1:0]                    wstate = WRRESET;\n    reg  [1:0]                    wnext;\n    reg  [ADDR_BITS-1:0]          waddr;\n    wire [31:0]                   wmask;\n    wire                          aw_hs;\n    wire                          w_hs;\n    reg  [1:0]                    rstate = RDRESET;\n    reg  [1:0]                    rnext;\n    reg  [31:0]                   rdata;\n    wire                          ar_hs;\n    wire [ADDR_BITS-1:0]          raddr;\n    wire                          int_ap_idle;\n    wire                          int_ap_ready;\n    reg                           int_ap_done = 1'b0;\n    reg                           int_ap_start = 1'b0;\n    reg                           int_auto_restart = 1'b0;\n    reg                           int_gie = 1'b0;\n    reg  [1:0]                    int_ier = 2'b0;\n    reg  [1:0]                    int_isr = 2'b0;\n\n    assign AWREADY = (wstate == WRIDLE);\n    assign WREADY  = (wstate == WRDATA);\n    assign BRESP   = 2'b00;  // OKAY\n    assign BVALID  = (wstate == WRRESP);\n    assign wmask   = { {8{WSTRB[3]}}, {8{WSTRB[2]}}, {8{WSTRB[1]}}, {8{WSTRB[0]}} };\n    assign aw_hs   = AWVALID & AWREADY;\n    assign w_hs    = WVALID & WREADY;\n\n    always @(posedge ACLK) begin\n        if (ARESET)\n            wstate <= WRRESET;\n        else if (ACLK_EN)\n            wstate <= wnext;\n    end\n\n    always @(*) begin\n        case (wstate)\n            WRIDLE:\n                if (AWVALID)\n                    wnext = WRDATA;\n                else\n                    wnext = WRIDLE;\n            WRDATA:\n                if (WVALID)\n                    wnext = WRRESP;\n                else\n                    wnext = WRDATA;\n            WRRESP:\n                if (BREADY)\n                    wnext = WRIDLE;\n                else\n                    wnext = WRRESP;\n            default:\n                wnext = WRIDLE;\n        endcase\n    end\n\n    always @(posedge ACLK) begin\n        if (ACLK_EN) begin\n            if (aw_hs)\n                waddr <= AWADDR[ADDR_BITS-1:0];\n        end\n    end\n\n    assign ARREADY = (rstate == RDIDLE);\n    assign RDATA   = rdata;\n    assign RRESP   = 2'b00;  // OKAY\n    assign RVALID  = (rstate == RDDATA);\n    assign ar_hs   = ARVALID & ARREADY;\n    assign raddr   = ARADDR[ADDR_BITS-1:0];\n\n    always @(posedge ACLK) begin\n        if (ARESET)\n            rstate <= RDRESET;\n        else if (ACLK_EN)\n            rstate <= rnext;\n    end\n\n    always @(*) begin\n        case (rstate)\n            RDIDLE:\n                if (ARVALID)\n                    rnext = RDDATA;\n                else\n                    rnext = RDIDLE;\n            RDDATA:\n                if (RREADY & RVALID)\n                    rnext = RDIDLE;\n                else\n                    rnext = RDDATA;\n            default:\n                rnext = RDIDLE;\n        endcase\n    end\n\n    always @(posedge ACLK) begin\n        if (ACLK_EN) begin\n            if (ar_hs) begin\n                rdata <= 1'b0;\n                case (raddr)\n                    ADDR_AP_CTRL: begin\n                        rdata[0] <= int_ap_start;\n                        rdata[1] <= int_ap_done;\n                        rdata[2] <= int_ap_idle;\n                        rdata[3] <= int_ap_ready;\n                        rdata[7] <= int_auto_restart;\n                    end\n                    ADDR_GIE: begin\n                        rdata <= int_gie;\n                    end\n                    ADDR_IER: begin\n                        rdata <= int_ier;\n                    end\n                    ADDR_ISR: begin\n                        rdata <= int_isr;\n                    end\n                endcase\n            end\n        end\n    end\n\n    assign interrupt    = int_gie & (|int_isr);\n    assign ap_start     = int_ap_start;\n    assign int_ap_idle  = ap_idle;\n    assign int_ap_ready = ap_ready;\n    always @(posedge ACLK) begin\n        if (ARESET)\n            int_ap_start <= 1'b0;\n        else if (ACLK_EN) begin\n            if (w_hs && waddr == ADDR_AP_CTRL && WSTRB[0] && WDATA[0])\n                int_ap_start <= 1'b1;\n            else if (int_ap_ready)\n                int_ap_start <= int_auto_restart;\n        end\n    end\n\n    always @(posedge ACLK) begin\n        if (ARESET)\n            int_ap_done <= 1'b0;\n        else if (ACLK_EN) begin\n            if (ap_done)\n                int_ap_done <= 1'b1;\n            else if (ar_hs && raddr == ADDR_AP_CTRL)\n                int_ap_done <= 1'b0;\n        end\n    end\n\n    always @(posedge ACLK) begin\n        if (ARESET)\n            int_auto_restart <= 1'b0;\n        else if (ACLK_EN) begin\n            if (w_hs && waddr == ADDR_AP_CTRL && WSTRB[0])\n                int_auto_restart <=  WDATA[7];\n        end\n    end\n\n    always @(posedge ACLK) begin\n        if (ARESET)\n            int_gie <= 1'b0;\n        else if (ACLK_EN) begin\n            if (w_hs && waddr == ADDR_GIE && WSTRB[0])\n                int_gie <= WDATA[0];\n        end\n    end\n\n    always @(posedge ACLK) begin\n        if (ARESET)\n            int_ier <= 1'b0;\n        else if (ACLK_EN) begin\n            if (w_hs && waddr == ADDR_IER && WSTRB[0])\n                int_ier <= WDATA[1:0];\n        end\n    end\n\n    always @(posedge ACLK) begin\n        if (ARESET)\n            int_isr[0] <= 1'b0;\n        else if (ACLK_EN) begin\n            if (int_ier[0] & ap_done)\n                int_isr[0] <= 1'b1;\n            else if (w_hs && waddr == ADDR_ISR && WSTRB[0])\n                int_isr[0] <= int_isr[0] ^ WDATA[0];\n        end\n    end\n\n    always @(posedge ACLK) begin\n        if (ARESET)\n            int_isr[1] <= 1'b0;\n        else if (ACLK_EN) begin\n            if (int_ier[1] & ap_ready)\n                int_isr[1] <= 1'b1;\n            else if (w_hs && waddr == ADDR_ISR && WSTRB[0])\n                int_isr[1] <= int_isr[1] ^ WDATA[1];\n        end\n    end\n\nendmodule"}
{"task_id": 1778, "completion": "(* techmap_simplemap *)\nmodule \\$not ;\nendmodule\n\n(* techmap_simplemap *)\nmodule \\$pos ;\nendmodule\n\n(* techmap_simplemap *)\nmodule \\$bu0 ;\nendmodule\n\nmodule \\$neg (A, Y);\n\nparameter A_SIGNED = 0;\nparameter A_WIDTH = 1;\nparameter Y_WIDTH = 1;\n\ninput [A_WIDTH-1:0] A;\noutput [Y_WIDTH-1:0] Y;\n\n\\$sub #(\n\t.A_SIGNED(A_SIGNED),\n\t.B_SIGNED(A_SIGNED),\n\t.A_WIDTH(1),\n\t.B_WIDTH(A_WIDTH),\n\t.Y_WIDTH(Y_WIDTH)\n) sub (\n\t.A(1'b0),\n\t.B(A),\n\t.Y(Y)\n);\n\nendmodule\n\n(* techmap_simplemap *)\nmodule \\$and ;\nendmodule\n\n(* techmap_simplemap *)\nmodule \\$or ;\nendmodule\n\n(* techmap_simplemap *)\nmodule \\$xor ;\nendmodule\n\n(* techmap_simplemap *)\nmodule \\$xnor ;\nendmodule\n\n(* techmap_simplemap *)\nmodule \\$reduce_and ;\nendmodule\n\n(* techmap_simplemap *)\nmodule \\$reduce_or ;\nendmodule\n\n(* techmap_simplemap *)\nmodule \\$reduce_xor ;\nendmodule\n\n(* techmap_simplemap *)\nmodule \\$reduce_xnor ;\nendmodule\n\n(* techmap_simplemap *)\nmodule \\$reduce_bool ;\nendmodule\n\nmodule \\$__shift (X, A, Y);\n\nparameter WIDTH = 1;\nparameter SHIFT = 0;\n\ninput X;\ninput [WIDTH-1:0] A;\noutput [WIDTH-1:0] Y;\n\ngenvar i;\ngenerate\n\tfor (i = 0; i < WIDTH; i = i + 1) begin:V\n\t\tif (i+SHIFT < 0) begin\n\t\t\tassign Y[i] = 0;\n\t\tend else\n\t\tif (i+SHIFT < WIDTH) begin\n\t\t\tassign Y[i] = A[i+SHIFT];\n\t\tend else begin\n\t\t\tassign Y[i] = X;\n\t\tend\n\tend\nendgenerate\nendmodule\n\nmodule \\$shl (A, B, Y);\n\nparameter A_SIGNED = 0;\nparameter B_SIGNED = 0;\nparameter A_WIDTH = 1;\nparameter B_WIDTH = 1;\nparameter Y_WIDTH = 1;\n\nparameter WIDTH = Y_WIDTH;\nlocalparam BB_WIDTH = $clog2(WIDTH) + 2 < B_WIDTH ? $clog2(WIDTH) + 2 : B_WIDTH;\n\ninput [A_WIDTH-1:0] A;\ninput [B_WIDTH-1:0] B;\noutput [Y_WIDTH-1:0] Y;\n\ngenvar i;\ngenerate\n\twire [WIDTH*(BB_WIDTH+1)-1:0] chain;\n\t\\$bu0 #(\n\t\t.A_SIGNED(A_SIGNED),\n\t\t.A_WIDTH(A_WIDTH),\n\t\t.Y_WIDTH(WIDTH)\n\t) expand (\n\t\t.A(A),\n\t\t.Y(chain[WIDTH-1:0])\n\t);\n\tassign Y = chain[WIDTH*(BB_WIDTH+1)-1 : WIDTH*BB_WIDTH];\n\tfor (i = 0; i < BB_WIDTH; i = i + 1) begin:V\n\t\twire [WIDTH-1:0] unshifted, shifted, result;\n\t\tassign unshifted = chain[WIDTH*i + WIDTH-1 : WIDTH*i];\n\t\tassign chain[WIDTH*(i+1) + WIDTH-1 : WIDTH*(i+1)] = result;\n\t\twire BBIT;\n\t\tif (i == BB_WIDTH-1 && BB_WIDTH < B_WIDTH)\n\t\t\tassign BBIT = |B[B_WIDTH-1:BB_WIDTH-1];\n\t\telse\n\t\t\tassign BBIT = B[i];\n\t\t\\$__shift #(\n\t\t\t.WIDTH(WIDTH),\n\t\t\t.SHIFT(0 - (2 ** (i > 30 ? 30 : i)))\n\t\t) sh (\n\t\t\t.X(0),\n\t\t\t.A(unshifted),\n\t\t\t.Y(shifted)\n\t\t);\n\t\t\\$mux #(\n\t\t\t.WIDTH(WIDTH)\n\t\t) mux (\n\t\t\t.A(unshifted),\n\t\t\t.B(shifted),\n\t\t\t.Y(result),\n\t\t\t.S(BBIT)\n\t\t);\n\tend\nendgenerate\nendmodule\n\nmodule \\$shr (A, B, Y);\n\nparameter A_SIGNED = 0;\nparameter B_SIGNED = 0;\nparameter A_WIDTH = 1;\nparameter B_WIDTH = 1;\nparameter Y_WIDTH = 1;\n\nlocalparam WIDTH = A_WIDTH > Y_WIDTH ? A_WIDTH : Y_WIDTH;\nlocalparam BB_WIDTH = $clog2(WIDTH) + 2 < B_WIDTH ? $clog2(WIDTH) + 2 : B_WIDTH;\n\ninput [A_WIDTH-1:0] A;\ninput [B_WIDTH-1:0] B;\noutput [Y_WIDTH-1:0] Y;\n\ngenvar i;\ngenerate\n\twire [WIDTH*(BB_WIDTH+1)-1:0] chain;\n\t\\$bu0 #(\n\t\t.A_SIGNED(A_SIGNED),\n\t\t.A_WIDTH(A_WIDTH),\n\t\t.Y_WIDTH(WIDTH)\n\t) expand (\n\t\t.A(A),\n\t\t.Y(chain[WIDTH-1:0])\n\t);\n\tassign Y = chain[WIDTH*(BB_WIDTH+1)-1 : WIDTH*BB_WIDTH];\n\tfor (i = 0; i < BB_WIDTH; i = i + 1) begin:V\n\t\twire [WIDTH-1:0] unshifted, shifted, result;\n\t\tassign unshifted = chain[WIDTH*i + WIDTH-1 : WIDTH*i];\n\t\tassign chain[WIDTH*(i+1) + WIDTH-1 : WIDTH*(i+1)] = result;\n\t\twire BBIT;\n\t\tif (i == BB_WIDTH-1 && BB_WIDTH < B_WIDTH)\n\t\t\tassign BBIT = |B[B_WIDTH-1:BB_WIDTH-1];\n\t\telse\n\t\t\tassign BBIT = B[i];\n\t\t\\$__shift #(\n\t\t\t.WIDTH(WIDTH),\n\t\t\t.SHIFT(2 ** (i > 30 ? 30 : i))\n\t\t) sh (\n\t\t\t.X(0),\n\t\t\t.A(unshifted),\n\t\t\t.Y(shifted)\n\t\t);\n\t\t\\$mux #(\n\t\t\t.WIDTH(WIDTH)\n\t\t) mux (\n\t\t\t.A(unshifted),\n\t\t\t.B(shifted),\n\t\t\t.Y(result),\n\t\t\t.S(BBIT)\n\t\t);\n\tend\nendgenerate\nendmodule\n\nmodule \\$sshl (A, B, Y);\n\nparameter A_SIGNED = 0;\nparameter B_SIGNED = 0;\nparameter A_WIDTH = 1;\nparameter B_WIDTH = 1;\nparameter Y_WIDTH = 1;\n\nlocalparam WIDTH = Y_WIDTH;\nlocalparam BB_WIDTH = $clog2(WIDTH) + 2 < B_WIDTH ? $clog2(WIDTH) + 2 : B_WIDTH;\n\ninput [A_WIDTH-1:0] A;\ninput [B_WIDTH-1:0] B;\noutput [Y_WIDTH-1:0] Y;\n\ngenvar i;\ngenerate\n\twire [WIDTH*(BB_WIDTH+1)-1:0] chain;\n\t\\$bu0 #(\n\t\t.A_SIGNED(A_SIGNED),\n\t\t.A_WIDTH(A_WIDTH),\n\t\t.Y_WIDTH(WIDTH)\n\t) expand (\n\t\t.A(A),\n\t\t.Y(chain[WIDTH-1:0])\n\t);\n\tassign Y = chain[WIDTH*(BB_WIDTH+1)-1 : WIDTH*BB_WIDTH];\n\tfor (i = 0; i < BB_WIDTH; i = i + 1) begin:V\n\t\twire [WIDTH-1:0] unshifted, shifted, result;\n\t\tassign unshifted = chain[WIDTH*i + WIDTH-1 : WIDTH*i];\n\t\tassign chain[WIDTH*(i+1) + WIDTH-1 : WIDTH*(i+1)] = result;\n\t\twire BBIT;\n\t\tif (i == BB_WIDTH-1 && BB_WIDTH < B_WIDTH)\n\t\t\tassign BBIT = |B[B_WIDTH-1:BB_WIDTH-1];\n\t\telse\n\t\t\tassign BBIT = B[i];\n\t\t\\$__shift #(\n\t\t\t.WIDTH(WIDTH),\n\t\t\t.SHIFT(0 - (2 ** (i > 30 ? 30 : i)))\n\t\t) sh (\n\t\t\t.X(0),\n\t\t\t.A(unshifted),\n\t\t\t.Y(shifted)\n\t\t);\n\t\t\\$mux #(\n\t\t\t.WIDTH(WIDTH)\n\t\t) mux (\n\t\t\t.A(unshifted),\n\t\t\t.B(shifted),\n\t\t\t.Y(result),\n\t\t\t.S(BBIT)\n\t\t);\n\tend\nendgenerate\nendmodule\n\nmodule \\$sshr (A, B, Y);\n\nparameter A_SIGNED = 0;\nparameter B_SIGNED = 0;\nparameter A_WIDTH = 1;\nparameter B_WIDTH = 1;\nparameter Y_WIDTH = 1;\n\nlocalparam WIDTH = A_WIDTH > Y_WIDTH ? A_WIDTH : Y_WIDTH;\nlocalparam BB_WIDTH = $clog2(WIDTH) + 2 < B_WIDTH ? $clog2(WIDTH) + 2 : B_WIDTH;\n\ninput [A_WIDTH-1:0] A;\ninput [B_WIDTH-1:0] B;\noutput [Y_WIDTH-1:0] Y;\n\ngenvar i;\ngenerate\n\twire [WIDTH*(BB_WIDTH+1)-1:0] chain;\n\t\\$bu0 #(\n\t\t.A_SIGNED(A_SIGNED),\n\t\t.A_WIDTH(A_WIDTH),\n\t\t.Y_WIDTH(WIDTH)\n\t) expand (\n\t\t.A(A),\n\t\t.Y(chain[WIDTH-1:0])\n\t);\n\tassign Y = chain[WIDTH*(BB_WIDTH+1)-1 : WIDTH*BB_WIDTH];\n\tfor (i = 0; i < BB_WIDTH; i = i + 1) begin:V\n\t\twire [WIDTH-1:0] unshifted, shifted, result;\n\t\tassign unshifted = chain[WIDTH*i + WIDTH-1 : WIDTH*i];\n\t\tassign chain[WIDTH*(i+1) + WIDTH-1 : WIDTH*(i+1)] = result;\n\t\twire BBIT;\n\t\tif (i == BB_WIDTH-1 && BB_WIDTH < B_WIDTH)\n\t\t\tassign BBIT = |B[B_WIDTH-1:BB_WIDTH-1];\n\t\telse\n\t\t\tassign BBIT = B[i];\n\t\t\\$__shift #(\n\t\t\t.WIDTH(WIDTH),\n\t\t\t.SHIFT(2 ** (i > 30 ? 30 : i))\n\t\t) sh (\n\t\t\t.X(0),\n\t\t\t.A(unshifted),\n\t\t\t.Y(shifted)\n\t\t);\n\t\t\\$mux #(\n\t\t\t.WIDTH(WIDTH)\n\t\t) mux (\n\t\t\t.A(unshifted),\n\t\t\t.B(shifted),\n\t\t\t.Y(result),\n\t\t\t.S(BBIT)\n\t\t);\n\tend\nendgenerate\nendmodule\n\nmodule \\$sshl (A, B, Y);\n\nparameter A_SIGNED = 0;\nparameter B_SIGNED = 0;\nparameter A_WIDTH = 1;\nparameter B_WIDTH = 1;\nparameter Y_WIDTH = 1;\n\nlocalparam WIDTH = Y_WIDTH;\nlocalparam BB_WIDTH = $clog2(WIDTH) + 2 < B_WIDTH ? $clog2(WIDTH) + 2 : B_WIDTH;\n\ninput [A_WIDTH-1:0] A;\ninput [B_WIDTH-1:0] B;\noutput [Y_WIDTH-1:0] Y;\n\ngenvar i;\ngenerate\n\twire [WIDTH*(BB_WIDTH+1)-1:0] chain;\n\t\\$bu0 #(\n\t\t.A_SIGNED(A_SIGNED),\n\t\t.A_WIDTH(A_WIDTH),\n\t\t.Y_WIDTH(WIDTH)\n\t) expand (\n\t\t.A(A),\n\t\t.Y(chain[WIDTH-1:0])\n\t);\n\tassign Y = chain[WIDTH*(BB_WIDTH+1)-1 : WIDTH*BB_WIDTH];\n\tfor (i = 0; i < BB_WIDTH; i = i + 1) begin:V\n\t\twire [WIDTH-1:0] unshifted, shifted, result;\n\t\tassign unshifted = chain[WIDTH*i + WIDTH-1 : WIDTH*i];\n\t\tassign chain[WIDTH*(i+1) + WIDTH-1 : WIDTH*(i+1)] = result;\n\t\twire BBIT;\n\t\tif (i == BB_WIDTH-1 && BB_WIDTH < B_WIDTH)\n\t\t\tassign BBIT = |B[B_WIDTH-1:BB_WIDTH-1];\n\t\telse\n\t\t\tassign BBIT = B[i];\n\t\t\\$__shift #(\n\t\t\t.WIDTH(WIDTH),\n\t\t\t.SHIFT(0 - (2 ** (i > 30 ? 30 : i)))\n\t\t) sh (\n\t\t\t.X(0),\n\t\t\t.A(unshifted),\n\t\t\t.Y(shifted)\n\t\t);\n\t\t\\$mux #(\n\t\t\t.WIDTH(WIDTH)\n\t\t) mux (\n\t\t\t.A(unshifted),\n\t\t\t.B(shifted),\n\t\t\t.Y(result),\n\t\t\t.S(BBIT)\n\t\t);\n\tend\nendgenerate\nendmodule\n\nmodule \\$sr ;\nendmodule\n\nmodule \\$dff ;\nendmodule\n\nmodule \\$adff ;\nendmodule\n\nmodule \\$dffsr ;\nendmodule\n\nmodule \\$dlatch ;\nendmodule"}
{"task_id": 1984, "completion": "function integer clogb2 (input integer size);\n    begin\n      size = size - 1;\n      for (clogb2=1; size>1; clogb2=clogb2+1)\n            size = size >> 1;\n    end\n  endfunction\n\n  localparam ONE = 1;\n  localparam MAINT_PRESCALER_WIDTH = clogb2(MAINT_PRESCALER_DIV + 1);\n  reg maint_prescaler_tick_r_lcl;\n  generate\n    begin : maint_prescaler\n      reg [MAINT_PRESCALER_WIDTH-1:0] maint_prescaler_r;\n      reg [MAINT_PRESCALER_WIDTH-1:0] maint_prescaler_ns;\n      wire maint_prescaler_tick_ns =\n             (maint_prescaler_r == ONE[MAINT_PRESCALER_WIDTH-1:0]);\n      always @(/*AS*/init_calib_complete or maint_prescaler_r\n               or maint_prescaler_tick_ns) begin\n        maint_prescaler_ns = maint_prescaler_r;\n        if (~init_calib_complete || maint_prescaler_tick_ns)\n           maint_prescaler_ns = MAINT_PRESCALER_DIV[MAINT_PRESCALER_WIDTH-1:0];\n        else if (|maint_prescaler_r)\n       maint_prescaler_ns = maint_prescaler_r - ONE[MAINT_PRESCALER_WIDTH-1:0];\n      end\n      always @(posedge clk) maint_prescaler_r <= #TCQ maint_prescaler_ns;\n\n      always @(posedge clk) maint_prescaler_tick_r_lcl <=\n                             #TCQ maint_prescaler_tick_ns;\n    end\n  endgenerate\n\n  assign maint_prescaler_tick_r = maint_prescaler_tick_r_lcl;\n\n  localparam REFRESH_TIMER_WIDTH = clogb2(REFRESH_TIMER_DIV + /*idle*/ 1);\n  wire refresh_tick_lcl;\n  generate\n    begin : refresh_timer\n      reg [REFRESH_TIMER_WIDTH-1:0] refresh_timer_r;\n      reg [REFRESH_TIMER_WIDTH-1:0] refresh_timer_ns;\n      always @(/*AS*/init_calib_complete or maint_prescaler_tick_r_lcl\n               or refresh_tick_lcl or refresh_timer_r) begin\n        refresh_timer_ns = refresh_timer_r;\n        if (~init_calib_complete || refresh_tick_lcl)\n              refresh_timer_ns = REFRESH_TIMER_DIV[REFRESH_TIMER_WIDTH-1:0];\n        else if (|refresh_timer_r && maint_prescaler_tick_r_lcl)\n                 refresh_timer_ns =\n                   refresh_timer_r - ONE[REFRESH_TIMER_WIDTH-1:0];\n      end\n      always @(posedge clk) refresh_timer_r <= #TCQ refresh_timer_ns;\n      assign refresh_tick_lcl = (refresh_timer_r ==\n                  ONE[REFRESH_TIMER_WIDTH-1:0]) && maint_prescaler_tick_r_lcl;\n    end\n  endgenerate\n\n  assign refresh_tick = refresh_tick_lcl;\n\n  localparam ZQ_TIMER_WIDTH = clogb2(ZQ_TIMER_DIV + 1);\n  reg maint_zq_r_lcl;\n  reg zq_request = 1'b0;\n  generate\n    if (DRAM_TYPE == \"DDR3\") begin : zq_cntrl\n      reg zq_tick = 1'b0;\n      if (ZQ_TIMER_DIV !=0) begin : zq_timer\n        reg [ZQ_TIMER_WIDTH-1:0] zq_timer_r;\n        reg [ZQ_TIMER_WIDTH-1:0] zq_timer_ns;\n        always @(/*AS*/init_calib_complete or maint_prescaler_tick_r_lcl\n                 or zq_tick or zq_timer_r) begin\n          zq_timer_ns = zq_timer_r;\n          if (~init_calib_complete || zq_tick)\n                zq_timer_ns = ZQ_TIMER_DIV[ZQ_TIMER_WIDTH-1:0];\n          else if (|zq_timer_r && maint_prescaler_tick_r_lcl)\n                   zq_timer_ns = zq_timer_r - ONE[ZQ_TIMER_WIDTH-1:0];\n        end\n        always @(posedge clk) zq_timer_r <= #TCQ zq_timer_ns;\n        always @(/*AS*/maint_prescaler_tick_r_lcl or zq_timer_r)\n                  zq_tick = (zq_timer_r ==\n                       ONE[ZQ_TIMER_WIDTH-1:0] && maint_prescaler_tick_r_lcl);\n      end\n    end\n  endgenerate\n\n  localparam nCKESR_CLKS = (nCKESR / nCK_PER_CLK) + (nCKESR % nCK_PER_CLK ? 1 : 0);\n  localparam CKESR_TIMER_WIDTH = clogb2(nCKESR_CLKS + 1);\n  reg maint_sre_r_lcl;\n  reg maint_srx_r_lcl;\n  reg sre_request = 1'b0;\n  wire inhbt_srx;\n  generate begin : sr_cntrl\n      begin : sre_request_logic\n        reg sre_request_r;\n        wire sre_clears_sre_request = insert_maint_r1 && maint_sre_r_lcl;\n        wire sre_request_ns = ~rst && ((sre_request_r && ~sre_clears_sre_request)\n                              || (app_sr_req && init_calib_complete && ~maint_sre_r_lcl));\n        always @(posedge clk) sre_request_r <= #TCQ sre_request_ns;\n        always @(init_calib_complete or sre_request_r)\n          sre_request = init_calib_complete && sre_request_r;\n      end\n      begin : ckesr_timer\n        reg [CKESR_TIMER_WIDTH-1:0] ckesr_timer_r = {CKESR_TIMER_WIDTH{1'b0}};\n        reg [CKESR_TIMER_WIDTH-1:0] ckesr_timer_ns = {CKESR_TIMER_WIDTH{1'b0}};\n        always @(insert_maint_r1 or ckesr_timer_r or maint_sre_r_lcl) begin\n          ckesr_timer_ns = ckesr_timer_r;\n          if (insert_maint_r1 && maint_sre_r_lcl)\n            ckesr_timer_ns = nCKESR_CLKS[CKESR_TIMER_WIDTH-1:0];\n          else if(|ckesr_timer_r)\n            ckesr_timer_ns = ckesr_timer_r - ONE[CKESR_TIMER_WIDTH-1:0];\n        end\n        always @(posedge clk) ckesr_timer_r <= #TCQ ckesr_timer_ns;\n        assign inhbt_srx = |ckesr_timer_r;\n      end\n    end\n  endgenerate\n\n  input[RANKS-1:0] refresh_request;\n  input maint_wip_r;\n  reg maint_req_r_lcl;\n  reg [RANK_WIDTH-1:0] maint_rank_r_lcl;\n  input [7:0] slot_0_present;\n  input [7:0] slot_1_present;\n  generate\n    begin : maintenance_request\n      reg upd_last_master_r;\n      reg new_maint_rank_r;\n      wire maint_busy = upd_last_master_r || new_maint_rank_r || maint_req_r_lcl || maint_wip_r;\n      wire [RANKS+1:0] maint_request = {sre_request, zq_request, refresh_request[RANKS-1:0]};\n      wire upd_last_master_ns = |maint_request && ~maint_busy;\n      always @(posedge clk) upd_last_master_r <= #TCQ upd_last_master_ns;\n      always @(posedge clk) new_maint_rank_r <= #TCQ upd_last_master_r;\n      always @(posedge clk) maint_req_r_lcl <= #TCQ new_maint_rank_r;\n      wire upd_last_master_pls = upd_last_master_r & (~new_maint_rank_r);\n      wire [RANKS+1:0] maint_grant_ns;\n      wire [RANKS+1:0] maint_grant_r;\n      mig_7series_v4_0_round_robin_arb #\n     (.WIDTH (RANKS+2))\n      maint_arb0\n      (.grant_ns (maint_grant_ns),\n       .grant_r (maint_grant_r),\n       .upd_last_master (upd_last_master_pls),\n       .current_master (maint_grant_r),\n       .req (maint_request),\n       .disable_grant (1'b0),\n       .clk (clk),\n       .rst (rst));\n      wire [7:0] present = slot_0_present | slot_1_present;\n      integer i;\n      reg [RANK_WIDTH-1:0] maint_rank_ns;\n      wire maint_zq_ns = ~rst && (upd_last_master_pls ? maint_grant_r[RANKS] : maint_zq_r_lcl);\n      wire maint_srx_ns = ~rst && (maint_sre_r_lcl ? ~app_sr_req & ~inhbt_srx : maint_srx_r_lcl && upd_last_master_pls ? maint_grant_r[RANKS+1] : maint_srx_r_lcl);\n      wire maint_sre_ns = ~rst && (upd_last_master_pls ? maint_grant_r[RANKS+1] : maint_sre_r_lcl && ~maint_srx_ns);\n      always @(/*AS*/maint_grant_r or maint_rank_r_lcl or maint_zq_ns or maint_sre_ns or maint_srx_ns or present or rst or upd_last_master_pls) begin\n        if (rst) maint_rank_ns = {RANK_WIDTH{1'b0}};\n        else begin\n          maint_rank_ns = maint_rank_r_lcl;\n          if (maint_zq_ns || maint_sre_ns || maint_srx_ns) begin\n            maint_rank_ns = maint_rank_r_lcl + ONE[RANK_WIDTH-1:0];\n            for (i=0; i<8; i=i+1)\n              if (~present[maint_rank_ns]) maint_rank_ns = maint_rank_ns + ONE[RANK_WIDTH-1:0];\n          end\n          else if (upd_last_master_pls)\n            for (i=0; i<RANKS; i=i+1)\n              if (maint_grant_r[i]) maint_rank_ns = i[RANK_WIDTH-1:0];\n        end\n      end\n      always @(posedge clk) maint_rank_r_lcl <= #TCQ maint_rank_ns;\n      always @(posedge clk) maint_zq_r_lcl <= #TCQ maint_zq_ns;\n      always @(posedge clk) maint_sre_r_lcl <= #TCQ maint_sre_ns;\n      always @(posedge clk) maint_srx_r_lcl <= #TCQ maint_srx_ns;\n    end\n  endgenerate\n\n  assign maint_zq_r = maint_zq_r_lcl;\n  assign maint_sre_r = maint_sre_r_lcl;\n  assign maint_srx_r = maint_srx_r_lcl;\n  assign maint_req_r = maint_req_r_lcl;\n  assign maint_rank_r = maint_rank_r_lcl;\n  reg app_sr_active_r;\n  wire app_sr_active_ns = insert_maint_r1 ? maint_sre_r && ~maint_srx_r : app_sr_active_r;\n  always @(posedge clk) app_sr_active_r <= #TCQ app_sr_active_ns;\n  assign app_sr_active = app_sr_active_r;\n  wire app_ref_ack_ns;\n  wire app_ref_ns;\n  reg app_ref_ack_r = 1'b0;\n  reg app_ref_r = 1'b0;\n  assign app_ref_ns = init_calib_complete && (app_ref_req || app_ref_r && |refresh_request);\n  assign app_ref_ack_ns = app_ref_r && ~|refresh_request;\n  always @(posedge clk) app_ref_r <= #TCQ app_ref_ns;\n  always @(posedge clk) app_ref_ack_r <= #TCQ app_ref_ack_ns;\n  assign app_ref_ack = app_ref_ack_r;\n  wire app_zq_ack_ns;\n  wire app_zq_ns;\n  reg app_zq_ack_r = 1'b0;\n  reg app_zq_r = 1'b0;\n  assign app_zq_ns = init_calib_complete && (app_zq_req || app_zq_r && zq_request);\n  assign app_zq_ack_ns = app_zq_r && ~zq_request;\n  always @(posedge clk) app_zq_r <= #TCQ app_zq_ns;\n  always @(posedge clk) app_zq_ack_r <= #TCQ app_zq_ack_ns;\n  assign app_zq_ack = app_zq_ack_r;\n  generate\n    if ( PERIODIC_RD_TIMER_DIV != 0 ) begin : periodic_read_request\n      reg periodic_rd_r_cnt;\n      wire int_periodic_rd_ack_r = (periodic_rd_ack_r && periodic_rd_r_cnt);\n      reg upd_last_master_r;\n      wire periodic_rd_busy = upd_last_master_r || periodic_rd_r_lcl;\n      wire upd_last_master_ns = init_calib_complete && (|periodic_rd_request && ~periodic_rd_busy);\n      always @(posedge clk) upd_last_master_r <= #TCQ upd_last_master_ns;\n      wire periodic_rd_ns = init_calib_complete && (upd_last_master_r || (periodic_rd_r_lcl && ~int_periodic_rd_ack_r));\n      always @(posedge clk) periodic_rd_r_lcl <= #TCQ periodic_rd_ns;\n      always @(posedge clk) begin\n\tif (rst) periodic_rd_r_cnt <= #TCQ 1'b0;\n\telse if (periodic_rd_r_lcl && periodic_rd_ack_r)\n\t   periodic_rd_r_cnt <= ~periodic_rd_r_cnt;\n      end\n      wire [RANKS-1:0] periodic_rd_grant_ns;\n      reg [RANKS-1:0] periodic_rd_grant_r;\n      mig_7series_v4_0_round_robin_arb #\n     (.WIDTH (RANKS))\n      periodic_rd_arb0\n      (.grant_ns (periodic_rd_grant_ns[RANKS-1:0]),\n       .grant_r (),\n       .upd_last_master (upd_last_master_r),\n       .current_master (periodic_rd_grant_r[RANKS-1:0]),\n       .req (periodic_rd_request[RANKS-1:0]),\n       .disable_grant (1'b0),\n       .clk (clk),\n       .rst (rst));\n      always @(posedge clk) periodic_rd_grant_r = upd_last_master_ns\n                                                   ? periodic_rd_grant_ns\n                                                   : periodic_rd_grant_r;\n      integer i;\n      reg [RANK_WIDTH-1:0] periodic_rd_rank_ns;\n      always @(/*AS*/periodic_rd_grant_r or periodic_rd_rank_r_lcl\n               or upd_last_master_r) begin\n        periodic_rd_rank_ns = periodic_rd_rank_r_lcl;\n        if (upd_last_master_r)\n          for (i=0; i<RANKS; i=i+1)\n            if (periodic_rd_grant_r[i])\n                  periodic_rd_rank_ns = i[RANK_WIDTH-1:0];\n      end\n      always @(posedge clk) periodic_rd_rank_r_lcl <=\n                             #TCQ periodic_rd_rank_ns;\n      assign clear_periodic_rd_request =\n               periodic_rd_grant_r & {RANKS{periodic_rd_ack_r}};\n      assign periodic_rd_r = periodic_rd_r_lcl;\n      assign periodic_rd_rank_r = periodic_rd_rank_r_lcl;\n    end else begin\n      assign clear_periodic_rd_request = {RANKS{1'b0}};\n      assign periodic_rd_r = 1'b0;\n      assign periodic_rd_rank_r = {RANK_WIDTH{1'b0}};\n    end\n  endgenerate\n\n  reg maint_ref_zq_wip_r = 1'b0;\n  assign maint_ref_zq_wip = maint_ref_zq_wip_r;\n  always @(posedge clk)\n    if(rst)\n      maint_ref_zq_wip_r <= #TCQ 1'b0;\n    else if((zq_request || |refresh_request) && insert_maint_r1)\n      maint_ref_zq_wip_r <= #TCQ 1'b1;\n    else if(~maint_wip_r)\n      maint_ref_zq_wip_r <= #TCQ 1'b0;\nendmodule"}
{"task_id": 1942, "completion": "parameter [11:0] D_KES_VALUE_ZERO = 12'b0000_0000_0000;\n    parameter [11:0] D_KES_VALUE_ONE = 12'b0000_0000_0001;\n    parameter KES_FSM_BIT = 7;\n    parameter KES_RESET = 7'b0000001;\n    parameter KES_START = 7'b0000010;\n    parameter KES_STEP1 = 7'b0000100;\n    parameter KES_STEP2 = 7'b0001000;\n    parameter KES_FWD = 7'b0010000;\n    parameter KES_PAUSE = 7'b0100000;\n    parameter KES_OUT = 7'b1000000;\n    wire [31:0] w_coef_2ip1_000;\n    wire [31:0] w_coef_2ip1_001;\n    wire [31:0] w_coef_2ip1_002;\n    wire [31:0] w_coef_2ip1_003;\n    wire [31:0] w_coef_2ip1_004;\n    wire [31:0] w_coef_2ip1_005;\n    wire [31:0] w_coef_2ip1_006;\n    wire [31:0] w_coef_2ip1_007;\n    wire [31:0] w_coef_2ip1_008;\n    wire [31:0] w_coef_2ip1_009;\n    wire [31:0] w_coef_2ip1_010;\n    wire [31:0] w_coef_2ip1_011;\n    wire [31:0] w_coef_2ip1_012;\n    wire [31:0] w_coef_2ip1_013;\n    wire [31:0] w_coef_2ip1_014;\n    reg [2:0] r_cur_state;\n    reg [2:0] r_nxt_state;\n    reg [3:0] r_count_kes;\n    reg [31:0] r_sdr_buffer;\n    reg r_exec_PE_DC;\n    reg r_exec_PE_ELU;\n    wire w_RESET_KES;\n    ... // (\u7701\u7565\u90e8\u5206\u5b9e\u73b0\u4ee3\u7801)\n    endmodule"}
{"task_id": 1738, "completion": "localparam CFG_FR_DWIDTH_RATIO = 2;\n    genvar afi_j, afi_n;\n    generate\n        for (afi_n = 0; afi_n < (CFG_DWIDTH_RATIO/2); afi_n = afi_n + 1'b1)\n        begin : gen_afi_signals\n            always @ (*) \n            begin\n                afi_cke         [((afi_n+1) * CFG_MEM_IF_CKE_WIDTH) -1 : (afi_n * CFG_MEM_IF_CKE_WIDTH)]  = int_afi_cke           [afi_n] ;\n                afi_cs_n        [((afi_n+1) * CFG_MEM_IF_CHIP)      -1 : (afi_n * CFG_MEM_IF_CHIP)]       = int_afi_cs_n          [afi_n] ;\n                afi_ras_n       [afi_n]                                                                   = int_afi_ras_n         [afi_n] ;\n                afi_cas_n       [afi_n]                                                                   = int_afi_cas_n         [afi_n] ;\n                afi_we_n        [afi_n]                                                                   = int_afi_we_n          [afi_n] ;\n                afi_ba          [((afi_n+1) * CFG_MEM_IF_BA_WIDTH)  -1 : (afi_n * CFG_MEM_IF_BA_WIDTH)]   = int_afi_ba            [afi_n] ;\n                afi_addr        [((afi_n+1) * CFG_MEM_IF_ADDR_WIDTH)-1 : (afi_n * CFG_MEM_IF_ADDR_WIDTH)] = int_afi_addr          [afi_n] ;\n                afi_rst_n       [afi_n]                                                                   = int_afi_rst_n         [afi_n] ;\n                afi_rmw_correct [afi_n]                                                                   = int_afi_rmw_correct   [afi_n] ;\n                afi_rmw_partial [afi_n]                                                                   = int_afi_rmw_partial   [afi_n] ;\n            end\n        end\n        if (CFG_DWIDTH_RATIO == 2)\n        begin\n            assign int_afi_cke         [0] = fr_afi_cke         ;\n            assign int_afi_cs_n        [0] = fr_afi_cs_n        ;\n            assign int_afi_ras_n       [0] = fr_afi_ras_n       ;\n            assign int_afi_cas_n       [0] = fr_afi_cas_n       ;\n            assign int_afi_we_n        [0] = fr_afi_we_n        ;\n            assign int_afi_ba          [0] = fr_afi_ba          ;\n            assign int_afi_addr        [0] = fr_afi_addr        ;\n            assign int_afi_rst_n       [0] = fr_afi_rst_n       ;\n            assign int_afi_rmw_correct [0] = fr_afi_rmw_correct ;\n            assign int_afi_rmw_partial [0] = fr_afi_rmw_partial ;\n        end\n        else if ((CFG_DWIDTH_RATIO/2) == CFG_AFI_INTF_PHASE_NUM)\n        begin\n            for (afi_j = 0; afi_j < CFG_AFI_INTF_PHASE_NUM; afi_j = afi_j + 1'b1)\n            begin : gen_afi_signals_0\n                assign int_afi_cke         [afi_j] = phase_afi_cke         [afi_j] ;\n                assign int_afi_cs_n        [afi_j] = phase_afi_cs_n        [afi_j] ;\n                assign int_afi_ras_n       [afi_j] = phase_afi_ras_n       [afi_j] ;\n                assign int_afi_cas_n       [afi_j] = phase_afi_cas_n       [afi_j] ;\n                assign int_afi_we_n        [afi_j] = phase_afi_we_n        [afi_j] ;\n                assign int_afi_ba          [afi_j] = phase_afi_ba          [afi_j] ;\n                assign int_afi_addr        [afi_j] = phase_afi_addr        [afi_j] ;\n                assign int_afi_rst_n       [afi_j] = phase_afi_rst_n       [afi_j] ;\n                assign int_afi_rmw_correct [afi_j] = phase_afi_rmw_correct [afi_j] ;\n                assign int_afi_rmw_partial [afi_j] = phase_afi_rmw_partial [afi_j] ;\n            end\n        end\n        else\n        begin\n            for (afi_j = 0; afi_j < (CFG_DWIDTH_RATIO/2); afi_j = afi_j + 1)\n            begin : gen_afi_signals_1\n                assign int_afi_cs_n        [afi_j] = ((afi_j % CFG_AFI_INTF_PHASE_NUM) == 1) ? phase_afi_cs_n [afi_j / CFG_AFI_INTF_PHASE_NUM] : { CFG_MEM_IF_CHIP {1'b1} };\n                assign int_afi_cke         [afi_j] = (afi_j == ((CFG_DWIDTH_RATIO/2) - 1))   ? phase_afi_cs_n [1] : phase_afi_cs_n [0];\n                assign int_afi_ras_n       [afi_j] = phase_afi_ras_n       [afi_j / CFG_AFI_INTF_PHASE_NUM];\n                assign int_afi_cas_n       [afi_j] = phase_afi_cas_n       [afi_j / CFG_AFI_INTF_PHASE_NUM];\n                assign int_afi_we_n        [afi_j] = phase_afi_we_n        [afi_j / CFG_AFI_INTF_PHASE_NUM];\n                assign int_afi_ba          [afi_j] = phase_afi_ba          [afi_j / CFG_AFI_INTF_PHASE_NUM];\n                assign int_afi_addr        [afi_j] = phase_afi_addr        [afi_j / CFG_AFI_INTF_PHASE_NUM];\n                assign int_afi_rst_n       [afi_j] = phase_afi_rst_n       [afi_j / CFG_AFI_INTF_PHASE_NUM];\n                assign int_afi_rmw_correct [afi_j] = phase_afi_rmw_correct [afi_j / CFG_AFI_INTF_PHASE_NUM];\n                assign int_afi_rmw_partial [afi_j] = phase_afi_rmw_partial [afi_j / CFG_AFI_INTF_PHASE_NUM];\n            end\n        end\n    endgenerate\n    assign mux_afi_cke               [0]  =     phase_afi_cke               [0];\n    assign mux_afi_cs_n              [0]  =     phase_afi_cs_n              [0];\n    assign mux_afi_ras_n             [0]  =     phase_afi_ras_n             [0];\n    assign mux_afi_cas_n             [0]  =     phase_afi_cas_n             [0];\n    assign mux_afi_we_n              [0]  =     phase_afi_we_n              [0];\n    assign mux_afi_ba                [0]  =     phase_afi_ba                [0];\n    assign mux_afi_addr              [0]  =     phase_afi_addr              [0];\n    assign mux_afi_rst_n             [0]  =     phase_afi_rst_n             [0];\n    assign mux_afi_rmw_correct       [0]  =     phase_afi_rmw_correct       [0];\n    assign mux_afi_rmw_partial       [0]  =     phase_afi_rmw_partial       [0];\n    genvar afi_l;\n    generate\n        for (afi_l = 1; afi_l < CFG_AFI_INTF_PHASE_NUM; afi_l = afi_l + 1)\n        begin : gen_resolve_phase_for_fullrate\n            assign mux_afi_cke               [afi_l]  =  mux_afi_cke         [(afi_l-1)] & phase_afi_cke         [afi_l];\n            assign mux_afi_cs_n              [afi_l]  =  mux_afi_cs_n        [(afi_l-1)] & phase_afi_cs_n        [afi_l];\n            assign mux_afi_ras_n             [afi_l]  =  mux_afi_ras_n       [(afi_l-1)] & phase_afi_ras_n       [afi_l];\n            assign mux_afi_cas_n             [afi_l]  =  mux_afi_cas_n       [(afi_l-1)] & phase_afi_cas_n       [afi_l];\n            assign mux_afi_we_n              [afi_l]  =  mux_afi_we_n        [(afi_l-1)] & phase_afi_we_n        [afi_l];\n            assign mux_afi_ba                [afi_l]  =  mux_afi_ba          [(afi_l-1)] | phase_afi_ba          [afi_l];\n            assign mux_afi_addr              [afi_l]  =  mux_afi_addr        [(afi_l-1)] | phase_afi_addr        [afi_l];\n            assign mux_afi_rst_n             [afi_l]  =  mux_afi_rst_n       [(afi_l-1)] | phase_afi_rst_n       [afi_l];\n            assign mux_afi_rmw_correct       [afi_l]  =  mux_afi_rmw_correct [(afi_l-1)] | phase_afi_rmw_correct [afi_l];\n            assign mux_afi_rmw_partial       [afi_l]  =  mux_afi_rmw_partial [(afi_l-1)] | phase_afi_rmw_partial [afi_l];\n        end\n    endgenerate\n    assign fr_afi_cke         = mux_afi_cke         [CFG_AFI_INTF_PHASE_NUM-1];\n    assign fr_afi_cs_n        = mux_afi_cs_n        [CFG_AFI_INTF_PHASE_NUM-1];\n    assign fr_afi_ras_n       = mux_afi_ras_n       [CFG_AFI_INTF_PHASE_NUM-1];\n    assign fr_afi_cas_n       = mux_afi_cas_n       [CFG_AFI_INTF_PHASE_NUM-1];\n    assign fr_afi_we_n        = mux_afi_we_n        [CFG_AFI_INTF_PHASE_NUM-1];\n    assign fr_afi_ba          = mux_afi_ba          [CFG_AFI_INTF_PHASE_NUM-1];\n    assign fr_afi_addr        = mux_afi_addr        [CFG_AFI_INTF_PHASE_NUM-1];\n    assign fr_afi_rst_n       = mux_afi_rst_n       [CFG_AFI_INTF_PHASE_NUM-1];\n    assign fr_afi_rmw_correct = mux_afi_rmw_correct [CFG_AFI_INTF_PHASE_NUM-1];\n    assign fr_afi_rmw_partial = mux_afi_rmw_partial [CFG_AFI_INTF_PHASE_NUM-1];\n    always @ (posedge ctl_clk or negedge ctl_reset_n)\n    begin\n        if (!ctl_reset_n)\n        begin\n            bg_do_self_refresh_r <= 0;\n            bg_do_deep_pdown_r   <= 0;\n        end\n        else\n        begin\n            bg_do_self_refresh_r <= bg_do_self_refresh;\n            bg_do_deep_pdown_r   <= bg_do_deep_pdown;\n        end\n    end\nendmodule"}
